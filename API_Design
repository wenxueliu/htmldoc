<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta http-equiv="Content-Style-Type" content="text/css" />
		<meta name="generator" content="MediaWiki 1.15.1" />
		<meta name="keywords" content="API Design,API Stability,API,APIDevelopment" />
		<link rel="shortcut icon" href="/favicon.ico" />
		<link rel="search" type="application/opensearchdescription+xml" href="/wiki/opensearch_desc.php" title="NetBeans Wiki (en)" />
		<link rel="alternate" type="application/rss+xml" title="NetBeans Wiki RSS Feed" href="/wiki/index.php?title=Special:RecentChanges&amp;feed=rss" />
		<link rel="alternate" type="application/atom+xml" title="NetBeans Wiki Atom Feed" href="/wiki/index.php?title=Special:RecentChanges&amp;feed=atom" />
		<title>API Design - NetBeans Wiki</title>
        <link rel="stylesheet" href="/wiki/skins/common/shared.css?207" type="text/css" media="screen" />
		<link rel="stylesheet" href="/wiki/skins/common/commonPrint.css?207" type="text/css" media="print" />
		<link rel="stylesheet" href="/wiki/index.php?title=MediaWiki:Common.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000" type="text/css" />
		<link rel="stylesheet" href="/wiki/index.php?title=MediaWiki:Print.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000" type="text/css" media="print" />
		<link rel="stylesheet" href="/wiki/index.php?title=MediaWiki:Netbeans.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000" type="text/css" />
		<link rel="stylesheet" href="/wiki/index.php?title=-&amp;action=raw&amp;maxage=18000&amp;gen=css" type="text/css" />        <script type="text/javascript" src="https://netbeans.org/images_www/js/jquery-1.6.2.min.js"></script>
        <script type="text/javascript" src="/wiki/skins/common/bzlink.js"></script>
				<style type="text/css" media="screen,projection">/*<![CDATA[*/
			@import "/wiki/skins/netbeans/main.css?207";
                        @import "/wiki/skins/netbeans/templates.css?207";
		/*]]>*/</style>
		                <link rel="stylesheet" type="text/css" media="print" href="/wiki/skins/netbeans/print.css?207" />		
		<link rel="stylesheet" type="text/css" media="print" href="/wiki/skins/common/commonPrint.css?207" />
				<!--[if lt IE 5.5000]><style type="text/css">@import "/wiki/skins/netbeans/IE50Fixes.css?207";</style><![endif]-->
		<!--[if IE 5.5000]><style type="text/css">@import "/wiki/skins/netbeans/IE55Fixes.css?207";</style><![endif]-->
		<!--[if IE 6]><style type="text/css">@import "/wiki/skins/netbeans/IE60Fixes.css?207";</style><![endif]-->
		<!--[if IE 7]><style type="text/css">@import "/wiki/skins/netbeans/IE70Fixes.css?207";</style><![endif]-->
				<!--[if lt IE 7]>
		<script type="text/javascript" src="/wiki/skins/common/IEFixes.js?207"></script>
		<meta http-equiv="imagetoolbar" content="no" />
		<![endif]-->

		<script type= "text/javascript">/*<![CDATA[*/
		var skin = "netbeans";
		var stylepath = "/wiki/skins";
		var wgArticlePath = "/$1";
		var wgScriptPath = "/wiki";
		var wgScript = "/wiki/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://wiki.netbeans.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "API_Design";
		var wgTitle = "API Design";
		var wgAction = "view";
		var wgArticleId = "16586";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 50821;
		var wgVersion = "1.15.1";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/</script>

		



                                 <script src="http://netbeans.org/images_www/js/companion-projects.js" type="text/javascript"></script>
<link rel="stylesheet" type="text/css" href="http://netbeans.org/netbeans3.css"/><link rel="icon" type="image/vnd.microsoft.icon" href="http://netbeans.org/favicon.ico"/>



		<script type="text/javascript" src="/wiki/skins/common/wikibits.js?207"><!-- wikibits js --></script>
		<script type="text/javascript" src="/wiki/index.php?title=-&amp;action=raw&amp;gen=js&amp;useskin=netbeans"><!-- site js --></script>
		<!-- Head Scripts -->
				<script type="text/javascript" src="/wiki/skins/common/ajax.js?207"></script>




		
 <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
 <meta name="keywords" content="java IDE, java editor, java Platform, free, open source, java development, j2ee support, development enviroment, web development, NetBeans, IDE, java" />



	</head>

<!-- Body -->
<body 		class="mediawiki composite blue-bg  ltr ns-0 ns-subject page-API_Design">


<!-- INCLUDED CODE FROM NB.ORG START -->
<!-- begin TopTabs  -->
<!-- static Community tab selected banner -->
<div id="wrapper-flex">
            <div id="hdr">               
                <div id="navtabs">
                    <a href="http://netbeans.org/"><img src="//netbeans.org/images_www/v7/design/logo_netbeans_red.png" id="nblogo" width="130" height="32"/></a>
                    <ul>
                        <li class="hover first"><a href="http://netbeans.org/features/index.html" title="NetBeans&nbsp;IDE"  >NetBeans IDE</a></li>
                        <li class="hover "><a href="http://netbeans.org/features/platform/index.html" title="NetBeans&nbsp;Platform"  >NetBeans Platform</a></li>
                        <li class="hover "><a href="http://plugins.netbeans.org/PluginPortal/" title="Plugins"  >Plugins</a></li>
                        <li class="hover "><a href="http://netbeans.org/kb/index.html" title="Docs&nbsp;&amp;&nbsp;Support"  >Docs &amp; Support</a></li>
                        <li class="current "><a href="http://netbeans.org/community/index.html" title="Community"  >Community</a></li>
                        <li class="hover "><a href="http://netbeans.org/community/partners/index.html" title="Partners"  >Partners</a></li>
                    </ul> 
                    <div id="search-div">                        
                        <form action="http://netbeans.org/search_result.html" id="cse-search-box">
                            <input type="hidden" name="cx" value="006102455337629464213:mt38ytkbuak" >
                            <input type="hidden" name="cof" value="FORID:11" >
                            <input type="text" id="search-input" value="Search" name="q"/>
                            <input type="image" src="//netbeans.org/images_www/v7/design/icon_search.png" id="magnifier" alt="search"/>
                        </form>
                        <script type="text/javascript" src="//www.google.com/coop/cse/brand?form=cse-search-box&lang=en"></script>
                        <!-- Google CSE Search Box Ends -->
                    </div>
                </div>
            </div>

			<div id="navig-breadcrumbs" style="margin:0px;">

				<!-- Home - Community - Projects, and module switcher combo -->
				<a href="http://netbeans.org/index.html">HOME</a> / <a href="http://netbeans.org/community/index.html">Community</a> / <a href="/Main_Page">Wiki</a> / API Design			</div>
			<div id="middle">
                <table class="colapse full-width f-page-table-2col"> <!-- main content table -->
                    <tr>
                        <td class="valign-top">
                            <div class="f-page-auto-cell">
  <!-- Begin Content Area -->
  <!-- INCLUDED CODE FROM NB.ORG END -->


                <div id="content">

                  <!-- Page Name -->
                  <h1 class="firstHeading">API Design</h1>

                  <!-- Page Subtitle (e.g. redirect notice) -->
                  <div id="contentSub"></div>

                  <!-- Undelete Notice [conditional] -->
                      
                  <!-- Page Contents -->
                      <table id="toc" class="toc" summary="Contents"><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1"><a href="#Introduction:_How_To_Design_a_.28module.29_API"><span class="tocnumber">1</span> <span class="toctext">Introduction: How To Design a (module) API</span></a></li>
<li class="toclevel-1"><a href="#Why_API.3F"><span class="tocnumber">2</span> <span class="toctext">Why API?</span></a></li>
<li class="toclevel-1"><a href="#What_is_an_API.3F"><span class="tocnumber">3</span> <span class="toctext">What is an API?</span></a></li>
<li class="toclevel-1"><a href="#The_Importance_of_Being_Use_Case_Oriented"><span class="tocnumber">4</span> <span class="toctext">The Importance of Being Use Case Oriented</span></a></li>
<li class="toclevel-1"><a href="#Life-cycle_of_an_API"><span class="tocnumber">5</span> <span class="toctext">Life-cycle of an API</span></a>
<ul>
<li class="toclevel-2"><a href="#Private"><span class="tocnumber">5.1</span> <span class="toctext">Private</span></a></li>
<li class="toclevel-2"><a href="#Friend"><span class="tocnumber">5.2</span> <span class="toctext">Friend</span></a></li>
<li class="toclevel-2"><a href="#Devel"><span class="tocnumber">5.3</span> <span class="toctext">Devel</span></a></li>
<li class="toclevel-2"><a href="#Stable"><span class="tocnumber">5.4</span> <span class="toctext">Stable</span></a></li>
<li class="toclevel-2"><a href="#Official"><span class="tocnumber">5.5</span> <span class="toctext">Official</span></a></li>
<li class="toclevel-2"><a href="#Third_Party"><span class="tocnumber">5.6</span> <span class="toctext">Third Party</span></a></li>
<li class="toclevel-2"><a href="#Standard"><span class="tocnumber">5.7</span> <span class="toctext">Standard</span></a></li>
<li class="toclevel-2"><a href="#Deprecated"><span class="tocnumber">5.8</span> <span class="toctext">Deprecated</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Preservation_of_Investments"><span class="tocnumber">6</span> <span class="toctext">Preservation of Investments</span></a>
<ul>
<li class="toclevel-2"><a href="#Maintained_.26_unmaintained"><span class="tocnumber">6.1</span> <span class="toctext">Maintained &amp; unmaintained</span></a></li>
<li class="toclevel-2"><a href="#Examples"><span class="tocnumber">6.2</span> <span class="toctext">Examples</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Design_Practices"><span class="tocnumber">7</span> <span class="toctext">Design Practices</span></a>
<ul>
<li class="toclevel-2"><a href="#Do_not_expose_more_than_you_want"><span class="tocnumber">7.1</span> <span class="toctext">Do not expose more than you want</span></a>
<ul>
<li class="toclevel-3"><a href="#Method_is_better_than_Field"><span class="tocnumber">7.1.1</span> <span class="toctext">Method is better than Field</span></a></li>
<li class="toclevel-3"><a href="#Factory_is_better_than_Constructor"><span class="tocnumber">7.1.2</span> <span class="toctext">Factory is better than Constructor</span></a></li>
<li class="toclevel-3"><a href="#Make_Everything_Final"><span class="tocnumber">7.1.3</span> <span class="toctext">Make Everything Final</span></a></li>
<li class="toclevel-3"><a href="#Allow_access_only_from_a_friend_code"><span class="tocnumber">7.1.4</span> <span class="toctext">Allow access only from a friend code</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Separate_API_for_clients_from_support_API"><span class="tocnumber">7.2</span> <span class="toctext">Separate API for clients from support API</span></a>
<ul>
<li class="toclevel-3"><a href="#The_Client_vs._Provider_API"><span class="tocnumber">7.2.1</span> <span class="toctext">The Client vs. Provider API</span></a></li>
<li class="toclevel-3"><a href="#Expressing_API.2FSPI_in_C_and_Java"><span class="tocnumber">7.2.2</span> <span class="toctext">Expressing API/SPI in C and Java</span></a></li>
<li class="toclevel-3"><a href="#Evolution_of_API_is_a_different_process_than_evolution_of_SPI"><span class="tocnumber">7.2.3</span> <span class="toctext">Evolution of API is a different process than evolution of SPI</span></a></li>
<li class="toclevel-3"><a href="#Example"><span class="tocnumber">7.2.4</span> <span class="toctext">Example</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Interfaces_vs._abstract_classes"><span class="tocnumber">7.3</span> <span class="toctext">Interfaces vs. abstract classes</span></a>
<ul>
<li class="toclevel-3"><a href="#The_Advantages_of_Interfaces"><span class="tocnumber">7.3.1</span> <span class="toctext">The Advantages of Interfaces</span></a></li>
<li class="toclevel-3"><a href="#The_Advantages_of_Abstract_Classes"><span class="tocnumber">7.3.2</span> <span class="toctext">The Advantages of Abstract Classes</span></a></li>
<li class="toclevel-3"><a href="#Use_cases"><span class="tocnumber">7.3.3</span> <span class="toctext">Use cases</span></a>
<ul>
<li class="toclevel-4"><a href="#TopManager"><span class="tocnumber">7.3.3.1</span> <span class="toctext">TopManager</span></a></li>
<li class="toclevel-4"><a href="#Cookies"><span class="tocnumber">7.3.3.2</span> <span class="toctext">Cookies</span></a></li>
<li class="toclevel-4"><a href="#FileObject"><span class="tocnumber">7.3.3.3</span> <span class="toctext">FileObject</span></a></li>
<li class="toclevel-4"><a href="#CloneableEditorSupport"><span class="tocnumber">7.3.3.4</span> <span class="toctext">CloneableEditorSupport</span></a></li>
</ul>
</li>
<li class="toclevel-3"><a href="#Interfaces_or_Classes.3F"><span class="tocnumber">7.3.4</span> <span class="toctext">Interfaces or Classes?</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Case_Study_of_client_API_and_SPI_separation"><span class="tocnumber">7.4</span> <span class="toctext">Case Study of client API and SPI separation</span></a>
<ul>
<li class="toclevel-3"><a href="#Move_Protected_Methods_Into_Interface"><span class="tocnumber">7.4.1</span> <span class="toctext">Move Protected Methods Into Interface</span></a></li>
<li class="toclevel-3"><a href="#Passing_Notifications_to_Implementation"><span class="tocnumber">7.4.2</span> <span class="toctext">Passing Notifications to Implementation</span></a></li>
<li class="toclevel-3"><a href="#Callbacks_to_Implementation"><span class="tocnumber">7.4.3</span> <span class="toctext">Callbacks to Implementation</span></a></li>
<li class="toclevel-3"><a href="#Extensible_Client_Behaviour"><span class="tocnumber">7.4.4</span> <span class="toctext">Extensible Client Behaviour</span></a></li>
<li class="toclevel-3"><a href="#Extensible_Communication_betwen_provider_and_implementation"><span class="tocnumber">7.4.5</span> <span class="toctext">Extensible Communication betwen provider and implementation</span></a></li>
<li class="toclevel-3"><a href="#Extensible_Provider_Evolution"><span class="tocnumber">7.4.6</span> <span class="toctext">Extensible Provider Evolution</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Using_games_to_Improve_API_Design_Skills"><span class="tocnumber">7.5</span> <span class="toctext">Using games to Improve API Design Skills</span></a></li>
</ul>
</li>
</ul>
</td></tr></table><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>
<a name="Introduction:_How_To_Design_a_.28module.29_API" id="Introduction:_How_To_Design_a_.28module.29_API"></a><h1> <span class="mw-headline">Introduction: How To Design a (module) API</span></h1>
<p>Read more in the newly published book: <a href="http://wiki.apidesign.org/wiki/Main_Page" class="extiw" title="apidesign:Main Page">Practical API Design</a>
</p>
<dl><dt> <b>Abstract:</b>
</dt><dd> A description of good design practices when design any APIs with especially closer look to the case of an API based on NetBeans infrastructure is content of this evolving document.
</dd></dl>
<a name="Why_API.3F" id="Why_API.3F"></a><h1> <span class="mw-headline">Why API?</span></h1>
<p>The API stands for <i>Application Programming Inteface</i> and before we drill down to descriptions and suggestions how to write it, it is not unreasonable to analyze a bit the meaning of these words.
</p><p>The word <i>interface</i> indicates that the <i>API</i> lives between at least two different subjects. For example the internal structure of the application could be seen on one side, while leaving foreing applications making calls into it on the on the other. Or there is the programmer (or team) developing the application and its API on one side and on the other the programmers using it. The important observation is that in both cases these two sides are <i>separated</i> - either <i>compiled</i> separatelly or <i>developed</i> in completely different groups with their own schedules, goals and needs.
</p><p>It is exactly this <i>separation</i> that implies that rules for designing and maintaining an API. If there was no <i>separation</i> and the whole product was developed by tight team, build at once, there would be no need for bothering with API (as it is definitively more work) and also writing this tutorial. But as the real world <b>products</b> are composed from a set of independent <b>projects</b> developed by teams that do not necessarily know about each other, have completely different schedules and build their projects independently, but still want to communicate among themselves there is a need for a <b>stable</b> <b>contract</b> that can be used <b>for</b> such <b>communication</b>.
</p><p><i>Example: <b>Linux</b> distributions are done by Mandrake or RedHat, but their content is composed from a thousands of independent open source projects. The producer of the distribution cannot influence their work, it just takes what is available and stable at given time, makes sure that everything works together and creates the release.</i>
</p>
<a name="What_is_an_API.3F" id="What_is_an_API.3F"></a><h1> <span class="mw-headline">What is an API?</span></h1>
<p>As the reason why API is used is to allow communictation between teams and applications in order to allow separated and distributed development the answer to question what is API shall include everything that influences such kind of development.
</p><p><i>The API is everything that another team or application can depend on</i>:
</p>
<ul><li> <b>method and field signatures</b> - communication between applications is usally about calling functions and passing data structures between each other. If there is a change in the names of the methods, in their arguments or in structure of exchanged data, the whole program often does not even link well, nor it can run.
</li><li> <b>files and their content</b> - many applications read various files and their content can influence their behaviour. Imagine application relying on the other one to read its configuration file and modifying its content prior to invoking the application. If the format of the file changes or the file is completely ignored, the communication between those applications gets broken.
</li><li> <b>environment variables</b> - for example behaviour of <code>cvs</code> can be influenced by the variable <code>CVSEDITOR</code>.
</li><li> <b>protocols</b> - opening a socket and being prepared to interpret streams sent there, or putting or reading a data to clipboard or during drag and drop again establishes an API that others can depend on.
</li><li> <b>behaviour</b> - a bit harder to grip, but important for the separation as well is the the dynamic behaviour. How the program flow looks like - what is the order of execution, what locks are being held during calls, in which threads a call can happen, etc.
</li><li> <b>L10N messages</b> - because the localization to a certain language is usually developed and distributed by somebody other than the person that writes the code, yet both of them have to use the same keys (<code>NbBundle.getMessage ("CTL_SomeKey")</code>), there is inherently a contract between the writer of the code and the translator - an API of sorts.
</li></ul>
<p>The important thing with respect to distributed development is to be aware of possible APIs - of possible things other code can depend on. Only by identifying such aspects of own application one can develop it in a way that will not hurt cooperation with seperately developed applications.
</p>
<a name="The_Importance_of_Being_Use_Case_Oriented" id="The_Importance_of_Being_Use_Case_Oriented"></a><h1> <span class="mw-headline">The Importance of Being Use Case Oriented</span></h1>
<p>It is often not hard to decide whether a program is good or bad - if it crashes without doing anything useful, it is bad. If the program cannot compile, it is even worse. But if it runs, helps to get a work done, just sometimes crashes, it is hardly good, but also it does not need to completely bad. The decision depends on the perception of the evaluator. The <i>subjective feeling</i> does matter. And the same applies when one tries to judge a design. It does not matter whether it is a UI design or API design. Again the personal perception is important.
</p><p>On the other hand software engineering is (or at least should be) done by engineers and important part of engineering is its measurability. So the ultimate goal for reasoning about design is to make it measurable, to suppress the subjective opinions and define set of requirements that will be used to measure the quality of the design. Of course defining the requirements might need some personal opinions, but as soon as they are written down, one can become pure engineer and use pure scientific methods to measure how much they are satisfied.
</p><p>But as shown on the example of a good/bad program, the users <i>subjective feeling</i> is important. And it is important in design as well. But in case of <i>API</i>, which stands for the interface between the internals of an application and a programatic usage of its functionality, the person that will have the <i>subjective feeling</i> is the programmer using the <i>API</i>. He is the <i>API</i> user. He is the one that will judge the design and represent opinions whether it is good or bad. Of course, such opinions will be absolutely personal, based on personal experience gain during learning the desing and using the API. The easier is for the <i>API</i> users to make their job done, the better perception of the design they will get.
</p><p>The external programmer is more concerned by the time needed to learn the API, by the amount of code needed to get his tasks done and by the stability of the contract. The art of making good API lays exactly in meeting these opposite requirements.
</p><p>As usually one shall optimize for larger audience, for bigger effect. Usually the amount of people using an API is a way larger than those coding it, and that is why one shall take a special care to simplify the life of these users. Little uneasiness in implementing the application is acceptable, if the life of majority of users is simpler. To better address user needs it is necessary to know and understand their requirements. If an API allows easy implementation of the common tasks, it is a good API.
</p><p>That is why the initial step in API design is to investigate and collect the scenarios for possible uses of the application. Having these use cases written down allows evaluation of each aspect of the API and validation of the design. The use cases serve as a fixed point to which one validates the design of API. It is practically impossible to jugde the quality of a design, but it is relatively easy to check whether the design satisfies required use cases or not.
</p><p>Once a usecase becomes supported, it should stay supported until the end of the world (e. g. until it is not interesting anymore).
</p>
<a name="Life-cycle_of_an_API" id="Life-cycle_of_an_API"></a><h1> <span class="mw-headline">Life-cycle of an API</span></h1>
<p>There seems to be two ways a feature can become an <i>API</i> (defining <i>API</i> as a stable interface that others can use over time without unpleasant surprises). An <i>API</i> can be evolved
</p>
<ul><li> <b>spontaneously</b> - someone is developing a feature, and another person finds it useful and starts to use it. Later they find out about each other, share their experiences and very likely find that the original design of the feature is not general enough or that it was never intended to be treated as an <i>API</i> In order to evolve it toward being an <i>API</i> they discuss changes to make the feature better and after few iterations it can become a useful and stable contract.
</li><li> <b>by design</b> - there is a known need for a contract between two components of the system. The requirements are collected, the problem area investigated, the use cases understood, and then someone designs and writes the <i>API</i>. Now others can use it in real world, comment, file bugs and enhancements which results in improvements to the <i>API</i> and finally evolve it into a state where it is a useful and stable contract.
</li></ul>
<p>In spite that these cases start differently they share the same attributes: Both of them need some time for feedback and evaluation before the <i>API</i> can be known to work and suit its purpose. Not every effort ends as its life as a stable API; sometimes it may turn out that the chosen way leads nowhere and then it is better to abandon the work.
</p><p>In order to clearly communicate what stage an <a href="/API" title="API" class="mw-redirect">API</a> is in, whether it is still being evolved, whether it is expected to ever be real <i>API</i> or whether it is stable and ready to use, let us introduce a system of <a href="/API_Stability" title="API Stability">stability clasification for APIs</a>. The aim is to give the code authors way how to communicate their intention with particular feature and others to find out such information.
</p>
<a name="Private" id="Private"></a><h2> <span class="mw-headline"> Private </span></h2>
<p><b>Private</b> is a category for features that are accessible but are not intended for use outside of their component (module). Such features are subject to change with every release and depending on them is risky and should be avoided.
</p>
<a name="Friend" id="Friend"></a><h2> <span class="mw-headline"> Friend </span></h2>
<p><b>Friend</b> <a href="/API" title="API" class="mw-redirect">API</a> is used for features accessible to specific components in the system, that help to overcome the lack of a real stable <a href="/API" title="API" class="mw-redirect">API</a>, but are intended only for use between these <i>friend</i> components and nobody else. Often friend components are developed by the same group of people. A change to this contract can be done every release, but owners of those <i>friend</i> components must be notified in advance. No one else should depend on such features - the author of this API does not have the intent to create a general purpose API.
</p>
<a name="Devel" id="Devel"></a><h2> <span class="mw-headline"> Devel </span></h2>
<p><b>Under development</b> is a name for a contract that is expected to become a stable API, but that has not yet been finished. The current state serves as a proof of concept, and others are encourage to try it and comment on a dedicated mailing list. Incompatible changes may be done between releases, but should be rare, not radical and properly announced on the mailing list.
</p>
<a name="Stable" id="Stable"></a><h2> <span class="mw-headline"> Stable </span></h2>
<p><b>Stable</b> interfaces are those that have received a final state and the maintainers are ready to support it forever and never change them incompatibly. The "forever" and "never" should not be taken as absolute: It is possible to change the contract, but only in major versions and only after a careful considerations and in cases where it is imperative that a change be made. Stable contracts should [#poi preserve the investments ] of those entering into them (users of an <a href="/API" title="API" class="mw-redirect">API</a>).
</p>
<a name="Official" id="Official"></a><h2> <span class="mw-headline"> Official </span></h2>
<p><b>Official</b> are <a href="#Stable" title="">stable</a> ones and also packaged into one of NetBeans official namespaces: <code>org.netbeans.api</code> or <code>org.netbeans.spi</code> or <code>org.openide</code>. By packaging a contract into this package (and making it part of a release) one notifies others that the contract is <a href="/APIDevelopment#Official_APIs_Restrictions" title="APIDevelopment">stable - with all the consequence</a> (except the conditional support for <a href="/APIDevelopment#Support_for_Early_Adoption" title="APIDevelopment">early adoptions</a> - such modules has code base name that ends with with /0). Also, the impact of possible incompatible changes to <i>official</i> API should be minimized by providing compatibility bridges and keeping binary compatibility even when source one is droped (see the <a href="#Preservation_of_Investments" title="">preservation</a> section).
</p>
<a name="Third_Party" id="Third_Party"></a><h2> <span class="mw-headline"> Third Party </span></h2>
<p><b>Third party</b> interfaces are provided by other parties that do not follow the <i>NetBeans</i> rules and thus are hard to classify. It is prefered not to expose such interfaces as part of own contracts, in order to insulate users of NetBeans APIs from unexpected changes made in the imported interfaces.
</p>
<a name="Standard" id="Standard"></a><h2> <span class="mw-headline"> Standard </span></h2>
<p><b>Standard</b> is similar to the <i>third party</i> classification. Also provided by someone out of <i>NetBeans</i>, but by someone expected to evolve the interface in compatible way (for example <a href="http://www.jcp.org" class="external text" title="http://www.jcp.org" rel="nofollow">JSRs</a>). The standard is expected to not change frequently.
</p>
<a name="Deprecated" id="Deprecated"></a><h2> <span class="mw-headline"> Deprecated </span></h2>
<p><b>Deprecated</b>. After a while, nearly every <i>API</i>, regardless of what state it is, becomes obsoleted. Usually a new, better support for the same task has been developed which replaces the old <i>API</i>. In such case, mark the old <i>API</i> <cite>deprecated</cite>. A previously stable <i>API</i> that changed its stability to <cite>deprecated</cite> shall be supported for reasonable amount of time (a release) to communicate to users that they shall migrate from it to the new replacement. After that time the API can be removed from the product, while trying to preserve it for old clients by making it available in alternative ways (e. g. autoupdate centers).
</p><p>At the beginning of this chapter two different ways have been mentioned how an API can be developed. Doing that <b>spontaneously</b> means in the light of the above <a href="/API_Stability" title="API Stability">API Stability</a> categories to introduce a <i>private</i> or <i>friend</i> <a href="/API" title="API" class="mw-redirect">API</a>, that is discovered by someone else, found useful and than evolves into <i>stable</i> one as described. An <a href="/API" title="API" class="mw-redirect">API</a> developed by design is more likely to begin its life with <i>under development</i> <a href="/API_Stability" title="API Stability">API Stability</a> status and after a bit of work can turn into <i>stable</i> API.
</p>
<a name="Preservation_of_Investments" id="Preservation_of_Investments"></a><h1> <span class="mw-headline">Preservation of Investments</span></h1>
<p>One of the most important things for NetBeans is fair treatment of our partners. Module authors, platform extenders, contributors and others have to be sure that their work will not vanish or break whenever a new release of NetBeans is announced. Their work has a right to be respected and admired. As long as NetBeans succeeds at that we can be sure that our partners will describe their experience to others and evangelize and evolve the NetBeans community.
</p><p>Because different parts of the system communicate with each other using public contracts (API, SPI, registration places, defined functional behavior), the way to preserve participants' investments is to always evolve these contracts in compatible ways. Each new version of NetBeans should make sure that it allows existing modules to execute and work in reasonable way, or, failing that, that it is easy to update existing sources to compile and use the contracts of the new release.
</p>
<a name="Maintained_.26_unmaintained" id="Maintained_.26_unmaintained"></a><h3> <span class="mw-headline">Maintained &amp; unmaintained</span></h3>
<p>Another reason why it is necessary that previous versions of modules continue to work is that often there is a module that works well and does an excellent job for its users, but in reality it is unmaintained. This can happen because the owner has left, works on different project or the company that created it does not exist anymore. There are even some projects on netbeans.org which are unmaintain but still serving their users well. If a new NetBeans version is released and introduces serious incompatibilities so the module fails to work, it is the authors of NetBeans who get blamed and shamed. That is why support for previously compiled modules is a necessary step: We must respect work that has been done and is currently unmaintained.
</p><p>On the other hand, the owner may still be alive, and want to bring their code up to date - for example, one of the reasons for changes to APIs is to improve performance, something any module author would want to take advantage of. This should be easy to do, requiring no work in most cases. However, even if great attention is paid to evolving the APIs well, in some cases updating may require a bit of work. If someone is maintaining a module, they are expected to make the necessary updates to the code to bring keep it in line with the current API set.
</p>
<a name="Examples" id="Examples"></a><h3> <span class="mw-headline">Examples</span></h3>
<p>Even the biggest currently known change of behavior (the classpath change planned for 4.0) still allows a user to use a module developed against previous version of NetBeans and correctly use its functionality. If someone wants to use an old module, the only necessary thing is to setup the roots of filesystems to match the classpath.
</p><p>On the other hand, APIs are designed by human beings, and the best of APIs may still contain things that turn out later to be mistakes. One example of such a mistake is the Node.Cookie marker interface, which restricts the usability of Cookies and forces a dependency on the nodes package that is not strictly necessary. This interface should be removed. As such the Node.Cookie Node.getCookie (Class) method will be changed to Object Node.getCookie (Class). Even after the change it can be guaranteed that old modules will continue to run. On the other hand, the originally correct source code cannot compile anymore. It is observed that 99% of all uses of that method will continue to compile - like
</p><p><br /> 
</p>
<pre><span class="type">MyCookie</span> <span class="variable-name">c</span> = (<span class="type">MyCookie</span>)node.getCookie(MyCookie.<span class="keyword">class</span>);
</pre>
<p>The remaining 1% of uses, which look like:
</p><p><br /> 
</p>
<pre><span class="type">Node.Cookie</span> <span class="variable-name">c</span> = node.getCookie(something);
</pre>
<p>will have to be updated, but active module authors will do it gladly because they profit by having their classes become more flexible, and the change that must be done is very simple. Of course instruction for doing this update has to be prominent part of release migration guide.
</p>
<a name="Design_Practices" id="Design_Practices"></a><h1> <span class="mw-headline">Design Practices</span></h1>
<p>Let's talk about actual Java design practices and patterns that help the writer and maintainer to achieve the general suggestions and rules that have been discussed in previous chapters and the make the user of an API feel comfortable, unsurprised and happy.
</p>
<a name="Do_not_expose_more_than_you_want" id="Do_not_expose_more_than_you_want"></a><h2> <span class="mw-headline">Do not expose more than you want</span></h2>
<p>Obviously the less of the implementation is expressed in the API, the more flexibility one can have in future. There are some tricks that one can use to hide the implementation, but still deliver the desired functionality. This section will discuss some of such tricks.
</p>
<a name="Method_is_better_than_Field" id="Method_is_better_than_Field"></a><h4> <span class="mw-headline">Method is better than Field</span></h4>
<p>It is better to use methods (usually getters and setters) to access fields than to expose them directly. The first reason is that a call to a method can do a lot of additional things, but in contrast an access to a field can only read or write the value. When using getters one can for example do lazy initialization, synchronize the access or compose the value using some computation algorithm. Setters on the other hand allow checks for correctness of assigned value or notification of listeners when the change happens.
</p><p>The other reason why to prefer methods can be found in the <i>Java Virtual Machine</i> specification. It is allowed to move a method from a class to one of its superclasses and still remain binary compatible. So a method initially introduced as <code>Dimension javax.swing.JComponent.getPreferredSize(Dimension d)</code> can be deleted in new version and moved to <code>Dimension java.awt.Component.getPreferredSize(Dimension d)</code> as the <code>JComponent</code> is a subclass of <code>Component</code> (this really happened in JDK 1.2). Such operation is not allowed for fields. Once a field is defined in a class, it has to stay there forever in order to keep binary compatibility. That is another reason why it is better to keep fields private.
</p>
<a name="Factory_is_better_than_Constructor" id="Factory_is_better_than_Constructor"></a><h4> <span class="mw-headline">Factory is better than Constructor</span></h4>
<p>It is more flexible to expose a factory method than to expose constructor. Once a constructor is available as part of an API, it guarantees not only that an instance assignable to a given class will be created, but also that the instance will be of the <b>exact class</b> (no subclasses allowed) and also that a <b>new instance</b> is created every time.
</p><p>If instead a factory method is provided (usually a static method that takes the same arguments as the constructor and returns instance of the same class the constructor is defined in), one has more possibilities. First of all one does not need to return the exact class, but some subclass - allows to use polymophism and possibly clean up the code. Second avantage is to cache instances. While in case of constructor new instance is created every time, the factory method can cache previously instantiated objects and reuse them in order to save the memory. Another reason is the possibility of proper synchronization when invoking the factory method which is not possible (at least is limited) in case of plain constructor. These are the reasons why one shall prefer factory methods over constructors.
</p>
<a name="Make_Everything_Final" id="Make_Everything_Final"></a><h4> <span class="mw-headline">Make Everything Final</span></h4>
<p>In a lot of cases people are not designing for subclassing and still they do not prevent it. If you are writing an API and you explicitly do not want people to subclass or implement your interfaces (also see paragraph about [#design.apiandspi API vs. SPI]) it is better to disallow that.
</p><p>Simplest solution is to make your class <code>final</code>. Other tricks include non-public constructors (one shall do it anyway in favor of [#design.less.factory factory methods]) or making all (or at least most) methods <code>final</code> or <code>private</code>.
</p><p>Of course this works only for classes, if you decide to use interfaces you cannot forbid foreign implementations on the level of virtual machine, you can only ask people in JavaDoc not to do it.
</p>
<a name="Allow_access_only_from_a_friend_code" id="Allow_access_only_from_a_friend_code"></a><h4> <span class="mw-headline">Allow access only from a friend code</span></h4>
<p>Another useful technique to not expose too much in API is to give access to certain functionality (e. g. ability to instantiate a class or to call a certain method) just to a friend code.
</p><p>Java by default restricts the friends of a class to those classes that are in the same package. If there is a functionality that you want share just among classes in the same package, use <i>package-private</i> modifier in definition of a constructor, a field or a method and then it will remain accessible only to friends.
</p><p>Sometimes however it is more useful to extend the set of friends to a wider range of classes - for example one wants to define a pure API package and put the implementation into separate one. In such cases following trick can be found useful. Imagine there is a class item (btw. also you can also check out <a href="http://treefs.netbeans.org/source/browse/treefs/apidesign/friendpackage/" class="external text" title="http://treefs.netbeans.org/source/browse/treefs/apidesign/friendpackage/" rel="nofollow">sources from CVS</a>):
</p><p><br /> 
</p>
<pre><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="type">api</span>.Item {
    <span class="comment">/** Friend only constructor */</span>
    <span class="type">Item</span>(<span class="type">int</span> <span class="variable-name">value</span>) {
        <span class="keyword">this</span>.value = value;
    }

    <span class="comment">/** API method(s) */</span>
    <span class="keyword">public</span> <span class="type">int</span> <span class="function-name">getValue</span>() {
        <span class="keyword">return</span> value;
    }

    <span class="comment">/** Friend only method */</span>
    <span class="keyword">final</span> <span class="type">void</span> <span class="function-name">addListener</span>(<span class="type">Listener</span> <span class="variable-name">l</span>) {
        <span class="comment">// some impl
</span>    }
}
</pre>
<p>that is part of the API, but cannot be instanitated nor listened on outside of the friend classes (but these classes are not only in api package). Then one can define an <code>Accessor</code> in the non-API package:
</p><p><br /> 
</p>
<pre><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="type">impl</span>.Accessor {
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Accessor</span> <span class="variable-name">DEFAULT</span>;

    <span class="keyword">public</span> <span class="keyword">static</span> Accessor getDefault() {
        <span class="keyword">if</span> (DEFAULT&nbsp;!= <span class="keyword">null</span>) {
            <span class="keyword">return</span> DEFAULT;
        }

        <span class="comment">// invokes static initializer of Item.class</span>
        <span class="comment">// that will assign value to the DEFAULT field above</span>
        <span class="type">Class</span> <span class="variable-name">c</span> = api.Item.<span class="keyword">class</span>;
        <span class="keyword">try</span> {
            <span class="type">Class</span>.forName(<span class="variable-name">c</span>.getName(), true, <span class="variable-name">c</span>.getClassLoader());
        } <span class="keyword">catch</span> (<span class="type">ClassNotFoundException</span> <span class="variable-name">ex</span>) {
            <span class="keyword">assert</span> false&nbsp;: ex;
        }
        <span class="keyword">assert</span> <span class="variable-name">DEFAULT</span>&nbsp;!= <span class="keyword">null</span>&nbsp;: "The DEFAULT field must be initialized";
        <span class="keyword">return</span> DEFAULT;
    }

    <span class="comment">/** Accessor to constructor */</span>
    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">Item</span> <span class="function-name">newItem</span>(<span class="type">int</span> <span class="variable-name">value</span>);
    <span class="comment">/** Accessor to listener */</span>
    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">void</span> <span class="function-name">addListener</span>(<span class="type">Item</span> <span class="variable-name">item</span>, <span class="type">Listener</span> <span class="variable-name">l</span>);
}
</pre>
<p>with abstract methods to access all friend functionality of the <code>Item</code> class and with a static field to get the accessor's instance. The main trick is to implement the <code>Accessor</code> by a (non-public) class in the <code>api</code> package:
</p><p><br /> 
</p>
<pre><span class="keyword">final</span> <span class="keyword">class</span> <span class="type">api</span>.AccessorImpl <span class="keyword">extends</span> <span class="type">impl.Accessor</span> {
    <span class="keyword">public</span> <span class="type">Item</span> <span class="function-name">newItem</span>(<span class="type">int</span> <span class="variable-name">value</span>) {
        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Item</span>(value);
    }
    <span class="keyword">public</span> <span class="type">void</span> <span class="function-name">addListener</span>(<span class="type">Item</span> <span class="variable-name">item</span>, <span class="type">Listener</span> <span class="variable-name">l</span>) {
        item.addListener(l);
    }
}
</pre>
<p>and register it as the default instance first time somebody touches <code>api.Item</code> by adding a static initializer to the <code>Item</code> class:
</p><p><br /> 
</p>
<pre><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="type">Item</span> {
    <span class="keyword">static</span> {
        impl.Accessor.DEFAULT = <span class="keyword">new</span> <span class="type">api.AccessorImpl</span>();
    }

    <span class="comment">// the rest of the Item class as shown above
</span>}
</pre>
<p>Then the <i>friend</i> code can use the accessor to invoke the hidden functionality from any package:
</p><p><br /> 
</p>
<pre><span class="type">api.Item</span> <span class="variable-name">item</span> = impl.Accessor.getDefault().newItem(10);
impl.Accessor.getDefault().addListener(item, <span class="keyword">this</span>);
</pre>
<p>Please note that in <i>NetBeans</i> this is very useful in combination with specifying publicly accessible packages in module manifest (<code>OpenIDE-Module-Public-Packages: api.**</code>) and thus disallowing on the class loading level other modules from accessing the <code>impl.Accessor</code>.
</p>
<a name="Separate_API_for_clients_from_support_API" id="Separate_API_for_clients_from_support_API"></a><h2> <span class="mw-headline">Separate API for clients from support API</span></h2>
<p>Are there really more types of API? If so, how do they differ? Do the users of those types differ? Do they have different expectations? Those are questions that shall be answered in the first part of this section. Then we will try to define the restrictions on evolution of different types of API, and present some tips, tricks and lessons learned, which one can use to achieve and enforce such restrictions.
</p>
<a name="The_Client_vs._Provider_API" id="The_Client_vs._Provider_API"></a><h4> <span class="mw-headline">The Client vs. Provider API</span></h4>
<p>Before we start, we should ask a question: Who is the client and who is the provider? Let us do it on an example of <i>XMMS</i>, the media player for <i>UNIX</i>es (called WinAmp on another platform).
</p><p>The player can play audio files, can skip to next song, return to previous one, offers a playlist with possibility to add, remove and reorder songs. The functionality is provided for users, but accessible to other programs as well. So a program can call <code>xmms.pause()</code> or <code>xmms.addToPlaylist(filename)</code>. As can be seen, the communication is initiated by the other program that uses the player's API to instruct it to perform an action. After the execution of the command ends, the control returns back to the caller. Let's name the caller a client and such an API a <i>client API</i>.
</p><p>On the other hand, the <i>XMMS'</i> APIs also allows third parties to register <i>output plugin</i>s. The functionality of the default player can be extended by providing a utility method that writes the played data to a disk, broadcasts it over a network, etc. The communication is in this case initiated by the player itself. After collecting enough data for playback, the program locates the current output plugin and sends it the data to process: <code>plugin.playback (data)</code>. After finishing the playback the execution is returned back to the player that can continue in gathering more data and the whole process continues. Is the plugin a client? Well, it is in completely different position than the client in previous paragraph. It does not instruct <i>XMMS</i> to do something, it increases the list of things <i>XMMS</i> can do. So no, the plugin is not a client. <i>XMMS</i> ability to register plugins is a <i>Service Provider Interface</i>, or SPI.
</p>
<a name="Expressing_API.2FSPI_in_C_and_Java" id="Expressing_API.2FSPI_in_C_and_Java"></a><h4> <span class="mw-headline">Expressing API/SPI in C and Java</span></h4>
<p>In this section we will discuss the actual implementation of the API in two sample languages - procedural C and object oriented Java.
</p><p>The C language is ready and suitable for expressing (client) API. One just writes the methods and announces them in the header files, so others can compile agaist them:
</p><p><br /> 
</p>
<pre><span class="type">void</span> <span class="function-name">xmms_pause</span>();
<span class="type">void</span> <span class="function-name">xmms_add_to_playlist</span>(<span class="type">char</span> *file);
</pre>
<p>The Java way is not much different:
</p><p><br /> 
</p>
<pre><span class="keyword">class</span> <span class="type">XMMS</span> {
    <span class="keyword">public</span> <span class="type">void</span> <span class="function-name">pause</span>();
    <span class="keyword">public</span> <span class="type">void</span> <span class="function-name">addToPlaylist</span>(<span class="type">String</span> <span class="variable-name">file</span>);
}
</pre>
<p>but one has more choices. It is possible to declare these methods static, to leave them as instance methods, make them abstract, final, etc. But generally speaking, the way C and Java handle client APIs is nearly similar. However the situation is a far different when writing an SPI.
</p><p>In order to write own plugin for <i>XMMS</i> in C one has to start with a method that will do the playback. So the a plugin must define:
</p><p><br /> 
</p>
<pre><span class="type">void</span> <span class="function-name">my_playback</span>(<span class="type">char</span> *data) {
    <span class="comment">// do the playback
</span>}
</pre>
<p>and the player itself has to have some registration method, for example,
</p><p><br /> 
</p>
<pre><span class="type">void</span> <span class="function-name">xmms_register_playback</span>((<span class="type">void</span>)(f*)(<span class="type">char</span>*));
</pre>
<p>that the plugin should call to register itself. <code> xmms_register_playback(my_playback)</code> and its playback function is then called by the <i>XMMS</i> whenever necessary. In Java the contract starts with a definition of playback interface:
</p><p><br /> 
</p>
<pre><span class="keyword">interface</span> XMMS.<span class="type">Playback</span> {
    <span class="keyword">public</span> <span class="type">void</span> <span class="function-name">playback</span>(<span class="type">byte</span>[] <span class="variable-name">data</span>);
}
</pre>
<p>then my plugin has to implement that interface <code>MyPlayback implements XMMS.Playback</code> and register that instance to the player:
</p><p><br /> 
</p>
<pre>XMMS.registerPlayback(<span class="keyword">new</span> <span class="type">MyPlayback</span>());
</pre>
<p>and that is all. The player can do its calls to the plugin as it could in case of C. The major difference is that writing this kind of code is taught in Java courses without a proper explanation of what it really means.
</p><p>In the C case, the amount of work to produce an SPI (for example callback) is high enough to prevent beginner from even trying it. One's knowledge has to grow significantly to get to state when one can (or will need to) design an SPI. But in Java any declared method that is not private, final or static is defacto an invitation for someone to provide a callback and thus an accidental SPI. This is often not well understood by programmers, teachers, and is not part of conventional wisdom. Any Java book introduces public, non-static and non-final methods in one of the first chapters (at least as soon as it starts to talk about Applets) without a proper warning of all consequences. That may be fine for simple development, but when one starts to design APIs, all habits learned at the begining turn into mistakes.
</p>
<a name="Evolution_of_API_is_a_different_process_than_evolution_of_SPI" id="Evolution_of_API_is_a_different_process_than_evolution_of_SPI"></a><h4> <span class="mw-headline">Evolution of API is a different process than evolution of SPI</span></h4>
<p>Evolution is a natural part of any contract. After a time everything gets obsoleted, insufficient or broken. APIs and SPIs are not exceptions. So it is better be prepared for evolution at the begining, plan for it and avoid mistakes that would otherwise be hard to undo.
</p><p>In case of an API that is offering methods to clients, there is no problem with additions. Extending the functionality to offer more functionality to clients cannot hurt them - if they do not want they do not need to use it.
</p><p>In the cas of an SPI, the situation is exactly the oposite. Adding new method into an interface that others must provide effectively breaks all existing implementations, because they do not implement it!  On the other hand it acceptable and valid to stop calling (de facto removal) a method from an SPI. If the operation flow is not part of the contract, not calling one method should not break anything.
</p><p>So the way of evolution depends on the type of the interface: API additions are fine but removing functionality is not; SPI de-facto removals are allowed, but additions are not. At the begining of producing a contract, one should realize and understand which parts will be API that clients will call, and what will be SPI that will extend the functionality one is writing. The biggest mistake that one can make is to <i>mix API and SPI together</i> into one class. Then there is no room for evolution. Adding a method is forbidden because of the contract for SPIs and removing because of the contract for APIs. <i>Always separate API and SPI</i>.
</p>
<a name="Example" id="Example"></a><h4> <span class="mw-headline">Example</span></h4>
<p>As an example let us choose <code>DataObject</code> class, a part of the <a href="http://www.netbeans.org/download/dev/javadoc/LoadersAPI/org/openide/loaders/DataObject.html" class="external text" title="http://www.netbeans.org/download/dev/javadoc/LoadersAPI/org/openide/loaders/DataObject.html" rel="nofollow">Data System API</a>. It is used for by clients to obtain a logical, representation of a file or set of files, and logically manipulate their contents:
</p><p><br /> 
</p>
<pre><span class="comment">// locate a data object
</span><span class="type">DataObject</span> <span class="variable-name">obj</span> = DataObject.find(fo);
<span class="comment">// move it to different place
</span>obj.move(destination);
<span class="comment">// try to open it if supported
</span><span class="type">OpenCookie</span> <span class="variable-name">o</span> = (<span class="type">OpenCookie</span>)obj.getCookie(OpenCookie.<span class="keyword">class</span>);
<span class="keyword">if</span> (o&nbsp;!= <span class="constant">null</span>) {
    o.open();
}
</pre>
<p>But the problem is that this client API is mixed together with a lot of methods provided just for subclasses (those that are protected in <a href="http://www.netbeans.org/download/dev/javadoc/LoadersAPI/org/openide/loaders/DataObject.html" class="external text" title="http://www.netbeans.org/download/dev/javadoc/LoadersAPI/org/openide/loaders/DataObject.html" rel="nofollow">javadoc </a>). They pointlessly clutter the API and moreover prevent the API from being extended in future.  Moreover not only do the API and SPI conflict and make evolution difficult, but the execution flow between API and SPI resulted in a lot of flow clashes - deadlocks.
</p><p>That is why during design of <a href="http://openide.netbeans.org/proposals/loaders/" class="external text" title="http://openide.netbeans.org/proposals/loaders/" rel="nofollow">new data systems</a> the <code>DataObject</code> has been reserved just for the API. It is supposed to be final and fully controlled by the implementation. The actual behaviour is provided by a separate SPI:
</p><p><br /> 
</p>
<pre><span class="keyword">interface</span> <span class="type">DataObjectOperator</span> {
     <span class="comment">// delegated to from DataObject.move(DataFolder df)
</span>    <span class="keyword">public</span> <span class="type">void</span> <span class="function-name">move</span>(<span class="type">DataObject</span> <span class="variable-name">obj</span>, <span class="type">DataFolder</span> <span class="variable-name">target</span>);
    <span class="comment">// delegated to from DataObject.rename(String name)
</span>    <span class="keyword">public</span> <span class="type">void</span> <span class="function-name">rename</span>(<span class="type">DataObject</span> <span class="variable-name">obj</span>, <span class="type">String</span> <span class="variable-name">name</span>);
    <span class="comment">// delegated to from DataObject.getCookie(Class clazz)
</span>    <span class="keyword">public</span> <span class="type">Object</span> <span class="function-name">getCookie</span>(<span class="type">DataObject</span> <span class="variable-name">obj</span>, <span class="type">Class</span> <span class="variable-name">clazz</span>);
    <span class="comment">// etc.
</span>}
</pre>
<p>By separating the API from SPI and fully controlling the flow between them we can evolve the API and SPI independently and moreover add various pre-condition and post-condition checks between the actual client and provider. For example it is simple to add a new method <code>DataObject.move(DataFolder df, String newName)</code> to the API that should move the object and rename it at once and bridge it as <code>move</code> and <code>rename</code> calls into the <code>DataObjectOperator</code> by default and (in case of of new improved operators) to the new method <code>moveAndRename(DataObject obj, DataFolder df, String name)</code> if provided.
</p><p>The new data systems should be an example of good design that is aware that <i>what's good for SPI implementors isn't necessarily good for API clients</i>, tries to give the API a chance to evolve and also <i>restrict SPI implementors as little as possible</i>.
</p><p>Another example in case you are not yet convinced: <a href="http://www.netbeans.org/download/dev/javadoc/AntProjectAPI/org/netbeans/api/project/ant/AntArtifact.html" class="external text" title="http://www.netbeans.org/download/dev/javadoc/AntProjectAPI/org/netbeans/api/project/ant/AntArtifact.html" rel="nofollow"><code>AntArtifact</code></a> was originally made an abstract class, rather than an interface, so that some final methods like <code>getArtifactFile</code> and <code>getScriptFile</code> could be added for clients, and <code>getID</code> could be defaulted. It seemed reasonable at the time. Of course, it turned out that later the SPI part had to be extended to support multiple artifacts and properties. Adding support for properties was easy enough to do compatibly, but adding support for multiple artifacts was messier: we had to deprecate the old single-artifact getters and introduce new getters, while preserving compatibility for old implementations. It would have been simpler to do had there been a final class <code>AntArtifact</code> with a factory method accepting an SPI interface <code>AntArtifactImpl</code> (or the like), since we could have produced a new SPI interface and a new factory method.
</p>
<a name="Interfaces_vs._abstract_classes" id="Interfaces_vs._abstract_classes"></a><h2> <span class="mw-headline">Interfaces vs. abstract classes</span></h2>
<p>There seems to be long, never-ending flame war between those who prefer the strict use of interfaces and those who like abstract classes. Such discussions continue forever, starting usually every few months again and leading nowhere, because people tend to hold to their opinions. Often such discussions start with no common ground - no agreement on use cases or requirements. Below we will look at the problem from use case point of view.
</p>
<a name="The_Advantages_of_Interfaces" id="The_Advantages_of_Interfaces"></a><h4> <span class="mw-headline">The Advantages of Interfaces</span></h4>
<p>The most obvious one is that <i>usage of the type</i>, if implemented as an abstract class, is limited as java doesn't allow multiple inheritance of classes. This only becomes a problem when a type is huge, or when it significantly enhances developer productivity to be able to subclass and reuse a base implementations. We will call these <i>support classes</i>, where one is expected to subclass and reuse a base class's implementation.
</p><p>The second advantage of interfaces is that there is an <i>enforced separation between the API and the implementation</i>. But this can be achieved with abstract classes too, with a bit of self control, while in interfaces that is enforced by the compiler.
</p>
<a name="The_Advantages_of_Abstract_Classes" id="The_Advantages_of_Abstract_Classes"></a><h4> <span class="mw-headline">The Advantages of Abstract Classes</span></h4>
<p>The main reason why people prefer to use abstract classes is their <i>ability to evolve in a time</i> - it is possible to add a new method with a default implementation without breaking existing clients or implementors (here we talk about runtime compatibility, not compile time one). Interfaces lack such functionality, so it is necessary to introduce another interface to provide future extensions. So you end up with a lot of interfaces such as <code>interface BuildTargetDependencyEx extends BuildTargetDependency</code> with additional methods. The original interface is still valid, the new one is available.
</p><p>A second very useful feature of abstract classes is the possibility of <i>restricting access rights</i>. Every method in a public interface is public and everybody can implement the interface. That for example means anybody can implement such interface, but in real life, one often wants to restrict that and have the creation under control. Interfaces lack such restrictions.
</p><p>Another thing that is possible with abstract classes is that they can contain static methods. Of course that with interface one can create separate classes with factory methods, but the truth is that a class is usually the most natural and reasonable place for factory methods that return instances.
</p>
<a name="Use_cases" id="Use_cases"></a><h3> <span class="mw-headline">Use cases</span></h3>
<p>Let's now give few real world examples and discuss whether the use of one or the other approach has some benefits and why.
</p>
<a name="TopManager" id="TopManager"></a><h4> <span class="mw-headline">TopManager</span></h4>
<p>The <a href="http://www.netbeans.org/unbranded-source/browse/~checkout~/openide/src/org/openide/TopManager.java?content-type=text/plain" class="external text" title="http://www.netbeans.org/unbranded-source/browse/~checkout~/openide/src/org/openide/TopManager.java?content-type=text/plain" rel="nofollow">TopManager </a> is one of the oldest types in the NetBeans Open APIs and was designed to bridge between the <code>org.openide.*</code> packages and their implementation in <code>org.netbeans.core</code>. There is just one instance of the manager (provided by the core) and clients of the API are not at all expected to extend/implement that type.
</p><p>Analysis shows that this is a typical situation of providing a lot of utility methods to clients with complete control over the implementation, where attention is be paid to ease of use for clients of such API, while permitting dynamic discovery of the implementation (the API is in different compilation unit [openide] than its implementation [core]).
</p><p>This is a situation where one cannot gain any advantage by using interfaces over using abstract classes. One needs a factory method, one can add new methods, separation between API and implementation is in the right hands and there is also the possibility to prevent instantiation of other instances than the default one. If you happen to be in similar situation, it is best to use an abstract class.
</p><p>An example what can happen if one chooses to use an interface is located next to <code>TopManager</code> in the same package - the <a href="http://www.netbeans.org/unbranded-source/browse/~checkout~/openide/src/org/openide/Places.java?content-type=text/plain" class="external text" title="http://www.netbeans.org/unbranded-source/browse/~checkout~/openide/src/org/openide/Places.java?content-type=text/plain" rel="nofollow">Places </a> interface. In reality it is the same singleton as the <code>TopManager</code>, it is accessed via the factory method <code>TopManager.getDefault().getPlaces()</code>. All its methods could be part of the <code>TopManager</code> as well. We just wanted to logically separate them and we did it using an interface. As a result, as newer "places" that might be useful API were created, we were afraid to add a method there after a time. Since we decided creating a <code>Places2</code> interface would be overkill, the interface started to be less and less used and now is nearly obsolete.
</p>
<a name="Cookies" id="Cookies"></a><h4> <span class="mw-headline">Cookies</span></h4>
<p>The <a href="http://www.netbeans.org/source/browse/openide/src/org/openide/cookies/" class="external text" title="http://www.netbeans.org/source/browse/openide/src/org/openide/cookies/" rel="nofollow">cookies </a> are a coding pattern that allows any object to provide a specific feature (called cookie) by calling:
</p><p><br /> 
</p>
<pre><span class="type">OpenCookie</span> <span class="variable-name">openCookie</span> = (<span class="type">OpenCookie</span>)anObject.getCookie(OpenCookie.<span class="keyword">class</span>);
<span class="keyword">if</span> (openCookie&nbsp;!= <span class="constant">null</span>) {
    openCookie.open();
}
</pre>
<p>Should the <code>OpenCookie</code> be interface or abstract class? Simple analysis can show that there is a lot of clients, users of the API, and also a lot of providers, often wanting to provide more cookies at once. Moreover the cookie itself contains just one method <code>open</code>. All of the that leads to answer that the type should be an interface. We have the ability for multiple inheritance, and there is no fear of evolving the interface because it has just one method that does it all, no need for static factory methods, no need to prevent subclassing. Thus an interface is the right choice.
</p><p>Very similar, but also very different example can be shown on another cookie - the <a href="http://www.netbeans.org/unbranded-source/browse/~checkout~/openide/src/org/openide/cookies/InstanceCookie.java?content-type=text/plain" class="external text" title="http://www.netbeans.org/unbranded-source/browse/~checkout~/openide/src/org/openide/cookies/InstanceCookie.java?content-type=text/plain" rel="nofollow">InstanceCookie </a>. It is also an interface and it used to have three methods but after few releases we realized a need for another to improve performance. So we were forced to introduced a subclass <code>InstanceCookie.Of</code> extending <code>InstanceCookie</code> and adding method <code>instanceOf</code>. This of course works, but adds a lot of pressure to users of the interface. Everyone using the API has to code as following:
</p><p><br /> 
</p>
<pre><span class="type">boolean</span> <span class="variable-name">doIAccept</span>;
<span class="type">InstanceCookie</span> <span class="variable-name">ic</span> = (<span class="type">InstanceCookie</span>)obj.getCookie(InstanceCookie.<span class="keyword">class</span>);
<span class="keyword">if</span> (ic <span class="keyword">instanceof</span> <span class="type">InstanceCookie.Of</span>) {
    doIAccept = ((<span class="type">InstanceCookie.Of</span>)ic).instanceOf(myRequiredClass);
} <span class="keyword">else</span> {
    doIAccept = ic&nbsp;!= <span class="constant">null</span> &amp;&amp;
        myRequiredClass.isAssignableFrom(ic.instanceClass());
}
</pre>
<p>The code is not too simple and moreover is spread over the whole codebase. How much simpler it would be if we could just add a new method into the cookie:
</p><p><br /> 
</p>
<pre><span class="type">boolean</span> <span class="function-name">isInstanceOf</span>(<span class="type">Class</span> <span class="variable-name">c</span>) {
    <span class="keyword">return</span> c.isAssignableFrom(instanceClass());
}
</pre>
<p>but because java does not allow default methods in interfaces, we are out of luck. Should we have used abstract class? No, we should not, the use cases are similar as with <code>OpenCookie</code>, but there is another trick that (very likely) should have been used.
</p><p>Instead of adding three methods into the interface we could add just one that would return a class with all necessary information.
</p><p><br /> 
</p>
<pre><span class="keyword">interface</span> <span class="type">InstanceCookie</span> {
    <span class="keyword">public</span> <span class="type">Info</span> <span class="function-name">instanceInfo</span>();

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="type">Info</span> <span class="keyword">extends</span> <span class="type">Object</span> {
        <span class="keyword">public</span> <span class="type">String</span> <span class="function-name">intanceName</span>();
        <span class="keyword">public</span> <span class="type">Class</span> <span class="function-name">instanceClass</span>();
        <span class="keyword">public</span> <span class="type">Object</span> <span class="function-name">instanceCreate</span>();
    }
}
</pre>
<p>This solution seems to combine the best of both worlds. Clients have simple API, providers can implement instead of extend and in the <code>instanceInfo</code> method instantiate the info either with some provided constructor or factory methods or lazily using subclassing. Also when we need to add the <code>instanceOf</code> after few releases, we can. <code>InstanceCookie.Info</code> is a class and as such can be extended by a method with a default implementation.
</p><p>Of course to make such methods additions safe, it is better to make the class final and provide factory methods that implementors of <code>InstanceCookie</code> could use. Those factory methods could either be simple, e.g. take values for <code>instanceName</code>, <code>instanceClass</code> and <code>instanceCreate</code> methods. Or the factory methods could take another interface with a methods that would be called to lazily handle the invocations of for example <code>Info.instanceCreate</code>. The actual solution depends on the needs of the users of the API.
</p><p>Please notice that similar pattern is used by java listeners. Every listener is an interface and as such it has a constant (often one) number of methods. But each method takes a subclass of <a href="http://java.sun.com/j2se/1.4/docs/api/java/util/EventObject.html" class="external text" title="http://java.sun.com/j2se/1.4/docs/api/java/util/EventObject.html" rel="nofollow">EventObject</a> which is a class and if necessary can be enhanced with a <a href="http://java.sun.com/j2se/1.4/docs/api/java/awt/dnd/DragGestureEvent.html#startDrag(java.awt.Cursor," class="external text" title="http://java.sun.com/j2se/1.4/docs/api/java/awt/dnd/DragGestureEvent.html#startDrag(java.awt.Cursor," rel="nofollow">java.awt.datatransfer.Transferable)  new method</a>.
</p>
<a name="FileObject" id="FileObject"></a><h4> <span class="mw-headline">FileObject</span></h4>
<p>Another example from NetBeans is the <a href="http://www.netbeans.org/unbranded-source/browse/~checkout~/openide/src/org/openide/filesystems/FileObject.java?content-type=text/plain" class="external text" title="http://www.netbeans.org/unbranded-source/browse/~checkout~/openide/src/org/openide/filesystems/FileObject.java?content-type=text/plain" rel="nofollow">FileObject </a> (part of the <a href="http://www.netbeans.org/download/dev/javadoc/org-openide-filesystems/org/openide/filesystems/doc-files/api.html" class="external text" title="http://www.netbeans.org/download/dev/javadoc/org-openide-filesystems/org/openide/filesystems/doc-files/api.html" rel="nofollow">filesystem API</a>). This type usage seems very close to the TopManager example (but is not as obvious): There are very few people directly subclassing <code>FileObject</code> (javadoc's HttpFileSystem, Kyley and Niclas) and tons of client API users (every NetBeans module).
</p><p>The amount of people directly subclassing <a href="http://www.netbeans.org/unbranded-source/browse/~checkout~/openide/src/org/openide/filesystems/FileSystem.java?content-type=text/plain" class="external text" title="http://www.netbeans.org/unbranded-source/browse/~checkout~/openide/src/org/openide/filesystems/FileSystem.java?content-type=text/plain" rel="nofollow">FileSystem </a> is the same as those doing that for <code>FileObject</code>, so it seems fine to choose abstract class for both types, but it is true that the filesystem would probably work as interface too.
</p><p>Moreover there is a support class, the <a href="http://www.netbeans.org/unbranded-source/browse/~checkout~/openide/src/org/openide/filesystems/AbstractFileSystem.java?content-type=text/plain" class="external text" title="http://www.netbeans.org/unbranded-source/browse/~checkout~/openide/src/org/openide/filesystems/AbstractFileSystem.java?content-type=text/plain" rel="nofollow">AbstractFileSystem </a> that most of the people providing filesystem implementations are subclass. Because it is a support class, it needs to be a concrete class or at least a factory method, but it offers five interfaces (Info, Change, Attr, List, Transfer) that are not exposed in the client API for users of filesystems, but users of it may implement to write an filesystem implementation. People who write the own filesystem implement these interfaces most of the time and can use multiple interface inheritance. And because AbstractFilesystem implements the client API contract, anyone subclassing it can be sure they are implementing the full API, but only that API.
</p>
<a name="CloneableEditorSupport" id="CloneableEditorSupport"></a><h4> <span class="mw-headline">CloneableEditorSupport</span></h4>
<p>Can support <a href="http://www.netbeans.org/unbranded-source/browse/~checkout~/openide/src/org/openide/text/CloneableEditorSupport.java?content-type=text/plain" class="external text" title="http://www.netbeans.org/unbranded-source/browse/~checkout~/openide/src/org/openide/text/CloneableEditorSupport.java?content-type=text/plain" rel="nofollow">class</a>es be provided as interfaces? It is not easy. What kind of support would it be if one would have to provide implementation of each method! So, often abstract classes are used as base for support classes.
</p><p>But one should carefully separate the support classes from the actual API (as the <code>CloneableEditorSupport</code> is in different package than the <a href="http://www.netbeans.org/unbranded-source/browse/~checkout~/openide/src/org/openide/cookies/EditorCookie.java?content-type=text/plain" class="external text" title="http://www.netbeans.org/unbranded-source/browse/~checkout~/openide/src/org/openide/cookies/EditorCookie.java?content-type=text/plain" rel="nofollow">EditorCookie </a> which it implements). Such separation ensures basic quality of design and prevents cheating - one needs to use just API methods even in the implementation and cannot rely on non-public hooks.
</p>
<a name="Interfaces_or_Classes.3F" id="Interfaces_or_Classes.3F"></a><h3> <span class="mw-headline">Interfaces or Classes?</span></h3>
<p>Is it better to use interfaces or a classes? None, could be simple answer to such general question. But if try to get down to the roots of the question we can get a better answers.
</p><p>First of all only those people that are designing an API that will be maintained for a while, have to care. Those who are writing code to pass an exam do not need to. They can choose whatever they wish.
</p><p>Second necessary thing is to treat users of your API well. If you do not care about them, do not care about the <i>interfaces or classes</i> question.
</p><p>If these conditions are satisfied then, from the discussion above, one can see that classes are better for <i>client API</i> and interfaces for <i>service provider API</i>. So if you know that most of the users of an API will just make calls to it, it is better to use classes (and the best thing is to make them unsubclassable, that way one prevents accidental subclasses at all). If you want people just to subclass. Then choose interfaces, they are more safe and easy to use when subclassing. If your case is somewhere in between (which should be prevented according to [#design.apiandspi separation] paragraph) the choice is up to you, but carefully judge what people will do more often. You will not be sorry.
</p>
<a name="Case_Study_of_client_API_and_SPI_separation" id="Case_Study_of_client_API_and_SPI_separation"></a><h2> <span class="mw-headline">Case Study of client API and SPI separation</span></h2>
<p>The previous example with <code>CloneableEditorSupport</code> claims that it is not easy to write support without classes, but the truth is it is not that complicated and moreover it really separates the SPI from the client API and allows easier and safe future evolution. Here is a sample rewrite of <code>CloneableEditorSupport</code> stuff using interfaces:
</p><p>The main goal of <a href="http://www.netbeans.org/source/browse/openide/src/org/openide/text/CloneableEditorSupport.java?rev=1.92&amp;content-type=text/x-cvsweb-markup&amp;showattic=1" class="external text" title="http://www.netbeans.org/source/browse/openide/src/org/openide/text/CloneableEditorSupport.java?rev=1.92&amp;content-type=text/x-cvsweb-markup&amp;showattic=1" rel="nofollow">CloneableEditorSupport</a> is to implement some interfaces <a href="http://www.netbeans.org/source/browse/openide/src/org/openide/cookies/OpenCookie.java?rev=1.7&amp;content-type=text/x-cvsweb-markup&amp;showattic=1" class="external text" title="http://www.netbeans.org/source/browse/openide/src/org/openide/cookies/OpenCookie.java?rev=1.7&amp;content-type=text/x-cvsweb-markup&amp;showattic=1" rel="nofollow">OpenCookie</a>, <a href="http://www.netbeans.org/source/browse/openide/src/org/openide/cookies/EditCookie.java?rev=1.6&amp;content-type=text/x-cvsweb-markup&amp;showattic=1" class="external text" title="http://www.netbeans.org/source/browse/openide/src/org/openide/cookies/EditCookie.java?rev=1.6&amp;content-type=text/x-cvsweb-markup&amp;showattic=1" rel="nofollow">EditCookie</a> and <a href="http://www.netbeans.org/source/browse/openide/src/org/openide/cookies/EditorCookie.java?rev=1.15&amp;content-type=text/x-cvsweb-markup&amp;showattic=1" class="external text" title="http://www.netbeans.org/source/browse/openide/src/org/openide/cookies/EditorCookie.java?rev=1.15&amp;content-type=text/x-cvsweb-markup&amp;showattic=1" rel="nofollow">EditorCookie</a> while letting the subclasses override abstract methods like <code>String messageName ()</code>, <code>String messageModified ()</code> and <code>String messageOpen ()</code> and provide and modify the behaviour of the abstract class. For implementation these methods the subclass can call some support functions like <code>protected final UndoRedo.Manager getUndoRedo()</code> and communicate with the superclass implementation using for example <code>protected Task reloadDocument()</code>. The whole already enough complex situation is additionally complicated by a fact that <i>nearly every method can be overriden by a subclass</i> which creates operating environment so wild that nobody can guess what combinations are possible and makes future evolution nearly impossible.
</p>
<a name="Move_Protected_Methods_Into_Interface" id="Move_Protected_Methods_Into_Interface"></a><h4> <span class="mw-headline">Move Protected Methods Into Interface</span></h4>
<p>The situation might be simplified by separating all methods that should be overriden in subclasses into own interface:
</p><p><br /> 
</p>
<pre><span class="keyword">public</span> <span class="keyword">interface</span> <span class="type">CloneableEditorProvider</span> {
    <span class="comment">// methods that have to be overridden
</span>    <span class="comment">// in order for the functionality to work
</span>    <span class="keyword">public</span> <span class="type">String</span> <span class="function-name">messageName</span>();
    <span class="keyword">public</span> <span class="type">String</span> <span class="function-name">messageSave</span>();

    <span class="comment">// additional stuff described below
</span>}
</pre>
<p>and having a factory method
</p><p><br /> 
</p>
<pre><span class="type">EditorCookie</span> <span class="variable-name">EditorFactory</span>.createEditor(<span class="type">CloneableEditorProvider</span> <span class="variable-name">p</span>);
</pre>
<p>that would convert the service provider interface into the desired client API (this is a bit simplified, the real API would have to support creation of multiple cookies <code>OpenCookie</code>, <code>EditCookie</code>, etc. for example by having additional argument of type <code>Class[]</code> that would specify all cookies the returned value should implement). Functionally this is equivalent to providing a class with abstract methods that should be implemented in subclasses, however in addition, it guarantees that nobody will be able to cast <code>EditorCookie</code> to <code>CloneableEditorProvider</code> and call some special methods on it because the <code>createEditor</code> method has to create new object for its result that bridges its functionality to the provider.
</p>
<a name="Passing_Notifications_to_Implementation" id="Passing_Notifications_to_Implementation"></a><h4> <span class="mw-headline">Passing Notifications to Implementation</span></h4>
<p>But the current state does not yet fully emulate the functionality of the old <code>CloneableEditorSupport</code> - the provider is not able to invoke <code>reloadDocument</code> or any similar one. In order to address this, let's enhance the interface:
</p><p><br /> 
</p>
<pre><span class="keyword">public</span> <span class="keyword">interface</span> <span class="type">CloneableEditorProvider</span> {
    <span class="comment">// the getter methods as in previous example
</span>    <span class="keyword">public</span> <span class="type">String</span> <span class="function-name">messageSave</span>();

    <span class="comment">// the support for listeners
</span>    <span class="keyword">public</span> <span class="type">void</span> <span class="function-name">addChangeListener</span>(<span class="type">ChangeListener</span> <span class="variable-name">l</span>)
        <span class="keyword">throws</span> <span class="type">TooManyListenersException</span>;
    <span class="keyword">public</span> <span class="type">void</span> <span class="function-name">removeChangeListener</span>(<span class="type">ChangeListener</span> <span class="variable-name">l</span>);
}
</pre>
<p>Now the factory methods will not just build an implementation of <code>EditorCookie</code>, but will also attach such implementation as a listener to the provider. As there will always be at most one listener, the method signagure throws <code>TooManyListenersException</code> to signal that the provider can implement the method in the most simple way:
</p><p><br /> 
</p>
<pre><span class="keyword">private</span> <span class="type">ChangeListener</span> <span class="variable-name">listener</span>;
<span class="keyword">public</span> <span class="type">void</span> <span class="function-name">addChangeListener</span>(<span class="type">ChangeListener</span> <span class="variable-name">l</span>)
        <span class="keyword">throws</span> <span class="type">TooManyListenersException</span> {
    <span class="keyword">if</span> (listener&nbsp;!= <span class="constant">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">TooManyListenersException</span>();
    listener = l;
}
</pre>
<p>and does not need to bother with support for multiple listeners, while following the <b>JavaBeans</b> conventions. Whenever the provider needs to reload the document, it can just fire <code>listener.stateChanged (ev)</code> and the listening implementation will know that the reload of the document is requested.
</p>
<a name="Callbacks_to_Implementation" id="Callbacks_to_Implementation"></a><h4> <span class="mw-headline">Callbacks to Implementation</span></h4>
<p>The listener approach allows simple communication flow from the provider to the implementation when needed, but there is still something missing - ability to obtain <code>UndoRedo</code> via <code>CloneableEditorSupport.getUndoRedo</code>. In order to achieve that we might change the interface once more:
</p><p><br /> 
</p>
<pre><span class="keyword">public</span> <span class="keyword">interface</span> <span class="type">CloneableEditorProvider</span> {
    <span class="comment">// the getter methods as in previous example
</span>    <span class="keyword">public</span> <span class="type">String</span> <span class="function-name">messageSave</span>();

    <span class="comment">// the support callbacks
</span>    <span class="keyword">public</span> <span class="type">void</span> <span class="function-name">attach</span>(<span class="type">Impl</span> <span class="variable-name">impl</span>) <span class="keyword">throws</span> <span class="type">TooManyListenersException</span>;


    <span class="comment">// the class with methods for communication with the implementation
</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="type">Impl</span> <span class="keyword">extends</span> <span class="type">Object</span> {
        <span class="keyword">public</span> <span class="type">void</span> <span class="function-name">reloadDocument</span>();
        <span class="keyword">public</span> <span class="type">UndoRedo</span> <span class="function-name">getUndoRedo</span>();
    }
}
</pre>
<p>We have replaced the listener with a special <code>Info</code> that contains all the methods that the provider can call on the implementation and added a method <code>attach</code> to allow registration of that class to any provider.
</p><p>This is the final state. Everything that is supposed to be called from the implementation is in the <code>CloneableEditorProvider</code> interface, everything that is supposed to be called by a clients is not avaible as <code>EditorCookie</code> and is completelly under control of the <code>EditorFactory</code> and the callback communication from the provider to the factory is separated into the <code>CloneableEditorProvider.Impl</code>. This state can at first sight look more complex than the original <code>CloneableEditorSupport</code>, but it is much clearer and separates the concerns comparing to the original mess in the support.
</p>
<a name="Extensible_Client_Behaviour" id="Extensible_Client_Behaviour"></a><h4> <span class="mw-headline">Extensible Client Behaviour</span></h4>
<p>Anybody wants to add new user method or functionality into <code>EditorCookie</code>? Why not, just enhance the <code>EditorFactory</code> to create better implementation in its factory method. Is there a need to log requests from clients? Again, <code>EditorFactory</code> is the right place to do it. Necessary to provide some synchronization, deadlock prevention, etc? Where else then in <code>EditorFactory</code>.
</p>
<a name="Extensible_Communication_betwen_provider_and_implementation" id="Extensible_Communication_betwen_provider_and_implementation"></a><h4> <span class="mw-headline">Extensible Communication betwen provider and implementation</span></h4>
<p>As we have carefully choosen the <code>CloneableEditorProvider.Impl</code> to be final class, we can always add a new methods to it. For example:
</p><p><br /> 
</p>
<pre><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="type">CloneableEditorProvider</span>.Impl <span class="keyword">extends</span> <span class="type">Object</span> {
    <span class="keyword">public</span> <span class="type">void</span> <span class="function-name">reloadDocument</span>();
    <span class="keyword">public</span> <span class="type">UndoRedo</span> <span class="function-name">getUndoRedo</span>();
    <span class="keyword">public</span> <span class="type">void</span> <span class="function-name">closeDocument</span>();
}
</pre>
<p>as far as we teach the implementation to understand what <code>closeDocument</code> means. Btw. actually the <code>Impl</code> acts as a client API for the <code>CloneableEditorProvider</code> and that is why it is better to make it class.
</p>
<a name="Extensible_Provider_Evolution" id="Extensible_Provider_Evolution"></a><h4> <span class="mw-headline">Extensible Provider Evolution</span></h4>
<p>It is often common that after a while the functionality of the <code>EditorCookie</code> might be improved, if the <code>CloneableEditorProvider</code> was a bit more capable. In the original <code>CloneableEditorSupport</code> example this would be solved by adding new (protected) method with default implementation in the <code>CloneableEditorSupport</code>, but as adding a method is always a bit dangerous (might introduce clashes - what used to compile in previous version need not compile anymore, or need not run anymore). The provider approach presented in this case study allows us to define
</p><p><br /> 
</p>
<pre><span class="keyword">interface</span> <span class="type">CloneableEditorProvider2</span> <span class="keyword">extends</span> <span class="type">CloneableEditorProvider</span> {
    <span class="comment">/** Will be called when the document is about to be closed by user */</span>
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="function-name">canClose</span>();
}
</pre>
<p>and (possibly) new factory method (possibly because the original method taking just <code>CloneableEditorProvider</code> could be enough)
</p><p><br /> 
</p>
<pre><span class="type">EditorCookie</span> <span class="variable-name">EditorFactory</span>.createEditor(<span class="type">CloneableEditorProvider2</span> <span class="variable-name">p</span>);
</pre>
<p>that will use the new interface for better implementation of the editor while keeping the same interface for client API.
</p><p>Another example of this kind of evolution can be observed in a situation when the old provider interface is completely wrong and we want to replace it, or enhance the amount of choices be completely new:
</p><p><br /> 
</p>
<pre><span class="keyword">interface</span> <span class="type">PaintProvider</span> {
    <span class="keyword">public</span> <span class="type">void</span> <span class="function-name">paintImage</span>(<span class="type">Image</span> <span class="variable-name">image</span>);
}
<span class="comment">/** Based on a ability to paint creates new EditorCookie */</span>
<span class="type">EditorCookie</span> <span class="variable-name">EditorFactory</span>.createEditor(<span class="type">PaintProvider</span> <span class="variable-name">p</span>);
</pre>
<p>In spite of that the service provider API has changed completely, the whole change is hidden in the factory that translates the calls between old client API to the new provider interface. Moreover there is no clash in evolution. Providers that really wishes to provide <code>CloneableEditorProvider</code> do that by implementing directly that interface, providers that want to handle the <code>closeDocument</code> call as well do that by implementing <code>CloneableEditorProvider2</code> and those that rely on the completely new paint style implement <code>PaintProvider</code>. Each of such providers explicitly specifies what SPI contract it wants to implement, this is much clearer than the possible mess with original evolution of <code>CloneableEditorSupport</code> based on adding methods to it.
</p>
<a name="Using_games_to_Improve_API_Design_Skills" id="Using_games_to_Improve_API_Design_Skills"></a><h2> <span class="mw-headline">Using games to Improve API Design Skills</span></h2>
<p>Having good API design skills is very important for people who work and create an open source framework like NetBeans. It is indeed fine to read and study some [api-design.html API design guidelines], however there is no better learning approach than practicing the design in a situation simulating the reality. Read the [api-fest.html article about API Fest] to learn about the game called <i>API Fest</i> that the NetBeans core team created and played as part of improving their design skills.
</p>
<!-- 
NewPP limit report
Preprocessor node count: 384/1000000
Post-expand include size: 4481/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->
<div class="printfooter">
Retrieved from "<a href="http://wiki.netbeans.org/API_Design">http://wiki.netbeans.org/API_Design</a>"</div>

		  <!-- Categories -->
		                      </div>


                <!-- Footer -->
                <div id="footer">
                                        <div id="f-poweredbyico"><a href="http://www.mediawiki.org/"><img src="/wiki/skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" /></a></div>
                                        <ul id="f-list">
                        				<li id="lastmod"> This page was last modified on 7 January 2012, at 22:30.</li>
                          				<li id="viewcount">This page has been accessed 36,739 times.</li>
                                            </ul>
                </div>

                <!-- scripts and debugging information -->
                    
		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
                    <!-- Served in 0.348 secs. -->                    
  <!-- INCLUDED CODE FROM NB.ORG START -->
  <!-- Content area end -->




</div>
                        </td>
                        <td class="valign-top rcol b-left"  id="rc">

<div id="loginbox" class="b-bottom bg-bege align-center">Not logged in. <a href="http://netbeans.org/people/login?original_uri=http://wiki.netbeans.org%2FAPI_Design"><b>Log in</b></a>, <a href="http://netbeans.org/people/new">Register</a>
</div>

 <!-- start NavCol -->

<div class="f-page-cell bg-sky b-bottom">

<!-- Site Name -->
<h2>NetBeans Wiki</h2>





<!-- Site Notice [conditional] -->

<!-- User-Messages Notification [conditional] -->



<!-- Sidebar Navigation [iterative] -->
		<div class='portlet' id='p-navigation'>
		<h5>Navigation</h5>
		<div class='pBody'>
			<ul>
				<li id="n-Main-Page"><a href="/Main_Page">Main Page</a></li>
				<li id="n-User-FAQ"><a href="/NetBeansUserFAQ">User FAQ</a></li>
				<li id="n-Developer-FAQ"><a href="/NetBeansDeveloperFAQ">Developer FAQ</a></li>
				<li id="n-Community-Docs"><a href="/CommunityDocs">Community Docs</a></li>
				<li id="n-Development"><a href="/Development">Development</a></li>
				<li id="n-Quality"><a href="/Quality">Quality</a></li>
				<li id="n-Dream-Team"><a href="/NetBeansDreamTeam">Dream Team</a></li>
				<li id="n-Popular-Projects"><a href="/PopularProjects">Popular Projects</a></li>
				<li id="n-Bug-DashBoard"><a href="http://services.netbeans.org/dashboard">Bug DashBoard</a></li>
				<li id="n-Hudson"><a href="http://deadlock.netbeans.org/hudson/">Hudson</a></li>
				<li id="n-Sources"><a href="http://hg.netbeans.org/main/">Sources</a></li>
				<li id="n-Nightly"><a href="http://bits.netbeans.org/download/trunk/nightly/latest/">Nightly</a></li>
				<li id="n-Wiki-Etiquette"><a href="/WikiEtiquette">Wiki Etiquette</a></li>
				<li id="n-Formatting-Rules"><a href="/TextFormattingRules">Formatting Rules</a></li>
				<li id="n-Terms-Of-Use"><a href="/TermsOfUse">Terms Of Use</a></li>
			</ul>
		</div>
	</div>
	


<!-- Toolbox -->
<div class="portlet" id="p-tb">
  <h5>Toolbox</h5>
  <div class="pBody">
    <ul>
              <li id="t-whatlinkshere"><a href="/Special:WhatLinksHere/API_Design" title="List of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
                  <li id="t-recentchangeslinked"><a href="/Special:RecentChangesLinked/API_Design" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
            <li id="t-specialpages"><a href="/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</a></li>
                  <li id="t-print"><a href="/wiki/index.php?title=API_Design&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>      <li id="t-permalink"><a href="/wiki/index.php?title=API_Design&amp;oldid=50821" title="Permanent link to this revision of the page">Permanent link</a></li>    </ul>
  </div>
</div>



<!-- Page Toolbar [iterative] -->
	<div id="p-cactions" class="portlet">
		<h5>Views</h5> <!-- Page Toolbar Label/Caption [optional] -->
		<div class="pBody">
			<ul>
					 <li id="ca-nstab-main" class="selected"><a href="/API_Design" title="View the content page [c]" accesskey="c">Page</a></li>
					 <li id="ca-talk" class="new"><a href="/wiki/index.php?title=Talk:API_Design&amp;action=edit&amp;redlink=1" title="Discussion about the content page [t]" accesskey="t">Discussion</a></li>
					 <li id="ca-viewsource"><a href="/wiki/index.php?title=API_Design&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></li>
					 <li id="ca-history"><a href="/wiki/index.php?title=API_Design&amp;action=history" title="Past revisions of this page [h]" accesskey="h">History</a></li>
				</ul>
		</div>
	</div>





</div>



<!-- end NavCol -->


<!-- right navigation -->
<div id="right-navigation">
<div class="f-page-cell bg-bege b-bottom" >
<h2 style="border:0px;">NetBeans.org</h2>
<div class="rrrarticle"><div class="rarticletitle"><a href="http://netbeans.org/people/new">Join</a></div></div>
<div class="rrrarticle"><div class="rarticletitle"><a href="http://netbeans.org/community/news/">News</a></div></div>
<div class="rrrarticle"><div class="rarticletitle"><a href="http://netbeans.org/community/releases/" class="nav" >Releases &amp; Planning</a></div></div>
<div class="rrrarticle"><div class="rarticletitle"><a href="http://netbeans.org/community/lists/" class="nav" >Mailing Lists</a></div></div>
<div class="rrrarticle"><div class="rarticletitle"><a href="http://netbeans.org/community/issues.html">Bugzilla</a></div></div>
<div class="rrrarticle"><div class="rarticletitle"><a href="http://netbeans.org/community/contribute/" class="nav" >Contribute</a></div></div>
<div class="rrrarticle"><div class="rarticletitle"><a href="http://netbeans.org/community/teams/" class="nav" >Teams</a></div></div>
<div class="rrrarticle"><div class="rarticletitle"><a href="http://netbeans.org/community/guidelines/" class="nav" >Guidelines</a></div></div>
<div class="rrrarticle"><div class="rarticletitle"><a href="http://netbeans.org/projects/">Projects</a></div></div>
</div>
</div>
<br>
</td>
                    </tr><!-- end main content -->
                </table><!-- end main content table -->
            </div>

            <!-- end contentarea -->
            <div id="ftr">
                <ul class="float-right" id="social-media">
                    <li><a href="http://www.facebook.com/NetBeans"><img src="//netbeans.org/images_www/v7/design/icin_facebook.png" width="30" height="30" alt="facebook"></a></li>
                    <li><a href="http://www.youtube.com/user/netbeansvideos"><img src="//netbeans.org/images_www/v7/design/icin_youtube.png" width="30" height="30" alt="youtube"></a></li>
                    <li><a href="https://plus.google.com/105597468329838196909/"><img src="//netbeans.org/images_www/v7/design/icin_google.png" width="30" height="30" alt="google+"></a></li>
                    <li><a href="https://twitter.com/netbeans"><img src="//netbeans.org/images_www/v7/design/icin_twitter.png" width="30" height="30" alt="twitter"></a></li>
                </ul>
                <ul>
                    <li><a href="http://netbeans.org/sitemaps/www_map.html">SiteMap</a></li>
                    <li><a href="http://netbeans.org/about/index.html">About Us</a></li>
                    <li><a href="http://netbeans.org/about/contact.html">Contact</a></li>
                    <li><a href="http://netbeans.org/about/legal/index.html">Legal &amp; Licences</a></li>
                </ul> 

            </div>
            <div id="tof" class="align-right">
                By use of this website, you agree to the <a href="https://netbeans.org/about/legal/terms-of-use.html">NetBeans Policies and Terms of Use</a>.
                &copy; 2012, Oracle Corporation and/or its affiliates. Sponsored by <img src="//netbeans.org/images_www/v7/design/logo_oracle.png" width="56" height="8" alt="Oracle logo"/>
            </div>
        </div>
        <div id="companion-projects">
            <script type="text/javascript">
                document.write(renderCompanionProjectIcons());
            </script>
        </div>

        <!-- Begin SiteCatalyst code -->
        <script language="JavaScript" src="//netbeans.org/images_www/js/s_code_remote.js" type="text/javascript"></script>
        <!-- End SiteCatalyst code -->

    </body>
</html>
	
	
