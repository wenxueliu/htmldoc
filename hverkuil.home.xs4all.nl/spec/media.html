<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>LINUX MEDIA INFRASTRUCTURE API</title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book"><div class="titlepage"><div><div><h1 class="title"><a name="media_api"></a>LINUX MEDIA INFRASTRUCTURE API</h1></div><div><p class="copyright">Copyright © 2009-2014 LinuxTV Developers</p></div><div><div class="legalnotice"><a name="idp45906912"></a><p>Permission is granted to copy, distribute and/or modify
		this document under the terms of the GNU Free Documentation License,
		Version 1.1 or any later version published by the Free Software
		Foundation. A copy of the license is included in the chapter entitled
		"GNU Free Documentation License"</p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="preface"><a href="media.html#idp45908784">Introduction</a></span></dt><dt><span class="part"><a href="media.html#v4l2spec">I. Video for Linux Two API Specification</a></span></dt><dd><dl><dt><span class="chapter"><a href="media.html#common">1. Common API Elements</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#open">Opening and Closing Devices</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp47233696">Device Naming</a></span></dt><dt><span class="section"><a href="media.html#related">Related Devices</a></span></dt><dt><span class="section"><a href="media.html#idp47249088">Multiple Opens</a></span></dt><dt><span class="section"><a href="media.html#idp47270192">Shared Data Streams</a></span></dt><dt><span class="section"><a href="media.html#idp47271584">Functions</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#querycap">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#app-pri">Application Priority</a></span></dt><dt><span class="section"><a href="media.html#video">Video Inputs and Outputs</a></span></dt><dt><span class="section"><a href="media.html#audio">Audio Inputs and Outputs</a></span></dt><dt><span class="section"><a href="media.html#tuner">Tuners and Modulators</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp47353184">Tuners</a></span></dt><dt><span class="section"><a href="media.html#idp47365392">Modulators</a></span></dt><dt><span class="section"><a href="media.html#idp47378112">Radio Frequency</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#standard">Video Standards</a></span></dt><dt><span class="section"><a href="media.html#dv-timings">Digital Video (DV) Timings</a></span></dt><dt><span class="section"><a href="media.html#control">User Controls</a></span></dt><dt><span class="section"><a href="media.html#extended-controls">Extended Controls</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp47658496">Introduction</a></span></dt><dt><span class="section"><a href="media.html#idp47662144">The Extended Control API</a></span></dt><dt><span class="section"><a href="media.html#idp47686784">Enumerating Extended Controls</a></span></dt><dt><span class="section"><a href="media.html#idp47456288">Creating Control Panels</a></span></dt><dt><span class="section"><a href="media.html#mpeg-controls">Codec Control Reference</a></span></dt><dt><span class="section"><a href="media.html#camera-controls">Camera Control Reference</a></span></dt><dt><span class="section"><a href="media.html#fm-tx-controls">FM Transmitter Control Reference</a></span></dt><dt><span class="section"><a href="media.html#flash-controls">Flash Control Reference</a></span></dt><dt><span class="section"><a href="media.html#jpeg-controls">JPEG Control Reference</a></span></dt><dt><span class="section"><a href="media.html#image-source-controls">Image Source Control Reference</a></span></dt><dt><span class="section"><a href="media.html#image-process-controls">Image Process Control Reference</a></span></dt><dt><span class="section"><a href="media.html#dv-controls">Digital Video Control Reference</a></span></dt><dt><span class="section"><a href="media.html#fm-rx-controls">FM Receiver Control Reference</a></span></dt><dt><span class="section"><a href="media.html#detect-controls">Detect Control Reference</a></span></dt><dt><span class="section"><a href="media.html#rf-tuner-controls">RF Tuner Control Reference</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#format">Data Formats</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp51292128">Data Format Negotiation</a></span></dt><dt><span class="section"><a href="media.html#idp51320592">Image Format Enumeration</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#planar-apis">Single- and multi-planar APIs</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp51329792">Multi-planar formats</a></span></dt><dt><span class="section"><a href="media.html#idp51333216">Calls that distinguish between single and multi-planar APIs</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#crop">Image Cropping, Insertion and Scaling</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp51365280">Cropping Structures</a></span></dt><dt><span class="section"><a href="media.html#idp51407488">Scaling Adjustments</a></span></dt><dt><span class="section"><a href="media.html#idp51416672">Examples</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#selection-api">Experimental API for cropping, composing and scaling</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp51447328">Introduction</a></span></dt><dt><span class="section"><a href="media.html#idp51494464">Selection targets</a></span></dt><dt><span class="section"><a href="media.html#idp51500704">Configuration</a></span></dt><dt><span class="section"><a href="media.html#idp51531648">Comparison with old cropping API</a></span></dt><dt><span class="section"><a href="media.html#idp51539232">Examples</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#streaming-par">Streaming Parameters</a></span></dt></dl></dd><dt><span class="chapter"><a href="media.html#pixfmt">2. Image Formats</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp53973040">Single-planar format structure</a></span></dt><dt><span class="section"><a href="media.html#idp54078128">Multi-planar format structures</a></span></dt><dt><span class="section"><a href="media.html#idp54128880">Standard Image Formats</a></span></dt><dt><span class="section"><a href="media.html#colorspaces">Colorspaces</a></span></dt><dt><span class="section"><a href="media.html#idp54168592">Defining Colorspaces in V4L2</a></span></dt><dt><span class="section"><a href="media.html#idp54232336">Detailed Colorspace Descriptions</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp54233024">Colorspace SMPTE 170M (<code class="constant">V4L2_COLORSPACE_SMPTE170M</code>)</a></span></dt><dt><span class="section"><a href="media.html#idp54271504">Colorspace Rec. 709 (<code class="constant">V4L2_COLORSPACE_REC709</code>)</a></span></dt><dt><span class="section"><a href="media.html#idp54308064">Colorspace sRGB (<code class="constant">V4L2_COLORSPACE_SRGB</code>)</a></span></dt><dt><span class="section"><a href="media.html#idp54339536">Colorspace Adobe RGB (<code class="constant">V4L2_COLORSPACE_ADOBERGB</code>)</a></span></dt><dt><span class="section"><a href="media.html#idp54366256">Colorspace BT.2020 (<code class="constant">V4L2_COLORSPACE_BT2020</code>)</a></span></dt><dt><span class="section"><a href="media.html#idp54404656">Colorspace SMPTE 240M (<code class="constant">V4L2_COLORSPACE_SMPTE240M</code>)</a></span></dt><dt><span class="section"><a href="media.html#idp54432112">Colorspace NTSC 1953 (<code class="constant">V4L2_COLORSPACE_470_SYSTEM_M</code>)</a></span></dt><dt><span class="section"><a href="media.html#idp54459200">Colorspace EBU Tech. 3213 (<code class="constant">V4L2_COLORSPACE_470_SYSTEM_BG</code>)</a></span></dt><dt><span class="section"><a href="media.html#idp54486512">Colorspace JPEG (<code class="constant">V4L2_COLORSPACE_JPEG</code>)</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#pixfmt-indexed">Indexed Format</a></span></dt><dt><span class="section"><a href="media.html#pixfmt-rgb">RGB Formats</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="media.html#packed-rgb">Packed RGB formats</a></span><span class="refpurpose"> &#8212; Packed RGB formats</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-SBGGR8">V4L2_PIX_FMT_SBGGR8 ('BA81')</a></span><span class="refpurpose"> &#8212; Bayer RGB format</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-SGBRG8">V4L2_PIX_FMT_SGBRG8 ('GBRG')</a></span><span class="refpurpose"> &#8212; Bayer RGB format</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-SGRBG8">V4L2_PIX_FMT_SGRBG8 ('GRBG')</a></span><span class="refpurpose"> &#8212; Bayer RGB format</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-SRGGB8">V4L2_PIX_FMT_SRGGB8 ('RGGB')</a></span><span class="refpurpose"> &#8212; Bayer RGB format</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-SBGGR16">V4L2_PIX_FMT_SBGGR16 ('BYR2')</a></span><span class="refpurpose"> &#8212; Bayer RGB format</span></dt><dt><span class="refentrytitle"><a href="media.html#pixfmt-srggb10">V4L2_PIX_FMT_SRGGB10 ('RG10'),
	 V4L2_PIX_FMT_SGRBG10 ('BA10'),
	 V4L2_PIX_FMT_SGBRG10 ('GB10'),
	 V4L2_PIX_FMT_SBGGR10 ('BG10'),
	 </a></span><span class="refpurpose"> &#8212; 10-bit Bayer formats expanded to 16 bits</span></dt><dt><span class="refentrytitle"><a href="media.html#idp56012848">
	      V4L2_PIX_FMT_SBGGR10ALAW8 ('aBA8'),
	      V4L2_PIX_FMT_SGBRG10ALAW8 ('aGA8'),
	      V4L2_PIX_FMT_SGRBG10ALAW8 ('agA8'),
	      V4L2_PIX_FMT_SRGGB10ALAW8 ('aRA8'),
	    </a></span><span class="refpurpose"> &#8212; 10-bit Bayer formats compressed to 8 bits</span></dt><dt><span class="refentrytitle"><a href="media.html#pixfmt-srggb10dpcm8">
	 V4L2_PIX_FMT_SBGGR10DPCM8 ('bBA8'),
	 V4L2_PIX_FMT_SGBRG10DPCM8 ('bGA8'),
	 V4L2_PIX_FMT_SGRBG10DPCM8 ('BD10'),
	 V4L2_PIX_FMT_SRGGB10DPCM8 ('bRA8'),
	 </a></span><span class="refpurpose"> &#8212; 10-bit Bayer formats compressed to 8 bits</span></dt><dt><span class="refentrytitle"><a href="media.html#idp56032208">V4L2_PIX_FMT_SRGGB12 ('RG12'),
	 V4L2_PIX_FMT_SGRBG12 ('BA12'),
	 V4L2_PIX_FMT_SGBRG12 ('GB12'),
	 V4L2_PIX_FMT_SBGGR12 ('BG12'),
	 </a></span><span class="refpurpose"> &#8212; 12-bit Bayer formats expanded to 16 bits</span></dt></dl></dd><dt><span class="section"><a href="media.html#yuv-formats">YUV Formats</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="media.html#packed-yuv">Packed YUV formats</a></span><span class="refpurpose"> &#8212; Packed YUV formats</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-GREY">V4L2_PIX_FMT_GREY ('GREY')</a></span><span class="refpurpose"> &#8212; Grey-scale image</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-Y10">V4L2_PIX_FMT_Y10 ('Y10 ')</a></span><span class="refpurpose"> &#8212; Grey-scale image</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-Y12">V4L2_PIX_FMT_Y12 ('Y12 ')</a></span><span class="refpurpose"> &#8212; Grey-scale image</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-Y10BPACK">V4L2_PIX_FMT_Y10BPACK ('Y10B')</a></span><span class="refpurpose"> &#8212; Grey-scale image as a bit-packed array</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-Y16">V4L2_PIX_FMT_Y16 ('Y16 ')</a></span><span class="refpurpose"> &#8212; Grey-scale image</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-UV8">V4L2_PIX_FMT_UV8  ('UV8')</a></span><span class="refpurpose"> &#8212; UV plane interleaved</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-YUYV">V4L2_PIX_FMT_YUYV ('YUYV')</a></span><span class="refpurpose"> &#8212; Packed format with ½ horizontal chroma
resolution, also known as YUV 4:2:2</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-UYVY">V4L2_PIX_FMT_UYVY ('UYVY')</a></span><span class="refpurpose"> &#8212; Variation of
<code class="constant">V4L2_PIX_FMT_YUYV</code> with different order of samples
in memory</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-YVYU">V4L2_PIX_FMT_YVYU ('YVYU')</a></span><span class="refpurpose"> &#8212; Variation of
<code class="constant">V4L2_PIX_FMT_YUYV</code> with different order of samples
in memory</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-VYUY">V4L2_PIX_FMT_VYUY ('VYUY')</a></span><span class="refpurpose"> &#8212; Variation of
<code class="constant">V4L2_PIX_FMT_YUYV</code> with different order of samples
in memory</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-Y41P">V4L2_PIX_FMT_Y41P ('Y41P')</a></span><span class="refpurpose"> &#8212; Format with ¼ horizontal chroma
resolution, also known as YUV 4:1:1</span></dt><dt><span class="refentrytitle"><a href="media.html#idp57342656">V4L2_PIX_FMT_YVU420 ('YV12'), V4L2_PIX_FMT_YUV420 ('YU12')</a></span><span class="refpurpose"> &#8212; Planar formats with ½ horizontal and
vertical chroma resolution, also known as YUV 4:2:0</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-YUV420M">V4L2_PIX_FMT_YUV420M ('YM12')</a></span><span class="refpurpose"> &#8212; Variation of <code class="constant">V4L2_PIX_FMT_YUV420</code>
	  with planes non contiguous in memory. </span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-YVU420M">V4L2_PIX_FMT_YVU420M ('YM21')</a></span><span class="refpurpose"> &#8212; Variation of <code class="constant">V4L2_PIX_FMT_YVU420</code>
	  with planes non contiguous in memory. </span></dt><dt><span class="refentrytitle"><a href="media.html#idp57708208">V4L2_PIX_FMT_YVU410 ('YVU9'), V4L2_PIX_FMT_YUV410 ('YUV9')</a></span><span class="refpurpose"> &#8212; Planar formats with ¼ horizontal and
vertical chroma resolution, also known as YUV 4:1:0</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-YUV422P">V4L2_PIX_FMT_YUV422P ('422P')</a></span><span class="refpurpose"> &#8212; Format with ½ horizontal chroma resolution,
also known as YUV 4:2:2. Planar layout as opposed to
<code class="constant">V4L2_PIX_FMT_YUYV</code></span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-YUV411P">V4L2_PIX_FMT_YUV411P ('411P')</a></span><span class="refpurpose"> &#8212; Format with ¼ horizontal chroma resolution,
also known as YUV 4:1:1. Planar layout as opposed to
<code class="constant">V4L2_PIX_FMT_Y41P</code></span></dt><dt><span class="refentrytitle"><a href="media.html#idp58050800">V4L2_PIX_FMT_NV12 ('NV12'), V4L2_PIX_FMT_NV21 ('NV21')</a></span><span class="refpurpose"> &#8212; Formats with ½ horizontal and vertical
chroma resolution, also known as YUV 4:2:0. One luminance and one
chrominance plane with alternating chroma samples as opposed to
<code class="constant">V4L2_PIX_FMT_YVU420</code></span></dt><dt><span class="refentrytitle"><a href="media.html#idp58169408">V4L2_PIX_FMT_NV12M ('NM12'), V4L2_PIX_FMT_NV21M ('NM21'), V4L2_PIX_FMT_NV12MT_16X16</a></span><span class="refpurpose"> &#8212; Variation of <code class="constant">V4L2_PIX_FMT_NV12</code> and <code class="constant">V4L2_PIX_FMT_NV21</code> with planes
	  non contiguous in memory. </span></dt><dt><span class="refentrytitle"><a href="media.html#idp58299328">V4L2_PIX_FMT_NV12MT ('TM12')</a></span><span class="refpurpose"> &#8212; Formats with ½ horizontal and vertical
chroma resolution. This format has two planes - one for luminance and one for
chrominance. Chroma samples are interleaved. The difference to
<code class="constant">V4L2_PIX_FMT_NV12</code> is the memory layout. Pixels are
grouped in macroblocks of 64x32 size. The order of macroblocks in memory is
also not standard.
	</span></dt><dt><span class="refentrytitle"><a href="media.html#idp58297872">V4L2_PIX_FMT_NV16 ('NV16'), V4L2_PIX_FMT_NV61 ('NV61')</a></span><span class="refpurpose"> &#8212; Formats with ½ horizontal
chroma resolution, also known as YUV 4:2:2. One luminance and one
chrominance plane with alternating chroma samples as opposed to
<code class="constant">V4L2_PIX_FMT_YVU420</code></span></dt><dt><span class="refentrytitle"><a href="media.html#idp58473760">V4L2_PIX_FMT_NV16M ('NM16'), V4L2_PIX_FMT_NV61M ('NM61')</a></span><span class="refpurpose"> &#8212; Variation of <code class="constant">V4L2_PIX_FMT_NV16</code> and <code class="constant">V4L2_PIX_FMT_NV61</code> with planes
	  non contiguous in memory. </span></dt><dt><span class="refentrytitle"><a href="media.html#idp58620656">V4L2_PIX_FMT_NV24 ('NV24'), V4L2_PIX_FMT_NV42 ('NV42')</a></span><span class="refpurpose"> &#8212; Formats with full horizontal and vertical
chroma resolutions, also known as YUV 4:4:4. One luminance and one
chrominance plane with alternating chroma samples as opposed to
<code class="constant">V4L2_PIX_FMT_YVU420</code></span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-M420">V4L2_PIX_FMT_M420 ('M420')</a></span><span class="refpurpose"> &#8212; Format with ½ horizontal and vertical chroma
	resolution, also known as YUV 4:2:0. Hybrid plane line-interleaved
	layout.</span></dt></dl></dd><dt><span class="section"><a href="media.html#idp58796032">Compressed Formats</a></span></dt><dt><span class="section"><a href="media.html#sdr-formats">SDR Formats</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="media.html#V4L2-SDR-FMT-CU08">V4L2_SDR_FMT_CU8 ('CU08')</a></span><span class="refpurpose"> &#8212; Complex unsigned 8-bit IQ sample</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-SDR-FMT-CU16LE">V4L2_SDR_FMT_CU16LE ('CU16')</a></span><span class="refpurpose"> &#8212; Complex unsigned 16-bit little endian IQ sample</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-SDR-FMT-CS08">V4L2_SDR_FMT_CS8 ('CS08')</a></span><span class="refpurpose"> &#8212; Complex signed 8-bit IQ sample</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-SDR-FMT-CS14LE">V4L2_SDR_FMT_CS14LE ('CS14')</a></span><span class="refpurpose"> &#8212; Complex signed 14-bit little endian IQ sample</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-SDR-FMT-RU12LE">V4L2_SDR_FMT_RU12LE ('RU12')</a></span><span class="refpurpose"> &#8212; Real unsigned 12-bit little endian sample</span></dt></dl></dd><dt><span class="section"><a href="media.html#pixfmt-reserved">Reserved Format Identifiers</a></span></dt></dl></dd><dt><span class="chapter"><a href="media.html#io">3. Input/Output</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#rw">Read/Write</a></span></dt><dt><span class="section"><a href="media.html#mmap">Streaming I/O (Memory Mapping)</a></span></dt><dt><span class="section"><a href="media.html#userp">Streaming I/O (User Pointers)</a></span></dt><dt><span class="section"><a href="media.html#dmabuf">Streaming I/O (DMA buffer importing)</a></span></dt><dt><span class="section"><a href="media.html#async">Asynchronous I/O</a></span></dt><dt><span class="section"><a href="media.html#buffer">Buffers</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp62487856">Timecodes</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#field-order">Field Order</a></span></dt></dl></dd><dt><span class="chapter"><a href="media.html#devices">4. Interfaces</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#capture">Video Capture Interface</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp63129312">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp63135904">Supplemental Functions</a></span></dt><dt><span class="section"><a href="media.html#idp63143280">Image Format Negotiation</a></span></dt><dt><span class="section"><a href="media.html#idp63167408">Reading Images</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#overlay">Video Overlay Interface</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp63229152">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp63232944">Supplemental Functions</a></span></dt><dt><span class="section"><a href="media.html#idp63239936">Setup</a></span></dt><dt><span class="section"><a href="media.html#idp63255648">Overlay Window</a></span></dt><dt><span class="section"><a href="media.html#idp63352768">Enabling Overlay</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#output">Video Output Interface</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp63496272">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp63501584">Supplemental Functions</a></span></dt><dt><span class="section"><a href="media.html#idp63508576">Image Format Negotiation</a></span></dt><dt><span class="section"><a href="media.html#idp63532608">Writing Images</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#osd">Video Output Overlay Interface</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp63588592">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp63592736">Framebuffer</a></span></dt><dt><span class="section"><a href="media.html#idp63605568">Overlay Window and Scaling</a></span></dt><dt><span class="section"><a href="media.html#idp63623776">Enabling Overlay</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#codec">Codec Interface</a></span></dt><dt><span class="section"><a href="media.html#effect">Effect Devices Interface</a></span></dt><dt><span class="section"><a href="media.html#raw-vbi">Raw VBI Data Interface</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp63701712">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp63705984">Supplemental Functions</a></span></dt><dt><span class="section"><a href="media.html#idp63710576">Raw VBI Format Negotiation</a></span></dt><dt><span class="section"><a href="media.html#idp63809184">Reading and writing VBI images</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#sliced">Sliced VBI Data Interface</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp63939408">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp63944448">Supplemental Functions</a></span></dt><dt><span class="section"><a href="media.html#sliced-vbi-format-negotitation">Sliced VBI Format Negotiation</a></span></dt><dt><span class="section"><a href="media.html#idp64060256">Reading and writing sliced VBI data</a></span></dt><dt><span class="section"><a href="media.html#idp64099728">Sliced VBI Data in MPEG Streams</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#ttx">Teletext Interface</a></span></dt><dt><span class="section"><a href="media.html#radio">Radio Interface</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp64509616">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp64564896">Supplemental Functions</a></span></dt><dt><span class="section"><a href="media.html#idp64568384">Programming</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#rds">RDS Interface</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp64515536">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#reading-rds-data">Reading RDS data</a></span></dt><dt><span class="section"><a href="media.html#writing-rds-data">Writing RDS data</a></span></dt><dt><span class="section"><a href="media.html#idp64621536">RDS datastructures</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#sdr">Software Defined Radio Interface (SDR)</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp64752064">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp64756400">Supplemental Functions</a></span></dt><dt><span class="section"><a href="media.html#idp64761456">Data Format Negotiation</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#event">Event Interface</a></span></dt><dt><span class="section"><a href="media.html#subdev">Sub-device Interface</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp64863392">Controls</a></span></dt><dt><span class="section"><a href="media.html#idp64867520">Events</a></span></dt><dt><span class="section"><a href="media.html#pad-level-formats">Pad-level Formats</a></span></dt><dt><span class="section"><a href="media.html#v4l2-mbus-format">Media Bus Formats</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="media.html#driver">5. V4L2 Driver Programming</a></span></dt><dt><span class="chapter"><a href="media.html#libv4l">6. Libv4l Userspace Library</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#libv4l-introduction">Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp73098096">libv4lconvert</a></span></dt><dt><span class="section"><a href="media.html#idp73133024">libv4l1</a></span></dt><dt><span class="section"><a href="media.html#idp73135024">libv4l2</a></span></dt><dt><span class="section"><a href="media.html#idp73163760">v4l1compat.so wrapper library</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="media.html#compat">7. Changes</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#diff-v4l">Differences between V4L and V4L2</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp73187792">Opening and Closing Devices</a></span></dt><dt><span class="section"><a href="media.html#idp73258032">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp73321456">Video Sources</a></span></dt><dt><span class="section"><a href="media.html#idp73346752">Tuning</a></span></dt><dt><span class="section"><a href="media.html#v4l-image-properties">Image Properties</a></span></dt><dt><span class="section"><a href="media.html#idp73438368">Audio</a></span></dt><dt><span class="section"><a href="media.html#idp73474704">Frame Buffer Overlay</a></span></dt><dt><span class="section"><a href="media.html#idp73505072">Cropping</a></span></dt><dt><span class="section"><a href="media.html#idp73520992">Reading Images, Memory Mapping</a></span></dt><dt><span class="section"><a href="media.html#idp73559232">Reading Raw VBI Data</a></span></dt><dt><span class="section"><a href="media.html#idp73583200">Miscellaneous</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#hist-v4l2">Changes of the V4L2 API</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp73589504">Early Versions</a></span></dt><dt><span class="section"><a href="media.html#idp73613424">V4L2 Version 0.16 1999-01-31</a></span></dt><dt><span class="section"><a href="media.html#idp73615264">V4L2 Version 0.18 1999-03-16</a></span></dt><dt><span class="section"><a href="media.html#idp73616672">V4L2 Version 0.19 1999-06-05</a></span></dt><dt><span class="section"><a href="media.html#idp73621104">V4L2 Version 0.20 (1999-09-10)</a></span></dt><dt><span class="section"><a href="media.html#idp73652672">V4L2 Version 0.20 incremental changes</a></span></dt><dt><span class="section"><a href="media.html#idp73680304">V4L2 Version 0.20 2000-11-23</a></span></dt><dt><span class="section"><a href="media.html#idp73695712">V4L2 Version 0.20 2002-07-25</a></span></dt><dt><span class="section"><a href="media.html#idp73696960">V4L2 in Linux 2.5.46, 2002-10</a></span></dt><dt><span class="section"><a href="media.html#idp73873264">V4L2 2003-06-19</a></span></dt><dt><span class="section"><a href="media.html#idp73897616">V4L2 2003-11-05</a></span></dt><dt><span class="section"><a href="media.html#idp73915888">V4L2 in Linux 2.6.6, 2004-05-09</a></span></dt><dt><span class="section"><a href="media.html#idp73919856">V4L2 in Linux 2.6.8</a></span></dt><dt><span class="section"><a href="media.html#idp73925088">V4L2 spec erratum 2004-08-01</a></span></dt><dt><span class="section"><a href="media.html#idp73934624">V4L2 in Linux 2.6.14</a></span></dt><dt><span class="section"><a href="media.html#idp73939664">V4L2 in Linux 2.6.15</a></span></dt><dt><span class="section"><a href="media.html#idp73952688">V4L2 spec erratum 2005-11-27</a></span></dt><dt><span class="section"><a href="media.html#idp73957168">V4L2 spec erratum 2006-01-10</a></span></dt><dt><span class="section"><a href="media.html#idp73962640">V4L2 spec erratum 2006-02-03</a></span></dt><dt><span class="section"><a href="media.html#idp73967104">V4L2 spec erratum 2006-02-04</a></span></dt><dt><span class="section"><a href="media.html#idp73972448">V4L2 in Linux 2.6.17</a></span></dt><dt><span class="section"><a href="media.html#idp73981536">V4L2 spec erratum 2006-09-23 (Draft 0.15)</a></span></dt><dt><span class="section"><a href="media.html#idp74000640">V4L2 in Linux 2.6.18</a></span></dt><dt><span class="section"><a href="media.html#idp74011472">V4L2 in Linux 2.6.19</a></span></dt><dt><span class="section"><a href="media.html#idp74020480">V4L2 spec erratum 2006-10-12 (Draft 0.17)</a></span></dt><dt><span class="section"><a href="media.html#idp74023952">V4L2 in Linux 2.6.21</a></span></dt><dt><span class="section"><a href="media.html#idp74030176">V4L2 in Linux 2.6.22</a></span></dt><dt><span class="section"><a href="media.html#idp74044000">V4L2 in Linux 2.6.24</a></span></dt><dt><span class="section"><a href="media.html#idp74048672">V4L2 in Linux 2.6.25</a></span></dt><dt><span class="section"><a href="media.html#idp74069136">V4L2 in Linux 2.6.26</a></span></dt><dt><span class="section"><a href="media.html#idp74074224">V4L2 in Linux 2.6.27</a></span></dt><dt><span class="section"><a href="media.html#idp74082240">V4L2 in Linux 2.6.28</a></span></dt><dt><span class="section"><a href="media.html#idp74088448">V4L2 in Linux 2.6.29</a></span></dt><dt><span class="section"><a href="media.html#idp74098320">V4L2 in Linux 2.6.30</a></span></dt><dt><span class="section"><a href="media.html#idp74102560">V4L2 in Linux 2.6.32</a></span></dt><dt><span class="section"><a href="media.html#idp74114320">V4L2 in Linux 2.6.33</a></span></dt><dt><span class="section"><a href="media.html#idp74116928">V4L2 in Linux 2.6.34</a></span></dt><dt><span class="section"><a href="media.html#idp74121184">V4L2 in Linux 2.6.37</a></span></dt><dt><span class="section"><a href="media.html#idp74123920">V4L2 in Linux 2.6.39</a></span></dt><dt><span class="section"><a href="media.html#idp74128224">V4L2 in Linux 3.1</a></span></dt><dt><span class="section"><a href="media.html#idp74131696">V4L2 in Linux 3.2</a></span></dt><dt><span class="section"><a href="media.html#idp74136112">V4L2 in Linux 3.3</a></span></dt><dt><span class="section"><a href="media.html#idp74140832">V4L2 in Linux 3.4</a></span></dt><dt><span class="section"><a href="media.html#idp74147504">V4L2 in Linux 3.5</a></span></dt><dt><span class="section"><a href="media.html#idp74165904">V4L2 in Linux 3.6</a></span></dt><dt><span class="section"><a href="media.html#idp74171856">V4L2 in Linux 3.9</a></span></dt><dt><span class="section"><a href="media.html#idp74179504">V4L2 in Linux 3.10</a></span></dt><dt><span class="section"><a href="media.html#idp74183200">V4L2 in Linux 3.11</a></span></dt><dt><span class="section"><a href="media.html#idp74187760">V4L2 in Linux 3.14</a></span></dt><dt><span class="section"><a href="media.html#idp74191600">V4L2 in Linux 3.15</a></span></dt><dt><span class="section"><a href="media.html#idp74194096">V4L2 in Linux 3.16</a></span></dt><dt><span class="section"><a href="media.html#idp74196656">V4L2 in Linux 3.17</a></span></dt><dt><span class="section"><a href="media.html#idp74201536">V4L2 in Linux 3.18</a></span></dt><dt><span class="section"><a href="media.html#idp74204960">V4L2 in Linux 3.19</a></span></dt><dt><span class="section"><a href="media.html#other">Relation of V4L2 to other Linux multimedia APIs</a></span></dt><dt><span class="section"><a href="media.html#experimental">Experimental API Elements</a></span></dt><dt><span class="section"><a href="media.html#obsolete">Obsolete API Elements</a></span></dt></dl></dd></dl></dd><dt><span class="appendix"><a href="media.html#user-func">A. Function Reference</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="media.html#func-close">V4L2 close()</a></span><span class="refpurpose"> &#8212; Close a V4L2 device</span></dt><dt><span class="refentrytitle"><a href="media.html#func-ioctl">V4L2 ioctl()</a></span><span class="refpurpose"> &#8212; Program a V4L2 device</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-create-bufs">ioctl VIDIOC_CREATE_BUFS</a></span><span class="refpurpose"> &#8212; Create buffers for Memory Mapped or User Pointer or DMA Buffer
    I/O</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-cropcap">ioctl VIDIOC_CROPCAP</a></span><span class="refpurpose"> &#8212; Information about the video cropping and scaling abilities</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-dbg-g-chip-info">ioctl VIDIOC_DBG_G_CHIP_INFO</a></span><span class="refpurpose"> &#8212; Identify the chips on a TV card</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-dbg-g-register">ioctl VIDIOC_DBG_G_REGISTER, VIDIOC_DBG_S_REGISTER</a></span><span class="refpurpose"> &#8212; Read or write hardware registers</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-decoder-cmd">ioctl VIDIOC_DECODER_CMD, VIDIOC_TRY_DECODER_CMD</a></span><span class="refpurpose"> &#8212; Execute an decoder command</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-dqevent">ioctl VIDIOC_DQEVENT</a></span><span class="refpurpose"> &#8212; Dequeue event</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-dv-timings-cap">ioctl VIDIOC_DV_TIMINGS_CAP, VIDIOC_SUBDEV_DV_TIMINGS_CAP</a></span><span class="refpurpose"> &#8212; The capabilities of the Digital Video receiver/transmitter</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-encoder-cmd">ioctl VIDIOC_ENCODER_CMD, VIDIOC_TRY_ENCODER_CMD</a></span><span class="refpurpose"> &#8212; Execute an encoder command</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-enumaudio">ioctl VIDIOC_ENUMAUDIO</a></span><span class="refpurpose"> &#8212; Enumerate audio inputs</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-enumaudioout">ioctl VIDIOC_ENUMAUDOUT</a></span><span class="refpurpose"> &#8212; Enumerate audio outputs</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-enum-dv-timings">ioctl VIDIOC_ENUM_DV_TIMINGS, VIDIOC_SUBDEV_ENUM_DV_TIMINGS</a></span><span class="refpurpose"> &#8212; Enumerate supported Digital Video timings</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-enum-fmt">ioctl VIDIOC_ENUM_FMT</a></span><span class="refpurpose"> &#8212; Enumerate image formats</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-enum-framesizes">ioctl VIDIOC_ENUM_FRAMESIZES</a></span><span class="refpurpose"> &#8212; Enumerate frame sizes</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-enum-frameintervals">ioctl VIDIOC_ENUM_FRAMEINTERVALS</a></span><span class="refpurpose"> &#8212; Enumerate frame intervals</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-enum-freq-bands">ioctl VIDIOC_ENUM_FREQ_BANDS</a></span><span class="refpurpose"> &#8212; Enumerate supported frequency bands</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-enuminput">ioctl VIDIOC_ENUMINPUT</a></span><span class="refpurpose"> &#8212; Enumerate video inputs</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-enumoutput">ioctl VIDIOC_ENUMOUTPUT</a></span><span class="refpurpose"> &#8212; Enumerate video outputs</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-enumstd">ioctl VIDIOC_ENUMSTD</a></span><span class="refpurpose"> &#8212; Enumerate supported video standards</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-expbuf">ioctl VIDIOC_EXPBUF</a></span><span class="refpurpose"> &#8212; Export a buffer as a DMABUF file descriptor.</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-audio">ioctl VIDIOC_G_AUDIO, VIDIOC_S_AUDIO</a></span><span class="refpurpose"> &#8212; Query or select the current audio input and its
attributes</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-audioout">ioctl VIDIOC_G_AUDOUT, VIDIOC_S_AUDOUT</a></span><span class="refpurpose"> &#8212; Query or select the current audio output</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-crop">ioctl VIDIOC_G_CROP, VIDIOC_S_CROP</a></span><span class="refpurpose"> &#8212; Get or set the current cropping rectangle</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-ctrl">ioctl VIDIOC_G_CTRL, VIDIOC_S_CTRL</a></span><span class="refpurpose"> &#8212; Get or set the value of a control</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-dv-timings">ioctl VIDIOC_G_DV_TIMINGS, VIDIOC_S_DV_TIMINGS</a></span><span class="refpurpose"> &#8212; Get or set DV timings for input or output</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-edid">ioctl VIDIOC_G_EDID, VIDIOC_S_EDID</a></span><span class="refpurpose"> &#8212; Get or set the EDID of a video receiver/transmitter</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-enc-index">ioctl VIDIOC_G_ENC_INDEX</a></span><span class="refpurpose"> &#8212; Get meta data about a compressed video stream</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-ext-ctrls">ioctl VIDIOC_G_EXT_CTRLS, VIDIOC_S_EXT_CTRLS,
VIDIOC_TRY_EXT_CTRLS</a></span><span class="refpurpose"> &#8212; Get or set the value of several controls, try control
values</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-fbuf">ioctl VIDIOC_G_FBUF, VIDIOC_S_FBUF</a></span><span class="refpurpose"> &#8212; Get or set frame buffer overlay parameters</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-fmt">ioctl VIDIOC_G_FMT, VIDIOC_S_FMT,
VIDIOC_TRY_FMT</a></span><span class="refpurpose"> &#8212; Get or set the data format, try a format</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-frequency">ioctl VIDIOC_G_FREQUENCY, VIDIOC_S_FREQUENCY</a></span><span class="refpurpose"> &#8212; Get or set tuner or modulator radio
frequency</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-input">ioctl VIDIOC_G_INPUT, VIDIOC_S_INPUT</a></span><span class="refpurpose"> &#8212; Query or select the current video input</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-jpegcomp">ioctl VIDIOC_G_JPEGCOMP, VIDIOC_S_JPEGCOMP</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-modulator">ioctl VIDIOC_G_MODULATOR, VIDIOC_S_MODULATOR</a></span><span class="refpurpose"> &#8212; Get or set modulator attributes</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-output">ioctl VIDIOC_G_OUTPUT, VIDIOC_S_OUTPUT</a></span><span class="refpurpose"> &#8212; Query or select the current video output</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-parm">ioctl VIDIOC_G_PARM, VIDIOC_S_PARM</a></span><span class="refpurpose"> &#8212; Get or set streaming parameters</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-priority">ioctl VIDIOC_G_PRIORITY, VIDIOC_S_PRIORITY</a></span><span class="refpurpose"> &#8212; Query or request the access priority associated with a
file descriptor</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-selection">ioctl VIDIOC_G_SELECTION, VIDIOC_S_SELECTION</a></span><span class="refpurpose"> &#8212; Get or set one of the selection rectangles</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-sliced-vbi-cap">ioctl VIDIOC_G_SLICED_VBI_CAP</a></span><span class="refpurpose"> &#8212; Query sliced VBI capabilities</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-std">ioctl VIDIOC_G_STD, VIDIOC_S_STD</a></span><span class="refpurpose"> &#8212; Query or select the video standard of the current input</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-tuner">ioctl VIDIOC_G_TUNER, VIDIOC_S_TUNER</a></span><span class="refpurpose"> &#8212; Get or set tuner attributes</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-log-status">ioctl VIDIOC_LOG_STATUS</a></span><span class="refpurpose"> &#8212; Log driver status information</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-overlay">ioctl VIDIOC_OVERLAY</a></span><span class="refpurpose"> &#8212; Start or stop video overlay</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-prepare-buf">ioctl VIDIOC_PREPARE_BUF</a></span><span class="refpurpose"> &#8212; Prepare a buffer for I/O</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-qbuf">ioctl VIDIOC_QBUF, VIDIOC_DQBUF</a></span><span class="refpurpose"> &#8212; Exchange a buffer with the driver</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-querybuf">ioctl VIDIOC_QUERYBUF</a></span><span class="refpurpose"> &#8212; Query the status of a buffer</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-querycap">ioctl VIDIOC_QUERYCAP</a></span><span class="refpurpose"> &#8212; Query device capabilities</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-queryctrl">ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU</a></span><span class="refpurpose"> &#8212; Enumerate controls and menu control items</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-query-dv-timings">ioctl VIDIOC_QUERY_DV_TIMINGS</a></span><span class="refpurpose"> &#8212; Sense the DV preset received by the current
input</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-querystd">ioctl VIDIOC_QUERYSTD</a></span><span class="refpurpose"> &#8212; Sense the video standard received by the current
input</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-reqbufs">ioctl VIDIOC_REQBUFS</a></span><span class="refpurpose"> &#8212; Initiate Memory Mapping or User Pointer I/O</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-s-hw-freq-seek">ioctl VIDIOC_S_HW_FREQ_SEEK</a></span><span class="refpurpose"> &#8212; Perform a hardware frequency seek</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-streamon">ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF</a></span><span class="refpurpose"> &#8212; Start or stop streaming I/O</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-subdev-enum-frame-interval">ioctl VIDIOC_SUBDEV_ENUM_FRAME_INTERVAL</a></span><span class="refpurpose"> &#8212; Enumerate frame intervals</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-subdev-enum-frame-size">ioctl VIDIOC_SUBDEV_ENUM_FRAME_SIZE</a></span><span class="refpurpose"> &#8212; Enumerate media bus frame sizes</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-subdev-enum-mbus-code">ioctl VIDIOC_SUBDEV_ENUM_MBUS_CODE</a></span><span class="refpurpose"> &#8212; Enumerate media bus formats</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-subdev-g-crop">ioctl VIDIOC_SUBDEV_G_CROP, VIDIOC_SUBDEV_S_CROP</a></span><span class="refpurpose"> &#8212; Get or set the crop rectangle on a subdev pad</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-subdev-g-fmt">ioctl VIDIOC_SUBDEV_G_FMT, VIDIOC_SUBDEV_S_FMT</a></span><span class="refpurpose"> &#8212; Get or set the data format on a subdev pad</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-subdev-g-frame-interval">ioctl VIDIOC_SUBDEV_G_FRAME_INTERVAL, VIDIOC_SUBDEV_S_FRAME_INTERVAL</a></span><span class="refpurpose"> &#8212; Get or set the frame interval on a subdev pad</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-subdev-g-selection">ioctl VIDIOC_SUBDEV_G_SELECTION, VIDIOC_SUBDEV_S_SELECTION</a></span><span class="refpurpose"> &#8212; Get or set selection rectangles on a subdev pad</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-subscribe-event">ioctl VIDIOC_SUBSCRIBE_EVENT, VIDIOC_UNSUBSCRIBE_EVENT</a></span><span class="refpurpose"> &#8212; Subscribe or unsubscribe event</span></dt><dt><span class="refentrytitle"><a href="media.html#func-mmap">V4L2 mmap()</a></span><span class="refpurpose"> &#8212; Map device memory into application address space</span></dt><dt><span class="refentrytitle"><a href="media.html#func-munmap">V4L2 munmap()</a></span><span class="refpurpose"> &#8212; Unmap device memory</span></dt><dt><span class="refentrytitle"><a href="media.html#func-open">V4L2 open()</a></span><span class="refpurpose"> &#8212; Open a V4L2 device</span></dt><dt><span class="refentrytitle"><a href="media.html#func-poll">V4L2 poll()</a></span><span class="refpurpose"> &#8212; Wait for some event on a file descriptor</span></dt><dt><span class="refentrytitle"><a href="media.html#func-read">V4L2 read()</a></span><span class="refpurpose"> &#8212; Read from a V4L2 device</span></dt><dt><span class="refentrytitle"><a href="media.html#func-select">V4L2 select()</a></span><span class="refpurpose"> &#8212; Synchronous I/O multiplexing</span></dt><dt><span class="refentrytitle"><a href="media.html#func-write">V4L2 write()</a></span><span class="refpurpose"> &#8212; Write to a V4L2 device</span></dt></dl></dd><dt><span class="appendix"><a href="media.html#idp85688448">B. Common definitions for V4L2 and V4L2 subdev interfaces</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#v4l2-selections-common">Common selection definitions</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#v4l2-selection-targets">Selection targets</a></span></dt><dt><span class="section"><a href="media.html#v4l2-selection-flags">Selection flags</a></span></dt></dl></dd></dl></dd><dt><span class="appendix"><a href="media.html#videodev">C. Video For Linux Two Header File</a></span></dt><dt><span class="appendix"><a href="media.html#capture-example">D. Video Capture Example</a></span></dt><dt><span class="appendix"><a href="media.html#v4l2grab-example">E. Video Grabber example using libv4l</a></span></dt><dt><span class="index"><a href="media.html#idp86648832">List of Types</a></span></dt><dt><span class="bibliography"><a href="media.html#idp87100320">References</a></span></dt></dl></dd><dt><span class="part"><a href="media.html#dvbapi">II. LINUX DVB API</a></span></dt><dd><dl><dt><span class="chapter"><a href="media.html#dvb_introdution">8. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#requisites">What you need to know</a></span></dt><dt><span class="section"><a href="media.html#history">History</a></span></dt><dt><span class="section"><a href="media.html#overview">Overview</a></span></dt><dt><span class="section"><a href="media.html#dvb_devices">Linux DVB Devices</a></span></dt><dt><span class="section"><a href="media.html#include_files">API include files</a></span></dt></dl></dd><dt><span class="chapter"><a href="media.html#dvb_frontend">9. DVB Frontend API</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#frontend_types">Frontend Data Types</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#fe-type-t">Frontend type</a></span></dt><dt><span class="section"><a href="media.html#fe-caps-t">frontend capabilities</a></span></dt><dt><span class="section"><a href="media.html#dvb-frontend-info">frontend information</a></span></dt><dt><span class="section"><a href="media.html#dvb-diseqc-master-cmd">diseqc master command</a></span></dt><dt><span class="section"><a href="media.html#dvb-diseqc-slave-reply">diseqc slave reply</a></span></dt><dt><span class="section"><a href="media.html#fe-sec-voltage-t">diseqc slave reply</a></span></dt><dt><span class="section"><a href="media.html#fe-sec-tone-mode-t">SEC continuous tone</a></span></dt><dt><span class="section"><a href="media.html#fe-sec-mini-cmd-t">SEC tone burst</a></span></dt><dt><span class="section"><a href="media.html#fe-status-t">frontend status</a></span></dt><dt><span class="section"><a href="media.html#dvb-frontend-parameters">frontend parameters</a></span></dt><dt><span class="section"><a href="media.html#dvb-frontend-event">frontend events</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#frontend_fcalls">Frontend Function Calls</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#frontend_f_open">open()</a></span></dt><dt><span class="section"><a href="media.html#frontend_f_close">close()</a></span></dt><dt><span class="section"><a href="media.html#FE_READ_STATUS">FE_READ_STATUS</a></span></dt><dt><span class="section"><a href="media.html#FE_READ_BER">FE_READ_BER</a></span></dt><dt><span class="section"><a href="media.html#FE_READ_SNR">FE_READ_SNR</a></span></dt><dt><span class="section"><a href="media.html#FE_READ_SIGNAL_STRENGTH">FE_READ_SIGNAL_STRENGTH</a></span></dt><dt><span class="section"><a href="media.html#FE_READ_UNCORRECTED_BLOCKS">FE_READ_UNCORRECTED_BLOCKS</a></span></dt><dt><span class="section"><a href="media.html#FE_SET_FRONTEND">FE_SET_FRONTEND</a></span></dt><dt><span class="section"><a href="media.html#FE_GET_FRONTEND">FE_GET_FRONTEND</a></span></dt><dt><span class="section"><a href="media.html#FE_GET_EVENT">FE_GET_EVENT</a></span></dt><dt><span class="section"><a href="media.html#FE_GET_INFO">FE_GET_INFO</a></span></dt><dt><span class="section"><a href="media.html#FE_DISEQC_RESET_OVERLOAD">FE_DISEQC_RESET_OVERLOAD</a></span></dt><dt><span class="section"><a href="media.html#FE_DISEQC_SEND_MASTER_CMD">FE_DISEQC_SEND_MASTER_CMD</a></span></dt><dt><span class="section"><a href="media.html#FE_DISEQC_RECV_SLAVE_REPLY">FE_DISEQC_RECV_SLAVE_REPLY</a></span></dt><dt><span class="section"><a href="media.html#FE_DISEQC_SEND_BURST">FE_DISEQC_SEND_BURST</a></span></dt><dt><span class="section"><a href="media.html#FE_SET_TONE">FE_SET_TONE</a></span></dt><dt><span class="section"><a href="media.html#FE_SET_VOLTAGE">FE_SET_VOLTAGE</a></span></dt><dt><span class="section"><a href="media.html#FE_ENABLE_HIGH_LNB_VOLTAGE">FE_ENABLE_HIGH_LNB_VOLTAGE</a></span></dt><dt><span class="section"><a href="media.html#FE_SET_FRONTEND_TUNE_MODE">FE_SET_FRONTEND_TUNE_MODE</a></span></dt><dt><span class="section"><a href="media.html#FE_DISHNETWORK_SEND_LEGACY_CMD">FE_DISHNETWORK_SEND_LEGACY_CMD</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#FE_GET_SET_PROPERTY"><code class="constant">FE_GET_PROPERTY/FE_SET_PROPERTY</code></a></span></dt><dd><dl><dt><span class="section"><a href="media.html#dtv-stats">DTV stats type</a></span></dt><dt><span class="section"><a href="media.html#dtv-fe-stats">DTV stats type</a></span></dt><dt><span class="section"><a href="media.html#dtv-property">DTV property type</a></span></dt><dt><span class="section"><a href="media.html#dtv-properties">DTV properties type</a></span></dt><dt><span class="section"><a href="media.html#FE_GET_PROPERTY">FE_GET_PROPERTY</a></span></dt><dt><span class="section"><a href="media.html#FE_SET_PROPERTY">FE_SET_PROPERTY</a></span></dt><dt><span class="section"><a href="media.html#idp105068368">Property types</a></span></dt><dt><span class="section"><a href="media.html#fe_property_parameters">Digital TV property parameters</a></span></dt><dt><span class="section"><a href="media.html#frontend-stat-properties">Frontend statistics indicators</a></span></dt><dt><span class="section"><a href="media.html#frontend-property-terrestrial-systems">Properties used on terrestrial delivery systems</a></span></dt><dt><span class="section"><a href="media.html#frontend-property-cable-systems">Properties used on cable delivery systems</a></span></dt><dt><span class="section"><a href="media.html#frontend-property-satellital-systems">Properties used on satellital delivery systems</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="media.html#dvb_demux">10. DVB Demux Device</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#dmx_types">Demux Data Types</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#dmx-output-t">dmx_output_t</a></span></dt><dt><span class="section"><a href="media.html#dmx-input-t">dmx_input_t</a></span></dt><dt><span class="section"><a href="media.html#dmx-pes-type-t">dmx_pes_type_t</a></span></dt><dt><span class="section"><a href="media.html#dmx-filter">struct dmx_filter</a></span></dt><dt><span class="section"><a href="media.html#dmx-sct-filter-params">struct dmx_sct_filter_params</a></span></dt><dt><span class="section"><a href="media.html#dmx-pes-filter-params">struct dmx_pes_filter_params</a></span></dt><dt><span class="section"><a href="media.html#dmx-event">struct dmx_event</a></span></dt><dt><span class="section"><a href="media.html#dmx-stc">struct dmx_stc</a></span></dt><dt><span class="section"><a href="media.html#dmx-caps">struct dmx_caps</a></span></dt><dt><span class="section"><a href="media.html#dmx-source-t">enum dmx_source_t</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#dmx_fcalls">Demux Function Calls</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#dmx_fopen">open()</a></span></dt><dt><span class="section"><a href="media.html#dmx_fclose">close()</a></span></dt><dt><span class="section"><a href="media.html#dmx_fread">read()</a></span></dt><dt><span class="section"><a href="media.html#dmx_fwrite">write()</a></span></dt><dt><span class="section"><a href="media.html#DMX_START">DMX_START</a></span></dt><dt><span class="section"><a href="media.html#DMX_STOP">DMX_STOP</a></span></dt><dt><span class="section"><a href="media.html#DMX_SET_FILTER">DMX_SET_FILTER</a></span></dt><dt><span class="section"><a href="media.html#DMX_SET_PES_FILTER">DMX_SET_PES_FILTER</a></span></dt><dt><span class="section"><a href="media.html#DMX_SET_BUFFER_SIZE">DMX_SET_BUFFER_SIZE</a></span></dt><dt><span class="section"><a href="media.html#DMX_GET_EVENT">DMX_GET_EVENT</a></span></dt><dt><span class="section"><a href="media.html#DMX_GET_STC">DMX_GET_STC</a></span></dt><dt><span class="section"><a href="media.html#DMX_GET_PES_PIDS">DMX_GET_PES_PIDS</a></span></dt><dt><span class="section"><a href="media.html#DMX_GET_CAPS">DMX_GET_CAPS</a></span></dt><dt><span class="section"><a href="media.html#DMX_SET_SOURCE">DMX_SET_SOURCE</a></span></dt><dt><span class="section"><a href="media.html#DMX_ADD_PID">DMX_ADD_PID</a></span></dt><dt><span class="section"><a href="media.html#DMX_REMOVE_PID">DMX_REMOVE_PID</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="media.html#dvb_video">11. DVB Video Device</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#video_types">Video Data Types</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#video-format-t">video_format_t</a></span></dt><dt><span class="section"><a href="media.html#video-displayformat-t">video_displayformat_t</a></span></dt><dt><span class="section"><a href="media.html#video-stream-source-t">video_stream_source_t</a></span></dt><dt><span class="section"><a href="media.html#video-play-state-t">video_play_state_t</a></span></dt><dt><span class="section"><a href="media.html#video-command">struct video_command</a></span></dt><dt><span class="section"><a href="media.html#video-size-t">video_size_t</a></span></dt><dt><span class="section"><a href="media.html#video-event">struct video_event</a></span></dt><dt><span class="section"><a href="media.html#video-status">struct video_status</a></span></dt><dt><span class="section"><a href="media.html#video-still-picture">struct video_still_picture</a></span></dt><dt><span class="section"><a href="media.html#video_caps">video capabilities</a></span></dt><dt><span class="section"><a href="media.html#video-system">video_system_t</a></span></dt><dt><span class="section"><a href="media.html#video-highlight">struct video_highlight</a></span></dt><dt><span class="section"><a href="media.html#video-spu">struct video_spu</a></span></dt><dt><span class="section"><a href="media.html#video-spu-palette">struct video_spu_palette</a></span></dt><dt><span class="section"><a href="media.html#video-navi-pack">struct video_navi_pack</a></span></dt><dt><span class="section"><a href="media.html#video-attributes-t">video_attributes_t</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#video_function_calls">Video Function Calls</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#video_fopen">open()</a></span></dt><dt><span class="section"><a href="media.html#video_fclose">close()</a></span></dt><dt><span class="section"><a href="media.html#video_fwrite">write()</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_STOP">VIDEO_STOP</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_PLAY">VIDEO_PLAY</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_FREEZE">VIDEO_FREEZE</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_CONTINUE">VIDEO_CONTINUE</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SELECT_SOURCE">VIDEO_SELECT_SOURCE</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_BLANK">VIDEO_SET_BLANK</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_GET_STATUS">VIDEO_GET_STATUS</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_GET_FRAME_COUNT">VIDEO_GET_FRAME_COUNT</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_GET_PTS">VIDEO_GET_PTS</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_GET_FRAME_RATE">VIDEO_GET_FRAME_RATE</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_GET_EVENT">VIDEO_GET_EVENT</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_COMMAND">VIDEO_COMMAND</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_TRY_COMMAND">VIDEO_TRY_COMMAND</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_GET_SIZE">VIDEO_GET_SIZE</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_DISPLAY_FORMAT">VIDEO_SET_DISPLAY_FORMAT</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_STILLPICTURE">VIDEO_STILLPICTURE</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_FAST_FORWARD">VIDEO_FAST_FORWARD</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SLOWMOTION">VIDEO_SLOWMOTION</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_GET_CAPABILITIES">VIDEO_GET_CAPABILITIES</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_ID">VIDEO_SET_ID</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_CLEAR_BUFFER">VIDEO_CLEAR_BUFFER</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_STREAMTYPE">VIDEO_SET_STREAMTYPE</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_FORMAT">VIDEO_SET_FORMAT</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_SYSTEM">VIDEO_SET_SYSTEM</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_HIGHLIGHT">VIDEO_SET_HIGHLIGHT</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_SPU">VIDEO_SET_SPU</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_SPU_PALETTE">VIDEO_SET_SPU_PALETTE</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_GET_NAVI">VIDEO_GET_NAVI</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_ATTRIBUTES">VIDEO_SET_ATTRIBUTES</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="media.html#dvb_audio">12. DVB Audio Device</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#audio_data_types">Audio Data Types</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#audio-stream-source-t">audio_stream_source_t</a></span></dt><dt><span class="section"><a href="media.html#audio-play-state-t">audio_play_state_t</a></span></dt><dt><span class="section"><a href="media.html#audio-channel-select-t">audio_channel_select_t</a></span></dt><dt><span class="section"><a href="media.html#audio-status">struct audio_status</a></span></dt><dt><span class="section"><a href="media.html#audio-mixer">struct audio_mixer</a></span></dt><dt><span class="section"><a href="media.html#audio_encodings">audio encodings</a></span></dt><dt><span class="section"><a href="media.html#audio-karaoke">struct audio_karaoke</a></span></dt><dt><span class="section"><a href="media.html#audio-attributes-t">audio attributes</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#audio_function_calls">Audio Function Calls</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#audio_fopen">open()</a></span></dt><dt><span class="section"><a href="media.html#audio_fclose">close()</a></span></dt><dt><span class="section"><a href="media.html#audio_fwrite">write()</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_STOP">AUDIO_STOP</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_PLAY">AUDIO_PLAY</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_PAUSE">AUDIO_PAUSE</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_CONTINUE">AUDIO_CONTINUE</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SELECT_SOURCE">AUDIO_SELECT_SOURCE</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_MUTE">AUDIO_SET_MUTE</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_AV_SYNC">AUDIO_SET_AV_SYNC</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_BYPASS_MODE">AUDIO_SET_BYPASS_MODE</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_CHANNEL_SELECT">AUDIO_CHANNEL_SELECT</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_BILINGUAL_CHANNEL_SELECT">AUDIO_BILINGUAL_CHANNEL_SELECT</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_GET_PTS">AUDIO_GET_PTS</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_GET_STATUS">AUDIO_GET_STATUS</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_GET_CAPABILITIES">AUDIO_GET_CAPABILITIES</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_CLEAR_BUFFER">AUDIO_CLEAR_BUFFER</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_ID">AUDIO_SET_ID</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_MIXER">AUDIO_SET_MIXER</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_STREAMTYPE">AUDIO_SET_STREAMTYPE</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_EXT_ID">AUDIO_SET_EXT_ID</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_ATTRIBUTES">AUDIO_SET_ATTRIBUTES</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_KARAOKE">AUDIO_SET_KARAOKE</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="media.html#dvb_ca">13. DVB CA Device</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#ca_data_types">CA Data Types</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#ca-slot-info">ca_slot_info_t</a></span></dt><dt><span class="section"><a href="media.html#ca-descr-info">ca_descr_info_t</a></span></dt><dt><span class="section"><a href="media.html#ca-caps">ca_caps_t</a></span></dt><dt><span class="section"><a href="media.html#ca-msg">ca_msg_t</a></span></dt><dt><span class="section"><a href="media.html#ca-descr">ca_descr_t</a></span></dt><dt><span class="section"><a href="media.html#ca-pid">ca-pid</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#ca_function_calls">CA Function Calls</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#ca_fopen">open()</a></span></dt><dt><span class="section"><a href="media.html#ca_fclose">close()</a></span></dt><dt><span class="section"><a href="media.html#CA_RESET">CA_RESET</a></span></dt><dt><span class="section"><a href="media.html#CA_GET_CAP">CA_GET_CAP</a></span></dt><dt><span class="section"><a href="media.html#CA_GET_SLOT_INFO">CA_GET_SLOT_INFO</a></span></dt><dt><span class="section"><a href="media.html#CA_GET_DESCR_INFO">CA_GET_DESCR_INFO</a></span></dt><dt><span class="section"><a href="media.html#CA_GET_MSG">CA_GET_MSG</a></span></dt><dt><span class="section"><a href="media.html#CA_SEND_MSG">CA_SEND_MSG</a></span></dt><dt><span class="section"><a href="media.html#CA_SET_DESCR">CA_SET_DESCR</a></span></dt><dt><span class="section"><a href="media.html#CA_SET_PID">CA_SET_PID</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="media.html#dvb_net">14. DVB Network API</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#dvb_net_types">DVB Net Data Types</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#dvb-net-if">struct dvb_net_if</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#net_fcalls">DVB net Function Calls</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#NET_ADD_IF">NET_ADD_IF</a></span></dt><dt><span class="section"><a href="media.html#NET_REMOVE_IF">NET_REMOVE_IF</a></span></dt><dt><span class="section"><a href="media.html#NET_GET_IF">NET_GET_IF</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="media.html#dvb_kdapi">15. Kernel Demux API</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#kernel_demux_data_types">Kernel Demux Data Types</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#dmx_success_t">dmx_success_t</a></span></dt><dt><span class="section"><a href="media.html#ts_filter_types">TS filter types</a></span></dt><dt><span class="section"><a href="media.html#dmx_ts_pes_t">dmx_ts_pes_t</a></span></dt><dt><span class="section"><a href="media.html#demux_demux_t">demux_demux_t</a></span></dt><dt><span class="section"><a href="media.html#demux_directory">Demux directory</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#demux_directory_api">Demux Directory API</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp110784096">dmx_register_demux()</a></span></dt><dt><span class="section"><a href="media.html#idp110801088">dmx_unregister_demux()</a></span></dt><dt><span class="section"><a href="media.html#idp110817936">dmx_get_demuxes()</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#demux_api">Demux API</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#kdapi_fopen">open()</a></span></dt><dt><span class="section"><a href="media.html#kdapi_fclose">close()</a></span></dt><dt><span class="section"><a href="media.html#kdapi_fwrite">write()</a></span></dt><dt><span class="section"><a href="media.html#idp110890656">allocate_ts_feed()</a></span></dt><dt><span class="section"><a href="media.html#idp110913216">release_ts_feed()</a></span></dt><dt><span class="section"><a href="media.html#idp110929088">allocate_section_feed()</a></span></dt><dt><span class="section"><a href="media.html#idp110951600">release_section_feed()</a></span></dt><dt><span class="section"><a href="media.html#idp110967536">descramble_mac_address()</a></span></dt><dt><span class="section"><a href="media.html#idp110994256">descramble_section_payload()</a></span></dt><dt><span class="section"><a href="media.html#idp111023728">add_frontend()</a></span></dt><dt><span class="section"><a href="media.html#idp111046176">remove_frontend()</a></span></dt><dt><span class="section"><a href="media.html#idp111064624">get_frontends()</a></span></dt><dt><span class="section"><a href="media.html#idp111078032">connect_frontend()</a></span></dt><dt><span class="section"><a href="media.html#idp111097408">disconnect_frontend()</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#demux_callback_api">Demux Callback API</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp111114592">dmx_ts_cb()</a></span></dt><dt><span class="section"><a href="media.html#idp111148960">dmx_section_cb()</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#ts_feed_api">TS Feed API</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp111176992">set()</a></span></dt><dt><span class="section"><a href="media.html#idp111205664">start_filtering()</a></span></dt><dt><span class="section"><a href="media.html#idp111219648">stop_filtering()</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#section_feed_api">Section Feed API</a></span></dt><dt><span class="section"><a href="media.html#kdapi_set">set()</a></span></dt><dt><span class="section"><a href="media.html#idp111263088">allocate_filter()</a></span></dt><dt><span class="section"><a href="media.html#idp111294528">release_filter()</a></span></dt><dt><span class="section"><a href="media.html#idp111312448">start_filtering()</a></span></dt><dt><span class="section"><a href="media.html#idp111326592">stop_filtering()</a></span></dt></dl></dd><dt><span class="chapter"><a href="media.html#dvb_examples">16. Examples</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#tuning">Tuning</a></span></dt><dt><span class="section"><a href="media.html#the_dvr_device">The DVR device</a></span></dt></dl></dd><dt><span class="appendix"><a href="media.html#audio_h">F. DVB Audio Header File</a></span></dt><dt><span class="appendix"><a href="media.html#ca_h">G. DVB Conditional Access Header File</a></span></dt><dt><span class="appendix"><a href="media.html#dmx_h">H. DVB Demux Header File</a></span></dt><dt><span class="appendix"><a href="media.html#frontend_h">I. DVB Frontend Header File</a></span></dt><dt><span class="appendix"><a href="media.html#net_h">J. DVB Network Header File</a></span></dt><dt><span class="appendix"><a href="media.html#video_h">K. DVB Video Header File</a></span></dt></dl></dd><dt><span class="part"><a href="media.html#remotes">III. Remote Controller API</a></span></dt><dd><dl><dt><span class="chapter"><a href="media.html#remote_controllers">17. Remote Controllers</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#Remote_controllers_Intro">Introduction</a></span></dt><dt><span class="section"><a href="media.html#remote_controllers_sysfs_nodes">Remote Controller's sysfs nodes</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#sys_class_rc">/sys/class/rc/</a></span></dt><dt><span class="section"><a href="media.html#sys_class_rc_rcN">/sys/class/rc/rcN/</a></span></dt><dt><span class="section"><a href="media.html#sys_class_rc_rcN_protocols">/sys/class/rc/rcN/protocols</a></span></dt><dt><span class="section"><a href="media.html#sys_class_rc_rcN_filter">/sys/class/rc/rcN/filter</a></span></dt><dt><span class="section"><a href="media.html#sys_class_rc_rcN_filter_mask">/sys/class/rc/rcN/filter_mask</a></span></dt><dt><span class="section"><a href="media.html#sys_class_rc_rcN_wakeup_protocols">/sys/class/rc/rcN/wakeup_protocols</a></span></dt><dt><span class="section"><a href="media.html#sys_class_rc_rcN_wakeup_filter">/sys/class/rc/rcN/wakeup_filter</a></span></dt><dt><span class="section"><a href="media.html#sys_class_rc_rcN_wakeup_filter_mask">/sys/class/rc/rcN/wakeup_filter_mask</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#Remote_controllers_tables">Remote controller tables</a></span></dt><dt><span class="section"><a href="media.html#Remote_controllers_table_change">Changing default Remote Controller mappings</a></span></dt><dt><span class="section"><a href="media.html#lirc_dev">LIRC Device Interface</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#lirc_dev_intro">Introduction</a></span></dt><dt><span class="section"><a href="media.html#lirc_read">LIRC read fop</a></span></dt><dt><span class="section"><a href="media.html#lirc_write">LIRC write fop</a></span></dt><dt><span class="section"><a href="media.html#lirc_ioctl">LIRC ioctl fop</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="media.html#media_common">IV. Media Controller API</a></span></dt><dd><dl><dt><span class="chapter"><a href="media.html#media_controller">18. Media Controller</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#media-controller-intro">Introduction</a></span></dt><dt><span class="section"><a href="media.html#media-controller-model">Media device model</a></span></dt></dl></dd><dt><span class="appendix"><a href="media.html#media-user-func">L. Function Reference</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="media.html#media-func-open">media open()</a></span><span class="refpurpose"> &#8212; Open a media device</span></dt><dt><span class="refentrytitle"><a href="media.html#media-func-close">media close()</a></span><span class="refpurpose"> &#8212; Close a media device</span></dt><dt><span class="refentrytitle"><a href="media.html#media-func-ioctl">media ioctl()</a></span><span class="refpurpose"> &#8212; Control a media device</span></dt><dt><span class="refentrytitle"><a href="media.html#media-ioc-device-info">ioctl MEDIA_IOC_DEVICE_INFO</a></span><span class="refpurpose"> &#8212; Query device information</span></dt><dt><span class="refentrytitle"><a href="media.html#media-ioc-enum-entities">ioctl MEDIA_IOC_ENUM_ENTITIES</a></span><span class="refpurpose"> &#8212; Enumerate entities and their properties</span></dt><dt><span class="refentrytitle"><a href="media.html#media-ioc-enum-links">ioctl MEDIA_IOC_ENUM_LINKS</a></span><span class="refpurpose"> &#8212; Enumerate all pads and links for a given entity</span></dt><dt><span class="refentrytitle"><a href="media.html#media-ioc-setup-link">ioctl MEDIA_IOC_SETUP_LINK</a></span><span class="refpurpose"> &#8212; Modify the properties of a link</span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="media.html#gen_errors">19. Generic Error Codes</a></span></dt><dt><span class="appendix"><a href="media.html#fdl">M. GNU Free Documentation License</a></span></dt><dd><dl><dt><span class="sect1"><a href="media.html#fdl-preamble">0. PREAMBLE</a></span></dt><dt><span class="sect1"><a href="media.html#fdl-section1">1. APPLICABILITY AND DEFINITIONS</a></span></dt><dt><span class="sect1"><a href="media.html#fdl-section2">2. VERBATIM COPYING</a></span></dt><dt><span class="sect1"><a href="media.html#fdl-section3">3. COPYING IN QUANTITY</a></span></dt><dt><span class="sect1"><a href="media.html#fdl-section4">4. MODIFICATIONS</a></span></dt><dt><span class="sect1"><a href="media.html#fdl-section5">5. COMBINING DOCUMENTS</a></span></dt><dt><span class="sect1"><a href="media.html#fdl-section6">6. COLLECTIONS OF DOCUMENTS</a></span></dt><dt><span class="sect1"><a href="media.html#fdl-section7">7. AGGREGATION WITH INDEPENDENT WORKS</a></span></dt><dt><span class="sect1"><a href="media.html#fdl-section8">8. TRANSLATION</a></span></dt><dt><span class="sect1"><a href="media.html#fdl-section9">9. TERMINATION</a></span></dt><dt><span class="sect1"><a href="media.html#fdl-section10">10. FUTURE REVISIONS OF THIS LICENSE</a></span></dt><dt><span class="sect1"><a href="media.html#fdl-using">Addendum</a></span></dt></dl></dd></dl></div><div class="list-of-figures"><p><b>List of Figures</b></p><dl><dt>1.1. <a href="media.html#crop-scale">Image Cropping, Insertion and Scaling</a></dt><dt>1.2. <a href="media.html#sel-targets-capture">Cropping and composing targets</a></dt><dt>2.1. <a href="media.html#nv12mt"><code class="constant">V4L2_PIX_FMT_NV12MT</code> macroblock Z shape
memory layout</a></dt><dt>2.2. <a href="media.html#nv12mt_ex">Example <code class="constant">V4L2_PIX_FMT_NV12MT</code> memory
layout of macroblocks</a></dt><dt>3.1. <a href="media.html#fieldseq-tb">Field Order, Top Field First Transmitted</a></dt><dt>3.2. <a href="media.html#fieldseq-bt">Field Order, Bottom Field First Transmitted</a></dt><dt>4.1. <a href="media.html#vbi-hsync">Line synchronization</a></dt><dt>4.2. <a href="media.html#vbi-525">ITU-R 525 line numbering (M/NTSC and M/PAL)</a></dt><dt>4.3. <a href="media.html#vbi-625">ITU-R 625 line numbering</a></dt><dt>4.4. <a href="media.html#pipeline-scaling">Image Format Negotiation on Pipelines</a></dt><dt>4.5. <a href="media.html#subdev-image-processing-crop">Image processing in subdevs: simple crop example</a></dt><dt>4.6. <a href="media.html#subdev-image-processing-scaling-multi-source">Image processing in subdevs: scaling with multiple sources</a></dt><dt>4.7. <a href="media.html#subdev-image-processing-full">Image processing in subdevs: scaling and composition
	with multiple sinks and sources</a></dt><dt>4.8. <a href="media.html#bayer-patterns">Bayer Patterns</a></dt><dt>A.1. <a href="media.html#sel-const-adjust">Size adjustments with constraint flags.</a></dt><dt>8.1. <a href="media.html#stb_components">Components of a DVB card/STB</a></dt></dl></div><div class="list-of-tables"><p><b>List of Tables</b></p><dl><dt>1.1. <a href="media.html#control-id">Control IDs</a></dt><dt>1.2. <a href="media.html#mpeg-control-id">Codec Control IDs</a></dt><dt>1.3. <a href="media.html#mfc51-control-id">MFC 5.1 Control IDs</a></dt><dt>1.4. <a href="media.html#cx2341x-control-id">CX2341x Control IDs</a></dt><dt>1.5. <a href="media.html#vpx-control-id">VPX Control IDs</a></dt><dt>1.6. <a href="media.html#camera-control-id">Camera Control IDs</a></dt><dt>1.7. <a href="media.html#fm-tx-control-id">FM_TX Control IDs</a></dt><dt>1.8. <a href="media.html#flash-control-id">Flash Control IDs</a></dt><dt>1.9. <a href="media.html#jpeg-control-id">JPEG Control IDs</a></dt><dt>1.10. <a href="media.html#image-source-control-id">Image Source Control IDs</a></dt><dt>1.11. <a href="media.html#image-process-control-id">Image Source Control IDs</a></dt><dt>1.12. <a href="media.html#dv-control-id">Digital Video Control IDs</a></dt><dt>1.13. <a href="media.html#fm-rx-control-id">FM_RX Control IDs</a></dt><dt>1.14. <a href="media.html#detect-control-id">Detect Control IDs</a></dt><dt>1.15. <a href="media.html#rf-tuner-control-id">RF_TUNER Control IDs</a></dt><dt>2.1. <a href="media.html#v4l2-pix-format">struct <span class="structname">v4l2_pix_format</span></a></dt><dt>2.2. <a href="media.html#v4l2-plane-pix-format">struct <span class="structname">v4l2_plane_pix_format</span></a></dt><dt>2.3. <a href="media.html#v4l2-pix-format-mplane">struct <span class="structname">v4l2_pix_format_mplane</span></a></dt><dt>2.4. <a href="media.html#v4l2-colorspace">V4L2 Colorspaces</a></dt><dt>2.5. <a href="media.html#v4l2-ycbcr-encoding">V4L2 Y'CbCr Encodings</a></dt><dt>2.6. <a href="media.html#v4l2-quantization">V4L2 Quantization Methods</a></dt><dt>2.7. <a href="media.html#idp54236320">SMPTE 170M Chromaticities</a></dt><dt>2.8. <a href="media.html#idp54274736">Rec. 709 Chromaticities</a></dt><dt>2.9. <a href="media.html#idp54311344">sRGB Chromaticities</a></dt><dt>2.10. <a href="media.html#idp54343696">Adobe RGB Chromaticities</a></dt><dt>2.11. <a href="media.html#idp54369456">BT.2020 Chromaticities</a></dt><dt>2.12. <a href="media.html#idp54407904">SMPTE 240M Chromaticities</a></dt><dt>2.13. <a href="media.html#idp54434672">NTSC 1953 Chromaticities</a></dt><dt>2.14. <a href="media.html#idp54462624">EBU Tech. 3213 Chromaticities</a></dt><dt>2.15. <a href="media.html#idp54494304">Indexed Image Format</a></dt><dt>2.16. <a href="media.html#rgb-formats">Packed RGB Image Formats</a></dt><dt>2.17. <a href="media.html#rgb-formats-deprecated">Deprecated Packed RGB Image Formats</a></dt><dt>2.18. <a href="media.html#idp56093152">Packed YUV Image Formats</a></dt><dt>2.19. <a href="media.html#compressed-formats">Compressed Image Formats</a></dt><dt>2.20. <a href="media.html#reserved-formats">Reserved Image Formats</a></dt><dt>2.21. <a href="media.html#format-flags">Format Flags</a></dt><dt>3.1. <a href="media.html#v4l2-buffer">struct <span class="structname">v4l2_buffer</span></a></dt><dt>3.2. <a href="media.html#v4l2-plane">struct <span class="structname">v4l2_plane</span></a></dt><dt>3.3. <a href="media.html#v4l2-buf-type">enum v4l2_buf_type</a></dt><dt>3.4. <a href="media.html#buffer-flags">Buffer Flags</a></dt><dt>3.5. <a href="media.html#v4l2-memory">enum v4l2_memory</a></dt><dt>3.6. <a href="media.html#v4l2-timecode">struct <span class="structname">v4l2_timecode</span></a></dt><dt>3.7. <a href="media.html#timecode-type">Timecode Types</a></dt><dt>3.8. <a href="media.html#timecode-flags">Timecode Flags</a></dt><dt>3.9. <a href="media.html#v4l2-field">enum v4l2_field</a></dt><dt>4.1. <a href="media.html#v4l2-window">struct <span class="structname">v4l2_window</span></a></dt><dt>4.2. <a href="media.html#v4l2-clip">struct <span class="structname">v4l2_clip</span></a></dt><dt>4.3. <a href="media.html#v4l2-rect">struct <span class="structname">v4l2_rect</span></a></dt><dt>4.4. <a href="media.html#v4l2-vbi-format">struct <span class="structname">v4l2_vbi_format</span></a></dt><dt>4.5. <a href="media.html#vbifmt-flags">Raw VBI Format Flags</a></dt><dt>4.6. <a href="media.html#v4l2-sliced-vbi-format">struct
<span class="structname">v4l2_sliced_vbi_format</span></a></dt><dt>4.7. <a href="media.html#vbi-services2">Sliced VBI services</a></dt><dt>4.8. <a href="media.html#v4l2-sliced-vbi-data">struct
<span class="structname">v4l2_sliced_vbi_data</span></a></dt><dt>4.9. <a href="media.html#v4l2-mpeg-vbi-fmt-ivtv">struct <span class="structname">v4l2_mpeg_vbi_fmt_ivtv</span>
      </a></dt><dt>4.10. <a href="media.html#v4l2-mpeg-vbi-fmt-ivtv-magic">Magic Constants for struct v4l2_mpeg_vbi_fmt_ivtv
	<em class="structfield"><code>magic</code></em> field</a></dt><dt>4.11. <a href="media.html#v4l2-mpeg-vbi-itv0">struct <span class="structname">v4l2_mpeg_vbi_itv0</span>
      </a></dt><dt>4.12. <a href="media.html#v4l2-mpeg-vbi-itv0-1">struct <span class="structname">v4l2_mpeg_vbi_ITV0</span>
      </a></dt><dt>4.13. <a href="media.html#v4l2-mpeg-vbi-itv0-line">struct <span class="structname">v4l2_mpeg_vbi_itv0_line</span>
      </a></dt><dt>4.14. <a href="media.html#ITV0-Line-Identifier-Constants">Line Identifiers for struct <span class="structname">
v4l2_mpeg_vbi_itv0_line</span> <em class="structfield"><code>id
</code></em> field</a></dt><dt>4.15. <a href="media.html#v4l2-rds-data">struct
<span class="structname">v4l2_rds_data</span></a></dt><dt>4.16. <a href="media.html#v4l2-rds-block">Block description</a></dt><dt>4.17. <a href="media.html#v4l2-rds-block-codes">Block defines</a></dt><dt>4.18. <a href="media.html#v4l2-sdr-format">struct <span class="structname">v4l2_sdr_format</span></a></dt><dt>4.19. <a href="media.html#sample-pipeline-config">Sample Pipeline Configuration</a></dt><dt>4.20. <a href="media.html#v4l2-mbus-framefmt">struct <span class="structname">v4l2_mbus_framefmt</span></a></dt><dt>4.21. <a href="media.html#v4l2-mbus-pixelcode-rgb">RGB formats</a></dt><dt>4.22. <a href="media.html#v4l2-mbus-pixelcode-bayer">Bayer Formats</a></dt><dt>4.23. <a href="media.html#v4l2-mbus-pixelcode-yuv8">YUV Formats</a></dt><dt>4.24. <a href="media.html#v4l2-mbus-pixelcode-hsv">HSV/HSL formats</a></dt><dt>4.25. <a href="media.html#v4l2-mbus-pixelcode-jpeg">JPEG Formats</a></dt><dt>4.26. <a href="media.html#v4l2-mbus-pixelcode-vendor-specific">Vendor and device specific formats</a></dt><dt>7.1. <a href="media.html#v4l-dev">V4L Device Types, Names and Numbers</a></dt><dt>A.1. <a href="media.html#v4l2-create-buffers">struct <span class="structname">v4l2_create_buffers</span></a></dt><dt>A.2. <a href="media.html#v4l2-cropcap">struct <span class="structname">v4l2_cropcap</span></a></dt><dt>A.3. <a href="media.html#v4l2-rect-crop">struct <span class="structname">v4l2_rect</span></a></dt><dt>A.4. <a href="media.html#name-v4l2-dbg-match">struct <span class="structname">v4l2_dbg_match</span></a></dt><dt>A.5. <a href="media.html#v4l2-dbg-chip-info">struct <span class="structname">v4l2_dbg_chip_info</span></a></dt><dt>A.6. <a href="media.html#name-chip-match-types">Chip Match Types</a></dt><dt>A.7. <a href="media.html#v4l2-dbg-match">struct <span class="structname">v4l2_dbg_match</span></a></dt><dt>A.8. <a href="media.html#v4l2-dbg-register">struct <span class="structname">v4l2_dbg_register</span></a></dt><dt>A.9. <a href="media.html#chip-match-types">Chip Match Types</a></dt><dt>A.10. <a href="media.html#v4l2-decoder-cmd">struct <span class="structname">v4l2_decoder_cmd</span></a></dt><dt>A.11. <a href="media.html#decoder-cmds">Decoder Commands</a></dt><dt>A.12. <a href="media.html#v4l2-event">struct <span class="structname">v4l2_event</span></a></dt><dt>A.13. <a href="media.html#v4l2-event-vsync">struct <span class="structname">v4l2_event_vsync</span></a></dt><dt>A.14. <a href="media.html#v4l2-event-ctrl">struct <span class="structname">v4l2_event_ctrl</span></a></dt><dt>A.15. <a href="media.html#v4l2-event-frame-sync">struct <span class="structname">v4l2_event_frame_sync</span></a></dt><dt>A.16. <a href="media.html#v4l2-event-src-change">struct <span class="structname">v4l2_event_src_change</span></a></dt><dt>A.17. <a href="media.html#v4l2-event-motion-det">struct <span class="structname">v4l2_event_motion_det</span></a></dt><dt>A.18. <a href="media.html#changes-flags">Changes</a></dt><dt>A.19. <a href="media.html#src-changes-flags">Source Changes</a></dt><dt>A.20. <a href="media.html#v4l2-bt-timings-cap">struct <span class="structname">v4l2_bt_timings_cap</span></a></dt><dt>A.21. <a href="media.html#v4l2-dv-timings-cap">struct <span class="structname">v4l2_dv_timings_cap</span></a></dt><dt>A.22. <a href="media.html#dv-bt-cap-capabilities">DV BT Timing capabilities</a></dt><dt>A.23. <a href="media.html#v4l2-encoder-cmd">struct <span class="structname">v4l2_encoder_cmd</span></a></dt><dt>A.24. <a href="media.html#encoder-cmds">Encoder Commands</a></dt><dt>A.25. <a href="media.html#encoder-flags">Encoder Command Flags</a></dt><dt>A.26. <a href="media.html#v4l2-enum-dv-timings">struct <span class="structname">v4l2_enum_dv_timings</span></a></dt><dt>A.27. <a href="media.html#v4l2-fmtdesc">struct <span class="structname">v4l2_fmtdesc</span></a></dt><dt>A.28. <a href="media.html#fmtdesc-flags">Image Format Description Flags</a></dt><dt>A.29. <a href="media.html#v4l2-frmsize-discrete">struct <span class="structname">v4l2_frmsize_discrete</span></a></dt><dt>A.30. <a href="media.html#v4l2-frmsize-stepwise">struct <span class="structname">v4l2_frmsize_stepwise</span></a></dt><dt>A.31. <a href="media.html#v4l2-frmsizeenum">struct <span class="structname">v4l2_frmsizeenum</span></a></dt><dt>A.32. <a href="media.html#v4l2-frmsizetypes">enum <span class="structname">v4l2_frmsizetypes</span></a></dt><dt>A.33. <a href="media.html#v4l2-frmival-stepwise">struct <span class="structname">v4l2_frmival_stepwise</span></a></dt><dt>A.34. <a href="media.html#v4l2-frmivalenum">struct <span class="structname">v4l2_frmivalenum</span></a></dt><dt>A.35. <a href="media.html#v4l2-frmivaltypes">enum <span class="structname">v4l2_frmivaltypes</span></a></dt><dt>A.36. <a href="media.html#v4l2-frequency-band">struct <span class="structname">v4l2_frequency_band</span></a></dt><dt>A.37. <a href="media.html#band-modulation">Band Modulation Systems</a></dt><dt>A.38. <a href="media.html#v4l2-input">struct <span class="structname">v4l2_input</span></a></dt><dt>A.39. <a href="media.html#input-type">Input Types</a></dt><dt>A.40. <a href="media.html#input-status">Input Status Flags</a></dt><dt>A.41. <a href="media.html#input-capabilities">Input capabilities</a></dt><dt>A.42. <a href="media.html#v4l2-output">struct <span class="structname">v4l2_output</span></a></dt><dt>A.43. <a href="media.html#output-type">Output Type</a></dt><dt>A.44. <a href="media.html#output-capabilities">Output capabilities</a></dt><dt>A.45. <a href="media.html#v4l2-standard">struct <span class="structname">v4l2_standard</span></a></dt><dt>A.46. <a href="media.html#v4l2-fract">struct <span class="structname">v4l2_fract</span></a></dt><dt>A.47. <a href="media.html#v4l2-std-id">typedef <span class="structname">v4l2_std_id</span></a></dt><dt>A.48. <a href="media.html#video-standards">Video Standards (based on [[<abbr class="abbrev">ITU BT.470</abbr>]])</a></dt><dt>A.49. <a href="media.html#v4l2-exportbuffer">struct <span class="structname">v4l2_exportbuffer</span></a></dt><dt>A.50. <a href="media.html#v4l2-audio">struct <span class="structname">v4l2_audio</span></a></dt><dt>A.51. <a href="media.html#audio-capability">Audio Capability Flags</a></dt><dt>A.52. <a href="media.html#audio-mode">Audio Mode Flags</a></dt><dt>A.53. <a href="media.html#v4l2-audioout">struct <span class="structname">v4l2_audioout</span></a></dt><dt>A.54. <a href="media.html#v4l2-crop">struct <span class="structname">v4l2_crop</span></a></dt><dt>A.55. <a href="media.html#v4l2-control">struct <span class="structname">v4l2_control</span></a></dt><dt>A.56. <a href="media.html#v4l2-bt-timings">struct <span class="structname">v4l2_bt_timings</span></a></dt><dt>A.57. <a href="media.html#v4l2-dv-timings">struct <span class="structname">v4l2_dv_timings</span></a></dt><dt>A.58. <a href="media.html#dv-timing-types">DV Timing types</a></dt><dt>A.59. <a href="media.html#dv-bt-standards">DV BT Timing standards</a></dt><dt>A.60. <a href="media.html#dv-bt-flags">DV BT Timing flags</a></dt><dt>A.61. <a href="media.html#v4l2-edid">struct <span class="structname">v4l2_edid</span></a></dt><dt>A.62. <a href="media.html#v4l2-enc-idx">struct <span class="structname">v4l2_enc_idx</span></a></dt><dt>A.63. <a href="media.html#v4l2-enc-idx-entry">struct <span class="structname">v4l2_enc_idx_entry</span></a></dt><dt>A.64. <a href="media.html#enc-idx-flags">Index Entry Flags</a></dt><dt>A.65. <a href="media.html#v4l2-ext-control">struct <span class="structname">v4l2_ext_control</span></a></dt><dt>A.66. <a href="media.html#v4l2-ext-controls">struct <span class="structname">v4l2_ext_controls</span></a></dt><dt>A.67. <a href="media.html#ctrl-class">Control classes</a></dt><dt>A.68. <a href="media.html#v4l2-framebuffer">struct <span class="structname">v4l2_framebuffer</span></a></dt><dt>A.69. <a href="media.html#framebuffer-cap">Frame Buffer Capability Flags</a></dt><dt>A.70. <a href="media.html#framebuffer-flags">Frame Buffer Flags</a></dt><dt>A.71. <a href="media.html#v4l2-format">struct <span class="structname">v4l2_format</span></a></dt><dt>A.72. <a href="media.html#v4l2-frequency">struct <span class="structname">v4l2_frequency</span></a></dt><dt>A.73. <a href="media.html#v4l2-jpegcompression">struct <span class="structname">v4l2_jpegcompression</span></a></dt><dt>A.74. <a href="media.html#jpeg-markers">JPEG Markers Flags</a></dt><dt>A.75. <a href="media.html#v4l2-modulator">struct <span class="structname">v4l2_modulator</span></a></dt><dt>A.76. <a href="media.html#modulator-txsubchans">Modulator Audio Transmission Flags</a></dt><dt>A.77. <a href="media.html#v4l2-streamparm">struct <span class="structname">v4l2_streamparm</span></a></dt><dt>A.78. <a href="media.html#v4l2-captureparm">struct <span class="structname">v4l2_captureparm</span></a></dt><dt>A.79. <a href="media.html#v4l2-outputparm">struct <span class="structname">v4l2_outputparm</span></a></dt><dt>A.80. <a href="media.html#parm-caps">Streaming Parameters Capabilites</a></dt><dt>A.81. <a href="media.html#parm-flags">Capture Parameters Flags</a></dt><dt>A.82. <a href="media.html#v4l2-priority">enum v4l2_priority</a></dt><dt>A.83. <a href="media.html#v4l2-selection">struct <span class="structname">v4l2_selection</span></a></dt><dt>A.84. <a href="media.html#v4l2-sliced-vbi-cap">struct <span class="structname">v4l2_sliced_vbi_cap</span></a></dt><dt>A.85. <a href="media.html#vbi-services">Sliced VBI services</a></dt><dt>A.86. <a href="media.html#v4l2-tuner">struct <span class="structname">v4l2_tuner</span></a></dt><dt>A.87. <a href="media.html#v4l2-tuner-type">enum v4l2_tuner_type</a></dt><dt>A.88. <a href="media.html#tuner-capability">Tuner and Modulator Capability Flags</a></dt><dt>A.89. <a href="media.html#tuner-rxsubchans">Tuner Audio Reception Flags</a></dt><dt>A.90. <a href="media.html#tuner-audmode">Tuner Audio Modes</a></dt><dt>A.91. <a href="media.html#tuner-matrix">Tuner Audio Matrix</a></dt><dt>A.92. <a href="media.html#v4l2-capability">struct <span class="structname">v4l2_capability</span></a></dt><dt>A.93. <a href="media.html#device-capabilities">Device Capabilities Flags</a></dt><dt>A.94. <a href="media.html#v4l2-queryctrl">struct <span class="structname">v4l2_queryctrl</span></a></dt><dt>A.95. <a href="media.html#v4l2-query-ext-ctrl">struct <span class="structname">v4l2_query_ext_ctrl</span></a></dt><dt>A.96. <a href="media.html#v4l2-querymenu">struct <span class="structname">v4l2_querymenu</span></a></dt><dt>A.97. <a href="media.html#v4l2-ctrl-type">enum v4l2_ctrl_type</a></dt><dt>A.98. <a href="media.html#control-flags">Control Flags</a></dt><dt>A.99. <a href="media.html#v4l2-requestbuffers">struct <span class="structname">v4l2_requestbuffers</span></a></dt><dt>A.100. <a href="media.html#v4l2-hw-freq-seek">struct <span class="structname">v4l2_hw_freq_seek</span></a></dt><dt>A.101. <a href="media.html#v4l2-subdev-frame-interval-enum">struct <span class="structname">v4l2_subdev_frame_interval_enum</span></a></dt><dt>A.102. <a href="media.html#v4l2-subdev-frame-size-enum">struct <span class="structname">v4l2_subdev_frame_size_enum</span></a></dt><dt>A.103. <a href="media.html#v4l2-subdev-mbus-code-enum">struct <span class="structname">v4l2_subdev_mbus_code_enum</span></a></dt><dt>A.104. <a href="media.html#v4l2-subdev-crop">struct <span class="structname">v4l2_subdev_crop</span></a></dt><dt>A.105. <a href="media.html#v4l2-subdev-format">struct <span class="structname">v4l2_subdev_format</span></a></dt><dt>A.106. <a href="media.html#v4l2-subdev-format-whence">enum <span class="structname">v4l2_subdev_format_whence</span></a></dt><dt>A.107. <a href="media.html#v4l2-subdev-frame-interval">struct <span class="structname">v4l2_subdev_frame_interval</span></a></dt><dt>A.108. <a href="media.html#v4l2-subdev-selection">struct <span class="structname">v4l2_subdev_selection</span></a></dt><dt>A.109. <a href="media.html#v4l2-event-subscription">struct <span class="structname">v4l2_event_subscription</span></a></dt><dt>A.110. <a href="media.html#event-type">Event Types</a></dt><dt>A.111. <a href="media.html#event-flags">Event Flags</a></dt><dt>B.1. <a href="media.html#v4l2-selection-targets-table">Selection target definitions</a></dt><dt>B.2. <a href="media.html#v4l2-selection-flags-table">Selection flag definitions</a></dt><dt>9.1. <a href="media.html#fe-type">Frontend types</a></dt><dt>17.1. <a href="media.html#rc_standard_keymap">IR default keymapping</a></dt><dt>17.2. <a href="media.html#rc_keymap_notes">Notes</a></dt><dt>L.1. <a href="media.html#media-device-info">struct <span class="structname">media_device_info</span></a></dt><dt>L.2. <a href="media.html#media-entity-desc">struct <span class="structname">media_entity_desc</span></a></dt><dt>L.3. <a href="media.html#media-entity-type">Media entity types</a></dt><dt>L.4. <a href="media.html#media-entity-flag">Media entity flags</a></dt><dt>L.5. <a href="media.html#media-links-enum">struct <span class="structname">media_links_enum</span></a></dt><dt>L.6. <a href="media.html#media-pad-desc">struct <span class="structname">media_pad_desc</span></a></dt><dt>L.7. <a href="media.html#media-pad-flag">Media pad flags</a></dt><dt>L.8. <a href="media.html#media-link-desc">struct <span class="structname">media_link_desc</span></a></dt><dt>L.9. <a href="media.html#media-link-flag">Media link flags</a></dt><dt>19.1. <a href="media.html#gen-errors">Generic error codes</a></dt></dl></div><div class="list-of-examples"><p><b>List of Examples</b></p><dl><dt>1.1. <a href="media.html#idp47310976">Information about the current video input</a></dt><dt>1.2. <a href="media.html#idp47315664">Switching to the first video input</a></dt><dt>1.3. <a href="media.html#idp47350240">Information about the current audio input</a></dt><dt>1.4. <a href="media.html#idp47344848">Switching to the first audio input</a></dt><dt>1.5. <a href="media.html#idp47410656">Information about the current video standard</a></dt><dt>1.6. <a href="media.html#idp47416064">Listing the video standards supported by the current
input</a></dt><dt>1.7. <a href="media.html#idp47424224">Selecting a new video standard</a></dt><dt>1.8. <a href="media.html#enum_all_controls">Enumerating all user controls</a></dt><dt>1.9. <a href="media.html#idp47644784">Enumerating all user controls (alternative)</a></dt><dt>1.10. <a href="media.html#idp47648240">Changing controls</a></dt><dt>1.11. <a href="media.html#idp51418528">Resetting the cropping parameters</a></dt><dt>1.12. <a href="media.html#idp51425040">Simple downscaling</a></dt><dt>1.13. <a href="media.html#idp51430336">Selecting an output area</a></dt><dt>1.14. <a href="media.html#idp51434592">Current scaling factor and pixel aspect</a></dt><dt>1.15. <a href="media.html#idp51541328">Resetting the cropping parameters</a></dt><dt>1.16. <a href="media.html#idp51545504">Simple downscaling</a></dt><dt>1.17. <a href="media.html#idp51554544">Querying for scaling factors</a></dt><dt>2.1. <a href="media.html#idp54894256"><code class="constant">V4L2_PIX_FMT_BGR24</code> 4 × 4 pixel
image</a></dt><dt>2.2. <a href="media.html#idp55656960"><code class="constant">V4L2_PIX_FMT_SBGGR8</code> 4 × 4
pixel image</a></dt><dt>2.3. <a href="media.html#idp55643376"><code class="constant">V4L2_PIX_FMT_SGBRG8</code> 4 × 4
pixel image</a></dt><dt>2.4. <a href="media.html#idp55696672"><code class="constant">V4L2_PIX_FMT_SGRBG8</code> 4 ×
4 pixel image</a></dt><dt>2.5. <a href="media.html#idp55747168"><code class="constant">V4L2_PIX_FMT_SRGGB8</code> 4 × 4
pixel image</a></dt><dt>2.6. <a href="media.html#idp55860000"><code class="constant">V4L2_PIX_FMT_SBGGR16</code> 4 × 4
pixel image</a></dt><dt>2.7. <a href="media.html#idp55937488"><code class="constant">V4L2_PIX_FMT_SBGGR10</code> 4 × 4
pixel image</a></dt><dt>2.8. <a href="media.html#idp56056192"><code class="constant">V4L2_PIX_FMT_SBGGR12</code> 4 × 4
pixel image</a></dt><dt>2.9. <a href="media.html#idp56363696"><code class="constant">V4L2_PIX_FMT_GREY</code> 4 × 4
pixel image</a></dt><dt>2.10. <a href="media.html#idp56392576"><code class="constant">V4L2_PIX_FMT_Y10</code> 4 × 4
pixel image</a></dt><dt>2.11. <a href="media.html#idp56489424"><code class="constant">V4L2_PIX_FMT_Y12</code> 4 × 4
pixel image</a></dt><dt>2.12. <a href="media.html#idp56562464"><code class="constant">V4L2_PIX_FMT_Y10BPACK</code> 4 pixel data stream taking 5 bytes</a></dt><dt>2.13. <a href="media.html#idp56580592"><code class="constant">V4L2_PIX_FMT_Y16</code> 4 × 4
pixel image</a></dt><dt>2.14. <a href="media.html#idp56667440">
	      <code class="constant">V4L2_PIX_FMT_UV8</code>
	       pixel image
	    </a></dt><dt>2.15. <a href="media.html#idp56758864"><code class="constant">V4L2_PIX_FMT_YUYV</code> 4 × 4
pixel image</a></dt><dt>2.16. <a href="media.html#idp56866672"><code class="constant">V4L2_PIX_FMT_UYVY</code> 4 × 4
pixel image</a></dt><dt>2.17. <a href="media.html#idp56974880"><code class="constant">V4L2_PIX_FMT_YVYU</code> 4 × 4
pixel image</a></dt><dt>2.18. <a href="media.html#idp57082992"><code class="constant">V4L2_PIX_FMT_VYUY</code> 4 × 4
pixel image</a></dt><dt>2.19. <a href="media.html#idp57193696"><code class="constant">V4L2_PIX_FMT_Y41P</code> 8 × 4
pixel image</a></dt><dt>2.20. <a href="media.html#idp57348752"><code class="constant">V4L2_PIX_FMT_YVU420</code> 4 × 4
pixel image</a></dt><dt>2.21. <a href="media.html#idp57469536"><code class="constant">V4L2_PIX_FMT_YVU420M</code> 4 × 4
pixel image</a></dt><dt>2.22. <a href="media.html#idp57591952"><code class="constant">V4L2_PIX_FMT_YVU420M</code> 4 × 4
pixel image</a></dt><dt>2.23. <a href="media.html#idp57712480"><code class="constant">V4L2_PIX_FMT_YVU410</code> 4 × 4
pixel image</a></dt><dt>2.24. <a href="media.html#idp57813248"><code class="constant">V4L2_PIX_FMT_YUV422P</code> 4 × 4
pixel image</a></dt><dt>2.25. <a href="media.html#idp57939968"><code class="constant">V4L2_PIX_FMT_YUV411P</code> 4 × 4
pixel image</a></dt><dt>2.26. <a href="media.html#idp58057584"><code class="constant">V4L2_PIX_FMT_NV12</code> 4 × 4
pixel image</a></dt><dt>2.27. <a href="media.html#idp58181232"><code class="constant">V4L2_PIX_FMT_NV12M</code> 4 × 4 pixel image</a></dt><dt>2.28. <a href="media.html#idp58306656">Memory layout of macroblocks in <code class="constant">V4L2_PIX_FMT_NV12
</code> format pixel image - extreme case</a></dt><dt>2.29. <a href="media.html#idp58339824"><code class="constant">V4L2_PIX_FMT_NV16</code> 4 × 4
pixel image</a></dt><dt>2.30. <a href="media.html#idp58482496"><code class="constant">V4L2_PIX_FMT_NV16M</code> 4 × 4 pixel image</a></dt><dt>2.31. <a href="media.html#idp58624944"><code class="constant">V4L2_PIX_FMT_NV24</code> 4 × 4
pixel image</a></dt><dt>2.32. <a href="media.html#idp58732576"><code class="constant">V4L2_PIX_FMT_M420</code> 4 × 4
pixel image</a></dt><dt>2.33. <a href="media.html#idp58889216"><code class="constant">V4L2_SDR_FMT_CU8</code> 1 sample</a></dt><dt>2.34. <a href="media.html#idp58883200"><code class="constant">V4L2_SDR_FMT_CU16LE</code> 1 sample</a></dt><dt>2.35. <a href="media.html#idp58899632"><code class="constant">V4L2_SDR_FMT_CS8</code> 1 sample</a></dt><dt>2.36. <a href="media.html#idp58950928"><code class="constant">V4L2_SDR_FMT_CS14LE</code> 1 sample</a></dt><dt>2.37. <a href="media.html#idp58958560"><code class="constant">V4L2_SDR_FMT_RU12LE</code> 1 sample</a></dt><dt>3.1. <a href="media.html#idp62120640">Mapping buffers in the single-planar API</a></dt><dt>3.2. <a href="media.html#idp62130352">Mapping buffers in the multi-planar API</a></dt><dt>3.3. <a href="media.html#idp62177472">Initiating streaming I/O with user pointers</a></dt><dt>3.4. <a href="media.html#idp62218576">Initiating streaming I/O with DMABUF file descriptors</a></dt><dt>3.5. <a href="media.html#idp62224288">Queueing DMABUF using single plane API</a></dt><dt>3.6. <a href="media.html#idp62227968">Queueing DMABUF using multi plane API</a></dt><dt>4.1. <a href="media.html#idp63601616">Finding a framebuffer device for OSD</a></dt><dt>A.1. <a href="media.html#idp78500416">Exporting a buffer.</a></dt><dt>A.2. <a href="media.html#idp78504848">Exporting a buffer using the multi-planar API.</a></dt></dl></div><div class="preface"><div class="titlepage"><div><div><h1 class="title"><a name="idp45908784"></a>Introduction</h1></div></div></div><p>This document covers the Linux Kernel to Userspace API's used by
		video and radio streaming devices, including video cameras,
		analog and digital TV receiver cards, AM/FM receiver cards,
		streaming capture and output devices, codec devices and remote
		controllers.</p><p>It is divided into four parts.</p><p>The first part covers radio, video capture and output,
		cameras, analog TV devices and codecs.</p><p>The second part covers the
		API used for digital TV and Internet reception via one of the
		several digital tv standards. While it is called as DVB API,
		in fact it covers several different video standards including
		DVB-T, DVB-S, DVB-C and ATSC. The API is currently being updated
		to document support also for DVB-S2, ISDB-T and ISDB-S.</p><p>The third part covers the Remote Controller API.</p><p>The fourth part covers the Media Controller API.</p><p>For additional information and for the latest development code,
		see: <a class="ulink" href="http://linuxtv.org" target="_top">http://linuxtv.org</a>.</p><p>For discussing improvements, reporting troubles, sending new drivers, etc, please mail to: <a class="ulink" href="http://vger.kernel.org/vger-lists.html#linux-media" target="_top">Linux Media Mailing List (LMML).</a>.</p></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="v4l2spec"></a>Part I. Video for Linux Two API Specification</h1></div><div><h2 class="subtitle">Revision 3.19</h2></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Michael</span> <span class="othername">H</span> <span class="surname">Schimek</span></h3><div class="affiliation"><div class="address"><p><br>
	    <code class="email">&lt;<a class="email" href="mailto:mschimek@gmx.at">mschimek@gmx.at</a>&gt;</code><br>
	  </p></div></div></div><div class="author"><h3 class="author"><span class="firstname">Bill</span> <span class="surname">Dirks</span></h3><span class="contrib">Original author of the V4L2 API and
documentation.</span> </div><div class="author"><h3 class="author"><span class="firstname">Hans</span> <span class="surname">Verkuil</span></h3><span class="contrib">Designed and documented the VIDIOC_LOG_STATUS ioctl,
the extended control ioctls, major parts of the sliced VBI API, the
MPEG encoder and decoder APIs and the DV Timings API.</span> <div class="affiliation"><div class="address"><p><br>
	    <code class="email">&lt;<a class="email" href="mailto:hverkuil@xs4all.nl">hverkuil@xs4all.nl</a>&gt;</code><br>
	  </p></div></div></div><div class="author"><h3 class="author"><span class="firstname">Martin</span> <span class="surname">Rubli</span></h3><span class="contrib">Designed and documented the VIDIOC_ENUM_FRAMESIZES
and VIDIOC_ENUM_FRAMEINTERVALS ioctls.</span> </div><div class="author"><h3 class="author"><span class="firstname">Andy</span> <span class="surname">Walls</span></h3><span class="contrib">Documented the fielded V4L2_MPEG_STREAM_VBI_FMT_IVTV
MPEG stream embedded, sliced VBI data format in this specification.
</span> <div class="affiliation"><div class="address"><p><br>
	    <code class="email">&lt;<a class="email" href="mailto:awalls@md.metrocast.net">awalls@md.metrocast.net</a>&gt;</code><br>
	  </p></div></div></div><div class="author"><h3 class="author"><span class="firstname">Mauro</span> <span class="surname">Carvalho Chehab</span></h3><span class="contrib">Documented libv4l, designed and added v4l2grab example,
Remote Controller chapter.</span> <div class="affiliation"><div class="address"><p><br>
	    <code class="email">&lt;<a class="email" href="mailto:m.chehab@samsung.com">m.chehab@samsung.com</a>&gt;</code><br>
	  </p></div></div></div><div class="author"><h3 class="author"><span class="firstname">Muralidharan</span> <span class="surname">Karicheri</span></h3><span class="contrib">Documented the Digital Video timings API.</span> <div class="affiliation"><div class="address"><p><br>
	    <code class="email">&lt;<a class="email" href="mailto:m-karicheri2@ti.com">m-karicheri2@ti.com</a>&gt;</code><br>
	  </p></div></div></div><div class="author"><h3 class="author"><span class="firstname">Pawel</span> <span class="surname">Osciak</span></h3><span class="contrib">Designed and documented the multi-planar API.</span> <div class="affiliation"><div class="address"><p><br>
	    <code class="email">&lt;<a class="email" href="mailto:pawel%20AT%20osciak.com">pawel AT osciak.com</a>&gt;</code><br>
	  </p></div></div></div><div class="author"><h3 class="author"><span class="firstname">Sakari</span> <span class="surname">Ailus</span></h3><span class="contrib">Subdev selections API.</span> <div class="affiliation"><div class="address"><p><br>
	    <code class="email">&lt;<a class="email" href="mailto:sakari.ailus@iki.fi">sakari.ailus@iki.fi</a>&gt;</code><br>
	  </p></div></div></div><div class="author"><h3 class="author"><span class="firstname">Antti</span> <span class="surname">Palosaari</span></h3><span class="contrib">SDR API.</span> <div class="affiliation"><div class="address"><p><br>
	    <code class="email">&lt;<a class="email" href="mailto:crope@iki.fi">crope@iki.fi</a>&gt;</code><br>
	  </p></div></div></div></div></div><div><p class="copyright">Copyright © 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014 Bill Dirks, Michael H. Schimek, Hans Verkuil, Martin
Rubli, Andy Walls, Muralidharan Karicheri, Mauro Carvalho Chehab,
	Pawel Osciak</p></div><div><div class="legalnotice"><a name="idp47064832"></a><p>Except when explicitly stated as GPL, programming examples within
	    this part can be used and distributed without restrictions.</p></div></div><div><div class="revhistory"><table style="border-style:solid; width:100%;" summary="Revision History"><tr><th align="left" valign="top" colspan="3"><b>Revision History</b></th></tr><tr><td align="left">Revision 3.19</td><td align="left">2014-12-05</td><td align="left">hv</td></tr><tr><td align="left" colspan="3">Rewrote Colorspace chapter, added new enum <a class="link" href="media.html#v4l2-ycbcr-encoding" title="Table 2.5. V4L2 Y'CbCr Encodings">v4l2_ycbcr_encoding</a> and enum <a class="link" href="media.html#v4l2-quantization" title="Table 2.6. V4L2 Quantization Methods">v4l2_quantization</a> fields
to struct <a class="link" href="media.html#v4l2-pix-format" title="Table 2.1. struct v4l2_pix_format">v4l2_pix_format</a>, struct <a class="link" href="media.html#v4l2-pix-format-mplane" title="Table 2.3. struct v4l2_pix_format_mplane">v4l2_pix_format_mplane</a> and struct <a class="link" href="media.html#v4l2-mbus-framefmt" title="Table 4.20. struct v4l2_mbus_framefmt">v4l2_mbus_framefmt</a>.
	</td></tr><tr><td align="left">Revision 3.17</td><td align="left">2014-08-04</td><td align="left">lp, hv</td></tr><tr><td align="left" colspan="3">Extended struct <a class="link" href="media.html#v4l2-pix-format" title="Table 2.1. struct v4l2_pix_format">v4l2_pix_format</a>. Added format flags. Added compound control types
and VIDIOC_QUERY_EXT_CTRL.
	</td></tr><tr><td align="left">Revision 3.15</td><td align="left">2014-02-03</td><td align="left">hv, ap</td></tr><tr><td align="left" colspan="3">Update several sections of "Common API Elements": "Opening and Closing Devices"
"Querying Capabilities", "Application Priority", "Video Inputs and Outputs", "Audio Inputs and Outputs"
"Tuners and Modulators", "Video Standards" and "Digital Video (DV) Timings". Added SDR API.
	</td></tr><tr><td align="left">Revision 3.14</td><td align="left">2013-11-25</td><td align="left">rr</td></tr><tr><td align="left" colspan="3">Set width and height as unsigned on v4l2_rect.
	</td></tr><tr><td align="left">Revision 3.11</td><td align="left">2013-05-26</td><td align="left">hv</td></tr><tr><td align="left" colspan="3">Remove obsolete VIDIOC_DBG_G_CHIP_IDENT ioctl.
	</td></tr><tr><td align="left">Revision 3.10</td><td align="left">2013-03-25</td><td align="left">hv</td></tr><tr><td align="left" colspan="3">Remove obsolete and unused DV_PRESET ioctls:
	VIDIOC_G_DV_PRESET, VIDIOC_S_DV_PRESET, VIDIOC_QUERY_DV_PRESET and
	VIDIOC_ENUM_DV_PRESET. Remove the related v4l2_input/output capability
	flags V4L2_IN_CAP_PRESETS and V4L2_OUT_CAP_PRESETS. Added VIDIOC_DBG_G_CHIP_INFO.
	</td></tr><tr><td align="left">Revision 3.9</td><td align="left">2012-12-03</td><td align="left">sa, sn</td></tr><tr><td align="left" colspan="3">Added timestamp types to v4l2_buffer.
	Added V4L2_EVENT_CTRL_CH_RANGE control event changes flag.
	</td></tr><tr><td align="left">Revision 3.6</td><td align="left">2012-07-02</td><td align="left">hv</td></tr><tr><td align="left" colspan="3">Added VIDIOC_ENUM_FREQ_BANDS.
	</td></tr><tr><td align="left">Revision 3.5</td><td align="left">2012-05-07</td><td align="left">sa, sn, hv</td></tr><tr><td align="left" colspan="3">Added V4L2_CTRL_TYPE_INTEGER_MENU and V4L2 subdev
	    selections API. Improved the description of V4L2_CID_COLORFX
	    control, added V4L2_CID_COLORFX_CBCR control.
	    Added camera controls V4L2_CID_AUTO_EXPOSURE_BIAS,
	    V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE, V4L2_CID_IMAGE_STABILIZATION,
	    V4L2_CID_ISO_SENSITIVITY, V4L2_CID_ISO_SENSITIVITY_AUTO,
	    V4L2_CID_EXPOSURE_METERING, V4L2_CID_SCENE_MODE,
	    V4L2_CID_3A_LOCK, V4L2_CID_AUTO_FOCUS_START,
	    V4L2_CID_AUTO_FOCUS_STOP, V4L2_CID_AUTO_FOCUS_STATUS
	    and V4L2_CID_AUTO_FOCUS_RANGE.
	    Added VIDIOC_ENUM_DV_TIMINGS, VIDIOC_QUERY_DV_TIMINGS and
	    VIDIOC_DV_TIMINGS_CAP.
	</td></tr><tr><td align="left">Revision 3.4</td><td align="left">2012-01-25</td><td align="left">sn</td></tr><tr><td align="left" colspan="3">Added <a class="link" href="media.html#jpeg-controls" title="JPEG Control Reference">JPEG compression
	    control class.</a>
	</td></tr><tr><td align="left">Revision 3.3</td><td align="left">2012-01-11</td><td align="left">hv</td></tr><tr><td align="left" colspan="3">Added device_caps field to struct v4l2_capabilities.</td></tr><tr><td align="left">Revision 3.2</td><td align="left">2011-08-26</td><td align="left">hv</td></tr><tr><td align="left" colspan="3">Added V4L2_CTRL_FLAG_VOLATILE.</td></tr><tr><td align="left">Revision 3.1</td><td align="left">2011-06-27</td><td align="left">mcc, po, hv</td></tr><tr><td align="left" colspan="3">Documented that VIDIOC_QUERYCAP now returns a per-subsystem version instead of a per-driver one.
		   Standardize an error code for invalid ioctl.
		   Added V4L2_CTRL_TYPE_BITMASK.</td></tr><tr><td align="left">Revision 2.6.39</td><td align="left">2011-03-01</td><td align="left">mcc, po</td></tr><tr><td align="left" colspan="3">Removed VIDIOC_*_OLD from videodev2.h header and update it to reflect latest changes. Added the <a class="link" href="media.html#planar-apis" title="Single- and multi-planar APIs">multi-planar API</a>.</td></tr><tr><td align="left">Revision 2.6.37</td><td align="left">2010-08-06</td><td align="left">hv</td></tr><tr><td align="left" colspan="3">Removed obsolete vtx (videotext) API.</td></tr><tr><td align="left">Revision 2.6.33</td><td align="left">2009-12-03</td><td align="left">mk</td></tr><tr><td align="left" colspan="3">Added documentation for the Digital Video timings API.</td></tr><tr><td align="left">Revision 2.6.32</td><td align="left">2009-08-31</td><td align="left">mcc</td></tr><tr><td align="left" colspan="3">Now, revisions will match the kernel version where
the V4L2 API changes will be used by the Linux Kernel.
Also added Remote Controller chapter.</td></tr><tr><td align="left">Revision 0.29</td><td align="left">2009-08-26</td><td align="left">ev</td></tr><tr><td align="left" colspan="3">Added documentation for string controls and for FM Transmitter controls.</td></tr><tr><td align="left">Revision 0.28</td><td align="left">2009-08-26</td><td align="left">gl</td></tr><tr><td align="left" colspan="3">Added V4L2_CID_BAND_STOP_FILTER documentation.</td></tr><tr><td align="left">Revision 0.27</td><td align="left">2009-08-15</td><td align="left">mcc</td></tr><tr><td align="left" colspan="3">Added libv4l and Remote Controller documentation;
added v4l2grab and keytable application examples.</td></tr><tr><td align="left">Revision 0.26</td><td align="left">2009-07-23</td><td align="left">hv</td></tr><tr><td align="left" colspan="3">Finalized the RDS capture API. Added modulator and RDS encoder
capabilities. Added support for string controls.</td></tr><tr><td align="left">Revision 0.25</td><td align="left">2009-01-18</td><td align="left">hv</td></tr><tr><td align="left" colspan="3">Added pixel formats VYUY, NV16 and NV61, and changed
the debug ioctls VIDIOC_DBG_G/S_REGISTER and VIDIOC_DBG_G_CHIP_IDENT.
Added camera controls V4L2_CID_ZOOM_ABSOLUTE, V4L2_CID_ZOOM_RELATIVE,
V4L2_CID_ZOOM_CONTINUOUS and V4L2_CID_PRIVACY.</td></tr><tr><td align="left">Revision 0.24</td><td align="left">2008-03-04</td><td align="left">mhs</td></tr><tr><td align="left" colspan="3">Added pixel formats Y16 and SBGGR16, new controls
and a camera controls class. Removed VIDIOC_G/S_MPEGCOMP.</td></tr><tr><td align="left">Revision 0.23</td><td align="left">2007-08-30</td><td align="left">mhs</td></tr><tr><td align="left" colspan="3">Fixed a typo in VIDIOC_DBG_G/S_REGISTER.
Clarified the byte order of packed pixel formats.</td></tr><tr><td align="left">Revision 0.22</td><td align="left">2007-08-29</td><td align="left">mhs</td></tr><tr><td align="left" colspan="3">Added the Video Output Overlay interface, new MPEG
controls, V4L2_FIELD_INTERLACED_TB and V4L2_FIELD_INTERLACED_BT,
VIDIOC_DBG_G/S_REGISTER, VIDIOC_(TRY_)ENCODER_CMD,
VIDIOC_G_CHIP_IDENT, VIDIOC_G_ENC_INDEX, new pixel formats.
Clarifications in the cropping chapter, about RGB pixel formats, the
mmap(), poll(), select(), read() and write() functions. Typographical
fixes.</td></tr><tr><td align="left">Revision 0.21</td><td align="left">2006-12-19</td><td align="left">mhs</td></tr><tr><td align="left" colspan="3">Fixed a link in the VIDIOC_G_EXT_CTRLS section.</td></tr><tr><td align="left">Revision 0.20</td><td align="left">2006-11-24</td><td align="left">mhs</td></tr><tr><td align="left" colspan="3">Clarified the purpose of the audioset field in
struct v4l2_input and v4l2_output.</td></tr><tr><td align="left">Revision 0.19</td><td align="left">2006-10-19</td><td align="left">mhs</td></tr><tr><td align="left" colspan="3">Documented V4L2_PIX_FMT_RGB444.</td></tr><tr><td align="left">Revision 0.18</td><td align="left">2006-10-18</td><td align="left">mhs</td></tr><tr><td align="left" colspan="3">Added the description of extended controls by Hans
Verkuil. Linked V4L2_PIX_FMT_MPEG to V4L2_CID_MPEG_STREAM_TYPE.</td></tr><tr><td align="left">Revision 0.17</td><td align="left">2006-10-12</td><td align="left">mhs</td></tr><tr><td align="left" colspan="3">Corrected V4L2_PIX_FMT_HM12 description.</td></tr><tr><td align="left">Revision 0.16</td><td align="left">2006-10-08</td><td align="left">mhs</td></tr><tr><td align="left" colspan="3">VIDIOC_ENUM_FRAMESIZES and
VIDIOC_ENUM_FRAMEINTERVALS are now part of the API.</td></tr><tr><td align="left">Revision 0.15</td><td align="left">2006-09-23</td><td align="left">mhs</td></tr><tr><td align="left" colspan="3">Cleaned up the bibliography, added BT.653 and
BT.1119. capture.c/start_capturing() for user pointer I/O did not
initialize the buffer index. Documented the V4L MPEG and MJPEG
VID_TYPEs and V4L2_PIX_FMT_SBGGR8. Updated the list of reserved pixel
formats. See the history chapter for API changes.</td></tr><tr><td align="left">Revision 0.14</td><td align="left">2006-09-14</td><td align="left">mr</td></tr><tr><td align="left" colspan="3">Added VIDIOC_ENUM_FRAMESIZES and
VIDIOC_ENUM_FRAMEINTERVALS proposal for frame format enumeration of
digital devices.</td></tr><tr><td align="left">Revision 0.13</td><td align="left">2006-04-07</td><td align="left">mhs</td></tr><tr><td align="left" colspan="3">Corrected the description of struct v4l2_window
clips. New V4L2_STD_ and V4L2_TUNER_MODE_LANG1_LANG2
defines.</td></tr><tr><td align="left">Revision 0.12</td><td align="left">2006-02-03</td><td align="left">mhs</td></tr><tr><td align="left" colspan="3">Corrected the description of struct
v4l2_captureparm and v4l2_outputparm.</td></tr><tr><td align="left">Revision 0.11</td><td align="left">2006-01-27</td><td align="left">mhs</td></tr><tr><td align="left" colspan="3">Improved the description of struct
v4l2_tuner.</td></tr><tr><td align="left">Revision 0.10</td><td align="left">2006-01-10</td><td align="left">mhs</td></tr><tr><td align="left" colspan="3">VIDIOC_G_INPUT and VIDIOC_S_PARM
clarifications.</td></tr><tr><td align="left">Revision 0.9</td><td align="left">2005-11-27</td><td align="left">mhs</td></tr><tr><td align="left" colspan="3">Improved the 525 line numbering diagram. Hans
Verkuil and I rewrote the sliced VBI section. He also contributed a
VIDIOC_LOG_STATUS page. Fixed VIDIOC_S_STD call in the video standard
selection example. Various updates.</td></tr><tr><td align="left">Revision 0.8</td><td align="left">2004-10-04</td><td align="left">mhs</td></tr><tr><td align="left" colspan="3">Somehow a piece of junk slipped into the capture
example, removed.</td></tr><tr><td align="left">Revision 0.7</td><td align="left">2004-09-19</td><td align="left">mhs</td></tr><tr><td align="left" colspan="3">Fixed video standard selection, control
enumeration, downscaling and aspect example. Added read and user
pointer i/o to video capture example.</td></tr><tr><td align="left">Revision 0.6</td><td align="left">2004-08-01</td><td align="left">mhs</td></tr><tr><td align="left" colspan="3">v4l2_buffer changes, added video capture example,
various corrections.</td></tr><tr><td align="left">Revision 0.5</td><td align="left">2003-11-05</td><td align="left">mhs</td></tr><tr><td align="left" colspan="3">Pixel format erratum.</td></tr><tr><td align="left">Revision 0.4</td><td align="left">2003-09-17</td><td align="left">mhs</td></tr><tr><td align="left" colspan="3">Corrected source and Makefile to generate a PDF.
SGML fixes. Added latest API changes. Closed gaps in the history
chapter.</td></tr><tr><td align="left">Revision 0.3</td><td align="left">2003-02-05</td><td align="left">mhs</td></tr><tr><td align="left" colspan="3">Another draft, more corrections.</td></tr><tr><td align="left">Revision 0.2</td><td align="left">2003-01-15</td><td align="left">mhs</td></tr><tr><td align="left" colspan="3">Second draft, with corrections pointed out by Gerd
Knorr.</td></tr><tr><td align="left">Revision 0.1</td><td align="left">2002-12-01</td><td align="left">mhs</td></tr><tr><td align="left" colspan="3">First draft, based on documentation by Bill Dirks
and discussions on the V4L mailing list.</td></tr></table></div></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="chapter"><a href="media.html#common">1. Common API Elements</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#open">Opening and Closing Devices</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp47233696">Device Naming</a></span></dt><dt><span class="section"><a href="media.html#related">Related Devices</a></span></dt><dt><span class="section"><a href="media.html#idp47249088">Multiple Opens</a></span></dt><dt><span class="section"><a href="media.html#idp47270192">Shared Data Streams</a></span></dt><dt><span class="section"><a href="media.html#idp47271584">Functions</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#querycap">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#app-pri">Application Priority</a></span></dt><dt><span class="section"><a href="media.html#video">Video Inputs and Outputs</a></span></dt><dt><span class="section"><a href="media.html#audio">Audio Inputs and Outputs</a></span></dt><dt><span class="section"><a href="media.html#tuner">Tuners and Modulators</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp47353184">Tuners</a></span></dt><dt><span class="section"><a href="media.html#idp47365392">Modulators</a></span></dt><dt><span class="section"><a href="media.html#idp47378112">Radio Frequency</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#standard">Video Standards</a></span></dt><dt><span class="section"><a href="media.html#dv-timings">Digital Video (DV) Timings</a></span></dt><dt><span class="section"><a href="media.html#control">User Controls</a></span></dt><dt><span class="section"><a href="media.html#extended-controls">Extended Controls</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp47658496">Introduction</a></span></dt><dt><span class="section"><a href="media.html#idp47662144">The Extended Control API</a></span></dt><dt><span class="section"><a href="media.html#idp47686784">Enumerating Extended Controls</a></span></dt><dt><span class="section"><a href="media.html#idp47456288">Creating Control Panels</a></span></dt><dt><span class="section"><a href="media.html#mpeg-controls">Codec Control Reference</a></span></dt><dt><span class="section"><a href="media.html#camera-controls">Camera Control Reference</a></span></dt><dt><span class="section"><a href="media.html#fm-tx-controls">FM Transmitter Control Reference</a></span></dt><dt><span class="section"><a href="media.html#flash-controls">Flash Control Reference</a></span></dt><dt><span class="section"><a href="media.html#jpeg-controls">JPEG Control Reference</a></span></dt><dt><span class="section"><a href="media.html#image-source-controls">Image Source Control Reference</a></span></dt><dt><span class="section"><a href="media.html#image-process-controls">Image Process Control Reference</a></span></dt><dt><span class="section"><a href="media.html#dv-controls">Digital Video Control Reference</a></span></dt><dt><span class="section"><a href="media.html#fm-rx-controls">FM Receiver Control Reference</a></span></dt><dt><span class="section"><a href="media.html#detect-controls">Detect Control Reference</a></span></dt><dt><span class="section"><a href="media.html#rf-tuner-controls">RF Tuner Control Reference</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#format">Data Formats</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp51292128">Data Format Negotiation</a></span></dt><dt><span class="section"><a href="media.html#idp51320592">Image Format Enumeration</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#planar-apis">Single- and multi-planar APIs</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp51329792">Multi-planar formats</a></span></dt><dt><span class="section"><a href="media.html#idp51333216">Calls that distinguish between single and multi-planar APIs</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#crop">Image Cropping, Insertion and Scaling</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp51365280">Cropping Structures</a></span></dt><dt><span class="section"><a href="media.html#idp51407488">Scaling Adjustments</a></span></dt><dt><span class="section"><a href="media.html#idp51416672">Examples</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#selection-api">Experimental API for cropping, composing and scaling</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp51447328">Introduction</a></span></dt><dt><span class="section"><a href="media.html#idp51494464">Selection targets</a></span></dt><dt><span class="section"><a href="media.html#idp51500704">Configuration</a></span></dt><dt><span class="section"><a href="media.html#idp51531648">Comparison with old cropping API</a></span></dt><dt><span class="section"><a href="media.html#idp51539232">Examples</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#streaming-par">Streaming Parameters</a></span></dt></dl></dd><dt><span class="chapter"><a href="media.html#pixfmt">2. Image Formats</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp53973040">Single-planar format structure</a></span></dt><dt><span class="section"><a href="media.html#idp54078128">Multi-planar format structures</a></span></dt><dt><span class="section"><a href="media.html#idp54128880">Standard Image Formats</a></span></dt><dt><span class="section"><a href="media.html#colorspaces">Colorspaces</a></span></dt><dt><span class="section"><a href="media.html#idp54168592">Defining Colorspaces in V4L2</a></span></dt><dt><span class="section"><a href="media.html#idp54232336">Detailed Colorspace Descriptions</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp54233024">Colorspace SMPTE 170M (<code class="constant">V4L2_COLORSPACE_SMPTE170M</code>)</a></span></dt><dt><span class="section"><a href="media.html#idp54271504">Colorspace Rec. 709 (<code class="constant">V4L2_COLORSPACE_REC709</code>)</a></span></dt><dt><span class="section"><a href="media.html#idp54308064">Colorspace sRGB (<code class="constant">V4L2_COLORSPACE_SRGB</code>)</a></span></dt><dt><span class="section"><a href="media.html#idp54339536">Colorspace Adobe RGB (<code class="constant">V4L2_COLORSPACE_ADOBERGB</code>)</a></span></dt><dt><span class="section"><a href="media.html#idp54366256">Colorspace BT.2020 (<code class="constant">V4L2_COLORSPACE_BT2020</code>)</a></span></dt><dt><span class="section"><a href="media.html#idp54404656">Colorspace SMPTE 240M (<code class="constant">V4L2_COLORSPACE_SMPTE240M</code>)</a></span></dt><dt><span class="section"><a href="media.html#idp54432112">Colorspace NTSC 1953 (<code class="constant">V4L2_COLORSPACE_470_SYSTEM_M</code>)</a></span></dt><dt><span class="section"><a href="media.html#idp54459200">Colorspace EBU Tech. 3213 (<code class="constant">V4L2_COLORSPACE_470_SYSTEM_BG</code>)</a></span></dt><dt><span class="section"><a href="media.html#idp54486512">Colorspace JPEG (<code class="constant">V4L2_COLORSPACE_JPEG</code>)</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#pixfmt-indexed">Indexed Format</a></span></dt><dt><span class="section"><a href="media.html#pixfmt-rgb">RGB Formats</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="media.html#packed-rgb">Packed RGB formats</a></span><span class="refpurpose"> &#8212; Packed RGB formats</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-SBGGR8">V4L2_PIX_FMT_SBGGR8 ('BA81')</a></span><span class="refpurpose"> &#8212; Bayer RGB format</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-SGBRG8">V4L2_PIX_FMT_SGBRG8 ('GBRG')</a></span><span class="refpurpose"> &#8212; Bayer RGB format</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-SGRBG8">V4L2_PIX_FMT_SGRBG8 ('GRBG')</a></span><span class="refpurpose"> &#8212; Bayer RGB format</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-SRGGB8">V4L2_PIX_FMT_SRGGB8 ('RGGB')</a></span><span class="refpurpose"> &#8212; Bayer RGB format</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-SBGGR16">V4L2_PIX_FMT_SBGGR16 ('BYR2')</a></span><span class="refpurpose"> &#8212; Bayer RGB format</span></dt><dt><span class="refentrytitle"><a href="media.html#pixfmt-srggb10">V4L2_PIX_FMT_SRGGB10 ('RG10'),
	 V4L2_PIX_FMT_SGRBG10 ('BA10'),
	 V4L2_PIX_FMT_SGBRG10 ('GB10'),
	 V4L2_PIX_FMT_SBGGR10 ('BG10'),
	 </a></span><span class="refpurpose"> &#8212; 10-bit Bayer formats expanded to 16 bits</span></dt><dt><span class="refentrytitle"><a href="media.html#idp56012848">
	      V4L2_PIX_FMT_SBGGR10ALAW8 ('aBA8'),
	      V4L2_PIX_FMT_SGBRG10ALAW8 ('aGA8'),
	      V4L2_PIX_FMT_SGRBG10ALAW8 ('agA8'),
	      V4L2_PIX_FMT_SRGGB10ALAW8 ('aRA8'),
	    </a></span><span class="refpurpose"> &#8212; 10-bit Bayer formats compressed to 8 bits</span></dt><dt><span class="refentrytitle"><a href="media.html#pixfmt-srggb10dpcm8">
	 V4L2_PIX_FMT_SBGGR10DPCM8 ('bBA8'),
	 V4L2_PIX_FMT_SGBRG10DPCM8 ('bGA8'),
	 V4L2_PIX_FMT_SGRBG10DPCM8 ('BD10'),
	 V4L2_PIX_FMT_SRGGB10DPCM8 ('bRA8'),
	 </a></span><span class="refpurpose"> &#8212; 10-bit Bayer formats compressed to 8 bits</span></dt><dt><span class="refentrytitle"><a href="media.html#idp56032208">V4L2_PIX_FMT_SRGGB12 ('RG12'),
	 V4L2_PIX_FMT_SGRBG12 ('BA12'),
	 V4L2_PIX_FMT_SGBRG12 ('GB12'),
	 V4L2_PIX_FMT_SBGGR12 ('BG12'),
	 </a></span><span class="refpurpose"> &#8212; 12-bit Bayer formats expanded to 16 bits</span></dt></dl></dd><dt><span class="section"><a href="media.html#yuv-formats">YUV Formats</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="media.html#packed-yuv">Packed YUV formats</a></span><span class="refpurpose"> &#8212; Packed YUV formats</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-GREY">V4L2_PIX_FMT_GREY ('GREY')</a></span><span class="refpurpose"> &#8212; Grey-scale image</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-Y10">V4L2_PIX_FMT_Y10 ('Y10 ')</a></span><span class="refpurpose"> &#8212; Grey-scale image</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-Y12">V4L2_PIX_FMT_Y12 ('Y12 ')</a></span><span class="refpurpose"> &#8212; Grey-scale image</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-Y10BPACK">V4L2_PIX_FMT_Y10BPACK ('Y10B')</a></span><span class="refpurpose"> &#8212; Grey-scale image as a bit-packed array</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-Y16">V4L2_PIX_FMT_Y16 ('Y16 ')</a></span><span class="refpurpose"> &#8212; Grey-scale image</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-UV8">V4L2_PIX_FMT_UV8  ('UV8')</a></span><span class="refpurpose"> &#8212; UV plane interleaved</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-YUYV">V4L2_PIX_FMT_YUYV ('YUYV')</a></span><span class="refpurpose"> &#8212; Packed format with ½ horizontal chroma
resolution, also known as YUV 4:2:2</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-UYVY">V4L2_PIX_FMT_UYVY ('UYVY')</a></span><span class="refpurpose"> &#8212; Variation of
<code class="constant">V4L2_PIX_FMT_YUYV</code> with different order of samples
in memory</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-YVYU">V4L2_PIX_FMT_YVYU ('YVYU')</a></span><span class="refpurpose"> &#8212; Variation of
<code class="constant">V4L2_PIX_FMT_YUYV</code> with different order of samples
in memory</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-VYUY">V4L2_PIX_FMT_VYUY ('VYUY')</a></span><span class="refpurpose"> &#8212; Variation of
<code class="constant">V4L2_PIX_FMT_YUYV</code> with different order of samples
in memory</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-Y41P">V4L2_PIX_FMT_Y41P ('Y41P')</a></span><span class="refpurpose"> &#8212; Format with ¼ horizontal chroma
resolution, also known as YUV 4:1:1</span></dt><dt><span class="refentrytitle"><a href="media.html#idp57342656">V4L2_PIX_FMT_YVU420 ('YV12'), V4L2_PIX_FMT_YUV420 ('YU12')</a></span><span class="refpurpose"> &#8212; Planar formats with ½ horizontal and
vertical chroma resolution, also known as YUV 4:2:0</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-YUV420M">V4L2_PIX_FMT_YUV420M ('YM12')</a></span><span class="refpurpose"> &#8212; Variation of <code class="constant">V4L2_PIX_FMT_YUV420</code>
	  with planes non contiguous in memory. </span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-YVU420M">V4L2_PIX_FMT_YVU420M ('YM21')</a></span><span class="refpurpose"> &#8212; Variation of <code class="constant">V4L2_PIX_FMT_YVU420</code>
	  with planes non contiguous in memory. </span></dt><dt><span class="refentrytitle"><a href="media.html#idp57708208">V4L2_PIX_FMT_YVU410 ('YVU9'), V4L2_PIX_FMT_YUV410 ('YUV9')</a></span><span class="refpurpose"> &#8212; Planar formats with ¼ horizontal and
vertical chroma resolution, also known as YUV 4:1:0</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-YUV422P">V4L2_PIX_FMT_YUV422P ('422P')</a></span><span class="refpurpose"> &#8212; Format with ½ horizontal chroma resolution,
also known as YUV 4:2:2. Planar layout as opposed to
<code class="constant">V4L2_PIX_FMT_YUYV</code></span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-YUV411P">V4L2_PIX_FMT_YUV411P ('411P')</a></span><span class="refpurpose"> &#8212; Format with ¼ horizontal chroma resolution,
also known as YUV 4:1:1. Planar layout as opposed to
<code class="constant">V4L2_PIX_FMT_Y41P</code></span></dt><dt><span class="refentrytitle"><a href="media.html#idp58050800">V4L2_PIX_FMT_NV12 ('NV12'), V4L2_PIX_FMT_NV21 ('NV21')</a></span><span class="refpurpose"> &#8212; Formats with ½ horizontal and vertical
chroma resolution, also known as YUV 4:2:0. One luminance and one
chrominance plane with alternating chroma samples as opposed to
<code class="constant">V4L2_PIX_FMT_YVU420</code></span></dt><dt><span class="refentrytitle"><a href="media.html#idp58169408">V4L2_PIX_FMT_NV12M ('NM12'), V4L2_PIX_FMT_NV21M ('NM21'), V4L2_PIX_FMT_NV12MT_16X16</a></span><span class="refpurpose"> &#8212; Variation of <code class="constant">V4L2_PIX_FMT_NV12</code> and <code class="constant">V4L2_PIX_FMT_NV21</code> with planes
	  non contiguous in memory. </span></dt><dt><span class="refentrytitle"><a href="media.html#idp58299328">V4L2_PIX_FMT_NV12MT ('TM12')</a></span><span class="refpurpose"> &#8212; Formats with ½ horizontal and vertical
chroma resolution. This format has two planes - one for luminance and one for
chrominance. Chroma samples are interleaved. The difference to
<code class="constant">V4L2_PIX_FMT_NV12</code> is the memory layout. Pixels are
grouped in macroblocks of 64x32 size. The order of macroblocks in memory is
also not standard.
	</span></dt><dt><span class="refentrytitle"><a href="media.html#idp58297872">V4L2_PIX_FMT_NV16 ('NV16'), V4L2_PIX_FMT_NV61 ('NV61')</a></span><span class="refpurpose"> &#8212; Formats with ½ horizontal
chroma resolution, also known as YUV 4:2:2. One luminance and one
chrominance plane with alternating chroma samples as opposed to
<code class="constant">V4L2_PIX_FMT_YVU420</code></span></dt><dt><span class="refentrytitle"><a href="media.html#idp58473760">V4L2_PIX_FMT_NV16M ('NM16'), V4L2_PIX_FMT_NV61M ('NM61')</a></span><span class="refpurpose"> &#8212; Variation of <code class="constant">V4L2_PIX_FMT_NV16</code> and <code class="constant">V4L2_PIX_FMT_NV61</code> with planes
	  non contiguous in memory. </span></dt><dt><span class="refentrytitle"><a href="media.html#idp58620656">V4L2_PIX_FMT_NV24 ('NV24'), V4L2_PIX_FMT_NV42 ('NV42')</a></span><span class="refpurpose"> &#8212; Formats with full horizontal and vertical
chroma resolutions, also known as YUV 4:4:4. One luminance and one
chrominance plane with alternating chroma samples as opposed to
<code class="constant">V4L2_PIX_FMT_YVU420</code></span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-M420">V4L2_PIX_FMT_M420 ('M420')</a></span><span class="refpurpose"> &#8212; Format with ½ horizontal and vertical chroma
	resolution, also known as YUV 4:2:0. Hybrid plane line-interleaved
	layout.</span></dt></dl></dd><dt><span class="section"><a href="media.html#idp58796032">Compressed Formats</a></span></dt><dt><span class="section"><a href="media.html#sdr-formats">SDR Formats</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="media.html#V4L2-SDR-FMT-CU08">V4L2_SDR_FMT_CU8 ('CU08')</a></span><span class="refpurpose"> &#8212; Complex unsigned 8-bit IQ sample</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-SDR-FMT-CU16LE">V4L2_SDR_FMT_CU16LE ('CU16')</a></span><span class="refpurpose"> &#8212; Complex unsigned 16-bit little endian IQ sample</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-SDR-FMT-CS08">V4L2_SDR_FMT_CS8 ('CS08')</a></span><span class="refpurpose"> &#8212; Complex signed 8-bit IQ sample</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-SDR-FMT-CS14LE">V4L2_SDR_FMT_CS14LE ('CS14')</a></span><span class="refpurpose"> &#8212; Complex signed 14-bit little endian IQ sample</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-SDR-FMT-RU12LE">V4L2_SDR_FMT_RU12LE ('RU12')</a></span><span class="refpurpose"> &#8212; Real unsigned 12-bit little endian sample</span></dt></dl></dd><dt><span class="section"><a href="media.html#pixfmt-reserved">Reserved Format Identifiers</a></span></dt></dl></dd><dt><span class="chapter"><a href="media.html#io">3. Input/Output</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#rw">Read/Write</a></span></dt><dt><span class="section"><a href="media.html#mmap">Streaming I/O (Memory Mapping)</a></span></dt><dt><span class="section"><a href="media.html#userp">Streaming I/O (User Pointers)</a></span></dt><dt><span class="section"><a href="media.html#dmabuf">Streaming I/O (DMA buffer importing)</a></span></dt><dt><span class="section"><a href="media.html#async">Asynchronous I/O</a></span></dt><dt><span class="section"><a href="media.html#buffer">Buffers</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp62487856">Timecodes</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#field-order">Field Order</a></span></dt></dl></dd><dt><span class="chapter"><a href="media.html#devices">4. Interfaces</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#capture">Video Capture Interface</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp63129312">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp63135904">Supplemental Functions</a></span></dt><dt><span class="section"><a href="media.html#idp63143280">Image Format Negotiation</a></span></dt><dt><span class="section"><a href="media.html#idp63167408">Reading Images</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#overlay">Video Overlay Interface</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp63229152">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp63232944">Supplemental Functions</a></span></dt><dt><span class="section"><a href="media.html#idp63239936">Setup</a></span></dt><dt><span class="section"><a href="media.html#idp63255648">Overlay Window</a></span></dt><dt><span class="section"><a href="media.html#idp63352768">Enabling Overlay</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#output">Video Output Interface</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp63496272">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp63501584">Supplemental Functions</a></span></dt><dt><span class="section"><a href="media.html#idp63508576">Image Format Negotiation</a></span></dt><dt><span class="section"><a href="media.html#idp63532608">Writing Images</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#osd">Video Output Overlay Interface</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp63588592">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp63592736">Framebuffer</a></span></dt><dt><span class="section"><a href="media.html#idp63605568">Overlay Window and Scaling</a></span></dt><dt><span class="section"><a href="media.html#idp63623776">Enabling Overlay</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#codec">Codec Interface</a></span></dt><dt><span class="section"><a href="media.html#effect">Effect Devices Interface</a></span></dt><dt><span class="section"><a href="media.html#raw-vbi">Raw VBI Data Interface</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp63701712">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp63705984">Supplemental Functions</a></span></dt><dt><span class="section"><a href="media.html#idp63710576">Raw VBI Format Negotiation</a></span></dt><dt><span class="section"><a href="media.html#idp63809184">Reading and writing VBI images</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#sliced">Sliced VBI Data Interface</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp63939408">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp63944448">Supplemental Functions</a></span></dt><dt><span class="section"><a href="media.html#sliced-vbi-format-negotitation">Sliced VBI Format Negotiation</a></span></dt><dt><span class="section"><a href="media.html#idp64060256">Reading and writing sliced VBI data</a></span></dt><dt><span class="section"><a href="media.html#idp64099728">Sliced VBI Data in MPEG Streams</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#ttx">Teletext Interface</a></span></dt><dt><span class="section"><a href="media.html#radio">Radio Interface</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp64509616">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp64564896">Supplemental Functions</a></span></dt><dt><span class="section"><a href="media.html#idp64568384">Programming</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#rds">RDS Interface</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp64515536">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#reading-rds-data">Reading RDS data</a></span></dt><dt><span class="section"><a href="media.html#writing-rds-data">Writing RDS data</a></span></dt><dt><span class="section"><a href="media.html#idp64621536">RDS datastructures</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#sdr">Software Defined Radio Interface (SDR)</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp64752064">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp64756400">Supplemental Functions</a></span></dt><dt><span class="section"><a href="media.html#idp64761456">Data Format Negotiation</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#event">Event Interface</a></span></dt><dt><span class="section"><a href="media.html#subdev">Sub-device Interface</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp64863392">Controls</a></span></dt><dt><span class="section"><a href="media.html#idp64867520">Events</a></span></dt><dt><span class="section"><a href="media.html#pad-level-formats">Pad-level Formats</a></span></dt><dt><span class="section"><a href="media.html#v4l2-mbus-format">Media Bus Formats</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="media.html#driver">5. V4L2 Driver Programming</a></span></dt><dt><span class="chapter"><a href="media.html#libv4l">6. Libv4l Userspace Library</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#libv4l-introduction">Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp73098096">libv4lconvert</a></span></dt><dt><span class="section"><a href="media.html#idp73133024">libv4l1</a></span></dt><dt><span class="section"><a href="media.html#idp73135024">libv4l2</a></span></dt><dt><span class="section"><a href="media.html#idp73163760">v4l1compat.so wrapper library</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="media.html#compat">7. Changes</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#diff-v4l">Differences between V4L and V4L2</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp73187792">Opening and Closing Devices</a></span></dt><dt><span class="section"><a href="media.html#idp73258032">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp73321456">Video Sources</a></span></dt><dt><span class="section"><a href="media.html#idp73346752">Tuning</a></span></dt><dt><span class="section"><a href="media.html#v4l-image-properties">Image Properties</a></span></dt><dt><span class="section"><a href="media.html#idp73438368">Audio</a></span></dt><dt><span class="section"><a href="media.html#idp73474704">Frame Buffer Overlay</a></span></dt><dt><span class="section"><a href="media.html#idp73505072">Cropping</a></span></dt><dt><span class="section"><a href="media.html#idp73520992">Reading Images, Memory Mapping</a></span></dt><dt><span class="section"><a href="media.html#idp73559232">Reading Raw VBI Data</a></span></dt><dt><span class="section"><a href="media.html#idp73583200">Miscellaneous</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#hist-v4l2">Changes of the V4L2 API</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp73589504">Early Versions</a></span></dt><dt><span class="section"><a href="media.html#idp73613424">V4L2 Version 0.16 1999-01-31</a></span></dt><dt><span class="section"><a href="media.html#idp73615264">V4L2 Version 0.18 1999-03-16</a></span></dt><dt><span class="section"><a href="media.html#idp73616672">V4L2 Version 0.19 1999-06-05</a></span></dt><dt><span class="section"><a href="media.html#idp73621104">V4L2 Version 0.20 (1999-09-10)</a></span></dt><dt><span class="section"><a href="media.html#idp73652672">V4L2 Version 0.20 incremental changes</a></span></dt><dt><span class="section"><a href="media.html#idp73680304">V4L2 Version 0.20 2000-11-23</a></span></dt><dt><span class="section"><a href="media.html#idp73695712">V4L2 Version 0.20 2002-07-25</a></span></dt><dt><span class="section"><a href="media.html#idp73696960">V4L2 in Linux 2.5.46, 2002-10</a></span></dt><dt><span class="section"><a href="media.html#idp73873264">V4L2 2003-06-19</a></span></dt><dt><span class="section"><a href="media.html#idp73897616">V4L2 2003-11-05</a></span></dt><dt><span class="section"><a href="media.html#idp73915888">V4L2 in Linux 2.6.6, 2004-05-09</a></span></dt><dt><span class="section"><a href="media.html#idp73919856">V4L2 in Linux 2.6.8</a></span></dt><dt><span class="section"><a href="media.html#idp73925088">V4L2 spec erratum 2004-08-01</a></span></dt><dt><span class="section"><a href="media.html#idp73934624">V4L2 in Linux 2.6.14</a></span></dt><dt><span class="section"><a href="media.html#idp73939664">V4L2 in Linux 2.6.15</a></span></dt><dt><span class="section"><a href="media.html#idp73952688">V4L2 spec erratum 2005-11-27</a></span></dt><dt><span class="section"><a href="media.html#idp73957168">V4L2 spec erratum 2006-01-10</a></span></dt><dt><span class="section"><a href="media.html#idp73962640">V4L2 spec erratum 2006-02-03</a></span></dt><dt><span class="section"><a href="media.html#idp73967104">V4L2 spec erratum 2006-02-04</a></span></dt><dt><span class="section"><a href="media.html#idp73972448">V4L2 in Linux 2.6.17</a></span></dt><dt><span class="section"><a href="media.html#idp73981536">V4L2 spec erratum 2006-09-23 (Draft 0.15)</a></span></dt><dt><span class="section"><a href="media.html#idp74000640">V4L2 in Linux 2.6.18</a></span></dt><dt><span class="section"><a href="media.html#idp74011472">V4L2 in Linux 2.6.19</a></span></dt><dt><span class="section"><a href="media.html#idp74020480">V4L2 spec erratum 2006-10-12 (Draft 0.17)</a></span></dt><dt><span class="section"><a href="media.html#idp74023952">V4L2 in Linux 2.6.21</a></span></dt><dt><span class="section"><a href="media.html#idp74030176">V4L2 in Linux 2.6.22</a></span></dt><dt><span class="section"><a href="media.html#idp74044000">V4L2 in Linux 2.6.24</a></span></dt><dt><span class="section"><a href="media.html#idp74048672">V4L2 in Linux 2.6.25</a></span></dt><dt><span class="section"><a href="media.html#idp74069136">V4L2 in Linux 2.6.26</a></span></dt><dt><span class="section"><a href="media.html#idp74074224">V4L2 in Linux 2.6.27</a></span></dt><dt><span class="section"><a href="media.html#idp74082240">V4L2 in Linux 2.6.28</a></span></dt><dt><span class="section"><a href="media.html#idp74088448">V4L2 in Linux 2.6.29</a></span></dt><dt><span class="section"><a href="media.html#idp74098320">V4L2 in Linux 2.6.30</a></span></dt><dt><span class="section"><a href="media.html#idp74102560">V4L2 in Linux 2.6.32</a></span></dt><dt><span class="section"><a href="media.html#idp74114320">V4L2 in Linux 2.6.33</a></span></dt><dt><span class="section"><a href="media.html#idp74116928">V4L2 in Linux 2.6.34</a></span></dt><dt><span class="section"><a href="media.html#idp74121184">V4L2 in Linux 2.6.37</a></span></dt><dt><span class="section"><a href="media.html#idp74123920">V4L2 in Linux 2.6.39</a></span></dt><dt><span class="section"><a href="media.html#idp74128224">V4L2 in Linux 3.1</a></span></dt><dt><span class="section"><a href="media.html#idp74131696">V4L2 in Linux 3.2</a></span></dt><dt><span class="section"><a href="media.html#idp74136112">V4L2 in Linux 3.3</a></span></dt><dt><span class="section"><a href="media.html#idp74140832">V4L2 in Linux 3.4</a></span></dt><dt><span class="section"><a href="media.html#idp74147504">V4L2 in Linux 3.5</a></span></dt><dt><span class="section"><a href="media.html#idp74165904">V4L2 in Linux 3.6</a></span></dt><dt><span class="section"><a href="media.html#idp74171856">V4L2 in Linux 3.9</a></span></dt><dt><span class="section"><a href="media.html#idp74179504">V4L2 in Linux 3.10</a></span></dt><dt><span class="section"><a href="media.html#idp74183200">V4L2 in Linux 3.11</a></span></dt><dt><span class="section"><a href="media.html#idp74187760">V4L2 in Linux 3.14</a></span></dt><dt><span class="section"><a href="media.html#idp74191600">V4L2 in Linux 3.15</a></span></dt><dt><span class="section"><a href="media.html#idp74194096">V4L2 in Linux 3.16</a></span></dt><dt><span class="section"><a href="media.html#idp74196656">V4L2 in Linux 3.17</a></span></dt><dt><span class="section"><a href="media.html#idp74201536">V4L2 in Linux 3.18</a></span></dt><dt><span class="section"><a href="media.html#idp74204960">V4L2 in Linux 3.19</a></span></dt><dt><span class="section"><a href="media.html#other">Relation of V4L2 to other Linux multimedia APIs</a></span></dt><dt><span class="section"><a href="media.html#experimental">Experimental API Elements</a></span></dt><dt><span class="section"><a href="media.html#obsolete">Obsolete API Elements</a></span></dt></dl></dd></dl></dd><dt><span class="appendix"><a href="media.html#user-func">A. Function Reference</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="media.html#func-close">V4L2 close()</a></span><span class="refpurpose"> &#8212; Close a V4L2 device</span></dt><dt><span class="refentrytitle"><a href="media.html#func-ioctl">V4L2 ioctl()</a></span><span class="refpurpose"> &#8212; Program a V4L2 device</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-create-bufs">ioctl VIDIOC_CREATE_BUFS</a></span><span class="refpurpose"> &#8212; Create buffers for Memory Mapped or User Pointer or DMA Buffer
    I/O</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-cropcap">ioctl VIDIOC_CROPCAP</a></span><span class="refpurpose"> &#8212; Information about the video cropping and scaling abilities</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-dbg-g-chip-info">ioctl VIDIOC_DBG_G_CHIP_INFO</a></span><span class="refpurpose"> &#8212; Identify the chips on a TV card</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-dbg-g-register">ioctl VIDIOC_DBG_G_REGISTER, VIDIOC_DBG_S_REGISTER</a></span><span class="refpurpose"> &#8212; Read or write hardware registers</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-decoder-cmd">ioctl VIDIOC_DECODER_CMD, VIDIOC_TRY_DECODER_CMD</a></span><span class="refpurpose"> &#8212; Execute an decoder command</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-dqevent">ioctl VIDIOC_DQEVENT</a></span><span class="refpurpose"> &#8212; Dequeue event</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-dv-timings-cap">ioctl VIDIOC_DV_TIMINGS_CAP, VIDIOC_SUBDEV_DV_TIMINGS_CAP</a></span><span class="refpurpose"> &#8212; The capabilities of the Digital Video receiver/transmitter</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-encoder-cmd">ioctl VIDIOC_ENCODER_CMD, VIDIOC_TRY_ENCODER_CMD</a></span><span class="refpurpose"> &#8212; Execute an encoder command</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-enumaudio">ioctl VIDIOC_ENUMAUDIO</a></span><span class="refpurpose"> &#8212; Enumerate audio inputs</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-enumaudioout">ioctl VIDIOC_ENUMAUDOUT</a></span><span class="refpurpose"> &#8212; Enumerate audio outputs</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-enum-dv-timings">ioctl VIDIOC_ENUM_DV_TIMINGS, VIDIOC_SUBDEV_ENUM_DV_TIMINGS</a></span><span class="refpurpose"> &#8212; Enumerate supported Digital Video timings</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-enum-fmt">ioctl VIDIOC_ENUM_FMT</a></span><span class="refpurpose"> &#8212; Enumerate image formats</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-enum-framesizes">ioctl VIDIOC_ENUM_FRAMESIZES</a></span><span class="refpurpose"> &#8212; Enumerate frame sizes</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-enum-frameintervals">ioctl VIDIOC_ENUM_FRAMEINTERVALS</a></span><span class="refpurpose"> &#8212; Enumerate frame intervals</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-enum-freq-bands">ioctl VIDIOC_ENUM_FREQ_BANDS</a></span><span class="refpurpose"> &#8212; Enumerate supported frequency bands</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-enuminput">ioctl VIDIOC_ENUMINPUT</a></span><span class="refpurpose"> &#8212; Enumerate video inputs</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-enumoutput">ioctl VIDIOC_ENUMOUTPUT</a></span><span class="refpurpose"> &#8212; Enumerate video outputs</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-enumstd">ioctl VIDIOC_ENUMSTD</a></span><span class="refpurpose"> &#8212; Enumerate supported video standards</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-expbuf">ioctl VIDIOC_EXPBUF</a></span><span class="refpurpose"> &#8212; Export a buffer as a DMABUF file descriptor.</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-audio">ioctl VIDIOC_G_AUDIO, VIDIOC_S_AUDIO</a></span><span class="refpurpose"> &#8212; Query or select the current audio input and its
attributes</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-audioout">ioctl VIDIOC_G_AUDOUT, VIDIOC_S_AUDOUT</a></span><span class="refpurpose"> &#8212; Query or select the current audio output</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-crop">ioctl VIDIOC_G_CROP, VIDIOC_S_CROP</a></span><span class="refpurpose"> &#8212; Get or set the current cropping rectangle</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-ctrl">ioctl VIDIOC_G_CTRL, VIDIOC_S_CTRL</a></span><span class="refpurpose"> &#8212; Get or set the value of a control</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-dv-timings">ioctl VIDIOC_G_DV_TIMINGS, VIDIOC_S_DV_TIMINGS</a></span><span class="refpurpose"> &#8212; Get or set DV timings for input or output</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-edid">ioctl VIDIOC_G_EDID, VIDIOC_S_EDID</a></span><span class="refpurpose"> &#8212; Get or set the EDID of a video receiver/transmitter</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-enc-index">ioctl VIDIOC_G_ENC_INDEX</a></span><span class="refpurpose"> &#8212; Get meta data about a compressed video stream</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-ext-ctrls">ioctl VIDIOC_G_EXT_CTRLS, VIDIOC_S_EXT_CTRLS,
VIDIOC_TRY_EXT_CTRLS</a></span><span class="refpurpose"> &#8212; Get or set the value of several controls, try control
values</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-fbuf">ioctl VIDIOC_G_FBUF, VIDIOC_S_FBUF</a></span><span class="refpurpose"> &#8212; Get or set frame buffer overlay parameters</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-fmt">ioctl VIDIOC_G_FMT, VIDIOC_S_FMT,
VIDIOC_TRY_FMT</a></span><span class="refpurpose"> &#8212; Get or set the data format, try a format</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-frequency">ioctl VIDIOC_G_FREQUENCY, VIDIOC_S_FREQUENCY</a></span><span class="refpurpose"> &#8212; Get or set tuner or modulator radio
frequency</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-input">ioctl VIDIOC_G_INPUT, VIDIOC_S_INPUT</a></span><span class="refpurpose"> &#8212; Query or select the current video input</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-jpegcomp">ioctl VIDIOC_G_JPEGCOMP, VIDIOC_S_JPEGCOMP</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-modulator">ioctl VIDIOC_G_MODULATOR, VIDIOC_S_MODULATOR</a></span><span class="refpurpose"> &#8212; Get or set modulator attributes</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-output">ioctl VIDIOC_G_OUTPUT, VIDIOC_S_OUTPUT</a></span><span class="refpurpose"> &#8212; Query or select the current video output</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-parm">ioctl VIDIOC_G_PARM, VIDIOC_S_PARM</a></span><span class="refpurpose"> &#8212; Get or set streaming parameters</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-priority">ioctl VIDIOC_G_PRIORITY, VIDIOC_S_PRIORITY</a></span><span class="refpurpose"> &#8212; Query or request the access priority associated with a
file descriptor</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-selection">ioctl VIDIOC_G_SELECTION, VIDIOC_S_SELECTION</a></span><span class="refpurpose"> &#8212; Get or set one of the selection rectangles</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-sliced-vbi-cap">ioctl VIDIOC_G_SLICED_VBI_CAP</a></span><span class="refpurpose"> &#8212; Query sliced VBI capabilities</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-std">ioctl VIDIOC_G_STD, VIDIOC_S_STD</a></span><span class="refpurpose"> &#8212; Query or select the video standard of the current input</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-tuner">ioctl VIDIOC_G_TUNER, VIDIOC_S_TUNER</a></span><span class="refpurpose"> &#8212; Get or set tuner attributes</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-log-status">ioctl VIDIOC_LOG_STATUS</a></span><span class="refpurpose"> &#8212; Log driver status information</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-overlay">ioctl VIDIOC_OVERLAY</a></span><span class="refpurpose"> &#8212; Start or stop video overlay</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-prepare-buf">ioctl VIDIOC_PREPARE_BUF</a></span><span class="refpurpose"> &#8212; Prepare a buffer for I/O</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-qbuf">ioctl VIDIOC_QBUF, VIDIOC_DQBUF</a></span><span class="refpurpose"> &#8212; Exchange a buffer with the driver</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-querybuf">ioctl VIDIOC_QUERYBUF</a></span><span class="refpurpose"> &#8212; Query the status of a buffer</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-querycap">ioctl VIDIOC_QUERYCAP</a></span><span class="refpurpose"> &#8212; Query device capabilities</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-queryctrl">ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU</a></span><span class="refpurpose"> &#8212; Enumerate controls and menu control items</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-query-dv-timings">ioctl VIDIOC_QUERY_DV_TIMINGS</a></span><span class="refpurpose"> &#8212; Sense the DV preset received by the current
input</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-querystd">ioctl VIDIOC_QUERYSTD</a></span><span class="refpurpose"> &#8212; Sense the video standard received by the current
input</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-reqbufs">ioctl VIDIOC_REQBUFS</a></span><span class="refpurpose"> &#8212; Initiate Memory Mapping or User Pointer I/O</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-s-hw-freq-seek">ioctl VIDIOC_S_HW_FREQ_SEEK</a></span><span class="refpurpose"> &#8212; Perform a hardware frequency seek</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-streamon">ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF</a></span><span class="refpurpose"> &#8212; Start or stop streaming I/O</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-subdev-enum-frame-interval">ioctl VIDIOC_SUBDEV_ENUM_FRAME_INTERVAL</a></span><span class="refpurpose"> &#8212; Enumerate frame intervals</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-subdev-enum-frame-size">ioctl VIDIOC_SUBDEV_ENUM_FRAME_SIZE</a></span><span class="refpurpose"> &#8212; Enumerate media bus frame sizes</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-subdev-enum-mbus-code">ioctl VIDIOC_SUBDEV_ENUM_MBUS_CODE</a></span><span class="refpurpose"> &#8212; Enumerate media bus formats</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-subdev-g-crop">ioctl VIDIOC_SUBDEV_G_CROP, VIDIOC_SUBDEV_S_CROP</a></span><span class="refpurpose"> &#8212; Get or set the crop rectangle on a subdev pad</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-subdev-g-fmt">ioctl VIDIOC_SUBDEV_G_FMT, VIDIOC_SUBDEV_S_FMT</a></span><span class="refpurpose"> &#8212; Get or set the data format on a subdev pad</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-subdev-g-frame-interval">ioctl VIDIOC_SUBDEV_G_FRAME_INTERVAL, VIDIOC_SUBDEV_S_FRAME_INTERVAL</a></span><span class="refpurpose"> &#8212; Get or set the frame interval on a subdev pad</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-subdev-g-selection">ioctl VIDIOC_SUBDEV_G_SELECTION, VIDIOC_SUBDEV_S_SELECTION</a></span><span class="refpurpose"> &#8212; Get or set selection rectangles on a subdev pad</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-subscribe-event">ioctl VIDIOC_SUBSCRIBE_EVENT, VIDIOC_UNSUBSCRIBE_EVENT</a></span><span class="refpurpose"> &#8212; Subscribe or unsubscribe event</span></dt><dt><span class="refentrytitle"><a href="media.html#func-mmap">V4L2 mmap()</a></span><span class="refpurpose"> &#8212; Map device memory into application address space</span></dt><dt><span class="refentrytitle"><a href="media.html#func-munmap">V4L2 munmap()</a></span><span class="refpurpose"> &#8212; Unmap device memory</span></dt><dt><span class="refentrytitle"><a href="media.html#func-open">V4L2 open()</a></span><span class="refpurpose"> &#8212; Open a V4L2 device</span></dt><dt><span class="refentrytitle"><a href="media.html#func-poll">V4L2 poll()</a></span><span class="refpurpose"> &#8212; Wait for some event on a file descriptor</span></dt><dt><span class="refentrytitle"><a href="media.html#func-read">V4L2 read()</a></span><span class="refpurpose"> &#8212; Read from a V4L2 device</span></dt><dt><span class="refentrytitle"><a href="media.html#func-select">V4L2 select()</a></span><span class="refpurpose"> &#8212; Synchronous I/O multiplexing</span></dt><dt><span class="refentrytitle"><a href="media.html#func-write">V4L2 write()</a></span><span class="refpurpose"> &#8212; Write to a V4L2 device</span></dt></dl></dd><dt><span class="appendix"><a href="media.html#idp85688448">B. Common definitions for V4L2 and V4L2 subdev interfaces</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#v4l2-selections-common">Common selection definitions</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#v4l2-selection-targets">Selection targets</a></span></dt><dt><span class="section"><a href="media.html#v4l2-selection-flags">Selection flags</a></span></dt></dl></dd></dl></dd><dt><span class="appendix"><a href="media.html#videodev">C. Video For Linux Two Header File</a></span></dt><dt><span class="appendix"><a href="media.html#capture-example">D. Video Capture Example</a></span></dt><dt><span class="appendix"><a href="media.html#v4l2grab-example">E. Video Grabber example using libv4l</a></span></dt><dt><span class="index"><a href="media.html#idp86648832">List of Types</a></span></dt><dt><span class="bibliography"><a href="media.html#idp87100320">References</a></span></dt></dl></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="common"></a>Chapter 1. Common API Elements</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="media.html#open">Opening and Closing Devices</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp47233696">Device Naming</a></span></dt><dt><span class="section"><a href="media.html#related">Related Devices</a></span></dt><dt><span class="section"><a href="media.html#idp47249088">Multiple Opens</a></span></dt><dt><span class="section"><a href="media.html#idp47270192">Shared Data Streams</a></span></dt><dt><span class="section"><a href="media.html#idp47271584">Functions</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#querycap">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#app-pri">Application Priority</a></span></dt><dt><span class="section"><a href="media.html#video">Video Inputs and Outputs</a></span></dt><dt><span class="section"><a href="media.html#audio">Audio Inputs and Outputs</a></span></dt><dt><span class="section"><a href="media.html#tuner">Tuners and Modulators</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp47353184">Tuners</a></span></dt><dt><span class="section"><a href="media.html#idp47365392">Modulators</a></span></dt><dt><span class="section"><a href="media.html#idp47378112">Radio Frequency</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#standard">Video Standards</a></span></dt><dt><span class="section"><a href="media.html#dv-timings">Digital Video (DV) Timings</a></span></dt><dt><span class="section"><a href="media.html#control">User Controls</a></span></dt><dt><span class="section"><a href="media.html#extended-controls">Extended Controls</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp47658496">Introduction</a></span></dt><dt><span class="section"><a href="media.html#idp47662144">The Extended Control API</a></span></dt><dt><span class="section"><a href="media.html#idp47686784">Enumerating Extended Controls</a></span></dt><dt><span class="section"><a href="media.html#idp47456288">Creating Control Panels</a></span></dt><dt><span class="section"><a href="media.html#mpeg-controls">Codec Control Reference</a></span></dt><dt><span class="section"><a href="media.html#camera-controls">Camera Control Reference</a></span></dt><dt><span class="section"><a href="media.html#fm-tx-controls">FM Transmitter Control Reference</a></span></dt><dt><span class="section"><a href="media.html#flash-controls">Flash Control Reference</a></span></dt><dt><span class="section"><a href="media.html#jpeg-controls">JPEG Control Reference</a></span></dt><dt><span class="section"><a href="media.html#image-source-controls">Image Source Control Reference</a></span></dt><dt><span class="section"><a href="media.html#image-process-controls">Image Process Control Reference</a></span></dt><dt><span class="section"><a href="media.html#dv-controls">Digital Video Control Reference</a></span></dt><dt><span class="section"><a href="media.html#fm-rx-controls">FM Receiver Control Reference</a></span></dt><dt><span class="section"><a href="media.html#detect-controls">Detect Control Reference</a></span></dt><dt><span class="section"><a href="media.html#rf-tuner-controls">RF Tuner Control Reference</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#format">Data Formats</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp51292128">Data Format Negotiation</a></span></dt><dt><span class="section"><a href="media.html#idp51320592">Image Format Enumeration</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#planar-apis">Single- and multi-planar APIs</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp51329792">Multi-planar formats</a></span></dt><dt><span class="section"><a href="media.html#idp51333216">Calls that distinguish between single and multi-planar APIs</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#crop">Image Cropping, Insertion and Scaling</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp51365280">Cropping Structures</a></span></dt><dt><span class="section"><a href="media.html#idp51407488">Scaling Adjustments</a></span></dt><dt><span class="section"><a href="media.html#idp51416672">Examples</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#selection-api">Experimental API for cropping, composing and scaling</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp51447328">Introduction</a></span></dt><dt><span class="section"><a href="media.html#idp51494464">Selection targets</a></span></dt><dt><span class="section"><a href="media.html#idp51500704">Configuration</a></span></dt><dt><span class="section"><a href="media.html#idp51531648">Comparison with old cropping API</a></span></dt><dt><span class="section"><a href="media.html#idp51539232">Examples</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#streaming-par">Streaming Parameters</a></span></dt></dl></div><p>Programming a V4L2 device consists of these
steps:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Opening the device</p></li><li class="listitem"><p>Changing device properties, selecting a video and audio
input, video standard, picture brightness a. o.</p></li><li class="listitem"><p>Negotiating a data format</p></li><li class="listitem"><p>Negotiating an input/output method</p></li><li class="listitem"><p>The actual input/output loop</p></li><li class="listitem"><p>Closing the device</p></li></ul></div><p>In practice most steps are optional and can be executed out of
order. It depends on the V4L2 device type, you can read about the
details in <a class="xref" href="media.html#devices" title="Chapter 4. Interfaces">Chapter 4, <i>Interfaces</i></a>. In this chapter we will discuss
the basic concepts applicable to all devices.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="open"></a>Opening and Closing Devices</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#idp47233696">Device Naming</a></span></dt><dt><span class="section"><a href="media.html#related">Related Devices</a></span></dt><dt><span class="section"><a href="media.html#idp47249088">Multiple Opens</a></span></dt><dt><span class="section"><a href="media.html#idp47270192">Shared Data Streams</a></span></dt><dt><span class="section"><a href="media.html#idp47271584">Functions</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp47233696"></a>Device Naming</h3></div></div></div><p>V4L2 drivers are implemented as kernel modules, loaded
manually by the system administrator or automatically when a device is
first discovered. The driver modules plug into the "videodev" kernel
module. It provides helper functions and a common application
interface specified in this document.</p><p>Each driver thus loaded registers one or more device nodes
with major number 81 and a minor number between 0 and 255. Minor numbers
are allocated dynamically unless the kernel is compiled with the kernel
option CONFIG_VIDEO_FIXED_MINOR_RANGES. In that case minor numbers are
allocated in ranges depending on the device node type (video, radio, etc.).</p><p>Many drivers support "video_nr", "radio_nr" or "vbi_nr"
module options to select specific video/radio/vbi node numbers. This allows
the user to request that the device node is named e.g. /dev/video5 instead
of leaving it to chance. When the driver supports multiple devices of the same
type more than one device node number can be assigned, separated by commas:
	</p><div class="informalexample"><pre class="screen">
&gt; modprobe mydriver video_nr=0,1 radio_nr=0,1</pre></div><p>In <code class="filename">/etc/modules.conf</code> this may be
written as: </p><div class="informalexample"><pre class="screen">
options mydriver video_nr=0,1 radio_nr=0,1
	  </pre></div><p> When no device node number is given as module
option the driver supplies a default.</p><p>Normally udev will create the device nodes in /dev automatically
for you. If udev is not installed, then you need to enable the
CONFIG_VIDEO_FIXED_MINOR_RANGES kernel option in order to be able to correctly
relate a minor number to a device node number. I.e., you need to be certain
that minor number 5 maps to device node name video5. With this kernel option
different device types have different minor number ranges. These ranges are
listed in <a class="xref" href="media.html#devices" title="Chapter 4. Interfaces">Chapter 4, <i>Interfaces</i></a>.
</p><p>The creation of character special files (with
<span class="application">mknod</span>) is a privileged operation and
devices cannot be opened by major and minor number. That means
applications cannot <span class="emphasis"><em>reliable</em></span> scan for loaded or
installed drivers. The user must enter a device name, or the
application can try the conventional device names.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="related"></a>Related Devices</h3></div></div></div><p>Devices can support several functions. For example
video capturing, VBI capturing and radio support.</p><p>The V4L2 API creates different nodes for each of these functions.</p><p>The V4L2 API was designed with the idea that one device node could support
all functions. However, in practice this never worked: this 'feature'
was never used by applications and many drivers did not support it and if
they did it was certainly never tested. In addition, switching a device
node between different functions only works when using the streaming I/O
API, not with the read()/write() API.</p><p>Today each device node supports just one function.</p><p>Besides video input or output the hardware may also
support audio sampling or playback. If so, these functions are
implemented as ALSA PCM devices with optional ALSA audio mixer
devices.</p><p>One problem with all these devices is that the V4L2 API
makes no provisions to find these related devices. Some really
complex devices use the Media Controller (see <a class="xref" href="media.html#media_controller" title="Chapter 18. Media Controller">Chapter 18, <i>Media Controller</i></a>)
which can be used for this purpose. But most drivers do not use it,
and while some code exists that uses sysfs to discover related devices
(see libmedia_dev in the <a class="ulink" href="http://git.linuxtv.org/cgit.cgi/v4l-utils.git/" target="_top">v4l-utils</a>
git repository), there is no library yet that can provide a single API towards
both Media Controller-based devices and devices that do not use the Media Controller.
If you want to work on this please write to the linux-media mailing list: <a class="ulink" href="http://www.linuxtv.org/lists.php" target="_top">http://www.linuxtv.org/lists.php</a>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp47249088"></a>Multiple Opens</h3></div></div></div><p>V4L2 devices can be opened more than once.<a href="media.html#ftn.idp47251232" class="footnote" name="idp47251232"><sup class="footnote">[1]</sup></a>
When this is supported by the driver, users can for example start a
"panel" application to change controls like brightness or audio
volume, while another application captures video and audio. In other words, panel
applications are comparable to an ALSA audio mixer application.
Just opening a V4L2 device should not change the state of the device.<a href="media.html#ftn.idp47255632" class="footnote" name="idp47255632"><sup class="footnote">[2]</sup></a></p><p>Once an application has allocated the memory buffers needed for
streaming data (by calling the <a class="link" href="media.html#vidioc-reqbufs" title="ioctl VIDIOC_REQBUFS"><code class="constant">VIDIOC_REQBUFS</code></a> or <a class="link" href="media.html#vidioc-create-bufs" title="ioctl VIDIOC_CREATE_BUFS"><code class="constant">VIDIOC_CREATE_BUFS</code></a> ioctls,
or implicitly by calling the <a class="link" href="media.html#func-read" title="V4L2 read()"><code class="function">read()</code></a> or <a class="link" href="media.html#func-write" title="V4L2 write()"><code class="function">write()</code></a> functions) that
application (filehandle) becomes the owner of the device. It is no longer
allowed to make changes that would affect the buffer sizes (e.g. by calling
the <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> ioctl) and other applications are no longer allowed to allocate
buffers or start or stop streaming. The <span class="errorcode">EBUSY</span> error code will be returned instead.</p><p>Merely opening a V4L2 device does not grant exclusive
access.<a href="media.html#ftn.idp47267904" class="footnote" name="idp47267904"><sup class="footnote">[3]</sup></a> Initiating data exchange however assigns the right
to read or write the requested type of data, and to change related
properties, to this file descriptor. Applications can request
additional access privileges using the priority mechanism described in
<a class="xref" href="media.html#app-pri" title="Application Priority">the section called &#8220;Application Priority&#8221;</a>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp47270192"></a>Shared Data Streams</h3></div></div></div><p>V4L2 drivers should not support multiple applications
reading or writing the same data stream on a device by copying
buffers, time multiplexing or similar means. This is better handled by
a proxy application in user space.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp47271584"></a>Functions</h3></div></div></div><p>To open and close V4L2 devices applications use the
<a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a> and <a class="link" href="media.html#func-close" title="V4L2 close()"><code class="function">close()</code></a> function, respectively. Devices are
programmed using the <a class="link" href="media.html#func-ioctl" title="V4L2 ioctl()"><code class="function">ioctl()</code></a> function as explained in the
following sections.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="querycap"></a>Querying Capabilities</h2></div></div></div><p>Because V4L2 covers a wide variety of devices not all
aspects of the API are equally applicable to all types of devices.
Furthermore devices of the same type have different capabilities and
this specification permits the omission of a few complicated and less
important parts of the API.</p><p>The <a class="link" href="media.html#vidioc-querycap" title="ioctl VIDIOC_QUERYCAP"><code class="constant">VIDIOC_QUERYCAP</code></a> ioctl is available to check if the kernel
device is compatible with this specification, and to query the <a class="link" href="media.html#devices" title="Chapter 4. Interfaces">functions</a> and <a class="link" href="media.html#io" title="Chapter 3. Input/Output">I/O
methods</a> supported by the device.</p><p>Starting with kernel version 3.1, VIDIOC-QUERYCAP will return the
V4L2 API version used by the driver, with generally matches the Kernel version.
There's no need of using <a class="link" href="media.html#vidioc-querycap" title="ioctl VIDIOC_QUERYCAP"><code class="constant">VIDIOC_QUERYCAP</code></a> to check if a specific ioctl is
supported, the V4L2 core now returns ENOTTY if a driver doesn't provide
support for an ioctl.</p><p>Other features can be queried
by calling the respective ioctl, for example <a class="link" href="media.html#vidioc-enuminput" title="ioctl VIDIOC_ENUMINPUT"><code class="constant">VIDIOC_ENUMINPUT</code></a>
to learn about the number, types and names of video connectors on the
device. Although abstraction is a major objective of this API, the
<a class="link" href="media.html#vidioc-querycap" title="ioctl VIDIOC_QUERYCAP"><code class="constant">VIDIOC_QUERYCAP</code></a> ioctl also allows driver specific applications to reliably identify
the driver.</p><p>All V4L2 drivers must support
<code class="constant">VIDIOC_QUERYCAP</code>. Applications should always call
this ioctl after opening the device.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="app-pri"></a>Application Priority</h2></div></div></div><p>When multiple applications share a device it may be
desirable to assign them different priorities. Contrary to the
traditional "rm -rf /" school of thought a video recording application
could for example block other applications from changing video
controls or switching the current TV channel. Another objective is to
permit low priority applications working in background, which can be
preempted by user controlled applications and automatically regain
control of the device at a later time.</p><p>Since these features cannot be implemented entirely in user
space V4L2 defines the <a class="link" href="media.html#vidioc-g-priority" title="ioctl VIDIOC_G_PRIORITY, VIDIOC_S_PRIORITY"><code class="constant">VIDIOC_G_PRIORITY</code></a> and <a class="link" href="media.html#vidioc-g-priority" title="ioctl VIDIOC_G_PRIORITY, VIDIOC_S_PRIORITY"><code class="constant">VIDIOC_S_PRIORITY</code></a>
ioctls to request and query the access priority associate with a file
descriptor. Opening a device assigns a medium priority, compatible
with earlier versions of V4L2 and drivers not supporting these ioctls.
Applications requiring a different priority will usually call
<code class="constant">VIDIOC_S_PRIORITY</code> after verifying the device with
the <a class="link" href="media.html#vidioc-querycap" title="ioctl VIDIOC_QUERYCAP"><code class="constant">VIDIOC_QUERYCAP</code></a> ioctl.</p><p>Ioctls changing driver properties, such as <a class="link" href="media.html#vidioc-g-input" title="ioctl VIDIOC_G_INPUT, VIDIOC_S_INPUT"><code class="constant">VIDIOC_S_INPUT</code></a>,
return an <span class="errorcode">EBUSY</span> error code after another application obtained higher priority.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="video"></a>Video Inputs and Outputs</h2></div></div></div><p>Video inputs and outputs are physical connectors of a
device. These can be for example RF connectors (antenna/cable), CVBS
a.k.a. Composite Video, S-Video or RGB connectors. Video and VBI
capture devices have inputs. Video and VBI output devices have outputs,
at least one each. Radio devices have no video inputs or outputs.</p><p>To learn about the number and attributes of the
available inputs and outputs applications can enumerate them with the
<a class="link" href="media.html#vidioc-enuminput" title="ioctl VIDIOC_ENUMINPUT"><code class="constant">VIDIOC_ENUMINPUT</code></a> and <a class="link" href="media.html#vidioc-enumoutput" title="ioctl VIDIOC_ENUMOUTPUT"><code class="constant">VIDIOC_ENUMOUTPUT</code></a> ioctl, respectively. The
struct <a class="link" href="media.html#v4l2-input" title="Table A.38. struct v4l2_input">v4l2_input</a> returned by the <code class="constant">VIDIOC_ENUMINPUT</code>
ioctl also contains signal status information applicable when the
current video input is queried.</p><p>The <a class="link" href="media.html#vidioc-g-input" title="ioctl VIDIOC_G_INPUT, VIDIOC_S_INPUT"><code class="constant">VIDIOC_G_INPUT</code></a> and <a class="link" href="media.html#vidioc-g-output" title="ioctl VIDIOC_G_OUTPUT, VIDIOC_S_OUTPUT"><code class="constant">VIDIOC_G_OUTPUT</code></a> ioctls return the
index of the current video input or output. To select a different
input or output applications call the <a class="link" href="media.html#vidioc-g-input" title="ioctl VIDIOC_G_INPUT, VIDIOC_S_INPUT"><code class="constant">VIDIOC_S_INPUT</code></a> and
<a class="link" href="media.html#vidioc-g-output" title="ioctl VIDIOC_G_OUTPUT, VIDIOC_S_OUTPUT"><code class="constant">VIDIOC_S_OUTPUT</code></a> ioctls. Drivers must implement all the input ioctls
when the device has one or more inputs, all the output ioctls when the
device has one or more outputs.</p><div class="example"><a name="idp47310976"></a><p class="title"><b>Example 1.1. Information about the current video input</b></p><div class="example-contents"><pre class="programlisting">
struct <a class="link" href="media.html#v4l2-input" title="Table A.38. struct v4l2_input">v4l2_input</a> input;
int index;

if (-1 == ioctl(fd, <a class="link" href="media.html#vidioc-g-input" title="ioctl VIDIOC_G_INPUT, VIDIOC_S_INPUT"><code class="constant">VIDIOC_G_INPUT</code></a>, &amp;index)) {
	perror("VIDIOC_G_INPUT");
	exit(EXIT_FAILURE);
}

memset(&amp;input, 0, sizeof(input));
input.index = index;

if (-1 == ioctl(fd, <a class="link" href="media.html#vidioc-enuminput" title="ioctl VIDIOC_ENUMINPUT"><code class="constant">VIDIOC_ENUMINPUT</code></a>, &amp;input)) {
	perror("VIDIOC_ENUMINPUT");
	exit(EXIT_FAILURE);
}

printf("Current input: %s\n", input.name);
      </pre></div></div><br class="example-break"><div class="example"><a name="idp47315664"></a><p class="title"><b>Example 1.2. Switching to the first video input</b></p><div class="example-contents"><pre class="programlisting">
int index;

index = 0;

if (-1 == ioctl(fd, <a class="link" href="media.html#vidioc-g-input" title="ioctl VIDIOC_G_INPUT, VIDIOC_S_INPUT"><code class="constant">VIDIOC_S_INPUT</code></a>, &amp;index)) {
	perror("VIDIOC_S_INPUT");
	exit(EXIT_FAILURE);
}
      </pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="audio"></a>Audio Inputs and Outputs</h2></div></div></div><p>Audio inputs and outputs are physical connectors of a
device. Video capture devices have inputs, output devices have
outputs, zero or more each. Radio devices have no audio inputs or
outputs. They have exactly one tuner which in fact
<span class="emphasis"><em>is</em></span> an audio source, but this API associates
tuners with video inputs or outputs only, and radio devices have
none of these.<a href="media.html#ftn.idp47320016" class="footnote" name="idp47320016"><sup class="footnote">[4]</sup></a> A connector on a TV card to loop back the received
audio signal to a sound card is not considered an audio output.</p><p>Audio and video inputs and outputs are associated. Selecting
a video source also selects an audio source. This is most evident when
the video and audio source is a tuner. Further audio connectors can
combine with more than one video input or output. Assumed two
composite video inputs and two audio inputs exist, there may be up to
four valid combinations. The relation of video and audio connectors
is defined in the <em class="structfield"><code>audioset</code></em> field of the
respective struct <a class="link" href="media.html#v4l2-input" title="Table A.38. struct v4l2_input">v4l2_input</a> or struct <a class="link" href="media.html#v4l2-output" title="Table A.42. struct v4l2_output">v4l2_output</a>, where each bit represents
the index number, starting at zero, of one audio input or output.</p><p>To learn about the number and attributes of the
available inputs and outputs applications can enumerate them with the
<a class="link" href="media.html#vidioc-enumaudio" title="ioctl VIDIOC_ENUMAUDIO"><code class="constant">VIDIOC_ENUMAUDIO</code></a> and <a class="link" href="media.html#vidioc-enumaudioout" title="ioctl VIDIOC_ENUMAUDOUT"><code class="constant">VIDIOC_ENUMAUDOUT</code></a> ioctl, respectively. The
struct <a class="link" href="media.html#v4l2-audio" title="Table A.50. struct v4l2_audio">v4l2_audio</a> returned by the <code class="constant">VIDIOC_ENUMAUDIO</code> ioctl
also contains signal status information applicable when the current
audio input is queried.</p><p>The <a class="link" href="media.html#vidioc-g-audio" title="ioctl VIDIOC_G_AUDIO, VIDIOC_S_AUDIO"><code class="constant">VIDIOC_G_AUDIO</code></a> and <a class="link" href="media.html#vidioc-g-audioout" title="ioctl VIDIOC_G_AUDOUT, VIDIOC_S_AUDOUT"><code class="constant">VIDIOC_G_AUDOUT</code></a> ioctls report
the current audio input and output, respectively. Note that, unlike
<a class="link" href="media.html#vidioc-g-input" title="ioctl VIDIOC_G_INPUT, VIDIOC_S_INPUT"><code class="constant">VIDIOC_G_INPUT</code></a> and <a class="link" href="media.html#vidioc-g-output" title="ioctl VIDIOC_G_OUTPUT, VIDIOC_S_OUTPUT"><code class="constant">VIDIOC_G_OUTPUT</code></a> these ioctls return a structure
as <code class="constant">VIDIOC_ENUMAUDIO</code> and
<code class="constant">VIDIOC_ENUMAUDOUT</code> do, not just an index.</p><p>To select an audio input and change its properties
applications call the <a class="link" href="media.html#vidioc-g-audio" title="ioctl VIDIOC_G_AUDIO, VIDIOC_S_AUDIO"><code class="constant">VIDIOC_S_AUDIO</code></a> ioctl. To select an audio
output (which presently has no changeable properties) applications
call the <a class="link" href="media.html#vidioc-g-audioout" title="ioctl VIDIOC_G_AUDOUT, VIDIOC_S_AUDOUT"><code class="constant">VIDIOC_S_AUDOUT</code></a> ioctl.</p><p>Drivers must implement all audio input ioctls when the device
has multiple selectable audio inputs, all audio output ioctls when the
device has multiple selectable audio outputs. When the device has any
audio inputs or outputs the driver must set the <code class="constant">V4L2_CAP_AUDIO</code>
flag in the struct <a class="link" href="media.html#v4l2-capability" title="Table A.92. struct v4l2_capability">v4l2_capability</a> returned by the <a class="link" href="media.html#vidioc-querycap" title="ioctl VIDIOC_QUERYCAP"><code class="constant">VIDIOC_QUERYCAP</code></a> ioctl.</p><div class="example"><a name="idp47350240"></a><p class="title"><b>Example 1.3. Information about the current audio input</b></p><div class="example-contents"><pre class="programlisting">
struct <a class="link" href="media.html#v4l2-audio" title="Table A.50. struct v4l2_audio">v4l2_audio</a> audio;

memset(&amp;audio, 0, sizeof(audio));

if (-1 == ioctl(fd, <a class="link" href="media.html#vidioc-g-audio" title="ioctl VIDIOC_G_AUDIO, VIDIOC_S_AUDIO"><code class="constant">VIDIOC_G_AUDIO</code></a>, &amp;audio)) {
	perror("VIDIOC_G_AUDIO");
	exit(EXIT_FAILURE);
}

printf("Current input: %s\n", audio.name);
      </pre></div></div><br class="example-break"><div class="example"><a name="idp47344848"></a><p class="title"><b>Example 1.4. Switching to the first audio input</b></p><div class="example-contents"><pre class="programlisting">
struct <a class="link" href="media.html#v4l2-audio" title="Table A.50. struct v4l2_audio">v4l2_audio</a> audio;

memset(&amp;audio, 0, sizeof(audio)); /* clear audio.mode, audio.reserved */

audio.index = 0;

if (-1 == ioctl(fd, <a class="link" href="media.html#vidioc-g-audio" title="ioctl VIDIOC_G_AUDIO, VIDIOC_S_AUDIO"><code class="constant">VIDIOC_S_AUDIO</code></a>, &amp;audio)) {
	perror("VIDIOC_S_AUDIO");
	exit(EXIT_FAILURE);
}
      </pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tuner"></a>Tuners and Modulators</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#idp47353184">Tuners</a></span></dt><dt><span class="section"><a href="media.html#idp47365392">Modulators</a></span></dt><dt><span class="section"><a href="media.html#idp47378112">Radio Frequency</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp47353184"></a>Tuners</h3></div></div></div><p>Video input devices can have one or more tuners
demodulating a RF signal. Each tuner is associated with one or more
video inputs, depending on the number of RF connectors on the tuner.
The <em class="structfield"><code>type</code></em> field of the respective
struct <a class="link" href="media.html#v4l2-input" title="Table A.38. struct v4l2_input">v4l2_input</a> returned by the <a class="link" href="media.html#vidioc-enuminput" title="ioctl VIDIOC_ENUMINPUT"><code class="constant">VIDIOC_ENUMINPUT</code></a> ioctl is set to
<code class="constant">V4L2_INPUT_TYPE_TUNER</code> and its
<em class="structfield"><code>tuner</code></em> field contains the index number of
the tuner.</p><p>Radio input devices have exactly one tuner with index zero, no
video inputs.</p><p>To query and change tuner properties applications use the
<a class="link" href="media.html#vidioc-g-tuner" title="ioctl VIDIOC_G_TUNER, VIDIOC_S_TUNER"><code class="constant">VIDIOC_G_TUNER</code></a> and <a class="link" href="media.html#vidioc-g-tuner" title="ioctl VIDIOC_G_TUNER, VIDIOC_S_TUNER"><code class="constant">VIDIOC_S_TUNER</code></a> ioctls, respectively. The
struct <a class="link" href="media.html#v4l2-tuner" title="Table A.86. struct v4l2_tuner">v4l2_tuner</a> returned by <code class="constant">VIDIOC_G_TUNER</code> also
contains signal status information applicable when the tuner of the
current video or radio input is queried. Note that
<code class="constant">VIDIOC_S_TUNER</code> does not switch the current tuner,
when there is more than one at all. The tuner is solely determined by
the current video input. Drivers must support both ioctls and set the
<code class="constant">V4L2_CAP_TUNER</code> flag in the struct <a class="link" href="media.html#v4l2-capability" title="Table A.92. struct v4l2_capability">v4l2_capability</a>
returned by the <a class="link" href="media.html#vidioc-querycap" title="ioctl VIDIOC_QUERYCAP"><code class="constant">VIDIOC_QUERYCAP</code></a> ioctl when the device has one or
more tuners.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp47365392"></a>Modulators</h3></div></div></div><p>Video output devices can have one or more modulators, uh,
modulating a video signal for radiation or connection to the antenna
input of a TV set or video recorder. Each modulator is associated with
one or more video outputs, depending on the number of RF connectors on
the modulator. The <em class="structfield"><code>type</code></em> field of the
respective struct <a class="link" href="media.html#v4l2-output" title="Table A.42. struct v4l2_output">v4l2_output</a> returned by the <a class="link" href="media.html#vidioc-enumoutput" title="ioctl VIDIOC_ENUMOUTPUT"><code class="constant">VIDIOC_ENUMOUTPUT</code></a> ioctl is
set to <code class="constant">V4L2_OUTPUT_TYPE_MODULATOR</code> and its
<em class="structfield"><code>modulator</code></em> field contains the index number
of the modulator.</p><p>Radio output devices have exactly one modulator with index
zero, no video outputs.</p><p>A video or radio device cannot support both a tuner and a
modulator. Two separate device nodes will have to be used for such
hardware, one that supports the tuner functionality and one that supports
the modulator functionality. The reason is a limitation with the
<a class="link" href="media.html#vidioc-g-frequency" title="ioctl VIDIOC_G_FREQUENCY, VIDIOC_S_FREQUENCY"><code class="constant">VIDIOC_S_FREQUENCY</code></a> ioctl where you cannot specify whether the frequency
is for a tuner or a modulator.</p><p>To query and change modulator properties applications use
the <a class="link" href="media.html#vidioc-g-modulator" title="ioctl VIDIOC_G_MODULATOR, VIDIOC_S_MODULATOR"><code class="constant">VIDIOC_G_MODULATOR</code></a> and <a class="link" href="media.html#vidioc-g-modulator" title="ioctl VIDIOC_G_MODULATOR, VIDIOC_S_MODULATOR"><code class="constant">VIDIOC_S_MODULATOR</code></a> ioctl. Note that
<code class="constant">VIDIOC_S_MODULATOR</code> does not switch the current
modulator, when there is more than one at all. The modulator is solely
determined by the current video output. Drivers must support both
ioctls and set the <code class="constant">V4L2_CAP_MODULATOR</code> flag in
the struct <a class="link" href="media.html#v4l2-capability" title="Table A.92. struct v4l2_capability">v4l2_capability</a> returned by the <a class="link" href="media.html#vidioc-querycap" title="ioctl VIDIOC_QUERYCAP"><code class="constant">VIDIOC_QUERYCAP</code></a> ioctl when the
device has one or more modulators.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp47378112"></a>Radio Frequency</h3></div></div></div><p>To get and set the tuner or modulator radio frequency
applications use the <a class="link" href="media.html#vidioc-g-frequency" title="ioctl VIDIOC_G_FREQUENCY, VIDIOC_S_FREQUENCY"><code class="constant">VIDIOC_G_FREQUENCY</code></a> and <a class="link" href="media.html#vidioc-g-frequency" title="ioctl VIDIOC_G_FREQUENCY, VIDIOC_S_FREQUENCY"><code class="constant">VIDIOC_S_FREQUENCY</code></a>
ioctl which both take a pointer to a struct <a class="link" href="media.html#v4l2-frequency" title="Table A.72. struct v4l2_frequency">v4l2_frequency</a>. These ioctls
are used for TV and radio devices alike. Drivers must support both
ioctls when the tuner or modulator ioctls are supported, or
when the device is a radio device.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="standard"></a>Video Standards</h2></div></div></div><p>Video devices typically support one or more different video
standards or variations of standards. Each video input and output may
support another set of standards. This set is reported by the
<em class="structfield"><code>std</code></em> field of struct <a class="link" href="media.html#v4l2-input" title="Table A.38. struct v4l2_input">v4l2_input</a> and
struct <a class="link" href="media.html#v4l2-output" title="Table A.42. struct v4l2_output">v4l2_output</a> returned by the <a class="link" href="media.html#vidioc-enuminput" title="ioctl VIDIOC_ENUMINPUT"><code class="constant">VIDIOC_ENUMINPUT</code></a> and
<a class="link" href="media.html#vidioc-enumoutput" title="ioctl VIDIOC_ENUMOUTPUT"><code class="constant">VIDIOC_ENUMOUTPUT</code></a> ioctls, respectively.</p><p>V4L2 defines one bit for each analog video standard
currently in use worldwide, and sets aside bits for driver defined
standards, e. g. hybrid standards to watch NTSC video tapes on PAL TVs
and vice versa. Applications can use the predefined bits to select a
particular standard, although presenting the user a menu of supported
standards is preferred. To enumerate and query the attributes of the
supported standards applications use the <a class="link" href="media.html#vidioc-enumstd" title="ioctl VIDIOC_ENUMSTD"><code class="constant">VIDIOC_ENUMSTD</code></a> ioctl.</p><p>Many of the defined standards are actually just variations
of a few major standards. The hardware may in fact not distinguish
between them, or do so internal and switch automatically. Therefore
enumerated standards also contain sets of one or more standard
bits.</p><p>Assume a hypothetic tuner capable of demodulating B/PAL,
G/PAL and I/PAL signals. The first enumerated standard is a set of B
and G/PAL, switched automatically depending on the selected radio
frequency in UHF or VHF band. Enumeration gives a "PAL-B/G" or "PAL-I"
choice. Similar a Composite input may collapse standards, enumerating
"PAL-B/G/H/I", "NTSC-M" and "SECAM-D/K".<a href="media.html#ftn.idp47392592" class="footnote" name="idp47392592"><sup class="footnote">[5]</sup></a></p><p>To query and select the standard used by the current video
input or output applications call the <a class="link" href="media.html#vidioc-g-std" title="ioctl VIDIOC_G_STD, VIDIOC_S_STD"><code class="constant">VIDIOC_G_STD</code></a> and
<a class="link" href="media.html#vidioc-g-std" title="ioctl VIDIOC_G_STD, VIDIOC_S_STD"><code class="constant">VIDIOC_S_STD</code></a> ioctl, respectively. The <span class="emphasis"><em>received</em></span>
standard can be sensed with the <a class="link" href="media.html#vidioc-querystd" title="ioctl VIDIOC_QUERYSTD"><code class="constant">VIDIOC_QUERYSTD</code></a> ioctl. Note that the
parameter of all these ioctls is a pointer to a <a class="link" href="media.html#v4l2-std-id" title="Table A.47. typedef v4l2_std_id">v4l2_std_id</a> type
(a standard set), <span class="emphasis"><em>not</em></span> an index into the standard
enumeration. Drivers must implement all video standard ioctls
when the device has one or more video inputs or outputs.</p><p>Special rules apply to devices such as USB cameras where the notion of video
standards makes little sense. More generally for any capture or output device
which is: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>incapable of capturing fields or frames at the nominal
rate of the video standard, or</p></li><li class="listitem"><p>that does not support the video standard formats at all.</p></li></ul></div><p> Here the driver shall set the
<em class="structfield"><code>std</code></em> field of struct <a class="link" href="media.html#v4l2-input" title="Table A.38. struct v4l2_input">v4l2_input</a> and struct <a class="link" href="media.html#v4l2-output" title="Table A.42. struct v4l2_output">v4l2_output</a>
to zero and the <code class="constant">VIDIOC_G_STD</code>,
<code class="constant">VIDIOC_S_STD</code>,
<code class="constant">VIDIOC_QUERYSTD</code> and
<code class="constant">VIDIOC_ENUMSTD</code> ioctls shall return the
<span class="errorcode">ENOTTY</span> error code or the <span class="errorcode">EINVAL</span> error code.</p><p>Applications can make use of the <a class="xref" href="media.html#input-capabilities" title="Table A.41. Input capabilities">Table A.41, &#8220;Input capabilities&#8221;</a> and
<a class="xref" href="media.html#output-capabilities" title="Table A.44. Output capabilities">Table A.44, &#8220;Output capabilities&#8221;</a> flags to determine whether the video standard ioctls
can be used with the given input or output.</p><div class="example"><a name="idp47410656"></a><p class="title"><b>Example 1.5. Information about the current video standard</b></p><div class="example-contents"><pre class="programlisting">
<a class="link" href="media.html#v4l2-std-id" title="Table A.47. typedef v4l2_std_id">v4l2_std_id</a> std_id;
struct <a class="link" href="media.html#v4l2-standard" title="Table A.45. struct v4l2_standard">v4l2_standard</a> standard;

if (-1 == ioctl(fd, <a class="link" href="media.html#vidioc-g-std" title="ioctl VIDIOC_G_STD, VIDIOC_S_STD"><code class="constant">VIDIOC_G_STD</code></a>, &amp;std_id)) {
	/* Note when VIDIOC_ENUMSTD always returns ENOTTY this
	   is no video device or it falls under the USB exception,
	   and VIDIOC_G_STD returning ENOTTY is no error. */

	perror("VIDIOC_G_STD");
	exit(EXIT_FAILURE);
}

memset(&amp;standard, 0, sizeof(standard));
standard.index = 0;

while (0 == ioctl(fd, <a class="link" href="media.html#vidioc-enumstd" title="ioctl VIDIOC_ENUMSTD"><code class="constant">VIDIOC_ENUMSTD</code></a>, &amp;standard)) {
	if (standard.id &amp; std_id) {
	       printf("Current video standard: %s\n", standard.name);
	       exit(EXIT_SUCCESS);
	}

	standard.index++;
}

/* EINVAL indicates the end of the enumeration, which cannot be
   empty unless this device falls under the USB exception. */

if (errno == EINVAL || standard.index == 0) {
	perror("VIDIOC_ENUMSTD");
	exit(EXIT_FAILURE);
}
      </pre></div></div><br class="example-break"><div class="example"><a name="idp47416064"></a><p class="title"><b>Example 1.6. Listing the video standards supported by the current
input</b></p><div class="example-contents"><pre class="programlisting">
struct <a class="link" href="media.html#v4l2-input" title="Table A.38. struct v4l2_input">v4l2_input</a> input;
struct <a class="link" href="media.html#v4l2-standard" title="Table A.45. struct v4l2_standard">v4l2_standard</a> standard;

memset(&amp;input, 0, sizeof(input));

if (-1 == ioctl(fd, <a class="link" href="media.html#vidioc-g-input" title="ioctl VIDIOC_G_INPUT, VIDIOC_S_INPUT"><code class="constant">VIDIOC_G_INPUT</code></a>, &amp;input.index)) {
	perror("VIDIOC_G_INPUT");
	exit(EXIT_FAILURE);
}

if (-1 == ioctl(fd, <a class="link" href="media.html#vidioc-enuminput" title="ioctl VIDIOC_ENUMINPUT"><code class="constant">VIDIOC_ENUMINPUT</code></a>, &amp;input)) {
	perror("VIDIOC_ENUM_INPUT");
	exit(EXIT_FAILURE);
}

printf("Current input %s supports:\n", input.name);

memset(&amp;standard, 0, sizeof(standard));
standard.index = 0;

while (0 == ioctl(fd, <a class="link" href="media.html#vidioc-enumstd" title="ioctl VIDIOC_ENUMSTD"><code class="constant">VIDIOC_ENUMSTD</code></a>, &amp;standard)) {
	if (standard.id &amp; input.std)
		printf("%s\n", standard.name);

	standard.index++;
}

/* EINVAL indicates the end of the enumeration, which cannot be
   empty unless this device falls under the USB exception. */

if (errno != EINVAL || standard.index == 0) {
	perror("VIDIOC_ENUMSTD");
	exit(EXIT_FAILURE);
}
      </pre></div></div><br class="example-break"><div class="example"><a name="idp47424224"></a><p class="title"><b>Example 1.7. Selecting a new video standard</b></p><div class="example-contents"><pre class="programlisting">
struct <a class="link" href="media.html#v4l2-input" title="Table A.38. struct v4l2_input">v4l2_input</a> input;
<a class="link" href="media.html#v4l2-std-id" title="Table A.47. typedef v4l2_std_id">v4l2_std_id</a> std_id;

memset(&amp;input, 0, sizeof(input));

if (-1 == ioctl(fd, <a class="link" href="media.html#vidioc-g-input" title="ioctl VIDIOC_G_INPUT, VIDIOC_S_INPUT"><code class="constant">VIDIOC_G_INPUT</code></a>, &amp;input.index)) {
	perror("VIDIOC_G_INPUT");
	exit(EXIT_FAILURE);
}

if (-1 == ioctl(fd, <a class="link" href="media.html#vidioc-enuminput" title="ioctl VIDIOC_ENUMINPUT"><code class="constant">VIDIOC_ENUMINPUT</code></a>, &amp;input)) {
	perror("VIDIOC_ENUM_INPUT");
	exit(EXIT_FAILURE);
}

if (0 == (input.std &amp; V4L2_STD_PAL_BG)) {
	fprintf(stderr, "Oops. B/G PAL is not supported.\n");
	exit(EXIT_FAILURE);
}

/* Note this is also supposed to work when only B
   <span class="emphasis"><em>or</em></span> G/PAL is supported. */

std_id = V4L2_STD_PAL_BG;

if (-1 == ioctl(fd, <a class="link" href="media.html#vidioc-g-std" title="ioctl VIDIOC_G_STD, VIDIOC_S_STD"><code class="constant">VIDIOC_S_STD</code></a>, &amp;std_id)) {
	perror("VIDIOC_S_STD");
	exit(EXIT_FAILURE);
}
      </pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dv-timings"></a>Digital Video (DV) Timings</h2></div></div></div><p>
	The video standards discussed so far have been dealing with Analog TV and the
corresponding video timings. Today there are many more different hardware interfaces
such as High Definition TV interfaces (HDMI), VGA, DVI connectors etc., that carry
video signals and there is a need to extend the API to select the video timings
for these interfaces. Since it is not possible to extend the <a class="link" href="media.html#v4l2-std-id" title="Table A.47. typedef v4l2_std_id">v4l2_std_id</a> due to
the limited bits available, a new set of ioctls was added to set/get video timings at
the input and output.</p><p>These ioctls deal with the detailed digital video timings that define
each video format. This includes parameters such as the active video width and height,
signal polarities, frontporches, backporches, sync widths etc. The <code class="filename">linux/v4l2-dv-timings.h</code>
header can be used to get the timings of the formats in the <a class="xref" href="media.html#cea861" title="A DTV Profile for Uncompressed High Speed Digital Interfaces">[<abbr class="abbrev">CEA-861-E</abbr>]</a> and
<a class="xref" href="media.html#vesadmt" title="VESA and Industry Standards and Guidelines for Computer Display Monitor Timing (DMT)">[<abbr class="abbrev">VESA DMT</abbr>]</a> standards.
	</p><p>To enumerate and query the attributes of the DV timings supported by a device
	applications use the <a class="link" href="media.html#vidioc-enum-dv-timings" title="ioctl VIDIOC_ENUM_DV_TIMINGS, VIDIOC_SUBDEV_ENUM_DV_TIMINGS"><code class="constant">VIDIOC_ENUM_DV_TIMINGS</code></a> and <a class="link" href="media.html#vidioc-dv-timings-cap" title="ioctl VIDIOC_DV_TIMINGS_CAP, VIDIOC_SUBDEV_DV_TIMINGS_CAP"><code class="constant">VIDIOC_DV_TIMINGS_CAP</code></a> ioctls.
	To set DV timings for the device applications use the
<a class="link" href="media.html#vidioc-g-dv-timings" title="ioctl VIDIOC_G_DV_TIMINGS, VIDIOC_S_DV_TIMINGS"><code class="constant">VIDIOC_S_DV_TIMINGS</code></a> ioctl and to get current DV timings they use the
<a class="link" href="media.html#vidioc-g-dv-timings" title="ioctl VIDIOC_G_DV_TIMINGS, VIDIOC_S_DV_TIMINGS"><code class="constant">VIDIOC_G_DV_TIMINGS</code></a> ioctl. To detect the DV timings as seen by the video receiver applications
use the <a class="link" href="media.html#vidioc-query-dv-timings" title="ioctl VIDIOC_QUERY_DV_TIMINGS"><code class="constant">VIDIOC_QUERY_DV_TIMINGS</code></a> ioctl.</p><p>Applications can make use of the <a class="xref" href="media.html#input-capabilities" title="Table A.41. Input capabilities">Table A.41, &#8220;Input capabilities&#8221;</a> and
<a class="xref" href="media.html#output-capabilities" title="Table A.44. Output capabilities">Table A.44, &#8220;Output capabilities&#8221;</a> flags to determine whether the digital video ioctls
can be used with the given input or output.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="control"></a>User Controls</h2></div></div></div><p>Devices typically have a number of user-settable controls
such as brightness, saturation and so on, which would be presented to
the user on a graphical user interface. But, different devices
will have different controls available, and furthermore, the range of
possible values, and the default value will vary from device to
device. The control ioctls provide the information and a mechanism to
create a nice user interface for these controls that will work
correctly with any device.</p><p>All controls are accessed using an ID value. V4L2 defines
several IDs for specific purposes. Drivers can also implement their
own custom controls using <code class="constant">V4L2_CID_PRIVATE_BASE</code>
<a href="media.html#ftn.idp47451360" class="footnote" name="idp47451360"><sup class="footnote">[6]</sup></a>
and higher values. The pre-defined control IDs have the prefix
<code class="constant">V4L2_CID_</code>, and are listed in <a class="xref" href="media.html#control-id" title="Table 1.1. Control IDs">Table 1.1, &#8220;Control IDs&#8221;</a>. The ID is used when querying the attributes of
a control, and when getting or setting the current value.</p><p>Generally applications should present controls to the user
without assumptions about their purpose. Each control comes with a
name string the user is supposed to understand. When the purpose is
non-intuitive the driver writer should provide a user manual, a user
interface plug-in or a driver specific panel application. Predefined
IDs were introduced to change a few controls programmatically, for
example to mute a device during a channel switch.</p><p>Drivers may enumerate different controls after switching
the current video input or output, tuner or modulator, or audio input
or output. Different in the sense of other bounds, another default and
current value, step size or other menu items. A control with a certain
<span class="emphasis"><em>custom</em></span> ID can also change name and
type.</p><p>If a control is not applicable to the current configuration
of the device (for example, it doesn't apply to the current video input)
drivers set the <code class="constant">V4L2_CTRL_FLAG_INACTIVE</code> flag.</p><p>Control values are stored globally, they do not
change when switching except to stay within the reported bounds. They
also do not change e. g. when the device is opened or closed, when the
tuner radio frequency is changed or generally never without
application request.</p><p>V4L2 specifies an event mechanism to notify applications
when controls change value (see <a class="link" href="media.html#vidioc-subscribe-event" title="ioctl VIDIOC_SUBSCRIBE_EVENT, VIDIOC_UNSUBSCRIBE_EVENT"><code class="constant">VIDIOC_SUBSCRIBE_EVENT</code></a>, event
<code class="constant">V4L2_EVENT_CTRL</code>), panel applications might want to make
use of that in order to always reflect the correct control value.</p><p>
      All controls use machine endianness.
    </p><div class="table"><a name="control-id"></a><p class="title"><b>Table 1.1. Control IDs</b></p><div class="table-contents"><table summary="Control IDs" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><thead><tr><th>ID</th><th>Type</th><th>Description</th></tr></thead><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_CID_BASE</code></td><td valign="top"> </td><td valign="top">First predefined ID, equal to
<code class="constant">V4L2_CID_BRIGHTNESS</code>.</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_USER_BASE</code></td><td valign="top"> </td><td valign="top">Synonym of <code class="constant">V4L2_CID_BASE</code>.</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_BRIGHTNESS</code></td><td valign="top">integer</td><td valign="top">Picture brightness, or more precisely, the black
level.</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_CONTRAST</code></td><td valign="top">integer</td><td valign="top">Picture contrast or luma gain.</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_SATURATION</code></td><td valign="top">integer</td><td valign="top">Picture color saturation or chroma gain.</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_HUE</code></td><td valign="top">integer</td><td valign="top">Hue or color balance.</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_AUDIO_VOLUME</code></td><td valign="top">integer</td><td valign="top">Overall audio volume. Note some drivers also
provide an OSS or ALSA mixer interface.</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_AUDIO_BALANCE</code></td><td valign="top">integer</td><td valign="top">Audio stereo balance. Minimum corresponds to all
the way left, maximum to right.</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_AUDIO_BASS</code></td><td valign="top">integer</td><td valign="top">Audio bass adjustment.</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_AUDIO_TREBLE</code></td><td valign="top">integer</td><td valign="top">Audio treble adjustment.</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_AUDIO_MUTE</code></td><td valign="top">boolean</td><td valign="top">Mute audio, i. e. set the volume to zero, however
without affecting <code class="constant">V4L2_CID_AUDIO_VOLUME</code>. Like
ALSA drivers, V4L2 drivers must mute at load time to avoid excessive
noise. Actually the entire device should be reset to a low power
consumption state.</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_AUDIO_LOUDNESS</code></td><td valign="top">boolean</td><td valign="top">Loudness mode (bass boost).</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_BLACK_LEVEL</code></td><td valign="top">integer</td><td valign="top">Another name for brightness (not a synonym of
<code class="constant">V4L2_CID_BRIGHTNESS</code>). This control is deprecated
and should not be used in new drivers and applications.</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_AUTO_WHITE_BALANCE</code></td><td valign="top">boolean</td><td valign="top">Automatic white balance (cameras).</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_DO_WHITE_BALANCE</code></td><td valign="top">button</td><td valign="top">This is an action control. When set (the value is
ignored), the device will do a white balance and then hold the current
setting. Contrast this with the boolean
<code class="constant">V4L2_CID_AUTO_WHITE_BALANCE</code>, which, when
activated, keeps adjusting the white balance.</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_RED_BALANCE</code></td><td valign="top">integer</td><td valign="top">Red chroma balance.</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_BLUE_BALANCE</code></td><td valign="top">integer</td><td valign="top">Blue chroma balance.</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_GAMMA</code></td><td valign="top">integer</td><td valign="top">Gamma adjust.</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_WHITENESS</code></td><td valign="top">integer</td><td valign="top">Whiteness for grey-scale devices. This is a synonym
for <code class="constant">V4L2_CID_GAMMA</code>. This control is deprecated
and should not be used in new drivers and applications.</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_EXPOSURE</code></td><td valign="top">integer</td><td valign="top">Exposure (cameras). [Unit?]</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_AUTOGAIN</code></td><td valign="top">boolean</td><td valign="top">Automatic gain/exposure control.</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_GAIN</code></td><td valign="top">integer</td><td valign="top">Gain control.</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_HFLIP</code></td><td valign="top">boolean</td><td valign="top">Mirror the picture horizontally.</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_VFLIP</code></td><td valign="top">boolean</td><td valign="top">Mirror the picture vertically.</td></tr><tr><td valign="top"><a name="v4l2-power-line-frequency"></a><code class="constant">V4L2_CID_POWER_LINE_FREQUENCY</code></td><td valign="top">enum</td><td valign="top">Enables a power line frequency filter to avoid
flicker. Possible values for <code class="constant">enum v4l2_power_line_frequency</code> are:
<code class="constant">V4L2_CID_POWER_LINE_FREQUENCY_DISABLED</code> (0),
<code class="constant">V4L2_CID_POWER_LINE_FREQUENCY_50HZ</code> (1),
<code class="constant">V4L2_CID_POWER_LINE_FREQUENCY_60HZ</code> (2) and
<code class="constant">V4L2_CID_POWER_LINE_FREQUENCY_AUTO</code> (3).</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_HUE_AUTO</code></td><td valign="top">boolean</td><td valign="top">Enables automatic hue control by the device. The
effect of setting <code class="constant">V4L2_CID_HUE</code> while automatic
hue control is enabled is undefined, drivers should ignore such
request.</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_WHITE_BALANCE_TEMPERATURE</code></td><td valign="top">integer</td><td valign="top">This control specifies the white balance settings
as a color temperature in Kelvin. A driver should have a minimum of
2800 (incandescent) to 6500 (daylight). For more information about
color temperature see <a class="ulink" href="http://en.wikipedia.org/wiki/Color_temperature" target="_top">Wikipedia</a>.</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_SHARPNESS</code></td><td valign="top">integer</td><td valign="top">Adjusts the sharpness filters in a camera. The
minimum value disables the filters, higher values give a sharper
picture.</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_BACKLIGHT_COMPENSATION</code></td><td valign="top">integer</td><td valign="top">Adjusts the backlight compensation in a camera. The
minimum value disables backlight compensation.</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_CHROMA_AGC</code></td><td valign="top">boolean</td><td valign="top">Chroma automatic gain control.</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_CHROMA_GAIN</code></td><td valign="top">integer</td><td valign="top">Adjusts the Chroma gain control (for use when chroma AGC
	    is disabled).</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_COLOR_KILLER</code></td><td valign="top">boolean</td><td valign="top">Enable the color killer (i. e. force a black &amp; white image in case of a weak video signal).</td></tr><tr><td valign="top"><a name="v4l2-colorfx"></a><code class="constant">V4L2_CID_COLORFX</code></td><td valign="top">enum</td><td valign="top">Selects a color effect. The following values are defined:
	    </td></tr><tr><td valign="top"> </td><td valign="top"> </td><td valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_COLORFX_NONE</code> </td><td valign="top">Color effect is disabled.</td></tr><tr><td valign="top"><code class="constant">V4L2_COLORFX_ANTIQUE</code> </td><td valign="top">An aging (old photo) effect.</td></tr><tr><td valign="top"><code class="constant">V4L2_COLORFX_ART_FREEZE</code> </td><td valign="top">Frost color effect.</td></tr><tr><td valign="top"><code class="constant">V4L2_COLORFX_AQUA</code> </td><td valign="top">Water color, cool tone.</td></tr><tr><td valign="top"><code class="constant">V4L2_COLORFX_BW</code> </td><td valign="top">Black and white.</td></tr><tr><td valign="top"><code class="constant">V4L2_COLORFX_EMBOSS</code> </td><td valign="top">Emboss, the highlights and shadows replace light/dark boundaries
		  and low contrast areas are set to a gray background.</td></tr><tr><td valign="top"><code class="constant">V4L2_COLORFX_GRASS_GREEN</code> </td><td valign="top">Grass green.</td></tr><tr><td valign="top"><code class="constant">V4L2_COLORFX_NEGATIVE</code> </td><td valign="top">Negative.</td></tr><tr><td valign="top"><code class="constant">V4L2_COLORFX_SEPIA</code> </td><td valign="top">Sepia tone.</td></tr><tr><td valign="top"><code class="constant">V4L2_COLORFX_SKETCH</code> </td><td valign="top">Sketch.</td></tr><tr><td valign="top"><code class="constant">V4L2_COLORFX_SKIN_WHITEN</code> </td><td valign="top">Skin whiten.</td></tr><tr><td valign="top"><code class="constant">V4L2_COLORFX_SKY_BLUE</code> </td><td valign="top">Sky blue.</td></tr><tr><td valign="top"><code class="constant">V4L2_COLORFX_SOLARIZATION</code> </td><td valign="top">Solarization, the image is partially reversed in tone,
		  only color values above or below a certain threshold are inverted.
		  </td></tr><tr><td valign="top"><code class="constant">V4L2_COLORFX_SILHOUETTE</code> </td><td valign="top">Silhouette (outline).</td></tr><tr><td valign="top"><code class="constant">V4L2_COLORFX_VIVID</code> </td><td valign="top">Vivid colors.</td></tr><tr><td valign="top"><code class="constant">V4L2_COLORFX_SET_CBCR</code> </td><td valign="top">The Cb and Cr chroma components are replaced by fixed
		  coefficients determined by <code class="constant">V4L2_CID_COLORFX_CBCR</code>
		  control.</td></tr></tbody></table></td></tr><tr><td valign="top"><code class="constant">V4L2_CID_COLORFX_CBCR</code></td><td valign="top">integer</td><td valign="top">Determines the Cb and Cr coefficients for <code class="constant">V4L2_COLORFX_SET_CBCR</code>
	    color effect. Bits [7:0] of the supplied 32 bit value are interpreted as
	    Cr component, bits [15:8] as Cb component and bits [31:16] must be zero.
	  </td></tr><tr><td valign="top"><code class="constant">V4L2_CID_AUTOBRIGHTNESS</code></td><td valign="top">boolean</td><td valign="top">Enable Automatic Brightness.</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_ROTATE</code></td><td valign="top">integer</td><td valign="top">Rotates the image by specified angle. Common angles are 90,
	    270 and 180. Rotating the image to 90 and 270 will reverse the height
	    and width of the display window. It is necessary to set the new height and
	    width of the picture using the <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> ioctl according to
	    the rotation angle selected.</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_BG_COLOR</code></td><td valign="top">integer</td><td valign="top">Sets the background color on the current output device.
	    Background color needs to be specified in the RGB24 format. The
	    supplied 32 bit value is interpreted as bits 0-7 Red color information,
	    bits 8-15 Green color information, bits 16-23 Blue color
	    information and bits 24-31 must be zero.</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_ILLUMINATORS_1</code>
		<code class="constant">V4L2_CID_ILLUMINATORS_2</code></td><td valign="top">boolean</td><td valign="top">Switch on or off the illuminator 1 or 2 of the device
		(usually a microscope).</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_MIN_BUFFERS_FOR_CAPTURE</code></td><td valign="top">integer</td><td valign="top">This is a read-only control that can be read by the application
and used as a hint to determine the number of CAPTURE buffers to pass to REQBUFS.
The value is the minimum number of CAPTURE buffers that is necessary for hardware
to work.</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_MIN_BUFFERS_FOR_OUTPUT</code></td><td valign="top">integer</td><td valign="top">This is a read-only control that can be read by the application
and used as a hint to determine the number of OUTPUT buffers to pass to REQBUFS.
The value is the minimum number of OUTPUT buffers that is necessary for hardware
to work.</td></tr><tr><td valign="top"><a name="v4l2-alpha-component"></a><code class="constant">V4L2_CID_ALPHA_COMPONENT</code></td><td valign="top">integer</td><td valign="top">Sets the alpha color component. When a capture device (or
	    capture queue of a mem-to-mem device) produces a frame format that
	    includes an alpha component
	    (e.g. <a class="link" href="media.html#rgb-formats" title="Table 2.16. Packed RGB Image Formats">packed RGB image formats</a>)
	    and the alpha value is not defined by the device or the mem-to-mem
	    input data this control lets you select the alpha component value of
	    all pixels. When an output device (or output queue of a mem-to-mem
	    device) consumes a frame format that doesn't include an alpha
	    component and the device supports alpha channel processing this
	    control lets you set the alpha component value of all pixels for
	    further processing in the device.
	    </td></tr><tr><td valign="top"><code class="constant">V4L2_CID_LASTP1</code></td><td valign="top"> </td><td valign="top">End of the predefined control IDs (currently
	      <code class="constant">V4L2_CID_ALPHA_COMPONENT</code> + 1).</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_PRIVATE_BASE</code></td><td valign="top"> </td><td valign="top">ID of the first custom (driver specific) control.
Applications depending on particular custom controls should check the
driver name and version, see <a class="xref" href="media.html#querycap" title="Querying Capabilities">the section called &#8220;Querying Capabilities&#8221;</a>.</td></tr></tbody></table></div></div><br class="table-break"><p>Applications can enumerate the available controls with the
<a class="link" href="media.html#vidioc-queryctrl" title="ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU"><code class="constant">VIDIOC_QUERYCTRL</code></a> and <a class="link" href="media.html#vidioc-queryctrl" title="ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU"><code class="constant">VIDIOC_QUERYMENU</code></a> ioctls, get and set a
control value with the <a class="link" href="media.html#vidioc-g-ctrl" title="ioctl VIDIOC_G_CTRL, VIDIOC_S_CTRL"><code class="constant">VIDIOC_G_CTRL</code></a> and <a class="link" href="media.html#vidioc-g-ctrl" title="ioctl VIDIOC_G_CTRL, VIDIOC_S_CTRL"><code class="constant">VIDIOC_S_CTRL</code></a> ioctls.
Drivers must implement <code class="constant">VIDIOC_QUERYCTRL</code>,
<code class="constant">VIDIOC_G_CTRL</code> and
<code class="constant">VIDIOC_S_CTRL</code> when the device has one or more
controls, <code class="constant">VIDIOC_QUERYMENU</code> when it has one or
more menu type controls.</p><div class="example"><a name="enum_all_controls"></a><p class="title"><b>Example 1.8. Enumerating all user controls</b></p><div class="example-contents"><pre class="programlisting">
struct <a class="link" href="media.html#v4l2-queryctrl" title="Table A.94. struct v4l2_queryctrl">v4l2_queryctrl</a> queryctrl;
struct <a class="link" href="media.html#v4l2-querymenu" title="Table A.96. struct v4l2_querymenu">v4l2_querymenu</a> querymenu;

static void enumerate_menu(void)
{
	printf("  Menu items:\n");

	memset(&amp;querymenu, 0, sizeof(querymenu));
	querymenu.id = queryctrl.id;

	for (querymenu.index = queryctrl.minimum;
	     querymenu.index &lt;= queryctrl.maximum;
	     querymenu.index++) {
		if (0 == ioctl(fd, <a class="link" href="media.html#vidioc-queryctrl" title="ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU"><code class="constant">VIDIOC_QUERYMENU</code></a>, &amp;querymenu)) {
			printf("  %s\n", querymenu.name);
		}
	}
}

memset(&amp;queryctrl, 0, sizeof(queryctrl));

for (queryctrl.id = V4L2_CID_BASE;
     queryctrl.id &lt; V4L2_CID_LASTP1;
     queryctrl.id++) {
	if (0 == ioctl(fd, <a class="link" href="media.html#vidioc-queryctrl" title="ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU"><code class="constant">VIDIOC_QUERYCTRL</code></a>, &amp;queryctrl)) {
		if (queryctrl.flags &amp; V4L2_CTRL_FLAG_DISABLED)
			continue;

		printf("Control %s\n", queryctrl.name);

		if (queryctrl.type == V4L2_CTRL_TYPE_MENU)
			enumerate_menu();
	} else {
		if (errno == EINVAL)
			continue;

		perror("VIDIOC_QUERYCTRL");
		exit(EXIT_FAILURE);
	}
}

for (queryctrl.id = V4L2_CID_PRIVATE_BASE;;
     queryctrl.id++) {
	if (0 == ioctl(fd, <a class="link" href="media.html#vidioc-queryctrl" title="ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU"><code class="constant">VIDIOC_QUERYCTRL</code></a>, &amp;queryctrl)) {
		if (queryctrl.flags &amp; V4L2_CTRL_FLAG_DISABLED)
			continue;

		printf("Control %s\n", queryctrl.name);

		if (queryctrl.type == V4L2_CTRL_TYPE_MENU)
			enumerate_menu();
	} else {
		if (errno == EINVAL)
			break;

		perror("VIDIOC_QUERYCTRL");
		exit(EXIT_FAILURE);
	}
}
</pre></div></div><br class="example-break"><div class="example"><a name="idp47644784"></a><p class="title"><b>Example 1.9. Enumerating all user controls (alternative)</b></p><div class="example-contents"><pre class="programlisting">
memset(&amp;queryctrl, 0, sizeof(queryctrl));

queryctrl.id = V4L2_CTRL_CLASS_USER | V4L2_CTRL_FLAG_NEXT_CTRL;
while (0 == ioctl(fd, <a class="link" href="media.html#vidioc-queryctrl" title="ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU"><code class="constant">VIDIOC_QUERYCTRL</code></a>, &amp;queryctrl)) {
	if (V4L2_CTRL_ID2CLASS(queryctrl.id) != V4L2_CTRL_CLASS_USER)
		break;
	if (queryctrl.flags &amp; V4L2_CTRL_FLAG_DISABLED)
		continue;

	printf("Control %s\n", queryctrl.name);

	if (queryctrl.type == V4L2_CTRL_TYPE_MENU)
		enumerate_menu();

	queryctrl.id |= V4L2_CTRL_FLAG_NEXT_CTRL;
}
if (errno != EINVAL) {
	perror("VIDIOC_QUERYCTRL");
	exit(EXIT_FAILURE);
}
</pre></div></div><br class="example-break"><div class="example"><a name="idp47648240"></a><p class="title"><b>Example 1.10. Changing controls</b></p><div class="example-contents"><pre class="programlisting">
struct <a class="link" href="media.html#v4l2-queryctrl" title="Table A.94. struct v4l2_queryctrl">v4l2_queryctrl</a> queryctrl;
struct <a class="link" href="media.html#v4l2-control" title="Table A.55. struct v4l2_control">v4l2_control</a> control;

memset(&amp;queryctrl, 0, sizeof(queryctrl));
queryctrl.id = V4L2_CID_BRIGHTNESS;

if (-1 == ioctl(fd, <a class="link" href="media.html#vidioc-queryctrl" title="ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU"><code class="constant">VIDIOC_QUERYCTRL</code></a>, &amp;queryctrl)) {
	if (errno != EINVAL) {
		perror("VIDIOC_QUERYCTRL");
		exit(EXIT_FAILURE);
	} else {
		printf("V4L2_CID_BRIGHTNESS is not supported\n");
	}
} else if (queryctrl.flags &amp; V4L2_CTRL_FLAG_DISABLED) {
	printf("V4L2_CID_BRIGHTNESS is not supported\n");
} else {
	memset(&amp;control, 0, sizeof (control));
	control.id = V4L2_CID_BRIGHTNESS;
	control.value = queryctrl.default_value;

	if (-1 == ioctl(fd, <a class="link" href="media.html#vidioc-g-ctrl" title="ioctl VIDIOC_G_CTRL, VIDIOC_S_CTRL"><code class="constant">VIDIOC_S_CTRL</code></a>, &amp;control)) {
		perror("VIDIOC_S_CTRL");
		exit(EXIT_FAILURE);
	}
}

memset(&amp;control, 0, sizeof(control));
control.id = V4L2_CID_CONTRAST;

if (0 == ioctl(fd, <a class="link" href="media.html#vidioc-g-ctrl" title="ioctl VIDIOC_G_CTRL, VIDIOC_S_CTRL"><code class="constant">VIDIOC_G_CTRL</code></a>, &amp;control)) {
	control.value += 1;

	/* The driver may clamp the value or return ERANGE, ignored here */

	if (-1 == ioctl(fd, <a class="link" href="media.html#vidioc-g-ctrl" title="ioctl VIDIOC_G_CTRL, VIDIOC_S_CTRL"><code class="constant">VIDIOC_S_CTRL</code></a>, &amp;control)
	    &amp;&amp; errno != ERANGE) {
		perror("VIDIOC_S_CTRL");
		exit(EXIT_FAILURE);
	}
/* Ignore if V4L2_CID_CONTRAST is unsupported */
} else if (errno != EINVAL) {
	perror("VIDIOC_G_CTRL");
	exit(EXIT_FAILURE);
}

control.id = V4L2_CID_AUDIO_MUTE;
control.value = 1; /* silence */

/* Errors ignored */
ioctl(fd, VIDIOC_S_CTRL, &amp;control);
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="extended-controls"></a>Extended Controls</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#idp47658496">Introduction</a></span></dt><dt><span class="section"><a href="media.html#idp47662144">The Extended Control API</a></span></dt><dt><span class="section"><a href="media.html#idp47686784">Enumerating Extended Controls</a></span></dt><dt><span class="section"><a href="media.html#idp47456288">Creating Control Panels</a></span></dt><dt><span class="section"><a href="media.html#mpeg-controls">Codec Control Reference</a></span></dt><dt><span class="section"><a href="media.html#camera-controls">Camera Control Reference</a></span></dt><dt><span class="section"><a href="media.html#fm-tx-controls">FM Transmitter Control Reference</a></span></dt><dt><span class="section"><a href="media.html#flash-controls">Flash Control Reference</a></span></dt><dt><span class="section"><a href="media.html#jpeg-controls">JPEG Control Reference</a></span></dt><dt><span class="section"><a href="media.html#image-source-controls">Image Source Control Reference</a></span></dt><dt><span class="section"><a href="media.html#image-process-controls">Image Process Control Reference</a></span></dt><dt><span class="section"><a href="media.html#dv-controls">Digital Video Control Reference</a></span></dt><dt><span class="section"><a href="media.html#fm-rx-controls">FM Receiver Control Reference</a></span></dt><dt><span class="section"><a href="media.html#detect-controls">Detect Control Reference</a></span></dt><dt><span class="section"><a href="media.html#rf-tuner-controls">RF Tuner Control Reference</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp47658496"></a>Introduction</h3></div></div></div><p>The control mechanism as originally designed was meant
to be used for user settings (brightness, saturation, etc). However,
it turned out to be a very useful model for implementing more
complicated driver APIs where each driver implements only a subset of
a larger API.</p><p>The MPEG encoding API was the driving force behind
designing and implementing this extended control mechanism: the MPEG
standard is quite large and the currently supported hardware MPEG
encoders each only implement a subset of this standard. Further more,
many parameters relating to how the video is encoded into an MPEG
stream are specific to the MPEG encoding chip since the MPEG standard
only defines the format of the resulting MPEG stream, not how the
video is actually encoded into that format.</p><p>Unfortunately, the original control API lacked some
features needed for these new uses and so it was extended into the
(not terribly originally named) extended control API.</p><p>Even though the MPEG encoding API was the first effort
to use the Extended Control API, nowadays there are also other classes
of Extended Controls, such as Camera Controls and FM Transmitter Controls.
The Extended Controls API as well as all Extended Controls classes are
described in the following text.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp47662144"></a>The Extended Control API</h3></div></div></div><p>Three new ioctls are available: <a class="link" href="media.html#vidioc-g-ext-ctrls" title="ioctl VIDIOC_G_EXT_CTRLS, VIDIOC_S_EXT_CTRLS, VIDIOC_TRY_EXT_CTRLS"><code class="constant">VIDIOC_G_EXT_CTRLS</code></a>,
<a class="link" href="media.html#vidioc-g-ext-ctrls" title="ioctl VIDIOC_G_EXT_CTRLS, VIDIOC_S_EXT_CTRLS, VIDIOC_TRY_EXT_CTRLS"><code class="constant">VIDIOC_S_EXT_CTRLS</code></a> and <a class="link" href="media.html#vidioc-g-ext-ctrls" title="ioctl VIDIOC_G_EXT_CTRLS, VIDIOC_S_EXT_CTRLS, VIDIOC_TRY_EXT_CTRLS"><code class="constant">VIDIOC_TRY_EXT_CTRLS</code></a>. These ioctls act on
arrays of controls (as opposed to the <a class="link" href="media.html#vidioc-g-ctrl" title="ioctl VIDIOC_G_CTRL, VIDIOC_S_CTRL"><code class="constant">VIDIOC_G_CTRL</code></a> and
<a class="link" href="media.html#vidioc-g-ctrl" title="ioctl VIDIOC_G_CTRL, VIDIOC_S_CTRL"><code class="constant">VIDIOC_S_CTRL</code></a> ioctls that act on a single control). This is needed
since it is often required to atomically change several controls at
once.</p><p>Each of the new ioctls expects a pointer to a
struct <a class="link" href="media.html#v4l2-ext-controls" title="Table A.66. struct v4l2_ext_controls">v4l2_ext_controls</a>. This structure contains a pointer to the control
array, a count of the number of controls in that array and a control
class. Control classes are used to group similar controls into a
single class. For example, control class
<code class="constant">V4L2_CTRL_CLASS_USER</code> contains all user controls
(i. e. all controls that can also be set using the old
<code class="constant">VIDIOC_S_CTRL</code> ioctl). Control class
<code class="constant">V4L2_CTRL_CLASS_MPEG</code> contains all controls
relating to MPEG encoding, etc.</p><p>All controls in the control array must belong to the
specified control class. An error is returned if this is not the
case.</p><p>It is also possible to use an empty control array (count
== 0) to check whether the specified control class is
supported.</p><p>The control array is a struct <a class="link" href="media.html#v4l2-ext-control" title="Table A.65. struct v4l2_ext_control">v4l2_ext_control</a> array. The
<span class="structname">v4l2_ext_control</span> structure is very similar to
struct <a class="link" href="media.html#v4l2-control" title="Table A.55. struct v4l2_control">v4l2_control</a>, except for the fact that it also allows for 64-bit
values and pointers to be passed.</p><p>Since the struct <a class="link" href="media.html#v4l2-ext-control" title="Table A.65. struct v4l2_ext_control">v4l2_ext_control</a> supports pointers it is now
also possible to have controls with compound types such as N-dimensional arrays
and/or structures. You need to specify the <code class="constant">V4L2_CTRL_FLAG_NEXT_COMPOUND</code>
when enumerating controls to actually be able to see such compound controls.
In other words, these controls with compound types should only be used
programmatically.</p><p>Since such compound controls need to expose more information
about themselves than is possible with <a class="link" href="media.html#vidioc-queryctrl" title="ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU"><code class="constant">VIDIOC_QUERYCTRL</code></a> the
<a class="link" href="media.html#vidioc-queryctrl" title="ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU"><code class="constant">VIDIOC_QUERY_EXT_CTRL</code></a> ioctl was added. In particular, this ioctl gives
the dimensions of the N-dimensional array if this control consists of more than
one element.</p><p>It is important to realize that due to the flexibility of
controls it is necessary to check whether the control you want to set
actually is supported in the driver and what the valid range of values
is. So use the <a class="link" href="media.html#vidioc-queryctrl" title="ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU"><code class="constant">VIDIOC_QUERYCTRL</code></a> (or <a class="link" href="media.html#vidioc-queryctrl" title="ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU"><code class="constant">VIDIOC_QUERY_EXT_CTRL</code></a>) and
<a class="link" href="media.html#vidioc-queryctrl" title="ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU"><code class="constant">VIDIOC_QUERYMENU</code></a> ioctls to check this. Also note that it is possible
that some of the menu indices in a control of type
<code class="constant">V4L2_CTRL_TYPE_MENU</code> may not be supported
(<code class="constant">VIDIOC_QUERYMENU</code> will return an error). A good
example is the list of supported MPEG audio bitrates. Some drivers only
support one or two bitrates, others support a wider range.</p><p>
	All controls use machine endianness.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp47686784"></a>Enumerating Extended Controls</h3></div></div></div><p>The recommended way to enumerate over the extended
controls is by using <a class="link" href="media.html#vidioc-queryctrl" title="ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU"><code class="constant">VIDIOC_QUERYCTRL</code></a> in combination with the
<code class="constant">V4L2_CTRL_FLAG_NEXT_CTRL</code> flag:</p><div class="informalexample"><pre class="programlisting">
struct <a class="link" href="media.html#v4l2-queryctrl" title="Table A.94. struct v4l2_queryctrl">v4l2_queryctrl</a> qctrl;

qctrl.id = V4L2_CTRL_FLAG_NEXT_CTRL;
while (0 == ioctl (fd, <a class="link" href="media.html#vidioc-queryctrl" title="ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU"><code class="constant">VIDIOC_QUERYCTRL</code></a>, &amp;qctrl)) {
	/* ... */
	qctrl.id |= V4L2_CTRL_FLAG_NEXT_CTRL;
}
</pre></div><p>The initial control ID is set to 0 ORed with the
<code class="constant">V4L2_CTRL_FLAG_NEXT_CTRL</code> flag. The
<code class="constant">VIDIOC_QUERYCTRL</code> ioctl will return the first
control with a higher ID than the specified one. When no such controls
are found an error is returned.</p><p>If you want to get all controls within a specific control
class, then you can set the initial
<em class="structfield"><code>qctrl.id</code></em> value to the control class and add
an extra check to break out of the loop when a control of another
control class is found:</p><div class="informalexample"><pre class="programlisting">
qctrl.id = V4L2_CTRL_CLASS_MPEG | V4L2_CTRL_FLAG_NEXT_CTRL;
while (0 == ioctl(fd, <a class="link" href="media.html#vidioc-queryctrl" title="ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU"><code class="constant">VIDIOC_QUERYCTRL</code></a>, &amp;qctrl)) {
	if (V4L2_CTRL_ID2CLASS(qctrl.id) != V4L2_CTRL_CLASS_MPEG)
		break;
		/* ... */
	qctrl.id |= V4L2_CTRL_FLAG_NEXT_CTRL;
}
</pre></div><p>The 32-bit <em class="structfield"><code>qctrl.id</code></em> value is
subdivided into three bit ranges: the top 4 bits are reserved for
flags (e. g. <code class="constant">V4L2_CTRL_FLAG_NEXT_CTRL</code>) and are not
actually part of the ID. The remaining 28 bits form the control ID, of
which the most significant 12 bits define the control class and the
least significant 16 bits identify the control within the control
class. It is guaranteed that these last 16 bits are always non-zero
for controls. The range of 0x1000 and up are reserved for
driver-specific controls. The macro
<code class="constant">V4L2_CTRL_ID2CLASS(id)</code> returns the control class
ID based on a control ID.</p><p>If the driver does not support extended controls, then
<code class="constant">VIDIOC_QUERYCTRL</code> will fail when used in
combination with <code class="constant">V4L2_CTRL_FLAG_NEXT_CTRL</code>. In
that case the old method of enumerating control should be used (see
<a class="xref" href="media.html#enum_all_controls" title="Example 1.8. Enumerating all user controls">Example 1.8, &#8220;Enumerating all user controls&#8221;</a>). But if it is supported, then it is guaranteed to enumerate over
all controls, including driver-private controls.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp47456288"></a>Creating Control Panels</h3></div></div></div><p>It is possible to create control panels for a graphical
user interface where the user can select the various controls.
Basically you will have to iterate over all controls using the method
described above. Each control class starts with a control of type
<code class="constant">V4L2_CTRL_TYPE_CTRL_CLASS</code>.
<code class="constant">VIDIOC_QUERYCTRL</code> will return the name of this
control class which can be used as the title of a tab page within a
control panel.</p><p>The flags field of struct <a class="link" href="media.html#v4l2-queryctrl" title="Table A.94. struct v4l2_queryctrl">v4l2_queryctrl</a> also contains hints on
the behavior of the control. See the <a class="link" href="media.html#vidioc-queryctrl" title="ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU"><code class="constant">VIDIOC_QUERYCTRL</code></a> documentation
for more details.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="mpeg-controls"></a>Codec Control Reference</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#idp47714832">Generic Codec Controls</a></span></dt><dt><span class="section"><a href="media.html#idp48382432">MFC 5.1 MPEG Controls</a></span></dt><dt><span class="section"><a href="media.html#idp48456224">CX2341x MPEG Controls</a></span></dt><dt><span class="section"><a href="media.html#idp48538480">VPX Control Reference</a></span></dt></dl></div><p>Below all controls within the Codec control class are
described. First the generic controls, then controls specific for
certain hardware.</p><p>Note: These controls are applicable to all codecs and
not just MPEG. The defines are prefixed with V4L2_CID_MPEG/V4L2_MPEG
as the controls were originally made for MPEG codecs and later
extended to cover all encoding formats.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp47714832"></a>Generic Codec Controls</h4></div></div></div><div class="table"><a name="mpeg-control-id"></a><p class="title"><b>Table 1.2. Codec Control IDs</b></p><div class="table-contents"><table summary="Codec Control IDs" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"></colgroup><thead><tr><th colspan="2" align="left">ID</th><th align="left">Type</th><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><th colspan="3" align="left">Description</th></tr></thead><tbody valign="top"><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_CLASS</code> </td><td valign="top">class</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">The Codec class
descriptor. Calling <a class="link" href="media.html#vidioc-queryctrl" title="ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU"><code class="constant">VIDIOC_QUERYCTRL</code></a> for this control will return a
description of this control class. This description can be used as the
caption of a Tab page in a GUI, for example.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-stream-type"></a><code class="constant">V4L2_CID_MPEG_STREAM_TYPE</code> </td><td valign="top">enum v4l2_mpeg_stream_type</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">The MPEG-1, -2 or -4
output stream type. One cannot assume anything here. Each hardware
MPEG encoder tends to support different subsets of the available MPEG
stream types. This control is specific to multiplexed MPEG streams.
The currently defined stream types are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_STREAM_TYPE_MPEG2_PS</code> </td><td valign="top">MPEG-2 program stream</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_STREAM_TYPE_MPEG2_TS</code> </td><td valign="top">MPEG-2 transport stream</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_STREAM_TYPE_MPEG1_SS</code> </td><td valign="top">MPEG-1 system stream</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_STREAM_TYPE_MPEG2_DVD</code> </td><td valign="top">MPEG-2 DVD-compatible stream</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_STREAM_TYPE_MPEG1_VCD</code> </td><td valign="top">MPEG-1 VCD-compatible stream</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_STREAM_TYPE_MPEG2_SVCD</code> </td><td valign="top">MPEG-2 SVCD-compatible stream</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_STREAM_PID_PMT</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Program Map Table
Packet ID for the MPEG transport stream (default 16)</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_STREAM_PID_AUDIO</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Audio Packet ID for
the MPEG transport stream (default 256)</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_STREAM_PID_VIDEO</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Video Packet ID for
the MPEG transport stream (default 260)</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_STREAM_PID_PCR</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Packet ID for the
MPEG transport stream carrying PCR fields (default 259)</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_STREAM_PES_ID_AUDIO</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Audio ID for MPEG
PES</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_STREAM_PES_ID_VIDEO</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Video ID for MPEG
PES</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-stream-vbi-fmt"></a><code class="constant">V4L2_CID_MPEG_STREAM_VBI_FMT</code> </td><td valign="top">enum v4l2_mpeg_stream_vbi_fmt</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Some cards can embed
VBI data (e. g. Closed Caption, Teletext) into the MPEG stream. This
control selects whether VBI data should be embedded, and if so, what
embedding method should be used. The list of possible VBI formats
depends on the driver. The currently defined VBI format types
are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_STREAM_VBI_FMT_NONE</code> </td><td valign="top">No VBI in the MPEG stream</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_STREAM_VBI_FMT_IVTV</code> </td><td valign="top">VBI in private packets, IVTV format (documented
in the kernel sources in the file <code class="filename">Documentation/video4linux/cx2341x/README.vbi</code>)</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-audio-sampling-freq"></a><code class="constant">V4L2_CID_MPEG_AUDIO_SAMPLING_FREQ</code> </td><td valign="top">enum v4l2_mpeg_audio_sampling_freq</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">MPEG Audio sampling
frequency. Possible values are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_SAMPLING_FREQ_44100</code> </td><td valign="top">44.1 kHz</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_SAMPLING_FREQ_48000</code> </td><td valign="top">48 kHz</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_SAMPLING_FREQ_32000</code> </td><td valign="top">32 kHz</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-audio-encoding"></a><code class="constant">V4L2_CID_MPEG_AUDIO_ENCODING</code> </td><td valign="top">enum v4l2_mpeg_audio_encoding</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">MPEG Audio encoding.
This control is specific to multiplexed MPEG streams.
Possible values are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_ENCODING_LAYER_1</code> </td><td valign="top">MPEG-1/2 Layer I encoding</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_ENCODING_LAYER_2</code> </td><td valign="top">MPEG-1/2 Layer II encoding</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_ENCODING_LAYER_3</code> </td><td valign="top">MPEG-1/2 Layer III encoding</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_ENCODING_AAC</code> </td><td valign="top">MPEG-2/4 AAC (Advanced Audio Coding)</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_ENCODING_AC3</code> </td><td valign="top">AC-3 aka ATSC A/52 encoding</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-audio-l1-bitrate"></a><code class="constant">V4L2_CID_MPEG_AUDIO_L1_BITRATE</code> </td><td valign="top">enum v4l2_mpeg_audio_l1_bitrate</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">MPEG-1/2 Layer I bitrate.
Possible values are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L1_BITRATE_32K</code> </td><td valign="top">32 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L1_BITRATE_64K</code> </td><td valign="top">64 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L1_BITRATE_96K</code> </td><td valign="top">96 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L1_BITRATE_128K</code> </td><td valign="top">128 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L1_BITRATE_160K</code> </td><td valign="top">160 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L1_BITRATE_192K</code> </td><td valign="top">192 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L1_BITRATE_224K</code> </td><td valign="top">224 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L1_BITRATE_256K</code> </td><td valign="top">256 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L1_BITRATE_288K</code> </td><td valign="top">288 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L1_BITRATE_320K</code> </td><td valign="top">320 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L1_BITRATE_352K</code> </td><td valign="top">352 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L1_BITRATE_384K</code> </td><td valign="top">384 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L1_BITRATE_416K</code> </td><td valign="top">416 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L1_BITRATE_448K</code> </td><td valign="top">448 kbit/s</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-audio-l2-bitrate"></a><code class="constant">V4L2_CID_MPEG_AUDIO_L2_BITRATE</code> </td><td valign="top">enum v4l2_mpeg_audio_l2_bitrate</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">MPEG-1/2 Layer II bitrate.
Possible values are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L2_BITRATE_32K</code> </td><td valign="top">32 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L2_BITRATE_48K</code> </td><td valign="top">48 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L2_BITRATE_56K</code> </td><td valign="top">56 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L2_BITRATE_64K</code> </td><td valign="top">64 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L2_BITRATE_80K</code> </td><td valign="top">80 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L2_BITRATE_96K</code> </td><td valign="top">96 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L2_BITRATE_112K</code> </td><td valign="top">112 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L2_BITRATE_128K</code> </td><td valign="top">128 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L2_BITRATE_160K</code> </td><td valign="top">160 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L2_BITRATE_192K</code> </td><td valign="top">192 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L2_BITRATE_224K</code> </td><td valign="top">224 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L2_BITRATE_256K</code> </td><td valign="top">256 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L2_BITRATE_320K</code> </td><td valign="top">320 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L2_BITRATE_384K</code> </td><td valign="top">384 kbit/s</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-audio-l3-bitrate"></a><code class="constant">V4L2_CID_MPEG_AUDIO_L3_BITRATE</code> </td><td valign="top">enum v4l2_mpeg_audio_l3_bitrate</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">MPEG-1/2 Layer III bitrate.
Possible values are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L3_BITRATE_32K</code> </td><td valign="top">32 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L3_BITRATE_40K</code> </td><td valign="top">40 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L3_BITRATE_48K</code> </td><td valign="top">48 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L3_BITRATE_56K</code> </td><td valign="top">56 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L3_BITRATE_64K</code> </td><td valign="top">64 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L3_BITRATE_80K</code> </td><td valign="top">80 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L3_BITRATE_96K</code> </td><td valign="top">96 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L3_BITRATE_112K</code> </td><td valign="top">112 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L3_BITRATE_128K</code> </td><td valign="top">128 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L3_BITRATE_160K</code> </td><td valign="top">160 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L3_BITRATE_192K</code> </td><td valign="top">192 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L3_BITRATE_224K</code> </td><td valign="top">224 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L3_BITRATE_256K</code> </td><td valign="top">256 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_L3_BITRATE_320K</code> </td><td valign="top">320 kbit/s</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_AUDIO_AAC_BITRATE</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">AAC bitrate in bits per second.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-audio-ac3-bitrate"></a><code class="constant">V4L2_CID_MPEG_AUDIO_AC3_BITRATE</code> </td><td valign="top">enum v4l2_mpeg_audio_ac3_bitrate</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">AC-3 bitrate.
Possible values are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_AC3_BITRATE_32K</code> </td><td valign="top">32 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_AC3_BITRATE_40K</code> </td><td valign="top">40 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_AC3_BITRATE_48K</code> </td><td valign="top">48 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_AC3_BITRATE_56K</code> </td><td valign="top">56 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_AC3_BITRATE_64K</code> </td><td valign="top">64 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_AC3_BITRATE_80K</code> </td><td valign="top">80 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_AC3_BITRATE_96K</code> </td><td valign="top">96 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_AC3_BITRATE_112K</code> </td><td valign="top">112 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_AC3_BITRATE_128K</code> </td><td valign="top">128 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_AC3_BITRATE_160K</code> </td><td valign="top">160 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_AC3_BITRATE_192K</code> </td><td valign="top">192 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_AC3_BITRATE_224K</code> </td><td valign="top">224 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_AC3_BITRATE_256K</code> </td><td valign="top">256 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_AC3_BITRATE_320K</code> </td><td valign="top">320 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_AC3_BITRATE_384K</code> </td><td valign="top">384 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_AC3_BITRATE_448K</code> </td><td valign="top">448 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_AC3_BITRATE_512K</code> </td><td valign="top">512 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_AC3_BITRATE_576K</code> </td><td valign="top">576 kbit/s</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_AC3_BITRATE_640K</code> </td><td valign="top">640 kbit/s</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-audio-mode"></a><code class="constant">V4L2_CID_MPEG_AUDIO_MODE</code> </td><td valign="top">enum v4l2_mpeg_audio_mode</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">MPEG Audio mode.
Possible values are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_MODE_STEREO</code> </td><td valign="top">Stereo</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_MODE_JOINT_STEREO</code> </td><td valign="top">Joint Stereo</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_MODE_DUAL</code> </td><td valign="top">Bilingual</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_MODE_MONO</code> </td><td valign="top">Mono</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-audio-mode-extension"></a><code class="constant">V4L2_CID_MPEG_AUDIO_MODE_EXTENSION</code> </td><td valign="top">enum v4l2_mpeg_audio_mode_extension</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Joint Stereo
audio mode extension. In Layer I and II they indicate which subbands
are in intensity stereo. All other subbands are coded in stereo. Layer
III is not (yet) supported. Possible values
are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_4</code> </td><td valign="top">Subbands 4-31 in intensity stereo</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_8</code> </td><td valign="top">Subbands 8-31 in intensity stereo</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_12</code> </td><td valign="top">Subbands 12-31 in intensity stereo</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_16</code> </td><td valign="top">Subbands 16-31 in intensity stereo</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-audio-emphasis"></a><code class="constant">V4L2_CID_MPEG_AUDIO_EMPHASIS</code> </td><td valign="top">enum v4l2_mpeg_audio_emphasis</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Audio Emphasis.
Possible values are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_EMPHASIS_NONE</code> </td><td valign="top">None</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_EMPHASIS_50_DIV_15_uS</code> </td><td valign="top">50/15 microsecond emphasis</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_EMPHASIS_CCITT_J17</code> </td><td valign="top">CCITT J.17</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-audio-crc"></a><code class="constant">V4L2_CID_MPEG_AUDIO_CRC</code> </td><td valign="top">enum v4l2_mpeg_audio_crc</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">CRC method. Possible
values are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_CRC_NONE</code> </td><td valign="top">None</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_CRC_CRC16</code> </td><td valign="top">16 bit parity check</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_AUDIO_MUTE</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Mutes the audio when
capturing. This is not done by muting audio hardware, which can still
produce a slight hiss, but in the encoder itself, guaranteeing a fixed
and reproducible audio bitstream. 0 = unmuted, 1 = muted.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-audio-dec-playback"></a><code class="constant">V4L2_CID_MPEG_AUDIO_DEC_PLAYBACK</code> </td><td valign="top">enum v4l2_mpeg_audio_dec_playback</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Determines how monolingual audio should be played back.
Possible values are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_DEC_PLAYBACK_AUTO</code> </td><td valign="top">Automatically determines the best playback mode.</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_DEC_PLAYBACK_STEREO</code> </td><td valign="top">Stereo playback.</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_DEC_PLAYBACK_LEFT</code> </td><td valign="top">Left channel playback.</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_DEC_PLAYBACK_RIGHT</code> </td><td valign="top">Right channel playback.</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_DEC_PLAYBACK_MONO</code> </td><td valign="top">Mono playback.</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_AUDIO_DEC_PLAYBACK_SWAPPED_STEREO</code> </td><td valign="top">Stereo playback with swapped left and right channels.</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-audio-dec-multilingual-playback"></a><code class="constant">V4L2_CID_MPEG_AUDIO_DEC_MULTILINGUAL_PLAYBACK</code> </td><td valign="top">enum v4l2_mpeg_audio_dec_playback</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Determines how multilingual audio should be played back.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-video-encoding"></a><code class="constant">V4L2_CID_MPEG_VIDEO_ENCODING</code> </td><td valign="top">enum v4l2_mpeg_video_encoding</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">MPEG Video encoding
method. This control is specific to multiplexed MPEG streams.
Possible values are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_ENCODING_MPEG_1</code> </td><td valign="top">MPEG-1 Video encoding</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_ENCODING_MPEG_2</code> </td><td valign="top">MPEG-2 Video encoding</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_ENCODING_MPEG_4_AVC</code> </td><td valign="top">MPEG-4 AVC (H.264) Video encoding</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-video-aspect"></a><code class="constant">V4L2_CID_MPEG_VIDEO_ASPECT</code> </td><td valign="top">enum v4l2_mpeg_video_aspect</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Video aspect.
Possible values are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_ASPECT_1x1</code> </td><td class="auto-generated"> </td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_ASPECT_4x3</code> </td><td class="auto-generated"> </td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_ASPECT_16x9</code> </td><td class="auto-generated"> </td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_ASPECT_221x100</code> </td><td class="auto-generated"> </td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_B_FRAMES</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Number of B-Frames
(default 2)</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_GOP_SIZE</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">GOP size (default
12)</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_GOP_CLOSURE</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">GOP closure (default
1)</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_PULLDOWN</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Enable 3:2 pulldown
(default 0)</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-video-bitrate-mode"></a><code class="constant">V4L2_CID_MPEG_VIDEO_BITRATE_MODE</code> </td><td valign="top">enum v4l2_mpeg_video_bitrate_mode</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Video bitrate mode.
Possible values are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_BITRATE_MODE_VBR</code> </td><td valign="top">Variable bitrate</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_BITRATE_MODE_CBR</code> </td><td valign="top">Constant bitrate</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_BITRATE</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Video bitrate in bits
per second.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_BITRATE_PEAK</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Peak video bitrate in
bits per second. Must be larger or equal to the average video bitrate.
It is ignored if the video bitrate mode is set to constant
bitrate.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_TEMPORAL_DECIMATION</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">For every captured
frame, skip this many subsequent frames (default 0).</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_MUTE</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">"Mutes" the video to a
fixed color when capturing. This is useful for testing, to produce a
fixed video bitstream. 0 = unmuted, 1 = muted.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_MUTE_YUV</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Sets the "mute" color
of the video. The supplied 32-bit integer is interpreted as follows (bit
0 = least significant bit):</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top">Bit 0:7</td><td valign="top">V chrominance information</td></tr><tr><td valign="top">Bit 8:15</td><td valign="top">U chrominance information</td></tr><tr><td valign="top">Bit 16:23</td><td valign="top">Y luminance information</td></tr><tr><td valign="top">Bit 24:31</td><td valign="top">Must be zero.</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-video-dec-pts"></a><code class="constant">V4L2_CID_MPEG_VIDEO_DEC_PTS</code> </td><td valign="top">integer64</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">This read-only control returns the
33-bit video Presentation Time Stamp as defined in ITU T-REC-H.222.0 and ISO/IEC 13818-1 of
the currently displayed frame. This is the same PTS as is used in <a class="link" href="media.html#vidioc-decoder-cmd" title="ioctl VIDIOC_DECODER_CMD, VIDIOC_TRY_DECODER_CMD"><code class="constant">VIDIOC_DECODER_CMD</code></a>.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-video-dec-frame"></a><code class="constant">V4L2_CID_MPEG_VIDEO_DEC_FRAME</code> </td><td valign="top">integer64</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">This read-only control returns the
frame counter of the frame that is currently displayed (decoded). This value is reset to 0 whenever
the decoder is started.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_DECODER_SLICE_INTERFACE</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">If enabled the decoder expects to receive a single slice per buffer, otherwise
the decoder expects a single frame in per buffer. Applicable to the decoder, all codecs.
</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_ENABLE</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Enable writing sample aspect ratio in the Video Usability Information.
Applicable to the H264 encoder.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-video-h264-vui-sar-idc"></a><code class="constant">V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_IDC</code> </td><td valign="top">enum v4l2_mpeg_video_h264_vui_sar_idc</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">VUI sample aspect ratio indicator for H.264 encoding. The value
is defined in the table E-1 in the standard. Applicable to the H264 encoder.</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_UNSPECIFIED</code> </td><td valign="top">Unspecified</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_1x1</code> </td><td valign="top">1x1</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_12x11</code> </td><td valign="top">12x11</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_10x11</code> </td><td valign="top">10x11</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_16x11</code> </td><td valign="top">16x11</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_40x33</code> </td><td valign="top">40x33</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_24x11</code> </td><td valign="top">24x11</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_20x11</code> </td><td valign="top">20x11</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_32x11</code> </td><td valign="top">32x11</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_80x33</code> </td><td valign="top">80x33</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_18x11</code> </td><td valign="top">18x11</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_15x11</code> </td><td valign="top">15x11</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_64x33</code> </td><td valign="top">64x33</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_160x99</code> </td><td valign="top">160x99</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_4x3</code> </td><td valign="top">4x3</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_3x2</code> </td><td valign="top">3x2</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_2x1</code> </td><td valign="top">2x1</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_EXTENDED</code> </td><td valign="top">Extended SAR</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_H264_VUI_EXT_SAR_WIDTH</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Extended sample aspect ratio width for H.264 VUI encoding.
Applicable to the H264 encoder.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_H264_VUI_EXT_SAR_HEIGHT</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Extended sample aspect ratio height for H.264 VUI encoding.
Applicable to the H264 encoder.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-video-h264-level"></a><code class="constant">V4L2_CID_MPEG_VIDEO_H264_LEVEL</code> </td><td valign="top">enum v4l2_mpeg_video_h264_level</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">The level information for the H264 video elementary stream.
Applicable to the H264 encoder.
Possible values are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_LEVEL_1_0</code> </td><td valign="top">Level 1.0</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_LEVEL_1B</code> </td><td valign="top">Level 1B</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_LEVEL_1_1</code> </td><td valign="top">Level 1.1</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_LEVEL_1_2</code> </td><td valign="top">Level 1.2</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_LEVEL_1_3</code> </td><td valign="top">Level 1.3</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_LEVEL_2_0</code> </td><td valign="top">Level 2.0</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_LEVEL_2_1</code> </td><td valign="top">Level 2.1</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_LEVEL_2_2</code> </td><td valign="top">Level 2.2</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_LEVEL_3_0</code> </td><td valign="top">Level 3.0</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_LEVEL_3_1</code> </td><td valign="top">Level 3.1</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_LEVEL_3_2</code> </td><td valign="top">Level 3.2</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_LEVEL_4_0</code> </td><td valign="top">Level 4.0</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_LEVEL_4_1</code> </td><td valign="top">Level 4.1</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_LEVEL_4_2</code> </td><td valign="top">Level 4.2</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_LEVEL_5_0</code> </td><td valign="top">Level 5.0</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_LEVEL_5_1</code> </td><td valign="top">Level 5.1</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-video-mpeg4-level"></a><code class="constant">V4L2_CID_MPEG_VIDEO_MPEG4_LEVEL</code> </td><td valign="top">enum v4l2_mpeg_video_mpeg4_level</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">The level information for the MPEG4 elementary stream.
Applicable to the MPEG4 encoder.
Possible values are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_LEVEL_0</code> </td><td valign="top">Level 0</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_LEVEL_0B</code> </td><td valign="top">Level 0b</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_LEVEL_1</code> </td><td valign="top">Level 1</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_LEVEL_2</code> </td><td valign="top">Level 2</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_LEVEL_3</code> </td><td valign="top">Level 3</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_LEVEL_3B</code> </td><td valign="top">Level 3b</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_LEVEL_4</code> </td><td valign="top">Level 4</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_LEVEL_5</code> </td><td valign="top">Level 5</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-video-h264-profile"></a><code class="constant">V4L2_CID_MPEG_VIDEO_H264_PROFILE</code> </td><td valign="top">enum v4l2_mpeg_video_h264_profile</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">The profile information for H264.
Applicable to the H264 encoder.
Possible values are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE</code> </td><td valign="top">Baseline profile</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_PROFILE_CONSTRAINED_BASELINE</code> </td><td valign="top">Constrained Baseline profile</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_PROFILE_MAIN</code> </td><td valign="top">Main profile</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_PROFILE_EXTENDED</code> </td><td valign="top">Extended profile</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_PROFILE_HIGH</code> </td><td valign="top">High profile</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_10</code> </td><td valign="top">High 10 profile</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_422</code> </td><td valign="top">High 422 profile</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_444_PREDICTIVE</code> </td><td valign="top">High 444 Predictive profile</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_10_INTRA</code> </td><td valign="top">High 10 Intra profile</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_422_INTRA</code> </td><td valign="top">High 422 Intra profile</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_444_INTRA</code> </td><td valign="top">High 444 Intra profile</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_PROFILE_CAVLC_444_INTRA</code> </td><td valign="top">CAVLC 444 Intra profile</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_PROFILE_SCALABLE_BASELINE</code> </td><td valign="top">Scalable Baseline profile</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_PROFILE_SCALABLE_HIGH</code> </td><td valign="top">Scalable High profile</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_PROFILE_SCALABLE_HIGH_INTRA</code> </td><td valign="top">Scalable High Intra profile</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_PROFILE_STEREO_HIGH</code> </td><td valign="top">Stereo High profile</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_PROFILE_MULTIVIEW_HIGH</code> </td><td valign="top">Multiview High profile</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-video-mpeg4-profile"></a><code class="constant">V4L2_CID_MPEG_VIDEO_MPEG4_PROFILE</code> </td><td valign="top">enum v4l2_mpeg_video_mpeg4_profile</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">The profile information for MPEG4.
Applicable to the MPEG4 encoder.
Possible values are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_PROFILE_SIMPLE</code> </td><td valign="top">Simple profile</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_PROFILE_ADVANCED_SIMPLE</code> </td><td valign="top">Advanced Simple profile</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_PROFILE_CORE</code> </td><td valign="top">Core profile</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_PROFILE_SIMPLE_SCALABLE</code> </td><td valign="top">Simple Scalable profile</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_PROFILE_ADVANCED_CODING_EFFICIENCY</code> </td><td valign="top"> </td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_MAX_REF_PIC</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">The maximum number of reference pictures used for encoding.
Applicable to the encoder.
</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-video-multi-slice-mode"></a><code class="constant">V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MODE</code> </td><td valign="top">enum v4l2_mpeg_video_multi_slice_mode</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Determines how the encoder should handle division of frame into slices.
Applicable to the encoder.
Possible values are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_SINGLE</code> </td><td valign="top">Single slice per frame.</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_MAX_MB</code> </td><td valign="top">Multiple slices with set maximum number of macroblocks per slice.</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_MAX_BYTES</code> </td><td valign="top">Multiple slice with set maximum size in bytes per slice.</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_MB</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">The maximum number of macroblocks in a slice. Used when
<code class="constant">V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MODE</code> is set to <code class="constant">V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_MAX_MB</code>.
Applicable to the encoder.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_BYTES</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">The maximum size of a slice in bytes. Used when
<code class="constant">V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MODE</code> is set to <code class="constant">V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_MAX_BYTES</code>.
Applicable to the encoder.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-video-h264-loop-filter-mode"></a><code class="constant">V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_MODE</code> </td><td valign="top">enum v4l2_mpeg_video_h264_loop_filter_mode</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Loop filter mode for H264 encoder.
Possible values are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_ENABLED</code> </td><td valign="top">Loop filter is enabled.</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_DISABLED</code> </td><td valign="top">Loop filter is disabled.</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_DISABLED_AT_SLICE_BOUNDARY</code> </td><td valign="top">Loop filter is disabled at the slice boundary.</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_ALPHA</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Loop filter alpha coefficient, defined in the H264 standard.
Applicable to the H264 encoder.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_BETA</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Loop filter beta coefficient, defined in the H264 standard.
Applicable to the H264 encoder.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-video-h264-entropy-mode"></a><code class="constant">V4L2_CID_MPEG_VIDEO_H264_ENTROPY_MODE</code> </td><td valign="top">enum v4l2_mpeg_video_h264_entropy_mode</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Entropy coding mode for H264 - CABAC/CAVALC.
Applicable to the H264 encoder.
Possible values are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CAVLC</code> </td><td valign="top">Use CAVLC entropy coding.</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CABAC</code> </td><td valign="top">Use CABAC entropy coding.</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_H264_8X8_TRANSFORM</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Enable 8X8 transform for H264. Applicable to the H264 encoder.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_CYCLIC_INTRA_REFRESH_MB</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Cyclic intra macroblock refresh. This is the number of continuous macroblocks
refreshed every frame. Each frame a successive set of macroblocks is refreshed until the cycle completes and starts from the
top of the frame. Applicable to H264, H263 and MPEG4 encoder.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Frame level rate control enable.
If this control is disabled then the quantization parameter for each frame type is constant and set with appropriate controls
(e.g. <code class="constant">V4L2_CID_MPEG_VIDEO_H263_I_FRAME_QP</code>).
If frame rate control is enabled then quantization parameter is adjusted to meet the chosen bitrate. Minimum and maximum value
for the quantization parameter can be set with appropriate controls (e.g. <code class="constant">V4L2_CID_MPEG_VIDEO_H263_MIN_QP</code>).
Applicable to encoders.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_MB_RC_ENABLE</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Macroblock level rate control enable.
Applicable to the MPEG4 and H264 encoders.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_MPEG4_QPEL</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Quarter pixel motion estimation for MPEG4. Applicable to the MPEG4 encoder.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_H263_I_FRAME_QP</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Quantization parameter for an I frame for H263. Valid range: from 1 to 31.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_H263_MIN_QP</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Minimum quantization parameter for H263. Valid range: from 1 to 31.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_H263_MAX_QP</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Maximum quantization parameter for H263. Valid range: from 1 to 31.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_H263_P_FRAME_QP</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Quantization parameter for an P frame for H263. Valid range: from 1 to 31.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_H263_B_FRAME_QP</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Quantization parameter for an B frame for H263. Valid range: from 1 to 31.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_H264_I_FRAME_QP</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Quantization parameter for an I frame for H264. Valid range: from 0 to 51.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_H264_MIN_QP</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Minimum quantization parameter for H264. Valid range: from 0 to 51.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_H264_MAX_QP</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Maximum quantization parameter for H264. Valid range: from 0 to 51.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_H264_P_FRAME_QP</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Quantization parameter for an P frame for H264. Valid range: from 0 to 51.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_H264_B_FRAME_QP</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Quantization parameter for an B frame for H264. Valid range: from 0 to 51.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_MPEG4_I_FRAME_QP</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Quantization parameter for an I frame for MPEG4. Valid range: from 1 to 31.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_MPEG4_MIN_QP</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Minimum quantization parameter for MPEG4. Valid range: from 1 to 31.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_MPEG4_MAX_QP</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Maximum quantization parameter for MPEG4. Valid range: from 1 to 31.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_MPEG4_P_FRAME_QP</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Quantization parameter for an P frame for MPEG4. Valid range: from 1 to 31.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_MPEG4_B_FRAME_QP</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Quantization parameter for an B frame for MPEG4. Valid range: from 1 to 31.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_VBV_SIZE</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">The Video Buffer Verifier size in kilobytes, it is used as a limitation of frame skip.
The VBV is defined in the standard as a mean to verify that the produced stream will be successfully decoded.
The standard describes it as "Part of a hypothetical decoder that is conceptually connected to the
output of the encoder. Its purpose is to provide a constraint on the variability of the data rate that an
encoder or editing process may produce.".
Applicable to the MPEG1, MPEG2, MPEG4 encoders.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-video-vbv-delay"></a><code class="constant">V4L2_CID_MPEG_VIDEO_VBV_DELAY</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Sets the initial delay in milliseconds for
VBV buffer control.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-video-hor-search-range"></a><code class="constant">V4L2_CID_MPEG_VIDEO_MV_H_SEARCH_RANGE</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Horizontal search range defines maximum horizontal search area in pixels
to search and match for the present Macroblock (MB) in the reference picture. This V4L2 control macro is used to set
horizontal search range for motion estimation module in video encoder.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-video-vert-search-range"></a><code class="constant">V4L2_CID_MPEG_VIDEO_MV_V_SEARCH_RANGE</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Vertical search range defines maximum vertical search area in pixels
to search and match for the present Macroblock (MB) in the reference picture. This V4L2 control macro is used to set
vertical search range for motion estimation module in video encoder.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_H264_CPB_SIZE</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">The Coded Picture Buffer size in kilobytes, it is used as a limitation of frame skip.
The CPB is defined in the H264 standard as a mean to verify that the produced stream will be successfully decoded.
Applicable to the H264 encoder.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_H264_I_PERIOD</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Period between I-frames in the open GOP for H264. In case of an open GOP
this is the period between two I-frames. The period between IDR (Instantaneous Decoding Refresh) frames is taken from the GOP_SIZE control.
An IDR frame, which stands for Instantaneous Decoding Refresh is an I-frame after which no prior frames are
referenced. This means that a stream can be restarted from an IDR frame without the need to store or decode any
previous frames. Applicable to the H264 encoder.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-video-header-mode"></a><code class="constant">V4L2_CID_MPEG_VIDEO_HEADER_MODE</code> </td><td valign="top">enum v4l2_mpeg_video_header_mode</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Determines whether the header is returned as the first buffer or is
it returned together with the first frame. Applicable to encoders.
Possible values are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_HEADER_MODE_SEPARATE</code> </td><td valign="top">The stream header is returned separately in the first buffer.</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_HEADER_MODE_JOINED_WITH_1ST_FRAME</code> </td><td valign="top">The stream header is returned together with the first encoded frame.</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_REPEAT_SEQ_HEADER</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Repeat the video sequence headers. Repeating these
headers makes random access to the video stream easier. Applicable to the MPEG1, 2 and 4 encoder.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_DECODER_MPEG4_DEBLOCK_FILTER</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Enabled the deblocking post processing filter for MPEG4 decoder.
Applicable to the MPEG4 decoder.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_MPEG4_VOP_TIME_RES</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">vop_time_increment_resolution value for MPEG4. Applicable to the MPEG4 encoder.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_MPEG4_VOP_TIME_INC</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">vop_time_increment value for MPEG4. Applicable to the MPEG4 encoder.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_H264_SEI_FRAME_PACKING</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Enable generation of frame packing supplemental enhancement information in the encoded bitstream.
The frame packing SEI message contains the arrangement of L and R planes for 3D viewing. Applicable to the H264 encoder.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_H264_SEI_FP_CURRENT_FRAME_0</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Sets current frame as frame0 in frame packing SEI.
Applicable to the H264 encoder.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-video-h264-sei-fp-arrangement-type"></a><code class="constant">V4L2_CID_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE</code> </td><td valign="top">enum v4l2_mpeg_video_h264_sei_fp_arrangement_type</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Frame packing arrangement type for H264 SEI.
Applicable to the H264 encoder.
Possible values are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_CHEKERBOARD</code> </td><td valign="top">Pixels are alternatively from L and R.</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_COLUMN</code> </td><td valign="top">L and R are interlaced by column.</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_ROW</code> </td><td valign="top">L and R are interlaced by row.</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_SIDE_BY_SIDE</code> </td><td valign="top">L is on the left, R on the right.</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_TOP_BOTTOM</code> </td><td valign="top">L is on top, R on bottom.</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_TEMPORAL</code> </td><td valign="top">One view per frame.</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_H264_FMO</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Enables flexible macroblock ordering in the encoded bitstream. It is a technique
used for restructuring the ordering of macroblocks in pictures. Applicable to the H264 encoder.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-video-h264-fmo-map-type"></a><code class="constant">V4L2_CID_MPEG_VIDEO_H264_FMO_MAP_TYPE</code> </td><td valign="top">enum v4l2_mpeg_video_h264_fmo_map_type</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">When using FMO, the map type divides the image in different scan patterns of macroblocks.
Applicable to the H264 encoder.
Possible values are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_INTERLEAVED_SLICES</code> </td><td valign="top">Slices are interleaved one after other with macroblocks in run length order.</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_SCATTERED_SLICES</code> </td><td valign="top">Scatters the macroblocks based on a mathematical function known to both encoder and decoder.</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_FOREGROUND_WITH_LEFT_OVER</code> </td><td valign="top">Macroblocks arranged in rectangular areas or regions of interest.</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_BOX_OUT</code> </td><td valign="top">Slice groups grow in a cyclic way from centre to outwards.</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_RASTER_SCAN</code> </td><td valign="top">Slice groups grow in raster scan pattern from left to right.</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_WIPE_SCAN</code> </td><td valign="top">Slice groups grow in wipe scan pattern from top to bottom.</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_EXPLICIT</code> </td><td valign="top">User defined map type.</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_H264_FMO_SLICE_GROUP</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Number of slice groups in FMO.
Applicable to the H264 encoder.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-video-h264-fmo-change-direction"></a><code class="constant">V4L2_CID_MPEG_VIDEO_H264_FMO_CHANGE_DIRECTION</code> </td><td valign="top">enum v4l2_mpeg_video_h264_fmo_change_dir</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Specifies a direction of the slice group change for raster and wipe maps.
Applicable to the H264 encoder.
Possible values are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_FMO_CHANGE_DIR_RIGHT</code> </td><td valign="top">Raster scan or wipe right.</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_FMO_CHANGE_DIR_LEFT</code> </td><td valign="top">Reverse raster scan or wipe left.</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_H264_FMO_CHANGE_RATE</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Specifies the size of the first slice group for raster and wipe map.
Applicable to the H264 encoder.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_H264_FMO_RUN_LENGTH</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Specifies the number of consecutive macroblocks for the interleaved map.
Applicable to the H264 encoder.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_H264_ASO</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Enables arbitrary slice ordering in encoded bitstream.
Applicable to the H264 encoder.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_H264_ASO_SLICE_ORDER</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Specifies the slice order in ASO. Applicable to the H264 encoder.
The supplied 32-bit integer is interpreted as follows (bit
0 = least significant bit):</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top">Bit 0:15</td><td valign="top">Slice ID</td></tr><tr><td valign="top">Bit 16:32</td><td valign="top">Slice position or order</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Enables H264 hierarchical coding.
Applicable to the H264 encoder.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-video-h264-hierarchical-coding-type"></a><code class="constant">V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_TYPE</code> </td><td valign="top">enum v4l2_mpeg_video_h264_hierarchical_coding_type</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Specifies the hierarchical coding type.
Applicable to the H264 encoder.
Possible values are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_HIERARCHICAL_CODING_B</code> </td><td valign="top">Hierarchical B coding.</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VIDEO_H264_HIERARCHICAL_CODING_P</code> </td><td valign="top">Hierarchical P coding.</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_LAYER</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Specifies the number of hierarchical coding layers.
Applicable to the H264 encoder.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_LAYER_QP</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Specifies a user defined QP for each layer. Applicable to the H264 encoder.
The supplied 32-bit integer is interpreted as follows (bit
0 = least significant bit):</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top">Bit 0:15</td><td valign="top">QP value</td></tr><tr><td valign="top">Bit 16:32</td><td valign="top">Layer number</td></tr></tbody></table></td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp48382432"></a>MFC 5.1 MPEG Controls</h4></div></div></div><p>The following MPEG class controls deal with MPEG
decoding and encoding settings that are specific to the Multi Format Codec 5.1 device present
in the S5P family of SoCs by Samsung.
</p><div class="table"><a name="mfc51-control-id"></a><p class="title"><b>Table 1.3. MFC 5.1 Control IDs</b></p><div class="table-contents"><table summary="MFC 5.1 Control IDs" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"></colgroup><thead><tr><th colspan="2" align="left">ID</th><th align="left">Type</th><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><th colspan="3" align="left">Description</th></tr></thead><tbody valign="top"><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_MFC51_VIDEO_DECODER_H264_DISPLAY_DELAY_ENABLE</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">If the display delay is enabled then the decoder has to return a
CAPTURE buffer after processing a certain number of OUTPUT buffers. If this number is low, then it may result in
buffers not being dequeued in display order. In addition hardware may still use those buffers as reference, thus
application should not write to those buffers. This feature can be used for example for generating thumbnails of videos.
Applicable to the H264 decoder.
	      </td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_MFC51_VIDEO_DECODER_H264_DISPLAY_DELAY</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Display delay value for H264 decoder.
The decoder is forced to return a decoded frame after the set 'display delay' number of frames. If this number is
low it may result in frames returned out of dispaly order, in addition the hardware may still be using the returned buffer
as a reference picture for subsequent frames.
</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_MFC51_VIDEO_H264_NUM_REF_PIC_FOR_P</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">The number of reference pictures used for encoding a P picture.
Applicable to the H264 encoder.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_MFC51_VIDEO_PADDING</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Padding enable in the encoder - use a color instead of repeating border pixels.
Applicable to encoders.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_MFC51_VIDEO_PADDING_YUV</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Padding color in the encoder. Applicable to encoders. The supplied 32-bit integer is interpreted as follows (bit
0 = least significant bit):</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top">Bit 0:7</td><td valign="top">V chrominance information</td></tr><tr><td valign="top">Bit 8:15</td><td valign="top">U chrominance information</td></tr><tr><td valign="top">Bit 16:23</td><td valign="top">Y luminance information</td></tr><tr><td valign="top">Bit 24:31</td><td valign="top">Must be zero.</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_MFC51_VIDEO_RC_REACTION_COEFF</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Reaction coefficient for MFC rate control. Applicable to encoders.
<p>Note 1: Valid only when the frame level RC is enabled.</p>
<p>Note 2: For tight CBR, this field must be small (ex. 2 ~ 10).
For VBR, this field must be large (ex. 100 ~ 1000).</p>
<p>Note 3: It is not recommended to use the greater number than FRAME_RATE * (10^9 / BIT_RATE).</p>
</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_DARK</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Adaptive rate control for dark region.
Valid only when H.264 and macroblock level RC is enabled (<code class="constant">V4L2_CID_MPEG_VIDEO_MB_RC_ENABLE</code>).
Applicable to the H264 encoder.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_SMOOTH</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Adaptive rate control for smooth region.
Valid only when H.264 and macroblock level RC is enabled (<code class="constant">V4L2_CID_MPEG_VIDEO_MB_RC_ENABLE</code>).
Applicable to the H264 encoder.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_STATIC</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Adaptive rate control for static region.
Valid only when H.264 and macroblock level RC is enabled (<code class="constant">V4L2_CID_MPEG_VIDEO_MB_RC_ENABLE</code>).
Applicable to the H264 encoder.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_ACTIVITY</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Adaptive rate control for activity region.
Valid only when H.264 and macroblock level RC is enabled (<code class="constant">V4L2_CID_MPEG_VIDEO_MB_RC_ENABLE</code>).
Applicable to the H264 encoder.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-mfc51-video-frame-skip-mode"></a><code class="constant">V4L2_CID_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE</code> </td><td valign="top">enum v4l2_mpeg_mfc51_video_frame_skip_mode</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">
Indicates in what conditions the encoder should skip frames. If encoding a frame would cause the encoded stream to be larger then
a chosen data limit then the frame will be skipped.
Possible values are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_MFC51_FRAME_SKIP_MODE_DISABLED</code> </td><td valign="top">Frame skip mode is disabled.</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_MFC51_FRAME_SKIP_MODE_LEVEL_LIMIT</code> </td><td valign="top">Frame skip mode enabled and buffer limit is set by the chosen level and is defined by the standard.</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_MFC51_FRAME_SKIP_MODE_BUF_LIMIT</code> </td><td valign="top">Frame skip mode enabled and buffer limit is set by the VBV (MPEG1/2/4) or CPB (H264) buffer size control.</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_MFC51_VIDEO_RC_FIXED_TARGET_BIT</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Enable rate-control with fixed target bit.
If this setting is enabled, then the rate control logic of the encoder will calculate the average bitrate
for a GOP and keep it below or equal the set bitrate target. Otherwise the rate control logic calculates the
overall average bitrate for the stream and keeps it below or equal to the set bitrate. In the first case
the average bitrate for the whole stream will be smaller then the set bitrate. This is caused because the
average is calculated for smaller number of frames, on the other hand enabling this setting will ensure that
the stream will meet tight bandwidth contraints. Applicable to encoders.
</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-mfc51-video-force-frame-type"></a><code class="constant">V4L2_CID_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE</code> </td><td valign="top">enum v4l2_mpeg_mfc51_video_force_frame_type</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Force a frame type for the next queued buffer. Applicable to encoders.
Possible values are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_MFC51_FORCE_FRAME_TYPE_DISABLED</code> </td><td valign="top">Forcing a specific frame type disabled.</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_MFC51_FORCE_FRAME_TYPE_I_FRAME</code> </td><td valign="top">Force an I-frame.</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_MFC51_FORCE_FRAME_TYPE_NOT_CODED</code> </td><td valign="top">Force a non-coded frame.</td></tr></tbody></table></td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp48456224"></a>CX2341x MPEG Controls</h4></div></div></div><p>The following MPEG class controls deal with MPEG
encoding settings that are specific to the Conexant CX23415 and
CX23416 MPEG encoding chips.</p><div class="table"><a name="cx2341x-control-id"></a><p class="title"><b>Table 1.4. CX2341x Control IDs</b></p><div class="table-contents"><table summary="CX2341x Control IDs" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"></colgroup><thead><tr><th colspan="2" align="left">ID</th><th align="left">Type</th><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><th colspan="3" align="left">Description</th></tr></thead><tbody valign="top"><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-cx2341x-video-spatial-filter-mode"></a><code class="constant">V4L2_CID_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE</code> </td><td valign="top">enum v4l2_mpeg_cx2341x_video_spatial_filter_mode</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Sets the Spatial
Filter mode (default <code class="constant">MANUAL</code>). Possible values
are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE_MANUAL</code> </td><td valign="top">Choose the filter manually</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE_AUTO</code> </td><td valign="top">Choose the filter automatically</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_CX2341X_VIDEO_SPATIAL_FILTER</code> </td><td valign="top">integer (0-15)</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">The setting for the
Spatial Filter. 0 = off, 15 = maximum. (Default is 0.)</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="luma-spatial-filter-type"></a><code class="constant">V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE</code> </td><td valign="top">enum v4l2_mpeg_cx2341x_video_luma_spatial_filter_type</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Select the algorithm
to use for the Luma Spatial Filter (default
<code class="constant">1D_HOR</code>). Possible values:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_OFF</code> </td><td valign="top">No filter</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_1D_HOR</code> </td><td valign="top">One-dimensional horizontal</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_1D_VERT</code> </td><td valign="top">One-dimensional vertical</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_2D_HV_SEPARABLE</code> </td><td valign="top">Two-dimensional separable</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_2D_SYM_NON_SEPARABLE</code> </td><td valign="top">Two-dimensional symmetrical
non-separable</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="chroma-spatial-filter-type"></a><code class="constant">V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE</code> </td><td valign="top">enum v4l2_mpeg_cx2341x_video_chroma_spatial_filter_type</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Select the algorithm
for the Chroma Spatial Filter (default <code class="constant">1D_HOR</code>).
Possible values are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE_OFF</code> </td><td valign="top">No filter</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE_1D_HOR</code> </td><td valign="top">One-dimensional horizontal</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-cx2341x-video-temporal-filter-mode"></a><code class="constant">V4L2_CID_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE</code> </td><td valign="top">enum v4l2_mpeg_cx2341x_video_temporal_filter_mode</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Sets the Temporal
Filter mode (default <code class="constant">MANUAL</code>). Possible values
are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE_MANUAL</code> </td><td valign="top">Choose the filter manually</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE_AUTO</code> </td><td valign="top">Choose the filter automatically</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER</code> </td><td valign="top">integer (0-31)</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">The setting for the
Temporal Filter. 0 = off, 31 = maximum. (Default is 8 for full-scale
capturing and 0 for scaled capturing.)</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-mpeg-cx2341x-video-median-filter-type"></a><code class="constant">V4L2_CID_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE</code> </td><td valign="top">enum v4l2_mpeg_cx2341x_video_median_filter_type</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Median Filter Type
(default <code class="constant">OFF</code>). Possible values are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_OFF</code> </td><td valign="top">No filter</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_HOR</code> </td><td valign="top">Horizontal filter</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_VERT</code> </td><td valign="top">Vertical filter</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_HOR_VERT</code> </td><td valign="top">Horizontal and vertical filter</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_DIAG</code> </td><td valign="top">Diagonal filter</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_MEDIAN_FILTER_BOTTOM</code> </td><td valign="top">integer (0-255)</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Threshold above which
the luminance median filter is enabled (default 0)</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_MEDIAN_FILTER_TOP</code> </td><td valign="top">integer (0-255)</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Threshold below which
the luminance median filter is enabled (default 255)</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_MEDIAN_FILTER_BOTTOM</code> </td><td valign="top">integer (0-255)</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Threshold above which
the chroma median filter is enabled (default 0)</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_MEDIAN_FILTER_TOP</code> </td><td valign="top">integer (0-255)</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Threshold below which
the chroma median filter is enabled (default 255)</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_CX2341X_STREAM_INSERT_NAV_PACKETS</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">The CX2341X MPEG encoder
can insert one empty MPEG-2 PES packet into the stream between every
four video frames. The packet size is 2048 bytes, including the
packet_start_code_prefix and stream_id fields. The stream_id is 0xBF
(private stream 2). The payload consists of 0x00 bytes, to be filled
in by the application. 0 = do not insert, 1 = insert packets.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp48538480"></a>VPX Control Reference</h4></div></div></div><p>The VPX controls include controls for encoding parameters
      of VPx video codec.</p><div class="table"><a name="vpx-control-id"></a><p class="title"><b>Table 1.5. VPX Control IDs</b></p><div class="table-contents"><table summary="VPX Control IDs" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"></colgroup><thead><tr><th colspan="2" align="left">ID</th><th align="left">Type</th><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><th colspan="3" align="left">Description</th></tr></thead><tbody valign="top"><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-vpx-num-partitions"></a><code class="constant">V4L2_CID_MPEG_VIDEO_VPX_NUM_PARTITIONS</code></td><td valign="top">enum v4l2_vp8_num_partitions</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">The number of token partitions to use in VP8 encoder.
Possible values are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_VPX_1_PARTITION</code></td><td valign="top">1 coefficient partition</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_VPX_2_PARTITIONS</code></td><td valign="top">2 coefficient partitions</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_VPX_4_PARTITIONS</code></td><td valign="top">4 coefficient partitions</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_VPX_8_PARTITIONS</code></td><td valign="top">8 coefficient partitions</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_VPX_IMD_DISABLE_4X4</code></td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Setting this prevents intra 4x4 mode in the intra mode decision.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-vpx-num-ref-frames"></a><code class="constant">V4L2_CID_MPEG_VIDEO_VPX_NUM_REF_FRAMES</code></td><td valign="top">enum v4l2_vp8_num_ref_frames</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">The number of reference pictures for encoding P frames.
Possible values are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_VPX_1_REF_FRAME</code></td><td valign="top">Last encoded frame will be searched</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_VPX_2_REF_FRAME</code></td><td valign="top">Two frames will be searched among the last encoded frame, the golden frame
and the alternate reference (altref) frame. The encoder implementation will decide which two are chosen.</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_VPX_3_REF_FRAME</code></td><td valign="top">The last encoded frame, the golden frame and the altref frame will be searched.</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_VPX_FILTER_LEVEL</code></td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Indicates the loop filter level. The adjustment of the loop
filter level is done via a delta value against a baseline loop filter value.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_VPX_FILTER_SHARPNESS</code></td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">This parameter affects the loop filter. Anything above
zero weakens the deblocking effect on the loop filter.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_REF_PERIOD</code></td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Sets the refresh period for the golden frame. The period is defined
in number of frames. For a value of 'n', every nth frame starting from the first key frame will be taken as a golden frame.
For eg. for encoding sequence of 0, 1, 2, 3, 4, 5, 6, 7 where the golden frame refresh period is set as 4, the frames
0, 4, 8 etc will be taken as the golden frames as frame 0 is always a key frame.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-vpx-golden-frame-sel"></a><code class="constant">V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_SEL</code></td><td valign="top">enum v4l2_vp8_golden_frame_sel</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Selects the golden frame for encoding.
Possible values are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_USE_PREV</code></td><td valign="top">Use the (n-2)th frame as a golden frame, current frame index being 'n'.</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_USE_REF_PERIOD</code></td><td valign="top">Use the previous specific frame indicated by
V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_REF_PERIOD as a golden frame.</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_VPX_MIN_QP</code></td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Minimum quantization parameter for VP8.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_VPX_MAX_QP</code></td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Maximum quantization parameter for VP8.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_VPX_I_FRAME_QP</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Quantization parameter for an I frame for VP8.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_VPX_P_FRAME_QP</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Quantization parameter for a P frame for VP8.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_MPEG_VIDEO_VPX_PROFILE</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Select the desired profile for VPx encoder.
Acceptable values are 0, 1, 2 and 3 corresponding to encoder profiles 0, 1, 2 and 3.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="camera-controls"></a>Camera Control Reference</h3></div></div></div><p>The Camera class includes controls for mechanical (or
equivalent digital) features of a device such as controllable lenses
or sensors.</p><div class="table"><a name="camera-control-id"></a><p class="title"><b>Table 1.6. Camera Control IDs</b></p><div class="table-contents"><table summary="Camera Control IDs" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"></colgroup><thead><tr><th colspan="2" align="left">ID</th><th align="left">Type</th><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><th colspan="3" align="left">Description</th></tr></thead><tbody valign="top"><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_CAMERA_CLASS</code> </td><td valign="top">class</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">The Camera class
descriptor. Calling <a class="link" href="media.html#vidioc-queryctrl" title="ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU"><code class="constant">VIDIOC_QUERYCTRL</code></a> for this control will return a
description of this control class.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-exposure-auto-type"></a><code class="constant">V4L2_CID_EXPOSURE_AUTO</code> </td><td valign="top">enum v4l2_exposure_auto_type</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Enables automatic
adjustments of the exposure time and/or iris aperture. The effect of
manual changes of the exposure time or iris aperture while these
features are enabled is undefined, drivers should ignore such
requests. Possible values are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_EXPOSURE_AUTO</code> </td><td valign="top">Automatic exposure time, automatic iris
aperture.</td></tr><tr><td valign="top"><code class="constant">V4L2_EXPOSURE_MANUAL</code> </td><td valign="top">Manual exposure time, manual iris.</td></tr><tr><td valign="top"><code class="constant">V4L2_EXPOSURE_SHUTTER_PRIORITY</code> </td><td valign="top">Manual exposure time, auto iris.</td></tr><tr><td valign="top"><code class="constant">V4L2_EXPOSURE_APERTURE_PRIORITY</code> </td><td valign="top">Auto exposure time, manual iris.</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_EXPOSURE_ABSOLUTE</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Determines the exposure
time of the camera sensor. The exposure time is limited by the frame
interval. Drivers should interpret the values as 100 µs units,
where the value 1 stands for 1/10000th of a second, 10000 for 1 second
and 100000 for 10 seconds.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_EXPOSURE_AUTO_PRIORITY</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">When
<code class="constant">V4L2_CID_EXPOSURE_AUTO</code> is set to
<code class="constant">AUTO</code> or <code class="constant">APERTURE_PRIORITY</code>,
this control determines if the device may dynamically vary the frame
rate. By default this feature is disabled (0) and the frame rate must
remain constant.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_EXPOSURE_BIAS</code> </td><td valign="top">integer menu</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"> Determines the automatic
exposure compensation, it is effective only when <code class="constant">V4L2_CID_EXPOSURE_AUTO</code>
control is set to <code class="constant">AUTO</code>, <code class="constant">SHUTTER_PRIORITY </code>
or <code class="constant">APERTURE_PRIORITY</code>.
It is expressed in terms of EV, drivers should interpret the values as 0.001 EV
units, where the value 1000 stands for +1 EV.
<p>Increasing the exposure compensation value is equivalent to decreasing
the exposure value (EV) and will increase the amount of light at the image
sensor. The camera performs the exposure compensation by adjusting absolute
exposure time and/or aperture.</p></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-exposure-metering"></a><code class="constant">V4L2_CID_EXPOSURE_METERING</code> </td><td valign="top">enum v4l2_exposure_metering</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Determines how the camera measures
the amount of light available for the frame exposure. Possible values are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_EXPOSURE_METERING_AVERAGE</code> </td><td valign="top">Use the light information coming from the entire frame
and average giving no weighting to any particular portion of the metered area.
		  </td></tr><tr><td valign="top"><code class="constant">V4L2_EXPOSURE_METERING_CENTER_WEIGHTED</code> </td><td valign="top">Average the light information coming from the entire frame
giving priority to the center of the metered area.</td></tr><tr><td valign="top"><code class="constant">V4L2_EXPOSURE_METERING_SPOT</code> </td><td valign="top">Measure only very small area at the center of the frame.</td></tr><tr><td valign="top"><code class="constant">V4L2_EXPOSURE_METERING_MATRIX</code> </td><td valign="top">A multi-zone metering. The light intensity is measured
in several points of the frame and the the results are combined. The
algorithm of the zones selection and their significance in calculating the
final value is device dependent.</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_PAN_RELATIVE</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">This control turns the
camera horizontally by the specified amount. The unit is undefined. A
positive value moves the camera to the right (clockwise when viewed
from above), a negative value to the left. A value of zero does not
cause motion. This is a write-only control.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_TILT_RELATIVE</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">This control turns the
camera vertically by the specified amount. The unit is undefined. A
positive value moves the camera up, a negative value down. A value of
zero does not cause motion. This is a write-only control.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_PAN_RESET</code> </td><td valign="top">button</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">When this control is set,
the camera moves horizontally to the default position.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_TILT_RESET</code> </td><td valign="top">button</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">When this control is set,
the camera moves vertically to the default position.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_PAN_ABSOLUTE</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">This control
turns the camera horizontally to the specified position. Positive
values move the camera to the right (clockwise when viewed from above),
negative values to the left. Drivers should interpret the values as arc
seconds, with valid values between -180 * 3600 and +180 * 3600
inclusive.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_TILT_ABSOLUTE</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">This control
turns the camera vertically to the specified position. Positive values
move the camera up, negative values down. Drivers should interpret the
values as arc seconds, with valid values between -180 * 3600 and +180
* 3600 inclusive.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_FOCUS_ABSOLUTE</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">This control sets the
focal point of the camera to the specified position. The unit is
undefined. Positive values set the focus closer to the camera,
negative values towards infinity.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_FOCUS_RELATIVE</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">This control moves the
focal point of the camera by the specified amount. The unit is
undefined. Positive values move the focus closer to the camera,
negative values towards infinity. This is a write-only control.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_FOCUS_AUTO</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Enables continuous automatic
focus adjustments. The effect of manual focus adjustments while this feature
is enabled is undefined, drivers should ignore such requests.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_AUTO_FOCUS_START</code> </td><td valign="top">button</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Starts single auto focus process.
The effect of setting this control when <code class="constant">V4L2_CID_FOCUS_AUTO</code>
is set to <code class="constant">TRUE</code> (1) is undefined, drivers should ignore
such requests.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_AUTO_FOCUS_STOP</code> </td><td valign="top">button</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Aborts automatic focusing
started with <code class="constant">V4L2_CID_AUTO_FOCUS_START</code> control. It is
effective only when the continuous autofocus is disabled, that is when
<code class="constant">V4L2_CID_FOCUS_AUTO</code> control is set to <code class="constant">FALSE
</code> (0).</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-auto-focus-status"></a>
	      <code class="constant">V4L2_CID_AUTO_FOCUS_STATUS</code> </td><td valign="top">bitmask</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">The automatic focus status. This is a read-only
	  control.</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_AUTO_FOCUS_STATUS_IDLE</code> </td><td valign="top">Automatic focus is not active.</td></tr><tr><td valign="top"><code class="constant">V4L2_AUTO_FOCUS_STATUS_BUSY</code> </td><td valign="top">Automatic focusing is in progress.</td></tr><tr><td valign="top"><code class="constant">V4L2_AUTO_FOCUS_STATUS_REACHED</code> </td><td valign="top">Focus has been reached.</td></tr><tr><td valign="top"><code class="constant">V4L2_AUTO_FOCUS_STATUS_FAILED</code> </td><td valign="top">Automatic focus has failed, the driver will not
		  transition from this state until another action is
		  performed by an application.</td></tr></tbody></table></td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">
Setting <code class="constant">V4L2_LOCK_FOCUS</code> lock bit of the <code class="constant">V4L2_CID_3A_LOCK
</code> control may stop updates of the <code class="constant">V4L2_CID_AUTO_FOCUS_STATUS</code>
control value.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-auto-focus-range"></a>
	      <code class="constant">V4L2_CID_AUTO_FOCUS_RANGE</code> </td><td valign="top">enum v4l2_auto_focus_range</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Determines auto focus distance range
for which lens may be adjusted. </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_AUTO_FOCUS_RANGE_AUTO</code> </td><td valign="top">The camera automatically selects the focus range.</td></tr><tr><td valign="top"><code class="constant">V4L2_AUTO_FOCUS_RANGE_NORMAL</code> </td><td valign="top">Normal distance range, limited for best automatic focus
performance.</td></tr><tr><td valign="top"><code class="constant">V4L2_AUTO_FOCUS_RANGE_MACRO</code> </td><td valign="top">Macro (close-up) auto focus. The camera will
use its minimum possible distance for auto focus.</td></tr><tr><td valign="top"><code class="constant">V4L2_AUTO_FOCUS_RANGE_INFINITY</code> </td><td valign="top">The lens is set to focus on an object at infinite distance.</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_ZOOM_ABSOLUTE</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Specify the objective lens
focal length as an absolute value. The zoom unit is driver-specific and its
value should be a positive integer.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_ZOOM_RELATIVE</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Specify the objective lens
focal length relatively to the current value. Positive values move the zoom
lens group towards the telephoto direction, negative values towards the
wide-angle direction. The zoom unit is driver-specific. This is a write-only control.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_ZOOM_CONTINUOUS</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Move the objective lens group
at the specified speed until it reaches physical device limits or until an
explicit request to stop the movement. A positive value moves the zoom lens
group towards the telephoto direction. A value of zero stops the zoom lens
group movement. A negative value moves the zoom lens group towards the
wide-angle direction. The zoom speed unit is driver-specific.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_IRIS_ABSOLUTE</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">This control sets the
camera's aperture to the specified value. The unit is undefined.
Larger values open the iris wider, smaller values close it.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_IRIS_RELATIVE</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">This control modifies the
camera's aperture by the specified amount. The unit is undefined.
Positive values open the iris one step further, negative values close
it one step further. This is a write-only control.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_PRIVACY</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Prevent video from being acquired
by the camera. When this control is set to <code class="constant">TRUE</code> (1), no
image can be captured by the camera. Common means to enforce privacy are
mechanical obturation of the sensor and firmware image processing, but the
device is not restricted to these methods. Devices that implement the privacy
control must support read access and may support write access.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_BAND_STOP_FILTER</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Switch the band-stop filter of a
camera sensor on or off, or specify its strength. Such band-stop filters can
be used, for example, to filter out the fluorescent light component.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-auto-n-preset-white-balance"></a><code class="constant">V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE</code> </td><td valign="top">enum v4l2_auto_n_preset_white_balance</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Sets white balance to automatic,
manual or a preset. The presets determine color temperature of the light as
a hint to the camera for white balance adjustments resulting in most accurate
color representation. The following white balance presets are listed in order
of increasing color temperature.</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_WHITE_BALANCE_MANUAL</code> </td><td valign="top">Manual white balance.</td></tr><tr><td valign="top"><code class="constant">V4L2_WHITE_BALANCE_AUTO</code> </td><td valign="top">Automatic white balance adjustments.</td></tr><tr><td valign="top"><code class="constant">V4L2_WHITE_BALANCE_INCANDESCENT</code> </td><td valign="top">White balance setting for incandescent (tungsten) lighting.
It generally cools down the colors and corresponds approximately to 2500...3500 K
color temperature range.</td></tr><tr><td valign="top"><code class="constant">V4L2_WHITE_BALANCE_FLUORESCENT</code> </td><td valign="top">White balance preset for fluorescent lighting.
It corresponds approximately to 4000...5000 K color temperature.</td></tr><tr><td valign="top"><code class="constant">V4L2_WHITE_BALANCE_FLUORESCENT_H</code> </td><td valign="top">With this setting the camera will compensate for
fluorescent H lighting.</td></tr><tr><td valign="top"><code class="constant">V4L2_WHITE_BALANCE_HORIZON</code> </td><td valign="top">White balance setting for horizon daylight.
It corresponds approximately to 5000 K color temperature.</td></tr><tr><td valign="top"><code class="constant">V4L2_WHITE_BALANCE_DAYLIGHT</code> </td><td valign="top">White balance preset for daylight (with clear sky).
It corresponds approximately to 5000...6500 K color temperature.</td></tr><tr><td valign="top"><code class="constant">V4L2_WHITE_BALANCE_FLASH</code> </td><td valign="top">With this setting the camera will compensate for the flash
light. It slightly warms up the colors and corresponds roughly to 5000...5500 K
color temperature.</td></tr><tr><td valign="top"><code class="constant">V4L2_WHITE_BALANCE_CLOUDY</code> </td><td valign="top">White balance preset for moderately overcast sky.
This option corresponds approximately to 6500...8000 K color temperature
range.</td></tr><tr><td valign="top"><code class="constant">V4L2_WHITE_BALANCE_SHADE</code> </td><td valign="top">White balance preset for shade or heavily overcast
sky. It corresponds approximately to 9000...10000 K color temperature.
</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-wide-dynamic-range"></a><code class="constant">V4L2_CID_WIDE_DYNAMIC_RANGE</code></td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Enables or disables the camera's wide dynamic
range feature. This feature allows to obtain clear images in situations where
intensity of the illumination varies significantly throughout the scene, i.e.
there are simultaneously very dark and very bright areas. It is most commonly
realized in cameras by combining two subsequent frames with different exposure
times. <a href="media.html#ftn.ctypeconv" class="footnote" name="ctypeconv"><sup class="footnote">[a]</sup></a></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-image-stabilization"></a><code class="constant">V4L2_CID_IMAGE_STABILIZATION</code></td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Enables or disables image stabilization.
	      <a href="media.html#ftn.ctypeconv" class="footnoteref"><sup class="footnoteref">[a]</sup></a></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_ISO_SENSITIVITY</code> </td><td valign="top">integer menu</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Determines ISO equivalent of an
image sensor indicating the sensor's sensitivity to light. The numbers are
expressed in arithmetic scale, as per <a class="xref" href="media.html#iso12232" title="Photography &#8212; Digital still cameras &#8212; Determination of exposure index, ISO speed ratings, standard output sensitivity, and recommended exposure index">[<abbr class="abbrev">ISO 12232:2006</abbr>]</a> standard,
where doubling the sensor sensitivity is represented by doubling the numerical
ISO value. Applications should interpret the values as standard ISO values
multiplied by 1000, e.g. control value 800 stands for ISO 0.8. Drivers will
usually support only a subset of standard ISO values. The effect of setting
this control while the <code class="constant">V4L2_CID_ISO_SENSITIVITY_AUTO</code>
control is set to a value other than <code class="constant">V4L2_CID_ISO_SENSITIVITY_MANUAL
</code> is undefined, drivers should ignore such requests.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-iso-sensitivity-auto-type"></a><code class="constant">V4L2_CID_ISO_SENSITIVITY_AUTO</code> </td><td valign="top">enum v4l2_iso_sensitivity_type</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Enables or disables automatic ISO
sensitivity adjustments.</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_CID_ISO_SENSITIVITY_MANUAL</code> </td><td valign="top">Manual ISO sensitivity.</td></tr><tr><td valign="top"><code class="constant">V4L2_CID_ISO_SENSITIVITY_AUTO</code> </td><td valign="top">Automatic ISO sensitivity adjustments.</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><a name="v4l2-scene-mode"></a><code class="constant">V4L2_CID_SCENE_MODE</code> </td><td valign="top">enum v4l2_scene_mode</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">This control allows to select
scene programs as the camera automatic modes optimized for common shooting
scenes. Within these modes the camera determines best exposure, aperture,
focusing, light metering, white balance and equivalent sensitivity. The
controls of those parameters are influenced by the scene mode control.
An exact behavior in each mode is subject to the camera specification.

<p>When the scene mode feature is not used, this control should be set to
<code class="constant">V4L2_SCENE_MODE_NONE</code> to make sure the other possibly
related controls are accessible. The following scene programs are defined:
</p>
</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_SCENE_MODE_NONE</code> </td><td valign="top">The scene mode feature is disabled.</td></tr><tr><td valign="top"><code class="constant">V4L2_SCENE_MODE_BACKLIGHT</code> </td><td valign="top">Backlight. Compensates for dark shadows when light is
		  coming from behind a subject, also by automatically turning
		  on the flash.</td></tr><tr><td valign="top"><code class="constant">V4L2_SCENE_MODE_BEACH_SNOW</code> </td><td valign="top">Beach and snow. This mode compensates for all-white or
bright scenes, which tend to look gray and low contrast, when camera's automatic
exposure is based on an average scene brightness. To compensate, this mode
automatically slightly overexposes the frames. The white balance may also be
adjusted to compensate for the fact that reflected snow looks bluish rather
than white.</td></tr><tr><td valign="top"><code class="constant">V4L2_SCENE_MODE_CANDLELIGHT</code> </td><td valign="top">Candle light. The camera generally raises the ISO
sensitivity and lowers the shutter speed. This mode compensates for relatively
close subject in the scene. The flash is disabled in order to preserve the
ambiance of the light.</td></tr><tr><td valign="top"><code class="constant">V4L2_SCENE_MODE_DAWN_DUSK</code> </td><td valign="top">Dawn and dusk. Preserves the colors seen in low
natural light before dusk and after down. The camera may turn off the flash,
and automatically focus at infinity. It will usually boost saturation and
lower the shutter speed.</td></tr><tr><td valign="top"><code class="constant">V4L2_SCENE_MODE_FALL_COLORS</code> </td><td valign="top">Fall colors. Increases saturation and adjusts white
balance for color enhancement. Pictures of autumn leaves get saturated reds
and yellows.</td></tr><tr><td valign="top"><code class="constant">V4L2_SCENE_MODE_FIREWORKS</code> </td><td valign="top">Fireworks. Long exposure times are used to capture
the expanding burst of light from a firework. The camera may invoke image
stabilization.</td></tr><tr><td valign="top"><code class="constant">V4L2_SCENE_MODE_LANDSCAPE</code> </td><td valign="top">Landscape. The camera may choose a small aperture to
provide deep depth of field and long exposure duration to help capture detail
in dim light conditions. The focus is fixed at infinity. Suitable for distant
and wide scenery.</td></tr><tr><td valign="top"><code class="constant">V4L2_SCENE_MODE_NIGHT</code> </td><td valign="top">Night, also known as Night Landscape. Designed for low
light conditions, it preserves detail in the dark areas without blowing out bright
objects. The camera generally sets itself to a medium-to-high ISO sensitivity,
with a relatively long exposure time, and turns flash off. As such, there will be
increased image noise and the possibility of blurred image.</td></tr><tr><td valign="top"><code class="constant">V4L2_SCENE_MODE_PARTY_INDOOR</code> </td><td valign="top">Party and indoor. Designed to capture indoor scenes
that are lit by indoor background lighting as well as the flash. The camera
usually increases ISO sensitivity, and adjusts exposure for the low light
conditions.</td></tr><tr><td valign="top"><code class="constant">V4L2_SCENE_MODE_PORTRAIT</code> </td><td valign="top">Portrait. The camera adjusts the aperture so that the
depth of field is reduced, which helps to isolate the subject against a smooth
background. Most cameras recognize the presence of faces in the scene and focus
on them. The color hue is adjusted to enhance skin tones. The intensity of the
flash is often reduced.</td></tr><tr><td valign="top"><code class="constant">V4L2_SCENE_MODE_SPORTS</code> </td><td valign="top">Sports. Significantly increases ISO and uses a fast
shutter speed to freeze motion of rapidly-moving subjects. Increased image
noise may be seen in this mode.</td></tr><tr><td valign="top"><code class="constant">V4L2_SCENE_MODE_SUNSET</code> </td><td valign="top">Sunset. Preserves deep hues seen in sunsets and
sunrises. It bumps up the saturation.</td></tr><tr><td valign="top"><code class="constant">V4L2_SCENE_MODE_TEXT</code> </td><td valign="top">Text. It applies extra contrast and sharpness, it is
typically a black-and-white mode optimized for readability. Automatic focus
may be switched to close-up mode and this setting may also involve some
lens-distortion correction.</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_3A_LOCK</code></td><td valign="top">bitmask</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">This control locks or unlocks the automatic
focus, exposure and white balance. The automatic adjustments can be paused
independently by setting the corresponding lock bit to 1. The camera then retains
the settings until the lock bit is cleared. The following lock bits are defined:
</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_LOCK_EXPOSURE</code></td><td valign="top">Automatic exposure adjustments lock.</td></tr><tr><td valign="top"><code class="constant">V4L2_LOCK_WHITE_BALANCE</code></td><td valign="top">Automatic white balance adjustments lock.</td></tr><tr><td valign="top"><code class="constant">V4L2_LOCK_FOCUS</code></td><td valign="top">Automatic focus lock.</td></tr></tbody></table></td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">
When a given algorithm is not enabled, drivers should ignore requests
to lock it and should return no error. An example might be an application
setting bit <code class="constant">V4L2_LOCK_WHITE_BALANCE</code> when the
<code class="constant">V4L2_CID_AUTO_WHITE_BALANCE</code> control is set to
<code class="constant">FALSE</code>. The value of this control may be changed
by exposure, white balance or focus controls.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_PAN_SPEED</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">This control turns the
camera horizontally at the specific speed. The unit is undefined. A
positive value moves the camera to the right (clockwise when viewed
from above), a negative value to the left. A value of zero stops the motion
if one is in progress and has no effect otherwise.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_TILT_SPEED</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">This control turns the
camera vertically at the specified speed. The unit is undefined. A
positive value moves the camera up, a negative value down. A value of zero
stops the motion if one is in progress and has no effect otherwise.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr></tbody><tbody class="footnotes"><tr><td colspan="4"><div id="ftn.ctypeconv" class="footnote"><p><a href="media.html#ctypeconv" class="para"><sup class="para">[a] </sup></a> This control may be changed to a menu
control in the future, if more options are required.</p></div></td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="fm-tx-controls"></a>FM Transmitter Control Reference</h3></div></div></div><p>The FM Transmitter (FM_TX) class includes controls for common features of
FM transmissions capable devices. Currently this class includes parameters for audio
compression, pilot tone generation, audio deviation limiter, RDS transmission and
tuning power features.</p><div class="table"><a name="fm-tx-control-id"></a><p class="title"><b>Table 1.7. FM_TX Control IDs</b></p><div class="table-contents"><table summary="FM_TX Control IDs" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"></colgroup><thead><tr><th colspan="2" align="left">ID</th><th align="left">Type</th><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><th colspan="3" align="left">Description</th></tr></thead><tbody valign="top"><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_FM_TX_CLASS</code> </td><td valign="top">class</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">The FM_TX class
descriptor. Calling <a class="link" href="media.html#vidioc-queryctrl" title="ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU"><code class="constant">VIDIOC_QUERYCTRL</code></a> for this control will return a
description of this control class.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_RDS_TX_DEVIATION</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Configures RDS signal frequency deviation level in Hz.
The range and step are driver-specific.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_RDS_TX_PI</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Sets the RDS Programme Identification field
for transmission.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_RDS_TX_PTY</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Sets the RDS Programme Type field for transmission.
This encodes up to 31 pre-defined programme types.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_RDS_TX_PS_NAME</code> </td><td valign="top">string</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Sets the Programme Service name (PS_NAME) for transmission.
It is intended for static display on a receiver. It is the primary aid to listeners in programme service
identification and selection.  In Annex E of <a class="xref" href="media.html#iec62106" title="Specification of the radio data system (RDS) for VHF/FM sound broadcasting in the frequency range from 87,5 to 108,0 MHz">[<abbr class="abbrev">IEC 62106</abbr>]</a>, the RDS specification,
there is a full description of the correct character encoding for Programme Service name strings.
Also from RDS specification, PS is usually a single eight character text. However, it is also possible
to find receivers which can scroll strings sized as 8 x N characters. So, this control must be configured
with steps of 8 characters. The result is it must always contain a string with size multiple of 8.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_RDS_TX_RADIO_TEXT</code> </td><td valign="top">string</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Sets the Radio Text info for transmission. It is a textual description of
what is being broadcasted. RDS Radio Text can be applied when broadcaster wishes to transmit longer PS names,
programme-related information or any other text. In these cases, RadioText should be used in addition to
<code class="constant">V4L2_CID_RDS_TX_PS_NAME</code>. The encoding for Radio Text strings is also fully described
in Annex E of <a class="xref" href="media.html#iec62106" title="Specification of the radio data system (RDS) for VHF/FM sound broadcasting in the frequency range from 87,5 to 108,0 MHz">[<abbr class="abbrev">IEC 62106</abbr>]</a>. The length of Radio Text strings depends on which RDS Block is being
used to transmit it, either 32 (2A block) or 64 (2B block).  However, it is also possible
to find receivers which can scroll strings sized as 32 x N or 64 x N characters. So, this control must be configured
with steps of 32 or 64 characters. The result is it must always contain a string with size multiple of 32 or 64. </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_RDS_TX_MONO_STEREO</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Sets the Mono/Stereo bit of the Decoder Identification code. If set,
then the audio was recorded as stereo.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_RDS_TX_ARTIFICIAL_HEAD</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Sets the
<a class="ulink" href="http://en.wikipedia.org/wiki/Artificial_head" target="_top">Artificial Head</a> bit of the Decoder
Identification code. If set, then the audio was recorded using an artificial head.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_RDS_TX_COMPRESSED</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Sets the Compressed bit of the Decoder Identification code. If set,
then the audio is compressed.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_RDS_TX_DYNAMIC_PTY</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Sets the Dynamic PTY bit of the Decoder Identification code. If set,
then the PTY code is dynamically switched.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_RDS_TX_TRAFFIC_ANNOUNCEMENT</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">If set, then a traffic announcement is in progress.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_RDS_TX_TRAFFIC_PROGRAM</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">If set, then the tuned programme carries traffic announcements.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_RDS_TX_MUSIC_SPEECH</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">If set, then this channel broadcasts music. If cleared, then it
broadcasts speech. If the transmitter doesn't make this distinction, then it should be set.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_RDS_TX_ALT_FREQS_ENABLE</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">If set, then transmit alternate frequencies.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_RDS_TX_ALT_FREQS</code> </td><td valign="top">__u32 array</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">The alternate frequencies in kHz units. The RDS standard allows
for up to 25 frequencies to be defined. Drivers may support fewer frequencies so check
the array size.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_AUDIO_LIMITER_ENABLED</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Enables or disables the audio deviation limiter feature.
The limiter is useful when trying to maximize the audio volume, minimize receiver-generated
distortion and prevent overmodulation.
</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_AUDIO_LIMITER_RELEASE_TIME</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Sets the audio deviation limiter feature release time.
Unit is in useconds. Step and range are driver-specific.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_AUDIO_LIMITER_DEVIATION</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Configures audio frequency deviation level in Hz.
The range and step are driver-specific.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_AUDIO_COMPRESSION_ENABLED</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Enables or disables the audio compression feature.
This feature amplifies signals below the threshold by a fixed gain and compresses audio
signals above the threshold by the ratio of Threshold/(Gain + Threshold).</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_AUDIO_COMPRESSION_GAIN</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Sets the gain for audio compression feature. It is
a dB value. The range and step are driver-specific.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_AUDIO_COMPRESSION_THRESHOLD</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Sets the threshold level for audio compression freature.
It is a dB value. The range and step are driver-specific.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_AUDIO_COMPRESSION_ATTACK_TIME</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Sets the attack time for audio compression feature.
It is a useconds value. The range and step are driver-specific.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_AUDIO_COMPRESSION_RELEASE_TIME</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Sets the release time for audio compression feature.
It is a useconds value. The range and step are driver-specific.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_PILOT_TONE_ENABLED</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Enables or disables the pilot tone generation feature.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_PILOT_TONE_DEVIATION</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Configures pilot tone frequency deviation level. Unit is
in Hz. The range and step are driver-specific.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_PILOT_TONE_FREQUENCY</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Configures pilot tone frequency value. Unit is
in Hz. The range and step are driver-specific.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_TUNE_PREEMPHASIS</code> </td><td valign="top">enum v4l2_preemphasis</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><a name="v4l2-preemphasis"></a>Configures the pre-emphasis value for broadcasting.
A pre-emphasis filter is applied to the broadcast to accentuate the high audio frequencies.
Depending on the region, a time constant of either 50 or 75 useconds is used. The enum v4l2_preemphasis
defines possible values for pre-emphasis. Here they are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_PREEMPHASIS_DISABLED</code> </td><td valign="top">No pre-emphasis is applied.</td></tr><tr><td valign="top"><code class="constant">V4L2_PREEMPHASIS_50_uS</code> </td><td valign="top">A pre-emphasis of 50 uS is used.</td></tr><tr><td valign="top"><code class="constant">V4L2_PREEMPHASIS_75_uS</code> </td><td valign="top">A pre-emphasis of 75 uS is used.</td></tr></tbody></table></td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_TUNE_POWER_LEVEL</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Sets the output power level for signal transmission.
Unit is in dBuV. Range and step are driver-specific.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_TUNE_ANTENNA_CAPACITOR</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">This selects the value of antenna tuning capacitor
manually or automatically if set to zero. Unit, range and step are driver-specific.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr></tbody></table></div></div><br class="table-break"><p>For more details about RDS specification, refer to
<a class="xref" href="media.html#iec62106" title="Specification of the radio data system (RDS) for VHF/FM sound broadcasting in the frequency range from 87,5 to 108,0 MHz">[<abbr class="abbrev">IEC 62106</abbr>]</a> document, from CENELEC.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="flash-controls"></a>Flash Control Reference</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#flash-controls-use-cases">Supported use cases</a></span></dt></dl></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Experimental</h3><p>This is an <a class="link" href="media.html#experimental" title="Experimental API Elements">experimental</a>
interface and may change in the future.</p></div><p>
	The V4L2 flash controls are intended to provide generic access
	to flash controller devices. Flash controller devices are
	typically used in digital cameras.
      </p><p>
	The interface can support both LED and xenon flash devices. As
	of writing this, there is no xenon flash driver using this
	interface.
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="flash-controls-use-cases"></a>Supported use cases</h4></div></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idp48930032"></a>Unsynchronised LED flash (software strobe)</h5></div></div></div><p>
	    Unsynchronised LED flash is controlled directly by the
	    host as the sensor. The flash must be enabled by the host
	    before the exposure of the image starts and disabled once
	    it ends. The host is fully responsible for the timing of
	    the flash.
	  </p><p>Example of such device: Nokia N900.</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idp48931856"></a>Synchronised LED flash (hardware strobe)</h5></div></div></div><p>
	    The synchronised LED flash is pre-programmed by the host
	    (power and timeout) but controlled by the sensor through a
	    strobe signal from the sensor to the flash.
	  </p><p>
	    The sensor controls the flash duration and timing. This
	    information typically must be made available to the
	    sensor.
	  </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idp48933728"></a>LED flash as torch</h5></div></div></div><p>
	    LED flash may be used as torch in conjunction with another
	    use case involving camera or individually.
	  </p><div class="table"><a name="flash-control-id"></a><p class="title"><b>Table 1.8. Flash Control IDs</b></p><div class="table-contents"><table summary="Flash Control IDs" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"></colgroup><thead><tr><th colspan="2" align="left">ID</th><th align="left">Type</th><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><th colspan="3" align="left">Description</th></tr></thead><tbody valign="top"><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_FLASH_CLASS</code></td><td valign="top">class</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">The FLASH class descriptor.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_FLASH_LED_MODE</code></td><td valign="top">menu</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><a name="v4l2-flash-led-mode"></a>Defines the mode of the flash LED,
    	    the high-power white LED attached to the flash controller.
    	    Setting this control may not be possible in presence of
    	    some faults. See V4L2_CID_FLASH_FAULT.</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_FLASH_LED_MODE_NONE</code></td><td valign="top">Off.</td></tr><tr><td valign="top"><code class="constant">V4L2_FLASH_LED_MODE_FLASH</code></td><td valign="top">Flash mode.</td></tr><tr><td valign="top"><code class="constant">V4L2_FLASH_LED_MODE_TORCH</code></td><td valign="top">Torch mode. See V4L2_CID_FLASH_TORCH_INTENSITY.</td></tr></tbody></table></td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_FLASH_STROBE_SOURCE</code></td><td valign="top">menu</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><a name="v4l2-flash-strobe-source"></a>Defines the source of the flash LED
    	  strobe.</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_FLASH_STROBE_SOURCE_SOFTWARE</code></td><td valign="top">The flash strobe is triggered by using
    		  the V4L2_CID_FLASH_STROBE control.</td></tr><tr><td valign="top"><code class="constant">V4L2_FLASH_STROBE_SOURCE_EXTERNAL</code></td><td valign="top">The flash strobe is triggered by an
    		  external source. Typically this is a sensor,
    		  which makes it possible to synchronises the
    		  flash strobe start to exposure start.</td></tr></tbody></table></td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_FLASH_STROBE</code></td><td valign="top">button</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Strobe flash. Valid when
    	    V4L2_CID_FLASH_LED_MODE is set to
    	    V4L2_FLASH_LED_MODE_FLASH and V4L2_CID_FLASH_STROBE_SOURCE
    	    is set to V4L2_FLASH_STROBE_SOURCE_SOFTWARE. Setting this
    	    control may not be possible in presence of some faults.
    	    See V4L2_CID_FLASH_FAULT.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_FLASH_STROBE_STOP</code></td><td valign="top">button</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Stop flash strobe immediately.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_FLASH_STROBE_STATUS</code></td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Strobe status: whether the flash
    	    is strobing at the moment or not. This is a read-only
    	    control.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_FLASH_TIMEOUT</code></td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Hardware timeout for flash. The
    	    flash strobe is stopped after this period of time has
    	    passed from the start of the strobe.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_FLASH_INTENSITY</code></td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Intensity of the flash strobe when
    	    the flash LED is in flash mode
    	    (V4L2_FLASH_LED_MODE_FLASH). The unit should be milliamps
    	    (mA) if possible.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_FLASH_TORCH_INTENSITY</code></td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Intensity of the flash LED in
    	    torch mode (V4L2_FLASH_LED_MODE_TORCH). The unit should be
    	    milliamps (mA) if possible. Setting this control may not
    	    be possible in presence of some faults. See
    	    V4L2_CID_FLASH_FAULT.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_FLASH_INDICATOR_INTENSITY</code></td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Intensity of the indicator LED.
    	    The indicator LED may be fully independent of the flash
    	    LED. The unit should be microamps (uA) if possible.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_FLASH_FAULT</code></td><td valign="top">bitmask</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Faults related to the flash. The
    	    faults tell about specific problems in the flash chip
    	    itself or the LEDs attached to it. Faults may prevent
    	    further use of some of the flash controls. In particular,
    	    V4L2_CID_FLASH_LED_MODE is set to V4L2_FLASH_LED_MODE_NONE
    	    if the fault affects the flash LED. Exactly which faults
    	    have such an effect is chip dependent. Reading the faults
    	    resets the control and returns the chip to a usable state
    	    if possible.</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_FLASH_FAULT_OVER_VOLTAGE</code></td><td valign="top">Flash controller voltage to the flash LED
    		  has exceeded the limit specific to the flash
    		  controller.</td></tr><tr><td valign="top"><code class="constant">V4L2_FLASH_FAULT_TIMEOUT</code></td><td valign="top">The flash strobe was still on when
    		  the timeout set by the user ---
    		  V4L2_CID_FLASH_TIMEOUT control --- has expired.
    		  Not all flash controllers may set this in all
    		  such conditions.</td></tr><tr><td valign="top"><code class="constant">V4L2_FLASH_FAULT_OVER_TEMPERATURE</code></td><td valign="top">The flash controller has overheated.</td></tr><tr><td valign="top"><code class="constant">V4L2_FLASH_FAULT_SHORT_CIRCUIT</code></td><td valign="top">The short circuit protection of the flash
    		  controller has been triggered.</td></tr><tr><td valign="top"><code class="constant">V4L2_FLASH_FAULT_OVER_CURRENT</code></td><td valign="top">Current in the LED power supply has exceeded the limit
    		  specific to the flash controller.</td></tr><tr><td valign="top"><code class="constant">V4L2_FLASH_FAULT_INDICATOR</code></td><td valign="top">The flash controller has detected a short or open
    		  circuit condition on the indicator LED.</td></tr><tr><td valign="top"><code class="constant">V4L2_FLASH_FAULT_UNDER_VOLTAGE</code></td><td valign="top">Flash controller voltage to the flash LED
		  has been below the minimum limit specific to the flash
		  controller.</td></tr><tr><td valign="top"><code class="constant">V4L2_FLASH_FAULT_INPUT_VOLTAGE</code></td><td valign="top">The input voltage of the flash controller is below
		  the limit under which strobing the flash at full current
		  will not be possible.The condition persists until this flag
		  is no longer set.</td></tr><tr><td valign="top"><code class="constant">V4L2_FLASH_FAULT_LED_OVER_TEMPERATURE</code></td><td valign="top">The temperature of the LED has exceeded its
		  allowed upper limit.</td></tr></tbody></table></td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_FLASH_CHARGE</code></td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Enable or disable charging of the xenon
    	  flash capacitor.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_FLASH_READY</code></td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Is the flash ready to strobe?
    	    Xenon flashes require their capacitors charged before
    	    strobing. LED flashes often require a cooldown period
    	    after strobe during which another strobe will not be
    	    possible. This is a read-only control.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr></tbody></table></div></div><br class="table-break"></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="jpeg-controls"></a>JPEG Control Reference</h3></div></div></div><p>The JPEG class includes controls for common features of JPEG
      encoders and decoders. Currently it includes features for codecs
      implementing progressive baseline DCT compression process with
      Huffman entrophy coding.</p><div class="table"><a name="jpeg-control-id"></a><p class="title"><b>Table 1.9. JPEG Control IDs</b></p><div class="table-contents"><table summary="JPEG Control IDs" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"></colgroup><thead><tr><th colspan="2" align="left">ID</th><th align="left">Type</th><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><th colspan="3" align="left">Description</th></tr></thead><tbody valign="top"><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_JPEG_CLASS</code> </td><td valign="top">class</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">The JPEG class descriptor. Calling
	  <a class="link" href="media.html#vidioc-queryctrl" title="ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU"><code class="constant">VIDIOC_QUERYCTRL</code></a> for this control will return a description of this
	  control class.

	</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_JPEG_CHROMA_SUBSAMPLING</code></td><td valign="top">menu</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><a name="v4l2-jpeg-chroma-subsampling"></a>The chroma subsampling factors describe how
	    each component of an input image is sampled, in respect to maximum
	    sample rate in each spatial dimension. See <a class="xref" href="media.html#itu-t81" title='ITU-T Recommendation T.81 "Information Technology &#8212; Digital Compression and Coding of Continous-Tone Still Images &#8212; Requirements and Guidelines"'>[<abbr class="abbrev">ITU-T.81</abbr>]</a>,
	    clause A.1.1. for more details. The <code class="constant">
	    V4L2_CID_JPEG_CHROMA_SUBSAMPLING</code> control determines how
	    Cb and Cr components are downsampled after coverting an input image
	    from RGB to Y'CbCr color space.
	    </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_JPEG_CHROMA_SUBSAMPLING_444</code>
		  </td><td valign="top">No chroma subsampling, each pixel has
		  Y, Cr and Cb values.</td></tr><tr><td valign="top"><code class="constant">V4L2_JPEG_CHROMA_SUBSAMPLING_422</code>
		  </td><td valign="top">Horizontally subsample Cr, Cb components
		  by a factor of 2.</td></tr><tr><td valign="top"><code class="constant">V4L2_JPEG_CHROMA_SUBSAMPLING_420</code>
		  </td><td valign="top">Subsample Cr, Cb components horizontally
		  and vertically by 2.</td></tr><tr><td valign="top"><code class="constant">V4L2_JPEG_CHROMA_SUBSAMPLING_411</code>
		  </td><td valign="top">Horizontally subsample Cr, Cb components
		  by a factor of 4.</td></tr><tr><td valign="top"><code class="constant">V4L2_JPEG_CHROMA_SUBSAMPLING_410</code>
		  </td><td valign="top">Subsample Cr, Cb components horizontally
		  by 4 and vertically by 2.</td></tr><tr><td valign="top"><code class="constant">V4L2_JPEG_CHROMA_SUBSAMPLING_GRAY</code>
		  </td><td valign="top">Use only luminance component.</td></tr></tbody></table></td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_JPEG_RESTART_INTERVAL</code>
	    </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">
	      The restart interval determines an interval of inserting RSTm
	      markers (m = 0..7). The purpose of these markers is to additionally
	      reinitialize the encoder process, in order to process blocks of
	      an image independently.
	      For the lossy compression processes the restart interval unit is
	      MCU (Minimum Coded Unit) and its value is contained in DRI
	      (Define Restart Interval) marker. If <code class="constant">
	      V4L2_CID_JPEG_RESTART_INTERVAL</code> control is set to 0,
	      DRI and RSTm markers will not be inserted.
	    </td></tr><tr><td colspan="2" valign="top"><a name="jpeg-quality-control"></a><code class="constant">V4L2_CID_JPEG_COMPRESSION_QUALITY</code></td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">
	      <code class="constant">V4L2_CID_JPEG_COMPRESSION_QUALITY</code> control
	      determines trade-off between image quality and size.
	      It provides simpler method for applications to control image quality,
	      without a need for direct reconfiguration of luminance and chrominance
	      quantization tables.

	      In cases where a driver uses quantization tables configured directly
	      by an application, using interfaces defined elsewhere, <code class="constant">
	      V4L2_CID_JPEG_COMPRESSION_QUALITY</code> control should be set
	      by driver to 0.

	      <p>The value range of this control is driver-specific. Only
	      positive, non-zero values are meaningful. The recommended range
	      is 1 - 100, where larger values correspond to better image quality.
	      </p>
	    </td></tr><tr><td colspan="2" valign="top"><a name="jpeg-active-marker-control"></a><code class="constant">V4L2_CID_JPEG_ACTIVE_MARKER</code></td><td valign="top">bitmask</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Specify which JPEG markers are included
	    in compressed stream. This control is valid only for encoders.
	    </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_JPEG_ACTIVE_MARKER_APP0</code></td><td valign="top">Application data segment APP<sub>0</sub>.</td></tr><tr><td valign="top"><code class="constant">V4L2_JPEG_ACTIVE_MARKER_APP1</code></td><td valign="top">Application data segment APP<sub>1</sub>.</td></tr><tr><td valign="top"><code class="constant">V4L2_JPEG_ACTIVE_MARKER_COM</code></td><td valign="top">Comment segment.</td></tr><tr><td valign="top"><code class="constant">V4L2_JPEG_ACTIVE_MARKER_DQT</code></td><td valign="top">Quantization tables segment.</td></tr><tr><td valign="top"><code class="constant">V4L2_JPEG_ACTIVE_MARKER_DHT</code></td><td valign="top">Huffman tables segment.</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr></tbody></table></div></div><br class="table-break"><p>For more details about JPEG specification, refer
      to <a class="xref" href="media.html#itu-t81" title='ITU-T Recommendation T.81 "Information Technology &#8212; Digital Compression and Coding of Continous-Tone Still Images &#8212; Requirements and Guidelines"'>[<abbr class="abbrev">ITU-T.81</abbr>]</a>, <a class="xref" href="media.html#jfif" title="JPEG File Interchange Format">[<abbr class="abbrev">JFIF</abbr>]</a>,
      <a class="xref" href="media.html#w3c-jpeg-jfif" title="JPEG JFIF">[<abbr class="abbrev">W3C JPEG JFIF</abbr>]</a>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="image-source-controls"></a>Image Source Control Reference</h3></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Experimental</h3><p>This is an <a class="link" href="media.html#experimental" title="Experimental API Elements">experimental</a> interface and may
	change in the future.</p></div><p>
	The Image Source control class is intended for low-level
	control of image source devices such as image sensors. The
	devices feature an analogue to digital converter and a bus
	transmitter to transmit the image data out of the device.
      </p><div class="table"><a name="image-source-control-id"></a><p class="title"><b>Table 1.10. Image Source Control IDs</b></p><div class="table-contents"><table summary="Image Source Control IDs" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"></colgroup><thead><tr><th colspan="2" align="left">ID</th><th align="left">Type</th><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><th colspan="3" align="left">Description</th></tr></thead><tbody valign="top"><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_IMAGE_SOURCE_CLASS</code></td><td valign="top">class</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">The IMAGE_SOURCE class descriptor.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_VBLANK</code></td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Vertical blanking. The idle period
	    after every frame during which no image data is produced.
	    The unit of vertical blanking is a line. Every line has
	    length of the image width plus horizontal blanking at the
	    pixel rate defined by
	    <code class="constant">V4L2_CID_PIXEL_RATE</code> control in the
	    same sub-device.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_HBLANK</code></td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Horizontal blanking. The idle
	    period after every line of image data during which no
	    image data is produced. The unit of horizontal blanking is
	    pixels.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_ANALOGUE_GAIN</code></td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Analogue gain is gain affecting
	    all colour components in the pixel matrix. The gain
	    operation is performed in the analogue domain before A/D
	    conversion.
	    </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_TEST_PATTERN_RED</code></td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Test pattern red colour component.
	    </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_TEST_PATTERN_GREENR</code></td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Test pattern green (next to red)
	    colour component.
	    </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_TEST_PATTERN_BLUE</code></td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Test pattern blue colour component.
	    </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_TEST_PATTERN_GREENB</code></td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Test pattern green (next to blue)
	    colour component.
	    </td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="image-process-controls"></a>Image Process Control Reference</h3></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Experimental</h3><p>This is an <a class="link" href="media.html#experimental" title="Experimental API Elements">experimental</a> interface and may
	change in the future.</p></div><p>
	The Image Source control class is intended for low-level control of
	image processing functions. Unlike
	<code class="constant">V4L2_CID_IMAGE_SOURCE_CLASS</code>, the controls in
	this class affect processing the image, and do not control capturing
	of it.
      </p><div class="table"><a name="image-process-control-id"></a><p class="title"><b>Table 1.11. Image Source Control IDs</b></p><div class="table-contents"><table summary="Image Source Control IDs" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"></colgroup><thead><tr><th colspan="2" align="left">ID</th><th align="left">Type</th><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><th colspan="3" align="left">Description</th></tr></thead><tbody valign="top"><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_IMAGE_PROC_CLASS</code></td><td valign="top">class</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">The IMAGE_PROC class descriptor.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_LINK_FREQ</code></td><td valign="top">integer menu</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Data bus frequency. Together with the
	    media bus pixel code, bus type (clock cycles per sample), the
	    data bus frequency defines the pixel rate
	    (<code class="constant">V4L2_CID_PIXEL_RATE</code>) in the
	    pixel array (or possibly elsewhere, if the device is not an
	    image sensor). The frame rate can be calculated from the pixel
	    clock, image width and height and horizontal and vertical
	    blanking. While the pixel rate control may be defined elsewhere
	    than in the subdev containing the pixel array, the frame rate
	    cannot be obtained from that information. This is because only
	    on the pixel array it can be assumed that the vertical and
	    horizontal blanking information is exact: no other blanking is
	    allowed in the pixel array. The selection of frame rate is
	    performed by selecting the desired horizontal and vertical
	    blanking. The unit of this control is Hz. </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_PIXEL_RATE</code></td><td valign="top">64-bit integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Pixel rate in the source pads of
	    the subdev. This control is read-only and its unit is
	    pixels / second.
	    </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_TEST_PATTERN</code></td><td valign="top">menu</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><a name="v4l2-test-pattern"></a> Some capture/display/sensor devices have
	    the capability to generate test pattern images. These hardware
	    specific test patterns can be used to test if a device is working
	    properly.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dv-controls"></a>Digital Video Control Reference</h3></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Experimental</h3><p>This is an <a class="link" href="media.html#experimental" title="Experimental API Elements">experimental</a> interface and may
	change in the future.</p></div><p>
	The Digital Video control class is intended to control receivers
	and transmitters for <a class="ulink" href="http://en.wikipedia.org/wiki/Vga" target="_top">VGA</a>,
	<a class="ulink" href="http://en.wikipedia.org/wiki/Digital_Visual_Interface" target="_top">DVI</a>
	(Digital Visual Interface), HDMI (<a class="xref" href="media.html#hdmi" title="High-Definition Multimedia Interface">[<abbr class="abbrev">HDMI</abbr>]</a>) and DisplayPort (<a class="xref" href="media.html#dp" title="VESA DisplayPort Standard">[<abbr class="abbrev">DP</abbr>]</a>).
	These controls are generally expected to be private to the receiver or transmitter
	subdevice that implements them, so they are only exposed on the
	<code class="filename">/dev/v4l-subdev*</code> device node.
      </p><p>Note that these devices can have multiple input or output pads which are
      hooked up to e.g. HDMI connectors. Even though the subdevice will receive or
      transmit video from/to only one of those pads, the other pads can still be
      active when it comes to EDID (Extended Display Identification Data,
      <a class="xref" href="media.html#vesaedid" title="VESA Enhanced Extended Display Identification Data Standard">[<abbr class="abbrev">EDID</abbr>]</a>) and HDCP (High-bandwidth Digital Content
      Protection System, <a class="xref" href="media.html#hdcp" title="High-bandwidth Digital Content Protection System">[<abbr class="abbrev">HDCP</abbr>]</a>) processing, allowing the device
      to do the fairly slow EDID/HDCP handling in advance. This allows for quick
      switching between connectors.</p><p>These pads appear in several of the controls in this section as
      bitmasks, one bit for each pad. Bit 0 corresponds to pad 0, bit 1 to pad 1,
      etc. The maximum value of the control is the set of valid pads.</p><div class="table"><a name="dv-control-id"></a><p class="title"><b>Table 1.12. Digital Video Control IDs</b></p><div class="table-contents"><table summary="Digital Video Control IDs" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"></colgroup><thead><tr><th colspan="2" align="left">ID</th><th align="left">Type</th><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><th colspan="3" align="left">Description</th></tr></thead><tbody valign="top"><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_DV_CLASS</code></td><td valign="top">class</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">The Digital Video class descriptor.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_DV_TX_HOTPLUG</code></td><td valign="top">bitmask</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Many connectors have a hotplug pin which is high
	    if EDID information is available from the source. This control shows the
	    state of the hotplug pin as seen by the transmitter.
	    Each bit corresponds to an output pad on the transmitter. If an output pad
	    does not have an associated hotplug pin, then the bit for that pad will be 0.
	    This read-only control is applicable to DVI-D, HDMI and DisplayPort connectors.
	    </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_DV_TX_RXSENSE</code></td><td valign="top">bitmask</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Rx Sense is the detection of pull-ups on the TMDS
            clock lines. This normally means that the sink has left/entered standby (i.e.
	    the transmitter can sense that the receiver is ready to receive video).
	    Each bit corresponds to an output pad on the transmitter. If an output pad
	    does not have an associated Rx Sense, then the bit for that pad will be 0.
	    This read-only control is applicable to DVI-D and HDMI devices.
	    </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_DV_TX_EDID_PRESENT</code></td><td valign="top">bitmask</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">When the transmitter sees the hotplug signal from the
	    receiver it will attempt to read the EDID. If set, then the transmitter has read
	    at least the first block (= 128 bytes).
	    Each bit corresponds to an output pad on the transmitter. If an output pad
	    does not support EDIDs, then the bit for that pad will be 0.
	    This read-only control is applicable to VGA, DVI-A/D, HDMI and DisplayPort connectors.
	    </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_DV_TX_MODE</code></td><td valign="top"><a name="v4l2-dv-tx-mode"></a>enum v4l2_dv_tx_mode</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">HDMI transmitters can transmit in DVI-D mode (just video)
	    or in HDMI mode (video + audio + auxiliary data). This control selects which mode
	    to use: V4L2_DV_TX_MODE_DVI_D or V4L2_DV_TX_MODE_HDMI.
	    This control is applicable to HDMI connectors.
	    </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_DV_TX_RGB_RANGE</code></td><td valign="top"><a name="v4l2-dv-rgb-range"></a>enum v4l2_dv_rgb_range</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Select the quantization range for RGB output. V4L2_DV_RANGE_AUTO
	    follows the RGB quantization range specified in the standard for the video interface
	    (ie. <a class="xref" href="media.html#cea861" title="A DTV Profile for Uncompressed High Speed Digital Interfaces">[<abbr class="abbrev">CEA-861-E</abbr>]</a> for HDMI). V4L2_DV_RANGE_LIMITED and V4L2_DV_RANGE_FULL override the standard
	    to be compatible with sinks that have not implemented the standard correctly
	    (unfortunately quite common for HDMI and DVI-D). Full range allows all possible values to be
	    used whereas limited range sets the range to (16 &lt;&lt; (N-8)) - (235 &lt;&lt; (N-8))
	    where N is the number of bits per component.
	    This control is applicable to VGA, DVI-A/D, HDMI and DisplayPort connectors.
	    </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_DV_RX_POWER_PRESENT</code></td><td valign="top">bitmask</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Detects whether the receiver receives power from the source
	    (e.g. HDMI carries 5V on one of the pins). This is often used to power an eeprom
	    which contains EDID information, such that the source can read the EDID even if
	    the sink is in standby/power off.
	    Each bit corresponds to an input pad on the transmitter. If an input pad
	    cannot detect whether power is present, then the bit for that pad will be 0.
	    This read-only control is applicable to DVI-D, HDMI and DisplayPort connectors.
	    </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_DV_RX_RGB_RANGE</code></td><td valign="top">enum v4l2_dv_rgb_range</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Select the quantization range for RGB input. V4L2_DV_RANGE_AUTO
	    follows the RGB quantization range specified in the standard for the video interface
	    (ie. <a class="xref" href="media.html#cea861" title="A DTV Profile for Uncompressed High Speed Digital Interfaces">[<abbr class="abbrev">CEA-861-E</abbr>]</a> for HDMI). V4L2_DV_RANGE_LIMITED and V4L2_DV_RANGE_FULL override the standard
	    to be compatible with sources that have not implemented the standard correctly
	    (unfortunately quite common for HDMI and DVI-D). Full range allows all possible values to be
	    used whereas limited range sets the range to (16 &lt;&lt; (N-8)) - (235 &lt;&lt; (N-8))
	    where N is the number of bits per component.
	    This control is applicable to VGA, DVI-A/D, HDMI and DisplayPort connectors.
	    </td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="fm-rx-controls"></a>FM Receiver Control Reference</h3></div></div></div><p>The FM Receiver (FM_RX) class includes controls for common features of
      FM Reception capable devices.</p><div class="table"><a name="fm-rx-control-id"></a><p class="title"><b>Table 1.13. FM_RX Control IDs</b></p><div class="table-contents"><table summary="FM_RX Control IDs" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"></colgroup><thead><tr><th colspan="2" align="left">ID</th><th align="left">Type</th><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><th colspan="3" align="left">Description</th></tr></thead><tbody valign="top"><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_FM_RX_CLASS</code> </td><td valign="top">class</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">The FM_RX class
descriptor. Calling <a class="link" href="media.html#vidioc-queryctrl" title="ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU"><code class="constant">VIDIOC_QUERYCTRL</code></a> for this control will return a
description of this control class.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_RDS_RECEPTION</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Enables/disables RDS
	  reception by the radio tuner</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_RDS_RX_PTY</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Gets RDS Programme Type field.
This encodes up to 31 pre-defined programme types.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_RDS_RX_PS_NAME</code> </td><td valign="top">string</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Gets the Programme Service name (PS_NAME).
It is intended for static display on a receiver. It is the primary aid to listeners in programme service
identification and selection.  In Annex E of <a class="xref" href="media.html#iec62106" title="Specification of the radio data system (RDS) for VHF/FM sound broadcasting in the frequency range from 87,5 to 108,0 MHz">[<abbr class="abbrev">IEC 62106</abbr>]</a>, the RDS specification,
there is a full description of the correct character encoding for Programme Service name strings.
Also from RDS specification, PS is usually a single eight character text. However, it is also possible
to find receivers which can scroll strings sized as 8 x N characters. So, this control must be configured
with steps of 8 characters. The result is it must always contain a string with size multiple of 8.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_RDS_RX_RADIO_TEXT</code> </td><td valign="top">string</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Gets the Radio Text info. It is a textual description of
what is being broadcasted. RDS Radio Text can be applied when broadcaster wishes to transmit longer PS names,
programme-related information or any other text. In these cases, RadioText can be used in addition to
<code class="constant">V4L2_CID_RDS_RX_PS_NAME</code>. The encoding for Radio Text strings is also fully described
in Annex E of <a class="xref" href="media.html#iec62106" title="Specification of the radio data system (RDS) for VHF/FM sound broadcasting in the frequency range from 87,5 to 108,0 MHz">[<abbr class="abbrev">IEC 62106</abbr>]</a>. The length of Radio Text strings depends on which RDS Block is being
used to transmit it, either 32 (2A block) or 64 (2B block).  However, it is also possible
to find receivers which can scroll strings sized as 32 x N or 64 x N characters. So, this control must be configured
with steps of 32 or 64 characters. The result is it must always contain a string with size multiple of 32 or 64. </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_RDS_RX_TRAFFIC_ANNOUNCEMENT</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">If set, then a traffic announcement is in progress.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_RDS_RX_TRAFFIC_PROGRAM</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">If set, then the tuned programme carries traffic announcements.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_RDS_RX_MUSIC_SPEECH</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">If set, then this channel broadcasts music. If cleared, then it
broadcasts speech. If the transmitter doesn't make this distinction, then it will be set.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_TUNE_DEEMPHASIS</code> </td><td valign="top">enum v4l2_deemphasis</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><a name="v4l2-deemphasis"></a>Configures the de-emphasis value for reception.
A de-emphasis filter is applied to the broadcast to accentuate the high audio frequencies.
Depending on the region, a time constant of either 50 or 75 useconds is used. The enum v4l2_deemphasis
defines possible values for de-emphasis. Here they are:</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_DEEMPHASIS_DISABLED</code> </td><td valign="top">No de-emphasis is applied.</td></tr><tr><td valign="top"><code class="constant">V4L2_DEEMPHASIS_50_uS</code> </td><td valign="top">A de-emphasis of 50 uS is used.</td></tr><tr><td valign="top"><code class="constant">V4L2_DEEMPHASIS_75_uS</code> </td><td valign="top">A de-emphasis of 75 uS is used.</td></tr></tbody></table></td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="detect-controls"></a>Detect Control Reference</h3></div></div></div><p>The Detect class includes controls for common features of
      various motion or object detection capable devices.</p><div class="table"><a name="detect-control-id"></a><p class="title"><b>Table 1.14. Detect Control IDs</b></p><div class="table-contents"><table summary="Detect Control IDs" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"></colgroup><thead><tr><th colspan="2" align="left">ID</th><th align="left">Type</th><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><th colspan="3" align="left">Description</th></tr></thead><tbody valign="top"><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_DETECT_CLASS</code> </td><td valign="top">class</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">The Detect class
descriptor. Calling <a class="link" href="media.html#vidioc-queryctrl" title="ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU"><code class="constant">VIDIOC_QUERYCTRL</code></a> for this control will return a
description of this control class.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_DETECT_MD_MODE</code> </td><td valign="top">menu</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Sets the motion detection mode.</td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top"><table width="100%" border="0"><colgroup><col><col></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_DETECT_MD_MODE_DISABLED</code>
		  </td><td valign="top">Disable motion detection.</td></tr><tr><td valign="top"><code class="constant">V4L2_DETECT_MD_MODE_GLOBAL</code>
		  </td><td valign="top">Use a single motion detection threshold.</td></tr><tr><td valign="top"><code class="constant">V4L2_DETECT_MD_MODE_THRESHOLD_GRID</code>
		  </td><td valign="top">The image is divided into a grid, each cell with its own
		  motion detection threshold. These thresholds are set through the
		  <code class="constant">V4L2_CID_DETECT_MD_THRESHOLD_GRID</code> matrix control.</td></tr><tr><td valign="top"><code class="constant">V4L2_DETECT_MD_MODE_REGION_GRID</code>
		  </td><td valign="top">The image is divided into a grid, each cell with its own
		  region value that specifies which per-region motion detection thresholds
		  should be used. Each region has its own thresholds. How these per-region
		  thresholds are set up is driver-specific. The region values for the grid are set
		  through the <code class="constant">V4L2_CID_DETECT_MD_REGION_GRID</code> matrix
		  control.</td></tr></tbody></table></td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_DETECT_MD_GLOBAL_THRESHOLD</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Sets the global motion detection threshold to be
	  used with the <code class="constant">V4L2_DETECT_MD_MODE_GLOBAL</code> motion detection mode.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_DETECT_MD_THRESHOLD_GRID</code> </td><td valign="top">__u16 matrix</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Sets the motion detection thresholds for each cell in the grid.
	  To be used with the <code class="constant">V4L2_DETECT_MD_MODE_THRESHOLD_GRID</code>
	  motion detection mode. Matrix element (0, 0) represents the cell at the top-left of the
	  grid.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_DETECT_MD_REGION_GRID</code> </td><td valign="top">__u8 matrix</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Sets the motion detection region value for each cell in the grid.
	  To be used with the <code class="constant">V4L2_DETECT_MD_MODE_REGION_GRID</code>
	  motion detection mode. Matrix element (0, 0) represents the cell at the top-left of the
	  grid.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="rf-tuner-controls"></a>RF Tuner Control Reference</h3></div></div></div><p>
The RF Tuner (RF_TUNER) class includes controls for common features of devices
having RF tuner.
      </p><p>
In this context, RF tuner is radio receiver circuit between antenna and
demodulator. It receives radio frequency (RF) from the antenna and converts that
received signal to lower intermediate frequency (IF) or baseband frequency (BB).
Tuners that could do baseband output are often called Zero-IF tuners. Older
tuners were typically simple PLL tuners inside a metal box, whilst newer ones
are highly integrated chips without a metal box "silicon tuners". These controls
are mostly applicable for new feature rich silicon tuners, just because older
tuners does not have much adjustable features.
      </p><p>
For more information about RF tuners see
<a class="ulink" href="http://en.wikipedia.org/wiki/Tuner_%28radio%29" target="_top">Tuner (radio)</a>
and
<a class="ulink" href="http://en.wikipedia.org/wiki/RF_front_end" target="_top">RF front end</a>
from Wikipedia.
      </p><div class="table"><a name="rf-tuner-control-id"></a><p class="title"><b>Table 1.15. RF_TUNER Control IDs</b></p><div class="table-contents"><table summary="RF_TUNER Control IDs" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"></colgroup><thead><tr><th colspan="2" align="left">ID</th><th align="left">Type</th><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><th colspan="3" align="left">Description</th></tr></thead><tbody valign="top"><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_RF_TUNER_CLASS</code> </td><td valign="top">class</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">The RF_TUNER class
descriptor. Calling <a class="link" href="media.html#vidioc-queryctrl" title="ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU"><code class="constant">VIDIOC_QUERYCTRL</code></a> for this control will return a
description of this control class.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_RF_TUNER_BANDWIDTH_AUTO</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Enables/disables tuner radio channel
bandwidth configuration. In automatic mode bandwidth configuration is performed
by the driver.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_RF_TUNER_BANDWIDTH</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Filter(s) on tuner signal path are used to
filter signal according to receiving party needs. Driver configures filters to
fulfill desired bandwidth requirement. Used when V4L2_CID_RF_TUNER_BANDWIDTH_AUTO is not
set. Unit is in Hz. The range and step are driver-specific.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_RF_TUNER_LNA_GAIN_AUTO</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Enables/disables LNA automatic gain control (AGC)</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_RF_TUNER_MIXER_GAIN_AUTO</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Enables/disables mixer automatic gain control (AGC)</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_RF_TUNER_IF_GAIN_AUTO</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Enables/disables IF automatic gain control (AGC)</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_RF_TUNER_LNA_GAIN</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">LNA (low noise amplifier) gain is first
gain stage on the RF tuner signal path. It is located very close to tuner
antenna input. Used when <code class="constant">V4L2_CID_RF_TUNER_LNA_GAIN_AUTO</code> is not set.
The range and step are driver-specific.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_RF_TUNER_MIXER_GAIN</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Mixer gain is second gain stage on the RF
tuner signal path. It is located inside mixer block, where RF signal is
down-converted by the mixer. Used when <code class="constant">V4L2_CID_RF_TUNER_MIXER_GAIN_AUTO</code>
is not set. The range and step are driver-specific.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_RF_TUNER_IF_GAIN</code> </td><td valign="top">integer</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">IF gain is last gain stage on the RF tuner
signal path. It is located on output of RF tuner. It controls signal level of
intermediate frequency output or baseband output. Used when
<code class="constant">V4L2_CID_RF_TUNER_IF_GAIN_AUTO</code> is not set. The range and step are
driver-specific.</td></tr><tr><td colspan="2" valign="top"><code class="constant">V4L2_CID_RF_TUNER_PLL_LOCK</code> </td><td valign="top">boolean</td><td class="auto-generated"> </td></tr><tr><td class="auto-generated"> </td><td colspan="3" valign="top">Is synthesizer PLL locked? RF tuner is
receiving given frequency when that control is set. This is a read-only control.
</td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="format"></a>Data Formats</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#idp51292128">Data Format Negotiation</a></span></dt><dt><span class="section"><a href="media.html#idp51320592">Image Format Enumeration</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp51292128"></a>Data Format Negotiation</h3></div></div></div><p>Different devices exchange different kinds of data with
applications, for example video images, raw or sliced VBI data, RDS
datagrams. Even within one kind many different formats are possible,
in particular an abundance of image formats. Although drivers must
provide a default and the selection persists across closing and
reopening a device, applications should always negotiate a data format
before engaging in data exchange. Negotiation means the application
asks for a particular format and the driver selects and reports the
best the hardware can do to satisfy the request. Of course
applications can also just query the current selection.</p><p>A single mechanism exists to negotiate all data formats
using the aggregate struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a> and the <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_G_FMT</code></a> and
<a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> ioctls. Additionally the <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_TRY_FMT</code></a> ioctl can be
used to examine what the hardware <span class="emphasis"><em>could</em></span> do,
without actually selecting a new data format. The data formats
supported by the V4L2 API are covered in the respective device section
in <a class="xref" href="media.html#devices" title="Chapter 4. Interfaces">Chapter 4, <i>Interfaces</i></a>. For a closer look at image formats see
<a class="xref" href="media.html#pixfmt" title="Chapter 2. Image Formats">Chapter 2, <i>Image Formats</i></a>.</p><p>The <code class="constant">VIDIOC_S_FMT</code> ioctl is a major
turning-point in the initialization sequence. Prior to this point
multiple panel applications can access the same device concurrently to
select the current input, change controls or modify other properties.
The first <code class="constant">VIDIOC_S_FMT</code> assigns a logical stream
(video data, VBI data etc.) exclusively to one file descriptor.</p><p>Exclusive means no other application, more precisely no
other file descriptor, can grab this stream or change device
properties inconsistent with the negotiated parameters. A video
standard change for example, when the new standard uses a different
number of scan lines, can invalidate the selected image format.
Therefore only the file descriptor owning the stream can make
invalidating changes. Accordingly multiple file descriptors which
grabbed different logical streams prevent each other from interfering
with their settings. When for example video overlay is about to start
or already in progress, simultaneous video capturing may be restricted
to the same cropping and image size.</p><p>When applications omit the
<code class="constant">VIDIOC_S_FMT</code> ioctl its locking side effects are
implied by the next step, the selection of an I/O method with the
<a class="link" href="media.html#vidioc-reqbufs" title="ioctl VIDIOC_REQBUFS"><code class="constant">VIDIOC_REQBUFS</code></a> ioctl or implicit with the first <a class="link" href="media.html#func-read" title="V4L2 read()"><code class="function">read()</code></a> or
<a class="link" href="media.html#func-write" title="V4L2 write()"><code class="function">write()</code></a> call.</p><p>Generally only one logical stream can be assigned to a
file descriptor, the exception being drivers permitting simultaneous
video capturing and overlay using the same file descriptor for
compatibility with V4L and earlier versions of V4L2. Switching the
logical stream or returning into "panel mode" is possible by closing
and reopening the device. Drivers <span class="emphasis"><em>may</em></span> support a
switch using <code class="constant">VIDIOC_S_FMT</code>.</p><p>All drivers exchanging data with
applications must support the <code class="constant">VIDIOC_G_FMT</code> and
<code class="constant">VIDIOC_S_FMT</code> ioctl. Implementation of the
<code class="constant">VIDIOC_TRY_FMT</code> is highly recommended but
optional.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp51320592"></a>Image Format Enumeration</h3></div></div></div><p>Apart of the generic format negotiation functions
a special ioctl to enumerate all image formats supported by video
capture, overlay or output devices is available.<a href="media.html#ftn.idp51321712" class="footnote" name="idp51321712"><sup class="footnote">[7]</sup></a></p><p>The <a class="link" href="media.html#vidioc-enum-fmt" title="ioctl VIDIOC_ENUM_FMT"><code class="constant">VIDIOC_ENUM_FMT</code></a> ioctl must be supported
by all drivers exchanging image data with applications.</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>Drivers are not supposed to convert image formats in
kernel space. They must enumerate only formats directly supported by
the hardware. If necessary driver writers should publish an example
conversion routine or library for integration into applications.</p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="planar-apis"></a>Single- and multi-planar APIs</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#idp51329792">Multi-planar formats</a></span></dt><dt><span class="section"><a href="media.html#idp51333216">Calls that distinguish between single and multi-planar APIs</a></span></dt></dl></div><p>Some devices require data for each input or output video frame
  to be placed in discontiguous memory buffers. In such cases, one
  video frame has to be addressed using more than one memory address, i.e. one
  pointer per "plane". A plane is a sub-buffer of the current frame. For
  examples of such formats see <a class="xref" href="media.html#pixfmt" title="Chapter 2. Image Formats">Chapter 2, <i>Image Formats</i></a>.</p><p>Initially, V4L2 API did not support multi-planar buffers and a set of
  extensions has been introduced to handle them. Those extensions constitute
  what is being referred to as the "multi-planar API".</p><p>Some of the V4L2 API calls and structures are interpreted differently,
  depending on whether single- or multi-planar API is being used. An application
  can choose whether to use one or the other by passing a corresponding buffer
  type to its ioctl calls. Multi-planar versions of buffer types are suffixed
  with an `_MPLANE' string. For a list of available multi-planar buffer types
  see enum <a class="link" href="media.html#v4l2-buf-type" title="Table 3.3. enum v4l2_buf_type">v4l2_buf_type</a>.
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp51329792"></a>Multi-planar formats</h3></div></div></div><p>Multi-planar API introduces new multi-planar formats. Those formats
    use a separate set of FourCC codes. It is important to distinguish between
    the multi-planar API and a multi-planar format. Multi-planar API calls can
    handle all single-planar formats as well (as long as they are passed in
    multi-planar API structures), while the single-planar API cannot
    handle multi-planar formats.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp51333216"></a>Calls that distinguish between single and multi-planar APIs</h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term"><a class="link" href="media.html#vidioc-querycap" title="ioctl VIDIOC_QUERYCAP"><code class="constant">VIDIOC_QUERYCAP</code></a></span></dt><dd><p>Two additional multi-planar capabilities are added. They can
        be set together with non-multi-planar ones for devices that handle
        both single- and multi-planar formats.</p></dd><dt><span class="term"><a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_G_FMT</code></a>, <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a>, <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_TRY_FMT</code></a></span></dt><dd><p>New structures for describing multi-planar formats are added:
        struct <a class="link" href="media.html#v4l2-pix-format-mplane" title="Table 2.3. struct v4l2_pix_format_mplane">v4l2_pix_format_mplane</a> and struct <a class="link" href="media.html#v4l2-plane-pix-format" title="Table 2.2. struct v4l2_plane_pix_format">v4l2_plane_pix_format</a>. Drivers may
        define new multi-planar formats, which have distinct FourCC codes from
        the existing single-planar ones.</p></dd><dt><span class="term"><a class="link" href="media.html#vidioc-qbuf" title="ioctl VIDIOC_QBUF, VIDIOC_DQBUF"><code class="constant">VIDIOC_QBUF</code></a>, <a class="link" href="media.html#vidioc-qbuf" title="ioctl VIDIOC_QBUF, VIDIOC_DQBUF"><code class="constant">VIDIOC_DQBUF</code></a>, <a class="link" href="media.html#vidioc-querybuf" title="ioctl VIDIOC_QUERYBUF"><code class="constant">VIDIOC_QUERYBUF</code></a></span></dt><dd><p>A new struct <a class="link" href="media.html#v4l2-plane" title="Table 3.2. struct v4l2_plane">v4l2_plane</a> structure for describing planes is added.
        Arrays of this structure are passed in the new
        <em class="structfield"><code>m.planes</code></em> field of struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a>.</p></dd><dt><span class="term"><a class="link" href="media.html#vidioc-reqbufs" title="ioctl VIDIOC_REQBUFS"><code class="constant">VIDIOC_REQBUFS</code></a></span></dt><dd><p>Will allocate multi-planar buffers as requested.</p></dd></dl></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="crop"></a>Image Cropping, Insertion and Scaling</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#idp51365280">Cropping Structures</a></span></dt><dt><span class="section"><a href="media.html#idp51407488">Scaling Adjustments</a></span></dt><dt><span class="section"><a href="media.html#idp51416672">Examples</a></span></dt></dl></div><p>Some video capture devices can sample a subsection of the
picture and shrink or enlarge it to an image of arbitrary size. We
call these abilities cropping and scaling. Some video output devices
can scale an image up or down and insert it at an arbitrary scan line
and horizontal offset into a video signal.</p><p>Applications can use the following API to select an area in
the video signal, query the default area and the hardware limits.
<span class="emphasis"><em>Despite their name, the <a class="link" href="media.html#vidioc-cropcap" title="ioctl VIDIOC_CROPCAP"><code class="constant">VIDIOC_CROPCAP</code></a>, <a class="link" href="media.html#vidioc-g-crop" title="ioctl VIDIOC_G_CROP, VIDIOC_S_CROP"><code class="constant">VIDIOC_G_CROP</code></a>
and <a class="link" href="media.html#vidioc-g-crop" title="ioctl VIDIOC_G_CROP, VIDIOC_S_CROP"><code class="constant">VIDIOC_S_CROP</code></a> ioctls apply to input as well as output
devices.</em></span></p><p>Scaling requires a source and a target. On a video capture
or overlay device the source is the video signal, and the cropping
ioctls determine the area actually sampled. The target are images
read by the application or overlaid onto the graphics screen. Their
size (and position for an overlay) is negotiated with the
<a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_G_FMT</code></a> and <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> ioctls.</p><p>On a video output device the source are the images passed in
by the application, and their size is again negotiated with the
<code class="constant">VIDIOC_G/S_FMT</code> ioctls, or may be encoded in a
compressed video stream. The target is the video signal, and the
cropping ioctls determine the area where the images are
inserted.</p><p>Source and target rectangles are defined even if the device
does not support scaling or the <code class="constant">VIDIOC_G/S_CROP</code>
ioctls. Their size (and position where applicable) will be fixed in
this case. <span class="emphasis"><em>All capture and output device must support the
<code class="constant">VIDIOC_CROPCAP</code> ioctl such that applications can
determine if scaling takes place.</em></span></p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp51365280"></a>Cropping Structures</h3></div></div></div><div class="figure"><a name="crop-scale"></a><p class="title"><b>Figure 1.1. Image Cropping, Insertion and Scaling</b></p><div class="figure-contents"><div class="mediaobject"><img src="crop.gif" alt="The cropping, insertion and scaling process"></div></div></div><br class="figure-break"><p>For capture devices the coordinates of the top left
corner, width and height of the area which can be sampled is given by
the <em class="structfield"><code>bounds</code></em> substructure of the
struct <a class="link" href="media.html#v4l2-cropcap" title="Table A.2. struct v4l2_cropcap">v4l2_cropcap</a> returned by the <code class="constant">VIDIOC_CROPCAP</code>
ioctl. To support a wide range of hardware this specification does not
define an origin or units. However by convention drivers should
horizontally count unscaled samples relative to 0H (the leading edge
of the horizontal sync pulse, see <a class="xref" href="media.html#vbi-hsync" title="Figure 4.1. Line synchronization">Figure 4.1, &#8220;Line synchronization&#8221;</a>).
Vertically ITU-R line
numbers of the first field (<a class="xref" href="media.html#vbi-525" title="Figure 4.2. ITU-R 525 line numbering (M/NTSC and M/PAL)">Figure 4.2, &#8220;ITU-R 525 line numbering (M/NTSC and M/PAL)&#8221;</a>, <a class="xref" href="media.html#vbi-625" title="Figure 4.3. ITU-R 625 line numbering">Figure 4.3, &#8220;ITU-R 625 line numbering&#8221;</a>), multiplied by two if the driver can capture both
fields.</p><p>The top left corner, width and height of the source
rectangle, that is the area actually sampled, is given by struct <a class="link" href="media.html#v4l2-crop" title="Table A.54. struct v4l2_crop">v4l2_crop</a>
using the same coordinate system as struct <a class="link" href="media.html#v4l2-cropcap" title="Table A.2. struct v4l2_cropcap">v4l2_cropcap</a>. Applications can
use the <code class="constant">VIDIOC_G_CROP</code> and
<code class="constant">VIDIOC_S_CROP</code> ioctls to get and set this
rectangle. It must lie completely within the capture boundaries and
the driver may further adjust the requested size and/or position
according to hardware limitations.</p><p>Each capture device has a default source rectangle, given
by the <em class="structfield"><code>defrect</code></em> substructure of
struct <a class="link" href="media.html#v4l2-cropcap" title="Table A.2. struct v4l2_cropcap">v4l2_cropcap</a>. The center of this rectangle shall align with the
center of the active picture area of the video signal, and cover what
the driver writer considers the complete picture. Drivers shall reset
the source rectangle to the default when the driver is first loaded,
but not later.</p><p>For output devices these structures and ioctls are used
accordingly, defining the <span class="emphasis"><em>target</em></span> rectangle where
the images will be inserted into the video signal.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp51407488"></a>Scaling Adjustments</h3></div></div></div><p>Video hardware can have various cropping, insertion and
scaling limitations. It may only scale up or down, support only
discrete scaling factors, or have different scaling abilities in
horizontal and vertical direction. Also it may not support scaling at
all. At the same time the struct <a class="link" href="media.html#v4l2-crop" title="Table A.54. struct v4l2_crop">v4l2_crop</a> rectangle may have to be
aligned, and both the source and target rectangles may have arbitrary
upper and lower size limits. In particular the maximum
<em class="structfield"><code>width</code></em> and <em class="structfield"><code>height</code></em>
in struct <a class="link" href="media.html#v4l2-crop" title="Table A.54. struct v4l2_crop">v4l2_crop</a> may be smaller than the
struct <a class="link" href="media.html#v4l2-cropcap" title="Table A.2. struct v4l2_cropcap">v4l2_cropcap</a>.<em class="structfield"><code>bounds</code></em> area. Therefore, as
usual, drivers are expected to adjust the requested parameters and
return the actual values selected.</p><p>Applications can change the source or the target rectangle
first, as they may prefer a particular image size or a certain area in
the video signal. If the driver has to adjust both to satisfy hardware
limitations, the last requested rectangle shall take priority, and the
driver should preferably adjust the opposite one. The <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_TRY_FMT</code></a>
ioctl however shall not change the driver state and therefore only
adjust the requested rectangle.</p><p>Suppose scaling on a video capture device is restricted to
a factor 1:1 or 2:1 in either direction and the target image size must
be a multiple of 16 × 16 pixels. The source cropping
rectangle is set to defaults, which are also the upper limit in this
example, of 640 × 400 pixels at offset 0, 0. An
application requests an image size of 300 × 225
pixels, assuming video will be scaled down from the "full picture"
accordingly. The driver sets the image size to the closest possible
values 304 × 224, then chooses the cropping rectangle
closest to the requested size, that is 608 × 224
(224 × 2:1 would exceed the limit 400). The offset
0, 0 is still valid, thus unmodified. Given the default cropping
rectangle reported by <code class="constant">VIDIOC_CROPCAP</code> the
application can easily propose another offset to center the cropping
rectangle.</p><p>Now the application may insist on covering an area using a
picture aspect ratio closer to the original request, so it asks for a
cropping rectangle of 608 × 456 pixels. The present
scaling factors limit cropping to 640 × 384, so the
driver returns the cropping size 608 × 384 and adjusts
the image size to closest possible 304 × 192.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp51416672"></a>Examples</h3></div></div></div><p>Source and target rectangles shall remain unchanged across
closing and reopening a device, such that piping data into or out of a
device will work without special preparations. More advanced
applications should ensure the parameters are suitable before starting
I/O.</p><div class="example"><a name="idp51418528"></a><p class="title"><b>Example 1.11. Resetting the cropping parameters</b></p><div class="example-contents"><p>(A video capture device is assumed; change
<code class="constant">V4L2_BUF_TYPE_VIDEO_CAPTURE</code> for other
devices.)</p><pre class="programlisting">
struct <a class="link" href="media.html#v4l2-cropcap" title="Table A.2. struct v4l2_cropcap">v4l2_cropcap</a> cropcap;
struct <a class="link" href="media.html#v4l2-crop" title="Table A.54. struct v4l2_crop">v4l2_crop</a> crop;

memset (&amp;cropcap, 0, sizeof (cropcap));
cropcap.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

if (-1 == ioctl (fd, <a class="link" href="media.html#vidioc-cropcap" title="ioctl VIDIOC_CROPCAP"><code class="constant">VIDIOC_CROPCAP</code></a>, &amp;cropcap)) {
	perror ("VIDIOC_CROPCAP");
	exit (EXIT_FAILURE);
}

memset (&amp;crop, 0, sizeof (crop));
crop.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
crop.c = cropcap.defrect;

/* Ignore if cropping is not supported (EINVAL). */

if (-1 == ioctl (fd, <a class="link" href="media.html#vidioc-g-crop" title="ioctl VIDIOC_G_CROP, VIDIOC_S_CROP"><code class="constant">VIDIOC_S_CROP</code></a>, &amp;crop)
    &amp;&amp; errno != EINVAL) {
	perror ("VIDIOC_S_CROP");
	exit (EXIT_FAILURE);
}
      </pre></div></div><br class="example-break"><div class="example"><a name="idp51425040"></a><p class="title"><b>Example 1.12. Simple downscaling</b></p><div class="example-contents"><p>(A video capture device is assumed.)</p><pre class="programlisting">
struct <a class="link" href="media.html#v4l2-cropcap" title="Table A.2. struct v4l2_cropcap">v4l2_cropcap</a> cropcap;
struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a> format;

reset_cropping_parameters ();

/* Scale down to 1/4 size of full picture. */

memset (&amp;format, 0, sizeof (format)); /* defaults */

format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

format.fmt.pix.width = cropcap.defrect.width &gt;&gt; 1;
format.fmt.pix.height = cropcap.defrect.height &gt;&gt; 1;
format.fmt.pix.pixelformat = V4L2_PIX_FMT_YUYV;

if (-1 == ioctl (fd, <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a>, &amp;format)) {
	perror ("VIDIOC_S_FORMAT");
	exit (EXIT_FAILURE);
}

/* We could check the actual image size now, the actual scaling factor
   or if the driver can scale at all. */
	</pre></div></div><br class="example-break"><div class="example"><a name="idp51430336"></a><p class="title"><b>Example 1.13. Selecting an output area</b></p><div class="example-contents"><pre class="programlisting">
struct <a class="link" href="media.html#v4l2-cropcap" title="Table A.2. struct v4l2_cropcap">v4l2_cropcap</a> cropcap;
struct <a class="link" href="media.html#v4l2-crop" title="Table A.54. struct v4l2_crop">v4l2_crop</a> crop;

memset (&amp;cropcap, 0, sizeof (cropcap));
cropcap.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;

if (-1 == ioctl (fd, VIDIOC_CROPCAP;, &amp;cropcap)) {
	perror ("VIDIOC_CROPCAP");
	exit (EXIT_FAILURE);
}

memset (&amp;crop, 0, sizeof (crop));

crop.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
crop.c = cropcap.defrect;

/* Scale the width and height to 50 % of their original size
   and center the output. */

crop.c.width /= 2;
crop.c.height /= 2;
crop.c.left += crop.c.width / 2;
crop.c.top += crop.c.height / 2;

/* Ignore if cropping is not supported (EINVAL). */

if (-1 == ioctl (fd, VIDIOC_S_CROP, &amp;crop)
    &amp;&amp; errno != EINVAL) {
	perror ("VIDIOC_S_CROP");
	exit (EXIT_FAILURE);
}
</pre></div></div><br class="example-break"><div class="example"><a name="idp51434592"></a><p class="title"><b>Example 1.14. Current scaling factor and pixel aspect</b></p><div class="example-contents"><p>(A video capture device is assumed.)</p><pre class="programlisting">
struct <a class="link" href="media.html#v4l2-cropcap" title="Table A.2. struct v4l2_cropcap">v4l2_cropcap</a> cropcap;
struct <a class="link" href="media.html#v4l2-crop" title="Table A.54. struct v4l2_crop">v4l2_crop</a> crop;
struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a> format;
double hscale, vscale;
double aspect;
int dwidth, dheight;

memset (&amp;cropcap, 0, sizeof (cropcap));
cropcap.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

if (-1 == ioctl (fd, <a class="link" href="media.html#vidioc-cropcap" title="ioctl VIDIOC_CROPCAP"><code class="constant">VIDIOC_CROPCAP</code></a>, &amp;cropcap)) {
	perror ("VIDIOC_CROPCAP");
	exit (EXIT_FAILURE);
}

memset (&amp;crop, 0, sizeof (crop));
crop.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

if (-1 == ioctl (fd, <a class="link" href="media.html#vidioc-g-crop" title="ioctl VIDIOC_G_CROP, VIDIOC_S_CROP"><code class="constant">VIDIOC_G_CROP</code></a>, &amp;crop)) {
	if (errno != EINVAL) {
		perror ("VIDIOC_G_CROP");
		exit (EXIT_FAILURE);
	}

	/* Cropping not supported. */
	crop.c = cropcap.defrect;
}

memset (&amp;format, 0, sizeof (format));
format.fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

if (-1 == ioctl (fd, <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_G_FMT</code></a>, &amp;format)) {
	perror ("VIDIOC_G_FMT");
	exit (EXIT_FAILURE);
}

/* The scaling applied by the driver. */

hscale = format.fmt.pix.width / (double) crop.c.width;
vscale = format.fmt.pix.height / (double) crop.c.height;

aspect = cropcap.pixelaspect.numerator /
	 (double) cropcap.pixelaspect.denominator;
aspect = aspect * hscale / vscale;

/* Devices following ITU-R BT.601 do not capture
   square pixels. For playback on a computer monitor
   we should scale the images to this size. */

dwidth = format.fmt.pix.width / aspect;
dheight = format.fmt.pix.height;
	</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="selection-api"></a>Experimental API for cropping, composing and scaling</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#idp51447328">Introduction</a></span></dt><dt><span class="section"><a href="media.html#idp51494464">Selection targets</a></span></dt><dt><span class="section"><a href="media.html#idp51500704">Configuration</a></span></dt><dt><span class="section"><a href="media.html#idp51531648">Comparison with old cropping API</a></span></dt><dt><span class="section"><a href="media.html#idp51539232">Examples</a></span></dt></dl></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Experimental</h3><p>This is an <a class="link" href="media.html#experimental" title="Experimental API Elements">experimental</a>
interface and may change in the future.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp51447328"></a>Introduction</h3></div></div></div><p>Some video capture devices can sample a subsection of a picture and
shrink or enlarge it to an image of arbitrary size. Next, the devices can
insert the image into larger one. Some video output devices can crop part of an
input image, scale it up or down and insert it at an arbitrary scan line and
horizontal offset into a video signal. We call these abilities cropping,
scaling and composing.</p><p>On a video <span class="emphasis"><em>capture</em></span> device the source is a video
signal, and the cropping target determine the area actually sampled. The sink
is an image stored in a memory buffer.  The composing area specifies which part
of the buffer is actually written to by the hardware. </p><p>On a video <span class="emphasis"><em>output</em></span> device the source is an image in a
memory buffer, and the cropping target is a part of an image to be shown on a
display. The sink is the display or the graphics screen. The application may
select the part of display where the image should be displayed. The size and
position of such a window is controlled by the compose target.</p><p>Rectangles for all cropping and composing targets are defined even if the
device does supports neither cropping nor composing. Their size and position
will be fixed in such a case. If the device does not support scaling then the
cropping and composing rectangles have the same size.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp51494464"></a>Selection targets</h3></div></div></div><p>
      </p><div class="figure"><a name="sel-targets-capture"></a><p class="title"><b>Figure 1.2. Cropping and composing targets</b></p><div class="figure-contents"><div class="mediaobject"><img src="selection.png" alt="Targets used by a cropping, composing and scaling process"></div></div></div><p><br class="figure-break">
      </p><p>See <a class="xref" href="media.html#v4l2-selection-targets" title="Selection targets">the section called &#8220;Selection targets&#8221;</a> for more
    information.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp51500704"></a>Configuration</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#idp51504768">Configuration of video capture</a></span></dt><dt><span class="section"><a href="media.html#idp51518416">Configuration of video output</a></span></dt><dt><span class="section"><a href="media.html#idp51529152">Scaling control</a></span></dt></dl></div><p>Applications can use the <a class="link" href="media.html#vidioc-g-selection" title="ioctl VIDIOC_G_SELECTION, VIDIOC_S_SELECTION">selection
API</a> to select an area in a video signal or a buffer, and to query for
default settings and hardware limits.</p><p>Video hardware can have various cropping, composing and scaling
limitations. It may only scale up or down, support only discrete scaling
factors, or have different scaling abilities in the horizontal and vertical
directions. Also it may not support scaling at all. At the same time the
cropping/composing rectangles may have to be aligned, and both the source and
the sink may have arbitrary upper and lower size limits. Therefore, as usual,
drivers are expected to adjust the requested parameters and return the actual
values selected. An application can control the rounding behaviour using <a class="link" href="media.html#v4l2-selection-flags" title="Selection flags"> constraint flags </a>.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp51504768"></a>Configuration of video capture</h4></div></div></div><p>See figure <a class="xref" href="media.html#sel-targets-capture" title="Figure 1.2. Cropping and composing targets">Figure 1.2, &#8220;Cropping and composing targets&#8221;</a> for examples of the
selection targets available for a video capture device.  It is recommended to
configure the cropping targets before to the composing targets.</p><p>The range of coordinates of the top left corner, width and height of
areas that can be sampled is given by the <code class="constant">V4L2_SEL_TGT_CROP_BOUNDS</code>
target. It is recommended for the driver developers to put the
top/left corner at position <code class="constant">(0,0)</code>.  The rectangle's
coordinates are expressed in pixels.</p><p>The top left corner, width and height of the source rectangle, that is
the area actually sampled, is given by the <code class="constant">V4L2_SEL_TGT_CROP</code>
target. It uses the same coordinate system as <code class="constant">V4L2_SEL_TGT_CROP_BOUNDS</code>.
The active cropping area must lie completely inside the capture boundaries. The
driver may further adjust the requested size and/or position according to hardware
limitations.</p><p>Each capture device has a default source rectangle, given by the
<code class="constant">V4L2_SEL_TGT_CROP_DEFAULT</code> target. This rectangle shall
over what the driver writer considers the complete picture.  Drivers shall set
the active crop rectangle to the default when the driver is first loaded, but
not later.</p><p>The composing targets refer to a memory buffer. The limits of composing
coordinates are obtained using <code class="constant">V4L2_SEL_TGT_COMPOSE_BOUNDS</code>.
All coordinates are expressed in pixels. The rectangle's top/left
corner must be located at position <code class="constant">(0,0)</code>. The width and
height are equal to the image size set by <code class="constant">VIDIOC_S_FMT</code>.
</p><p>The part of a buffer into which the image is inserted by the hardware is
controlled by the <code class="constant">V4L2_SEL_TGT_COMPOSE</code> target.
The rectangle's coordinates are also expressed in the same coordinate system as
the bounds rectangle. The composing rectangle must lie completely inside bounds
rectangle. The driver must adjust the composing rectangle to fit to the
bounding limits. Moreover, the driver can perform other adjustments according
to hardware limitations. The application can control rounding behaviour using
<a class="link" href="media.html#v4l2-selection-flags" title="Selection flags"> constraint flags</a>.</p><p>For capture devices the default composing rectangle is queried using
<code class="constant">V4L2_SEL_TGT_COMPOSE_DEFAULT</code>. It is usually equal to the
bounding rectangle.</p><p>The part of a buffer that is modified by the hardware is given by
<code class="constant">V4L2_SEL_TGT_COMPOSE_PADDED</code>. It contains all pixels
defined using <code class="constant">V4L2_SEL_TGT_COMPOSE</code> plus all
padding data modified by hardware during insertion process. All pixels outside
this rectangle <span class="emphasis"><em>must not</em></span> be changed by the hardware. The
content of pixels that lie inside the padded area but outside active area is
undefined. The application can use the padded and active rectangles to detect
where the rubbish pixels are located and remove them if needed.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp51518416"></a>Configuration of video output</h4></div></div></div><p>For output devices targets and ioctls are used similarly to the video
capture case. The <span class="emphasis"><em>composing</em></span> rectangle refers to the
insertion of an image into a video signal. The cropping rectangles refer to a
memory buffer. It is recommended to configure the composing targets before to
the cropping targets.</p><p>The cropping targets refer to the memory buffer that contains an image to
be inserted into a video signal or graphical screen. The limits of cropping
coordinates are obtained using <code class="constant">V4L2_SEL_TGT_CROP_BOUNDS</code>.
All coordinates are expressed in pixels. The top/left corner is always point
<code class="constant">(0,0)</code>.  The width and height is equal to the image size
specified using <code class="constant">VIDIOC_S_FMT</code> ioctl.</p><p>The top left corner, width and height of the source rectangle, that is
the area from which image date are processed by the hardware, is given by the
<code class="constant">V4L2_SEL_TGT_CROP</code>. Its coordinates are expressed
in in the same coordinate system as the bounds rectangle. The active cropping
area must lie completely inside the crop boundaries and the driver may further
adjust the requested size and/or position according to hardware
limitations.</p><p>For output devices the default cropping rectangle is queried using
<code class="constant">V4L2_SEL_TGT_CROP_DEFAULT</code>. It is usually equal to the
bounding rectangle.</p><p>The part of a video signal or graphics display where the image is
inserted by the hardware is controlled by <code class="constant">V4L2_SEL_TGT_COMPOSE</code>
target.  The rectangle's coordinates are expressed in pixels. The composing
rectangle must lie completely inside the bounds rectangle.  The driver must
adjust the area to fit to the bounding limits.  Moreover, the driver can
perform other adjustments according to hardware limitations.</p><p>The device has a default composing rectangle, given by the
<code class="constant">V4L2_SEL_TGT_COMPOSE_DEFAULT</code> target. This rectangle shall cover what
the driver writer considers the complete picture. It is recommended for the
driver developers to put the top/left corner at position <code class="constant">(0,0)</code>.
Drivers shall set the active composing rectangle to the default
one when the driver is first loaded.</p><p>The devices may introduce additional content to video signal other than
an image from memory buffers.  It includes borders around an image. However,
such a padded area is driver-dependent feature not covered by this document.
Driver developers are encouraged to keep padded rectangle equal to active one.
The padded target is accessed by the <code class="constant">V4L2_SEL_TGT_COMPOSE_PADDED</code>
identifier.  It must contain all pixels from the <code class="constant">V4L2_SEL_TGT_COMPOSE</code>
target.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp51529152"></a>Scaling control</h4></div></div></div><p>An application can detect if scaling is performed by comparing the width
and the height of rectangles obtained using <code class="constant">V4L2_SEL_TGT_CROP</code>
and <code class="constant">V4L2_SEL_TGT_COMPOSE</code> targets. If
these are not equal then the scaling is applied. The application can compute
the scaling ratios using these values.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp51531648"></a>Comparison with old cropping API</h3></div></div></div><p>The selection API was introduced to cope with deficiencies of previous
<a class="link" href="media.html#crop" title="Image Cropping, Insertion and Scaling"> API</a>, that was designed to control simple capture
devices. Later the cropping API was adopted by video output drivers. The ioctls
are used to select a part of the display were the video signal is inserted. It
should be considered as an API abuse because the described operation is
actually the composing.  The selection API makes a clear distinction between
composing and cropping operations by setting the appropriate targets.  The V4L2
API lacks any support for composing to and cropping from an image inside a
memory buffer.  The application could configure a capture device to fill only a
part of an image by abusing V4L2 API.  Cropping a smaller image from a larger
one is achieved by setting the field
struct <a class="link" href="media.html#v4l2-pix-format" title="Table 2.1. struct v4l2_pix_format">v4l2_pix_format</a><em class="structfield"><code>::bytesperline</code></em>.  Introducing an image offsets
could be done by modifying field struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a><em class="structfield"><code>::m_userptr</code></em>
before calling <code class="constant">VIDIOC_QBUF</code>. Those
operations should be avoided because they are not portable (endianness), and do
not work for macroblock and Bayer formats and mmap buffers.  The selection API
deals with configuration of buffer cropping/composing in a clear, intuitive and
portable way.  Next, with the selection API the concepts of the padded target
and constraints flags are introduced.  Finally, struct <a class="link" href="media.html#v4l2-crop" title="Table A.54. struct v4l2_crop">v4l2_crop</a> and struct <a class="link" href="media.html#v4l2-cropcap" title="Table A.2. struct v4l2_cropcap">v4l2_cropcap</a>
have no reserved fields. Therefore there is no way to extend their functionality.
The new struct <a class="link" href="media.html#v4l2-selection" title="Table A.83. struct v4l2_selection">v4l2_selection</a> provides a lot of place for future
extensions.  Driver developers are encouraged to implement only selection API.
The former cropping API would be simulated using the new one.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp51539232"></a>Examples</h3></div></div></div><div class="example"><a name="idp51541328"></a><p class="title"><b>Example 1.15. Resetting the cropping parameters</b></p><div class="example-contents"><p>(A video capture device is assumed; change
<code class="constant">V4L2_BUF_TYPE_VIDEO_CAPTURE</code> for other devices; change target to
<code class="constant">V4L2_SEL_TGT_COMPOSE_*</code> family to configure composing
area)</p><pre class="programlisting">

	struct <a class="link" href="media.html#v4l2-selection" title="Table A.83. struct v4l2_selection">v4l2_selection</a> sel = {
		.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,
		.target = V4L2_SEL_TGT_CROP_DEFAULT,
	};
	ret = ioctl(fd, <a class="link" href="media.html#vidioc-g-selection" title="ioctl VIDIOC_G_SELECTION, VIDIOC_S_SELECTION"><code class="constant">VIDIOC_G_SELECTION</code></a>, &amp;sel);
	if (ret)
		exit(-1);
	sel.target = V4L2_SEL_TGT_CROP;
	ret = ioctl(fd, <a class="link" href="media.html#vidioc-g-selection" title="ioctl VIDIOC_G_SELECTION, VIDIOC_S_SELECTION"><code class="constant">VIDIOC_S_SELECTION</code></a>, &amp;sel);
	if (ret)
		exit(-1);

        </pre></div></div><br class="example-break"><div class="example"><a name="idp51545504"></a><p class="title"><b>Example 1.16. Simple downscaling</b></p><div class="example-contents"><p>Setting a composing area on output of size of <span class="emphasis"><em> at most
</em></span> half of limit placed at a center of a display.</p><pre class="programlisting">

	struct <a class="link" href="media.html#v4l2-selection" title="Table A.83. struct v4l2_selection">v4l2_selection</a> sel = {
		.type = V4L2_BUF_TYPE_VIDEO_OUTPUT,
		.target = V4L2_SEL_TGT_COMPOSE_BOUNDS,
	};
	struct v4l2_rect r;

	ret = ioctl(fd, <a class="link" href="media.html#vidioc-g-selection" title="ioctl VIDIOC_G_SELECTION, VIDIOC_S_SELECTION"><code class="constant">VIDIOC_G_SELECTION</code></a>, &amp;sel);
	if (ret)
		exit(-1);
	/* setting smaller compose rectangle */
	r.width = sel.r.width / 2;
	r.height = sel.r.height / 2;
	r.left = sel.r.width / 4;
	r.top = sel.r.height / 4;
	sel.r = r;
	sel.target = V4L2_SEL_TGT_COMPOSE;
	sel.flags = V4L2_SEL_FLAG_LE;
	ret = ioctl(fd, <a class="link" href="media.html#vidioc-g-selection" title="ioctl VIDIOC_G_SELECTION, VIDIOC_S_SELECTION"><code class="constant">VIDIOC_S_SELECTION</code></a>, &amp;sel);
	if (ret)
		exit(-1);

        </pre></div></div><br class="example-break"><div class="example"><a name="idp51554544"></a><p class="title"><b>Example 1.17. Querying for scaling factors</b></p><div class="example-contents"><p>A video output device is assumed; change
<code class="constant">V4L2_BUF_TYPE_VIDEO_OUTPUT</code> for other devices</p><pre class="programlisting">

	struct <a class="link" href="media.html#v4l2-selection" title="Table A.83. struct v4l2_selection">v4l2_selection</a> compose = {
		.type = V4L2_BUF_TYPE_VIDEO_OUTPUT,
		.target = V4L2_SEL_TGT_COMPOSE,
	};
	struct <a class="link" href="media.html#v4l2-selection" title="Table A.83. struct v4l2_selection">v4l2_selection</a> crop = {
		.type = V4L2_BUF_TYPE_VIDEO_OUTPUT,
		.target = V4L2_SEL_TGT_CROP,
	};
	double hscale, vscale;

	ret = ioctl(fd, <a class="link" href="media.html#vidioc-g-selection" title="ioctl VIDIOC_G_SELECTION, VIDIOC_S_SELECTION"><code class="constant">VIDIOC_G_SELECTION</code></a>, &amp;compose);
	if (ret)
		exit(-1);
	ret = ioctl(fd, <a class="link" href="media.html#vidioc-g-selection" title="ioctl VIDIOC_G_SELECTION, VIDIOC_S_SELECTION"><code class="constant">VIDIOC_G_SELECTION</code></a>, &amp;crop);
	if (ret)
		exit(-1);

	/* computing scaling factors */
	hscale = (double)compose.r.width / crop.r.width;
	vscale = (double)compose.r.height / crop.r.height;

	</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="streaming-par"></a>Streaming Parameters</h2></div></div></div><p>Streaming parameters are intended to optimize the video
capture process as well as I/O. Presently applications can request a
high quality capture mode with the <a class="link" href="media.html#vidioc-g-parm" title="ioctl VIDIOC_G_PARM, VIDIOC_S_PARM"><code class="constant">VIDIOC_S_PARM</code></a> ioctl.</p><p>The current video standard determines a nominal number of
frames per second. If less than this number of frames is to be
captured or output, applications can request frame skipping or
duplicating on the driver side. This is especially useful when using
the <a class="link" href="media.html#func-read" title="V4L2 read()"><code class="function">read()</code></a> or <a class="link" href="media.html#func-write" title="V4L2 write()"><code class="function">write()</code></a>, which are not augmented by timestamps
or sequence counters, and to avoid unnecessary data copying.</p><p>Finally these ioctls can be used to determine the number of
buffers used internally by a driver in read/write mode. For
implications see the section discussing the <a class="link" href="media.html#func-read" title="V4L2 read()"><code class="function">read()</code></a>
function.</p><p>To get and set the streaming parameters applications call
the <a class="link" href="media.html#vidioc-g-parm" title="ioctl VIDIOC_G_PARM, VIDIOC_S_PARM"><code class="constant">VIDIOC_G_PARM</code></a> and <a class="link" href="media.html#vidioc-g-parm" title="ioctl VIDIOC_G_PARM, VIDIOC_S_PARM"><code class="constant">VIDIOC_S_PARM</code></a> ioctl, respectively. They take
a pointer to a struct <a class="link" href="media.html#v4l2-streamparm" title="Table A.77. struct v4l2_streamparm">v4l2_streamparm</a>, which contains a union holding
separate parameters for input and output devices.</p><p>These ioctls are optional, drivers need not implement
them. If so, they return the <span class="errorcode">EINVAL</span> error code.</p></div><div class="footnotes"><br><hr style="width:100; text-align:left;margin-left: 0"><div id="ftn.idp47251232" class="footnote"><p><a href="media.html#idp47251232" class="para"><sup class="para">[1] </sup></a>
There are still some old and obscure drivers that have not been updated to
allow for multiple opens. This implies that for such drivers <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a> can
return an <span class="errorcode">EBUSY</span> error code when the device is already in use.</p></div><div id="ftn.idp47255632" class="footnote"><p><a href="media.html#idp47255632" class="para"><sup class="para">[2] </sup></a>Unfortunately, opening a radio device often switches the state of the
device to radio mode in many drivers. This behavior should be fixed eventually
as it violates the V4L2 specification.</p></div><div id="ftn.idp47267904" class="footnote"><p><a href="media.html#idp47267904" class="para"><sup class="para">[3] </sup></a>Drivers could recognize the
<code class="constant">O_EXCL</code> open flag. Presently this is not required,
so applications cannot know if it really works.</p></div><div id="ftn.idp47320016" class="footnote"><p><a href="media.html#idp47320016" class="para"><sup class="para">[4] </sup></a>Actually struct <a class="link" href="media.html#v4l2-audio" title="Table A.50. struct v4l2_audio">v4l2_audio</a> ought to have a
<em class="structfield"><code>tuner</code></em> field like struct <a class="link" href="media.html#v4l2-input" title="Table A.38. struct v4l2_input">v4l2_input</a>, not only
making the API more consistent but also permitting radio devices with
multiple tuners.</p></div><div id="ftn.idp47392592" class="footnote"><p><a href="media.html#idp47392592" class="para"><sup class="para">[5] </sup></a>Some users are already confused by technical terms PAL,
NTSC and SECAM. There is no point asking them to distinguish between
B, G, D, or K when the software or hardware can do that
automatically.</p></div><div id="ftn.idp47451360" class="footnote"><p><a href="media.html#idp47451360" class="para"><sup class="para">[6] </sup></a>The use of <code class="constant">V4L2_CID_PRIVATE_BASE</code>
is problematic because different drivers may use the same
<code class="constant">V4L2_CID_PRIVATE_BASE</code> ID for different controls.
This makes it hard to programatically set such controls since the meaning
of the control with that ID is driver dependent. In order to resolve this
drivers use unique IDs and the <code class="constant">V4L2_CID_PRIVATE_BASE</code>
IDs are mapped to those unique IDs by the kernel. Consider these
<code class="constant">V4L2_CID_PRIVATE_BASE</code> IDs as aliases to the real
IDs.</p><p>Many applications today still use the <code class="constant">V4L2_CID_PRIVATE_BASE</code>
IDs instead of using <a class="link" href="media.html#vidioc-queryctrl" title="ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU"><code class="constant">VIDIOC_QUERYCTRL</code></a> with the <code class="constant">V4L2_CTRL_FLAG_NEXT_CTRL</code>
flag to enumerate all IDs, so support for <code class="constant">V4L2_CID_PRIVATE_BASE</code>
is still around.</p></div><div id="ftn.idp51321712" class="footnote"><p><a href="media.html#idp51321712" class="para"><sup class="para">[7] </sup></a>Enumerating formats an application has no a-priori
knowledge of (otherwise it could explicitly ask for them and need not
enumerate) seems useless, but there are applications serving as proxy
between drivers and the actual video applications for which this is
useful.</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="pixfmt"></a>Chapter 2. Image Formats</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="media.html#idp53973040">Single-planar format structure</a></span></dt><dt><span class="section"><a href="media.html#idp54078128">Multi-planar format structures</a></span></dt><dt><span class="section"><a href="media.html#idp54128880">Standard Image Formats</a></span></dt><dt><span class="section"><a href="media.html#colorspaces">Colorspaces</a></span></dt><dt><span class="section"><a href="media.html#idp54168592">Defining Colorspaces in V4L2</a></span></dt><dt><span class="section"><a href="media.html#idp54232336">Detailed Colorspace Descriptions</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp54233024">Colorspace SMPTE 170M (<code class="constant">V4L2_COLORSPACE_SMPTE170M</code>)</a></span></dt><dt><span class="section"><a href="media.html#idp54271504">Colorspace Rec. 709 (<code class="constant">V4L2_COLORSPACE_REC709</code>)</a></span></dt><dt><span class="section"><a href="media.html#idp54308064">Colorspace sRGB (<code class="constant">V4L2_COLORSPACE_SRGB</code>)</a></span></dt><dt><span class="section"><a href="media.html#idp54339536">Colorspace Adobe RGB (<code class="constant">V4L2_COLORSPACE_ADOBERGB</code>)</a></span></dt><dt><span class="section"><a href="media.html#idp54366256">Colorspace BT.2020 (<code class="constant">V4L2_COLORSPACE_BT2020</code>)</a></span></dt><dt><span class="section"><a href="media.html#idp54404656">Colorspace SMPTE 240M (<code class="constant">V4L2_COLORSPACE_SMPTE240M</code>)</a></span></dt><dt><span class="section"><a href="media.html#idp54432112">Colorspace NTSC 1953 (<code class="constant">V4L2_COLORSPACE_470_SYSTEM_M</code>)</a></span></dt><dt><span class="section"><a href="media.html#idp54459200">Colorspace EBU Tech. 3213 (<code class="constant">V4L2_COLORSPACE_470_SYSTEM_BG</code>)</a></span></dt><dt><span class="section"><a href="media.html#idp54486512">Colorspace JPEG (<code class="constant">V4L2_COLORSPACE_JPEG</code>)</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#pixfmt-indexed">Indexed Format</a></span></dt><dt><span class="section"><a href="media.html#pixfmt-rgb">RGB Formats</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="media.html#packed-rgb">Packed RGB formats</a></span><span class="refpurpose"> &#8212; Packed RGB formats</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-SBGGR8">V4L2_PIX_FMT_SBGGR8 ('BA81')</a></span><span class="refpurpose"> &#8212; Bayer RGB format</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-SGBRG8">V4L2_PIX_FMT_SGBRG8 ('GBRG')</a></span><span class="refpurpose"> &#8212; Bayer RGB format</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-SGRBG8">V4L2_PIX_FMT_SGRBG8 ('GRBG')</a></span><span class="refpurpose"> &#8212; Bayer RGB format</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-SRGGB8">V4L2_PIX_FMT_SRGGB8 ('RGGB')</a></span><span class="refpurpose"> &#8212; Bayer RGB format</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-SBGGR16">V4L2_PIX_FMT_SBGGR16 ('BYR2')</a></span><span class="refpurpose"> &#8212; Bayer RGB format</span></dt><dt><span class="refentrytitle"><a href="media.html#pixfmt-srggb10">V4L2_PIX_FMT_SRGGB10 ('RG10'),
	 V4L2_PIX_FMT_SGRBG10 ('BA10'),
	 V4L2_PIX_FMT_SGBRG10 ('GB10'),
	 V4L2_PIX_FMT_SBGGR10 ('BG10'),
	 </a></span><span class="refpurpose"> &#8212; 10-bit Bayer formats expanded to 16 bits</span></dt><dt><span class="refentrytitle"><a href="media.html#idp56012848">
	      V4L2_PIX_FMT_SBGGR10ALAW8 ('aBA8'),
	      V4L2_PIX_FMT_SGBRG10ALAW8 ('aGA8'),
	      V4L2_PIX_FMT_SGRBG10ALAW8 ('agA8'),
	      V4L2_PIX_FMT_SRGGB10ALAW8 ('aRA8'),
	    </a></span><span class="refpurpose"> &#8212; 10-bit Bayer formats compressed to 8 bits</span></dt><dt><span class="refentrytitle"><a href="media.html#pixfmt-srggb10dpcm8">
	 V4L2_PIX_FMT_SBGGR10DPCM8 ('bBA8'),
	 V4L2_PIX_FMT_SGBRG10DPCM8 ('bGA8'),
	 V4L2_PIX_FMT_SGRBG10DPCM8 ('BD10'),
	 V4L2_PIX_FMT_SRGGB10DPCM8 ('bRA8'),
	 </a></span><span class="refpurpose"> &#8212; 10-bit Bayer formats compressed to 8 bits</span></dt><dt><span class="refentrytitle"><a href="media.html#idp56032208">V4L2_PIX_FMT_SRGGB12 ('RG12'),
	 V4L2_PIX_FMT_SGRBG12 ('BA12'),
	 V4L2_PIX_FMT_SGBRG12 ('GB12'),
	 V4L2_PIX_FMT_SBGGR12 ('BG12'),
	 </a></span><span class="refpurpose"> &#8212; 12-bit Bayer formats expanded to 16 bits</span></dt></dl></dd><dt><span class="section"><a href="media.html#yuv-formats">YUV Formats</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="media.html#packed-yuv">Packed YUV formats</a></span><span class="refpurpose"> &#8212; Packed YUV formats</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-GREY">V4L2_PIX_FMT_GREY ('GREY')</a></span><span class="refpurpose"> &#8212; Grey-scale image</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-Y10">V4L2_PIX_FMT_Y10 ('Y10 ')</a></span><span class="refpurpose"> &#8212; Grey-scale image</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-Y12">V4L2_PIX_FMT_Y12 ('Y12 ')</a></span><span class="refpurpose"> &#8212; Grey-scale image</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-Y10BPACK">V4L2_PIX_FMT_Y10BPACK ('Y10B')</a></span><span class="refpurpose"> &#8212; Grey-scale image as a bit-packed array</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-Y16">V4L2_PIX_FMT_Y16 ('Y16 ')</a></span><span class="refpurpose"> &#8212; Grey-scale image</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-UV8">V4L2_PIX_FMT_UV8  ('UV8')</a></span><span class="refpurpose"> &#8212; UV plane interleaved</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-YUYV">V4L2_PIX_FMT_YUYV ('YUYV')</a></span><span class="refpurpose"> &#8212; Packed format with ½ horizontal chroma
resolution, also known as YUV 4:2:2</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-UYVY">V4L2_PIX_FMT_UYVY ('UYVY')</a></span><span class="refpurpose"> &#8212; Variation of
<code class="constant">V4L2_PIX_FMT_YUYV</code> with different order of samples
in memory</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-YVYU">V4L2_PIX_FMT_YVYU ('YVYU')</a></span><span class="refpurpose"> &#8212; Variation of
<code class="constant">V4L2_PIX_FMT_YUYV</code> with different order of samples
in memory</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-VYUY">V4L2_PIX_FMT_VYUY ('VYUY')</a></span><span class="refpurpose"> &#8212; Variation of
<code class="constant">V4L2_PIX_FMT_YUYV</code> with different order of samples
in memory</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-Y41P">V4L2_PIX_FMT_Y41P ('Y41P')</a></span><span class="refpurpose"> &#8212; Format with ¼ horizontal chroma
resolution, also known as YUV 4:1:1</span></dt><dt><span class="refentrytitle"><a href="media.html#idp57342656">V4L2_PIX_FMT_YVU420 ('YV12'), V4L2_PIX_FMT_YUV420 ('YU12')</a></span><span class="refpurpose"> &#8212; Planar formats with ½ horizontal and
vertical chroma resolution, also known as YUV 4:2:0</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-YUV420M">V4L2_PIX_FMT_YUV420M ('YM12')</a></span><span class="refpurpose"> &#8212; Variation of <code class="constant">V4L2_PIX_FMT_YUV420</code>
	  with planes non contiguous in memory. </span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-YVU420M">V4L2_PIX_FMT_YVU420M ('YM21')</a></span><span class="refpurpose"> &#8212; Variation of <code class="constant">V4L2_PIX_FMT_YVU420</code>
	  with planes non contiguous in memory. </span></dt><dt><span class="refentrytitle"><a href="media.html#idp57708208">V4L2_PIX_FMT_YVU410 ('YVU9'), V4L2_PIX_FMT_YUV410 ('YUV9')</a></span><span class="refpurpose"> &#8212; Planar formats with ¼ horizontal and
vertical chroma resolution, also known as YUV 4:1:0</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-YUV422P">V4L2_PIX_FMT_YUV422P ('422P')</a></span><span class="refpurpose"> &#8212; Format with ½ horizontal chroma resolution,
also known as YUV 4:2:2. Planar layout as opposed to
<code class="constant">V4L2_PIX_FMT_YUYV</code></span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-YUV411P">V4L2_PIX_FMT_YUV411P ('411P')</a></span><span class="refpurpose"> &#8212; Format with ¼ horizontal chroma resolution,
also known as YUV 4:1:1. Planar layout as opposed to
<code class="constant">V4L2_PIX_FMT_Y41P</code></span></dt><dt><span class="refentrytitle"><a href="media.html#idp58050800">V4L2_PIX_FMT_NV12 ('NV12'), V4L2_PIX_FMT_NV21 ('NV21')</a></span><span class="refpurpose"> &#8212; Formats with ½ horizontal and vertical
chroma resolution, also known as YUV 4:2:0. One luminance and one
chrominance plane with alternating chroma samples as opposed to
<code class="constant">V4L2_PIX_FMT_YVU420</code></span></dt><dt><span class="refentrytitle"><a href="media.html#idp58169408">V4L2_PIX_FMT_NV12M ('NM12'), V4L2_PIX_FMT_NV21M ('NM21'), V4L2_PIX_FMT_NV12MT_16X16</a></span><span class="refpurpose"> &#8212; Variation of <code class="constant">V4L2_PIX_FMT_NV12</code> and <code class="constant">V4L2_PIX_FMT_NV21</code> with planes
	  non contiguous in memory. </span></dt><dt><span class="refentrytitle"><a href="media.html#idp58299328">V4L2_PIX_FMT_NV12MT ('TM12')</a></span><span class="refpurpose"> &#8212; Formats with ½ horizontal and vertical
chroma resolution. This format has two planes - one for luminance and one for
chrominance. Chroma samples are interleaved. The difference to
<code class="constant">V4L2_PIX_FMT_NV12</code> is the memory layout. Pixels are
grouped in macroblocks of 64x32 size. The order of macroblocks in memory is
also not standard.
	</span></dt><dt><span class="refentrytitle"><a href="media.html#idp58297872">V4L2_PIX_FMT_NV16 ('NV16'), V4L2_PIX_FMT_NV61 ('NV61')</a></span><span class="refpurpose"> &#8212; Formats with ½ horizontal
chroma resolution, also known as YUV 4:2:2. One luminance and one
chrominance plane with alternating chroma samples as opposed to
<code class="constant">V4L2_PIX_FMT_YVU420</code></span></dt><dt><span class="refentrytitle"><a href="media.html#idp58473760">V4L2_PIX_FMT_NV16M ('NM16'), V4L2_PIX_FMT_NV61M ('NM61')</a></span><span class="refpurpose"> &#8212; Variation of <code class="constant">V4L2_PIX_FMT_NV16</code> and <code class="constant">V4L2_PIX_FMT_NV61</code> with planes
	  non contiguous in memory. </span></dt><dt><span class="refentrytitle"><a href="media.html#idp58620656">V4L2_PIX_FMT_NV24 ('NV24'), V4L2_PIX_FMT_NV42 ('NV42')</a></span><span class="refpurpose"> &#8212; Formats with full horizontal and vertical
chroma resolutions, also known as YUV 4:4:4. One luminance and one
chrominance plane with alternating chroma samples as opposed to
<code class="constant">V4L2_PIX_FMT_YVU420</code></span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-M420">V4L2_PIX_FMT_M420 ('M420')</a></span><span class="refpurpose"> &#8212; Format with ½ horizontal and vertical chroma
	resolution, also known as YUV 4:2:0. Hybrid plane line-interleaved
	layout.</span></dt></dl></dd><dt><span class="section"><a href="media.html#idp58796032">Compressed Formats</a></span></dt><dt><span class="section"><a href="media.html#sdr-formats">SDR Formats</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="media.html#V4L2-SDR-FMT-CU08">V4L2_SDR_FMT_CU8 ('CU08')</a></span><span class="refpurpose"> &#8212; Complex unsigned 8-bit IQ sample</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-SDR-FMT-CU16LE">V4L2_SDR_FMT_CU16LE ('CU16')</a></span><span class="refpurpose"> &#8212; Complex unsigned 16-bit little endian IQ sample</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-SDR-FMT-CS08">V4L2_SDR_FMT_CS8 ('CS08')</a></span><span class="refpurpose"> &#8212; Complex signed 8-bit IQ sample</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-SDR-FMT-CS14LE">V4L2_SDR_FMT_CS14LE ('CS14')</a></span><span class="refpurpose"> &#8212; Complex signed 14-bit little endian IQ sample</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-SDR-FMT-RU12LE">V4L2_SDR_FMT_RU12LE ('RU12')</a></span><span class="refpurpose"> &#8212; Real unsigned 12-bit little endian sample</span></dt></dl></dd><dt><span class="section"><a href="media.html#pixfmt-reserved">Reserved Format Identifiers</a></span></dt></dl></div><p>The V4L2 API was primarily designed for devices exchanging
image data with applications. The
<span class="structname">v4l2_pix_format</span> and <span class="structname">v4l2_pix_format_mplane
</span> structures define the format and layout of an image in memory.
The former is used with the single-planar API, while the latter is used with the
multi-planar version (see <a class="xref" href="media.html#planar-apis" title="Single- and multi-planar APIs">the section called &#8220;Single- and multi-planar APIs&#8221;</a>). Image formats are
negotiated with the <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> ioctl. (The explanations here focus on video
capturing and output, for overlay frame buffer formats see also
<a class="link" href="media.html#vidioc-g-fbuf" title="ioctl VIDIOC_G_FBUF, VIDIOC_S_FBUF"><code class="constant">VIDIOC_G_FBUF</code></a>.)</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp53973040"></a>Single-planar format structure</h2></div></div></div><div class="table"><a name="v4l2-pix-format"></a><p class="title"><b>Table 2.1. struct <span class="structname">v4l2_pix_format</span></b></p><div class="table-contents"><table summary="struct v4l2_pix_format" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>width</code></em></td><td valign="top">Image width in pixels.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>height</code></em></td><td valign="top">Image height in pixels. If <em class="structfield"><code>field</code></em> is
	  one of <code class="constant">V4L2_FIELD_TOP</code>, <code class="constant">V4L2_FIELD_BOTTOM</code>
	  or <code class="constant">V4L2_FIELD_ALTERNATE</code> then height refers to the
	  number of lines in the field, otherwise it refers to the number of
	  lines in the frame (which is twice the field height for interlaced
	  formats).</td></tr><tr><td colspan="3" valign="top">Applications set these fields to
request an image size, drivers return the closest possible values. In
case of planar formats the <em class="structfield"><code>width</code></em> and
<em class="structfield"><code>height</code></em> applies to the largest plane. To
avoid ambiguities drivers must return values rounded up to a multiple
of the scale factor of any smaller planes. For example when the image
format is YUV 4:2:0, <em class="structfield"><code>width</code></em> and
<em class="structfield"><code>height</code></em> must be multiples of two.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>pixelformat</code></em></td><td valign="top">The pixel format or type of compression, set by the
application. This is a little endian <a class="link" href="media.html#v4l2-fourcc">four character code</a>. V4L2 defines
standard RGB formats in <a class="xref" href="media.html#rgb-formats" title="Table 2.16. Packed RGB Image Formats">Table 2.16, &#8220;Packed RGB Image Formats&#8221;</a>, YUV formats in <a class="xref" href="media.html#yuv-formats" title="YUV Formats">the section called &#8220;YUV Formats&#8221;</a>, and reserved codes in <a class="xref" href="media.html#reserved-formats" title="Table 2.20. Reserved Image Formats">Table 2.20, &#8220;Reserved Image Formats&#8221;</a></td></tr><tr><td valign="top">enum <a class="link" href="media.html#v4l2-field" title="Table 3.9. enum v4l2_field">v4l2_field</a></td><td valign="top"><em class="structfield"><code>field</code></em></td><td valign="top">Video images are typically interlaced. Applications
can request to capture or output only the top or bottom field, or both
fields interlaced or sequentially stored in one buffer or alternating
in separate buffers. Drivers return the actual field order selected.
For more details on fields see <a class="xref" href="media.html#field-order" title="Field Order">the section called &#8220;Field Order&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>bytesperline</code></em></td><td valign="top">Distance in bytes between the leftmost pixels in two
adjacent lines.</td></tr><tr><td colspan="3" valign="top"><p>Both applications and drivers
can set this field to request padding bytes at the end of each line.
Drivers however may ignore the value requested by the application,
returning <em class="structfield"><code>width</code></em> times bytes per pixel or a
larger value required by the hardware. That implies applications can
just set this field to zero to get a reasonable
default.</p><p>Video hardware may access padding bytes,
therefore they must reside in accessible memory. Consider cases where
padding bytes after the last line of an image cross a system page
boundary. Input devices may write padding bytes, the value is
undefined. Output devices ignore the contents of padding
bytes.</p><p>When the image format is planar the
<em class="structfield"><code>bytesperline</code></em> value applies to the largest
plane and is divided by the same factor as the
<em class="structfield"><code>width</code></em> field for any smaller planes. For
example the Cb and Cr planes of a YUV 4:2:0 image have half as many
padding bytes following each line as the Y plane. To avoid ambiguities
drivers must return a <em class="structfield"><code>bytesperline</code></em> value
rounded up to a multiple of the scale factor.</p>
<p>For compressed formats the <em class="structfield"><code>bytesperline</code></em>
value makes no sense. Applications and drivers must set this to 0 in
that case.</p></td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>sizeimage</code></em></td><td valign="top">Size in bytes of the buffer to hold a complete image,
set by the driver. Usually this is
<em class="structfield"><code>bytesperline</code></em> times
<em class="structfield"><code>height</code></em>. When the image consists of variable
length compressed data this is the maximum number of bytes required to
hold an image.</td></tr><tr><td valign="top">enum <a class="link" href="media.html#v4l2-colorspace" title="Table 2.4. V4L2 Colorspaces">v4l2_colorspace</a></td><td valign="top"><em class="structfield"><code>colorspace</code></em></td><td valign="top">This information supplements the
<em class="structfield"><code>pixelformat</code></em> and must be set by the driver for
capture streams and by the application for output streams,
see <a class="xref" href="media.html#colorspaces" title="Colorspaces">the section called &#8220;Colorspaces&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>priv</code></em></td><td valign="top"><p>This field indicates whether the remaining fields of the
<span class="structname">v4l2_pix_format</span> structure, also called the extended
fields, are valid. When set to <code class="constant">V4L2_PIX_FMT_PRIV_MAGIC</code>, it
indicates that the extended fields have been correctly initialized. When set to
any other value it indicates that the extended fields contain undefined values.
</p>
<p>Applications that wish to use the pixel format extended fields must first
ensure that the feature is supported by querying the device for the
<a class="link" href="media.html#querycap" title="Querying Capabilities"><code class="constant">V4L2_CAP_EXT_PIX_FORMAT</code></a>
capability. If the capability isn't set the pixel format extended fields are not
supported and using the extended fields will lead to undefined results.</p>
<p>To use the extended fields, applications must set the
<em class="structfield"><code>priv</code></em> field to
<code class="constant">V4L2_PIX_FMT_PRIV_MAGIC</code>, initialize all the extended fields
and zero the unused bytes of the <span class="structname">v4l2_format</span>
<em class="structfield"><code>raw_data</code></em> field.</p>
<p>When the <em class="structfield"><code>priv</code></em> field isn't set to
<code class="constant">V4L2_PIX_FMT_PRIV_MAGIC</code> drivers must act as if all the
extended fields were set to zero. On return drivers must set the
<em class="structfield"><code>priv</code></em> field to
<code class="constant">V4L2_PIX_FMT_PRIV_MAGIC</code> and all the extended fields to
applicable values.</p></td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>flags</code></em></td><td valign="top">Flags set by the application or driver, see <a class="xref" href="media.html#format-flags" title="Table 2.21. Format Flags">Table 2.21, &#8220;Format Flags&#8221;</a>.</td></tr><tr><td valign="top">enum <a class="link" href="media.html#v4l2-ycbcr-encoding" title="Table 2.5. V4L2 Y'CbCr Encodings">v4l2_ycbcr_encoding</a></td><td valign="top"><em class="structfield"><code>ycbcr_enc</code></em></td><td valign="top">This information supplements the
<em class="structfield"><code>colorspace</code></em> and must be set by the driver for
capture streams and by the application for output streams,
see <a class="xref" href="media.html#colorspaces" title="Colorspaces">the section called &#8220;Colorspaces&#8221;</a>.</td></tr><tr><td valign="top">enum <a class="link" href="media.html#v4l2-quantization" title="Table 2.6. V4L2 Quantization Methods">v4l2_quantization</a></td><td valign="top"><em class="structfield"><code>quantization</code></em></td><td valign="top">This information supplements the
<em class="structfield"><code>colorspace</code></em> and must be set by the driver for
capture streams and by the application for output streams,
see <a class="xref" href="media.html#colorspaces" title="Colorspaces">the section called &#8220;Colorspaces&#8221;</a>.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp54078128"></a>Multi-planar format structures</h2></div></div></div><p>The <span class="structname">v4l2_plane_pix_format</span> structures define
    size and layout for each of the planes in a multi-planar format.
    The <span class="structname">v4l2_pix_format_mplane</span> structure contains
    information common to all planes (such as image width and height) and
    an array of <span class="structname">v4l2_plane_pix_format</span> structures,
    describing all planes of that format.</p><div class="table"><a name="v4l2-plane-pix-format"></a><p class="title"><b>Table 2.2. struct <span class="structname">v4l2_plane_pix_format</span></b></p><div class="table-contents"><table summary="struct v4l2_plane_pix_format" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>sizeimage</code></em></td><td valign="top">Maximum size in bytes required for image data in this plane.
          </td></tr><tr><td valign="top">__u16</td><td valign="top"><em class="structfield"><code>bytesperline</code></em></td><td valign="top">Distance in bytes between the leftmost pixels in two adjacent
            lines. See struct <a class="link" href="media.html#v4l2-pix-format" title="Table 2.1. struct v4l2_pix_format">v4l2_pix_format</a>.</td></tr><tr><td valign="top">__u16</td><td valign="top"><em class="structfield"><code>reserved[7]</code></em></td><td valign="top">Reserved for future extensions. Should be zeroed by the
           application.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-pix-format-mplane"></a><p class="title"><b>Table 2.3. struct <span class="structname">v4l2_pix_format_mplane</span></b></p><div class="table-contents"><table summary="struct v4l2_pix_format_mplane" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>width</code></em></td><td valign="top">Image width in pixels. See struct <a class="link" href="media.html#v4l2-pix-format" title="Table 2.1. struct v4l2_pix_format">v4l2_pix_format</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>height</code></em></td><td valign="top">Image height in pixels. See struct <a class="link" href="media.html#v4l2-pix-format" title="Table 2.1. struct v4l2_pix_format">v4l2_pix_format</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>pixelformat</code></em></td><td valign="top">The pixel format. Both single- and multi-planar four character
codes can be used.</td></tr><tr><td valign="top">enum <a class="link" href="media.html#v4l2-field" title="Table 3.9. enum v4l2_field">v4l2_field</a></td><td valign="top"><em class="structfield"><code>field</code></em></td><td valign="top">See struct <a class="link" href="media.html#v4l2-pix-format" title="Table 2.1. struct v4l2_pix_format">v4l2_pix_format</a>.</td></tr><tr><td valign="top">enum <a class="link" href="media.html#v4l2-colorspace" title="Table 2.4. V4L2 Colorspaces">v4l2_colorspace</a></td><td valign="top"><em class="structfield"><code>colorspace</code></em></td><td valign="top">See struct <a class="link" href="media.html#v4l2-pix-format" title="Table 2.1. struct v4l2_pix_format">v4l2_pix_format</a>.</td></tr><tr><td valign="top">struct <a class="link" href="media.html#v4l2-plane-pix-format" title="Table 2.2. struct v4l2_plane_pix_format">v4l2_plane_pix_format</a></td><td valign="top"><em class="structfield"><code>plane_fmt[VIDEO_MAX_PLANES]</code></em></td><td valign="top">An array of structures describing format of each plane this
          pixel format consists of. The number of valid entries in this array
          has to be put in the <em class="structfield"><code>num_planes</code></em>
          field.</td></tr><tr><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>num_planes</code></em></td><td valign="top">Number of planes (i.e. separate memory buffers) for this format
          and the number of valid entries in the
          <em class="structfield"><code>plane_fmt</code></em> array.</td></tr><tr><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>flags</code></em></td><td valign="top">Flags set by the application or driver, see <a class="xref" href="media.html#format-flags" title="Table 2.21. Format Flags">Table 2.21, &#8220;Format Flags&#8221;</a>.</td></tr><tr><td valign="top">enum <a class="link" href="media.html#v4l2-ycbcr-encoding" title="Table 2.5. V4L2 Y'CbCr Encodings">v4l2_ycbcr_encoding</a></td><td valign="top"><em class="structfield"><code>ycbcr_enc</code></em></td><td valign="top">This information supplements the
<em class="structfield"><code>colorspace</code></em> and must be set by the driver for
capture streams and by the application for output streams,
see <a class="xref" href="media.html#colorspaces" title="Colorspaces">the section called &#8220;Colorspaces&#8221;</a>.</td></tr><tr><td valign="top">enum <a class="link" href="media.html#v4l2-quantization" title="Table 2.6. V4L2 Quantization Methods">v4l2_quantization</a></td><td valign="top"><em class="structfield"><code>quantization</code></em></td><td valign="top">This information supplements the
<em class="structfield"><code>colorspace</code></em> and must be set by the driver for
capture streams and by the application for output streams,
see <a class="xref" href="media.html#colorspaces" title="Colorspaces">the section called &#8220;Colorspaces&#8221;</a>.</td></tr><tr><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>reserved[8]</code></em></td><td valign="top">Reserved for future extensions. Should be zeroed by the
           application.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp54128880"></a>Standard Image Formats</h2></div></div></div><p>In order to exchange images between drivers and
applications, it is necessary to have standard image data formats
which both sides will interpret the same way. V4L2 includes several
such formats, and this section is intended to be an unambiguous
specification of the standard image data formats in V4L2.</p><p>V4L2 drivers are not limited to these formats, however.
Driver-specific formats are possible. In that case the application may
depend on a codec to convert images to one of the standard formats
when needed. But the data can still be stored and retrieved in the
proprietary format. For example, a device may support a proprietary
compressed format. Applications can still capture and save the data in
the compressed format, saving much disk space, and later use a codec
to convert the images to the X Windows screen format when the video is
to be displayed.</p><p>Even so, ultimately, some standard formats are needed, so
the V4L2 specification would not be complete without well-defined
standard formats.</p><p>The V4L2 standard formats are mainly uncompressed formats. The
pixels are always arranged in memory from left to right, and from top
to bottom. The first byte of data in the image buffer is always for
the leftmost pixel of the topmost row. Following that is the pixel
immediately to its right, and so on until the end of the top row of
pixels. Following the rightmost pixel of the row there may be zero or
more bytes of padding to guarantee that each row of pixel data has a
certain alignment. Following the pad bytes, if any, is data for the
leftmost pixel of the second row from the top, and so on. The last row
has just as many pad bytes after it as the other rows.</p><p>In V4L2 each format has an identifier which looks like
<code class="constant">PIX_FMT_XXX</code>, defined in the <a class="link" href="media.html#videodev" title="Appendix C. Video For Linux Two Header File">videodev2.h</a> header file. These identifiers
represent <a class="link" href="media.html#v4l2-fourcc">four character (FourCC) codes</a>
which are also listed below, however they are not the same as those
used in the Windows world.</p><p>For some formats, data is stored in separate, discontiguous
memory buffers. Those formats are identified by a separate set of FourCC codes
and are referred to as "multi-planar formats". For example, a YUV422 frame is
normally stored in one memory buffer, but it can also be placed in two or three
separate buffers, with Y component in one buffer and CbCr components in another
in the 2-planar version or with each component in its own buffer in the
3-planar case. Those sub-buffers are referred to as "planes".</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="colorspaces"></a>Colorspaces</h2></div></div></div><p>'Color' is a very complex concept and depends on physics, chemistry and
biology. Just because you have three numbers that describe the 'red', 'green'
and 'blue' components of the color of a pixel does not mean that you can accurately
display that color. A colorspace defines what it actually <span class="emphasis"><em>means</em></span>
to have an RGB value of e.g. (255, 0, 0). That is, which color should be
reproduced on the screen in a perfectly calibrated environment.</p><p>In order to do that we first need to have a good definition of
color, i.e. some way to uniquely and unambiguously define a color so that someone
else can reproduce it. Human color vision is trichromatic since the human eye has
color receptors that are sensitive to three different wavelengths of light. Hence
the need to use three numbers to describe color. Be glad you are not a mantis shrimp
as those are sensitive to 12 different wavelengths, so instead of RGB we would be
using the ABCDEFGHIJKL colorspace...</p><p>Color exists only in the eye and brain and is the result of how strongly
color receptors are stimulated. This is based on the Spectral
Power Distribution (SPD) which is a graph showing the intensity (radiant power)
of the light at wavelengths covering the visible spectrum as it enters the eye.
The science of colorimetry is about the relationship between the SPD and color as
perceived by the human brain.</p><p>Since the human eye has only three color receptors it is perfectly
possible that different SPDs will result in the same stimulation of those receptors
and are perceived as the same color, even though the SPD of the light is
different.</p><p>In the 1920s experiments were devised to determine the relationship
between SPDs and the perceived color and that resulted in the CIE 1931 standard
that defines spectral weighting functions that model the perception of color.
Specifically that standard defines functions that can take an SPD and calculate
the stimulus for each color receptor. After some further mathematical transforms
these stimuli are known as the <span class="emphasis"><em>CIE XYZ tristimulus</em></span> values
and these X, Y and Z values describe a color as perceived by a human unambiguously.
These X, Y and Z values are all in the range [0&#8230;1].</p><p>The Y value in the CIE XYZ colorspace corresponds to luminance. Often
the CIE XYZ colorspace is transformed to the normalized CIE xyY colorspace:</p><p>x = X / (X + Y + Z)</p><p>y = Y / (X + Y + Z)</p><p>The x and y values are the chromaticity coordinates and can be used to
define a color without the luminance component Y. It is very confusing to
have such similar names for these colorspaces. Just be aware that if colors
are specified with lower case 'x' and 'y', then the CIE xyY colorspace is
used. Upper case 'X' and 'Y' refer to the CIE XYZ colorspace. Also, y has nothing
to do with luminance. Together x and y specify a color, and Y the luminance.
That is really all you need to remember from a practical point of view. At
the end of this section you will find reading resources that go into much more
detail if you are interested.
</p><p>A monitor or TV will reproduce colors by emitting light at three
different wavelengths, the combination of which will stimulate the color receptors
in the eye and thus cause the perception of color. Historically these wavelengths
were defined by the red, green and blue phosphors used in the displays. These
<span class="emphasis"><em>color primaries</em></span> are part of what defines a colorspace.</p><p>Different display devices will have different primaries and some
primaries are more suitable for some display technologies than others. This has
resulted in a variety of colorspaces that are used for different display
technologies or uses. To define a colorspace you need to define the three
color primaries (these are typically defined as x, y chromaticity coordinates
from the CIE xyY colorspace) but also the white reference: that is the color obtained
when all three primaries are at maximum power. This determines the relative power
or energy of the primaries. This is usually chosen to be close to daylight which has
been defined as the CIE D65 Illuminant.</p><p>To recapitulate: the CIE XYZ colorspace uniquely identifies colors.
Other colorspaces are defined by three chromaticity coordinates defined in the
CIE xyY colorspace. Based on those a 3x3 matrix can be constructed that
transforms CIE XYZ colors to colors in the new colorspace.
</p><p>Both the CIE XYZ and the RGB colorspace that are derived from the
specific chromaticity primaries are linear colorspaces. But neither the eye,
nor display technology is linear. Doubling the values of all components in
the linear colorspace will not be perceived as twice the intensity of the color.
So each colorspace also defines a transfer function that takes a linear color
component value and transforms it to the non-linear component value, which is a
closer match to the non-linear performance of both the eye and displays. Linear
component values are denoted RGB, non-linear are denoted as R'G'B'. In general
colors used in graphics are all R'G'B', except in openGL which uses linear RGB.
Special care should be taken when dealing with openGL to provide linear RGB colors
or to use the built-in openGL support to apply the inverse transfer function.</p><p>The final piece that defines a colorspace is a function that
transforms non-linear R'G'B' to non-linear Y'CbCr. This function is determined
by the so-called luma coefficients. There may be multiple possible Y'CbCr
encodings allowed for the same colorspace. Many encodings of color
prefer to use luma (Y') and chroma (CbCr) instead of R'G'B'. Since the human
eye is more sensitive to differences in luminance than in color this encoding
allows one to reduce the amount of color information compared to the luma
data. Note that the luma (Y') is unrelated to the Y in the CIE XYZ colorspace.
Also note that Y'CbCr is often called YCbCr or YUV even though these are
strictly speaking wrong.</p><p>Sometimes people confuse Y'CbCr as being a colorspace. This is not
correct, it is just an encoding of an R'G'B' color into luma and chroma
values. The underlying colorspace that is associated with the R'G'B' color
is also associated with the Y'CbCr color.</p><p>The final step is how the RGB, R'G'B' or Y'CbCr values are
quantized. The CIE XYZ colorspace where X, Y and Z are in the range
[0&#8230;1] describes all colors that humans can perceive, but the transform to
another colorspace will produce colors that are outside the [0&#8230;1] range.
Once clamped to the [0&#8230;1] range those colors can no longer be reproduced
in that colorspace. This clamping is what reduces the extent or gamut of the
colorspace. How the range of [0&#8230;1] is translated to integer values in the
range of [0&#8230;255] (or higher, depending on the color depth) is called the
quantization. This is <span class="emphasis"><em>not</em></span> part of the colorspace
definition. In practice RGB or R'G'B' values are full range, i.e. they
use the full [0&#8230;255] range. Y'CbCr values on the other hand are limited
range with Y' using [16&#8230;235] and Cb and Cr using [16&#8230;240].</p><p>Unfortunately, in some cases limited range RGB is also used
where the components use the range [16&#8230;235]. And full range Y'CbCr also exists
using the [0&#8230;255] range.</p><p>In order to correctly interpret a color you need to know the
quantization range, whether it is R'G'B' or Y'CbCr, the used Y'CbCr encoding
and the colorspace.
From that information you can calculate the corresponding CIE XYZ color
and map that again to whatever colorspace your display device uses.</p><p>The colorspace definition itself consists of the three
chromaticity primaries, the white reference chromaticity, a transfer
function and the luma coefficients needed to transform R'G'B' to Y'CbCr. While
some colorspace standards correctly define all four, quite often the colorspace
standard only defines some, and you have to rely on other standards for
the missing pieces. The fact that colorspaces are often a mix of different
standards also led to very confusing naming conventions where the name of
a standard was used to name a colorspace when in fact that standard was
part of various other colorspaces as well.</p><p>If you want to read more about colors and colorspaces, then the
following resources are useful: <a class="xref" href="media.html#poynton" title="Digital Video and HDTV, Algorithms and Interfaces">[<abbr class="abbrev">poynton</abbr>]</a> is a good practical
book for video engineers, <a class="xref" href="media.html#colimg" title="Color Imaging: Fundamentals and Applications">[<abbr class="abbrev">colimg</abbr>]</a> has a much broader scope and
describes many more aspects of color (physics, chemistry, biology, etc.).
The <a class="ulink" href="http://www.brucelindbloom.com" target="_top">http://www.brucelindbloom.com</a>
website is an excellent resource, especially with respect to the mathematics behind
colorspace conversions. The wikipedia <a class="ulink" href="http://en.wikipedia.org/wiki/CIE_1931_color_space#CIE_xy_chromaticity_diagram_and_the_CIE_xyY_color_space" target="_top">CIE 1931 colorspace</a> article
is also very useful.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp54168592"></a>Defining Colorspaces in V4L2</h2></div></div></div><p>In V4L2 colorspaces are defined by three values. The first is the colorspace
identifier (enum <a class="link" href="media.html#v4l2-colorspace" title="Table 2.4. V4L2 Colorspaces">v4l2_colorspace</a>) which defines the chromaticities, the transfer
function, the default Y'CbCr encoding and the default quantization method. The second
is the Y'CbCr encoding identifier (enum <a class="link" href="media.html#v4l2-ycbcr-encoding" title="Table 2.5. V4L2 Y'CbCr Encodings">v4l2_ycbcr_encoding</a>) to specify non-standard
Y'CbCr encodings and the third is the quantization identifier (enum <a class="link" href="media.html#v4l2-quantization" title="Table 2.6. V4L2 Quantization Methods">v4l2_quantization</a>)
to specify non-standard quantization methods. Most of the time only the colorspace
field of struct <a class="link" href="media.html#v4l2-pix-format" title="Table 2.1. struct v4l2_pix_format">v4l2_pix_format</a> or struct <a class="link" href="media.html#v4l2-pix-format-mplane" title="Table 2.3. struct v4l2_pix_format_mplane">v4l2_pix_format_mplane</a> needs to be filled in. Note
that the default R'G'B' quantization is always full range for all colorspaces,
so this won't be mentioned explicitly for each colorspace description.</p><div class="table"><a name="v4l2-colorspace"></a><p class="title"><b>Table 2.4. V4L2 Colorspaces</b></p><div class="table-contents"><table summary="V4L2 Colorspaces" width="100%" border="0"><colgroup><col align="left" class="c1"><col align="left" class="c2"></colgroup><thead><tr><th align="left">Identifier</th><th align="left">Details</th></tr></thead><tbody valign="top"><tr><td align="left" valign="top"><code class="constant">V4L2_COLORSPACE_SMPTE170M</code></td><td align="left" valign="top">See <a class="xref" href="media.html#col-smpte-170m">the section called &#8220;Colorspace SMPTE 170M (<code class="constant">V4L2_COLORSPACE_SMPTE170M</code>)&#8221;</a>.</td></tr><tr><td align="left" valign="top"><code class="constant">V4L2_COLORSPACE_REC709</code></td><td align="left" valign="top">See <a class="xref" href="media.html#col-rec709">the section called &#8220;Colorspace Rec. 709 (<code class="constant">V4L2_COLORSPACE_REC709</code>)&#8221;</a>.</td></tr><tr><td align="left" valign="top"><code class="constant">V4L2_COLORSPACE_SRGB</code></td><td align="left" valign="top">See <a class="xref" href="media.html#col-srgb">the section called &#8220;Colorspace sRGB (<code class="constant">V4L2_COLORSPACE_SRGB</code>)&#8221;</a>.</td></tr><tr><td align="left" valign="top"><code class="constant">V4L2_COLORSPACE_ADOBERGB</code></td><td align="left" valign="top">See <a class="xref" href="media.html#col-adobergb">the section called &#8220;Colorspace Adobe RGB (<code class="constant">V4L2_COLORSPACE_ADOBERGB</code>)&#8221;</a>.</td></tr><tr><td align="left" valign="top"><code class="constant">V4L2_COLORSPACE_BT2020</code></td><td align="left" valign="top">See <a class="xref" href="media.html#col-bt2020">the section called &#8220;Colorspace BT.2020 (<code class="constant">V4L2_COLORSPACE_BT2020</code>)&#8221;</a>.</td></tr><tr><td align="left" valign="top"><code class="constant">V4L2_COLORSPACE_SMPTE240M</code></td><td align="left" valign="top">See <a class="xref" href="media.html#col-smpte-240m">the section called &#8220;Colorspace SMPTE 240M (<code class="constant">V4L2_COLORSPACE_SMPTE240M</code>)&#8221;</a>.</td></tr><tr><td align="left" valign="top"><code class="constant">V4L2_COLORSPACE_470_SYSTEM_M</code></td><td align="left" valign="top">See <a class="xref" href="media.html#col-sysm">the section called &#8220;Colorspace NTSC 1953 (<code class="constant">V4L2_COLORSPACE_470_SYSTEM_M</code>)&#8221;</a>.</td></tr><tr><td align="left" valign="top"><code class="constant">V4L2_COLORSPACE_470_SYSTEM_BG</code></td><td align="left" valign="top">See <a class="xref" href="media.html#col-sysbg">the section called &#8220;Colorspace EBU Tech. 3213 (<code class="constant">V4L2_COLORSPACE_470_SYSTEM_BG</code>)&#8221;</a>.</td></tr><tr><td align="left" valign="top"><code class="constant">V4L2_COLORSPACE_JPEG</code></td><td align="left" valign="top">See <a class="xref" href="media.html#col-jpeg">the section called &#8220;Colorspace JPEG (<code class="constant">V4L2_COLORSPACE_JPEG</code>)&#8221;</a>.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-ycbcr-encoding"></a><p class="title"><b>Table 2.5. V4L2 Y'CbCr Encodings</b></p><div class="table-contents"><table summary="V4L2 Y'CbCr Encodings" width="100%" border="0"><colgroup><col align="left" class="c1"><col align="left" class="c2"></colgroup><thead><tr><th align="left">Identifier</th><th align="left">Details</th></tr></thead><tbody valign="top"><tr><td align="left" valign="top"><code class="constant">V4L2_YCBCR_ENC_DEFAULT</code></td><td align="left" valign="top">Use the default Y'CbCr encoding as defined by the colorspace.</td></tr><tr><td align="left" valign="top"><code class="constant">V4L2_YCBCR_ENC_601</code></td><td align="left" valign="top">Use the BT.601 Y'CbCr encoding.</td></tr><tr><td align="left" valign="top"><code class="constant">V4L2_YCBCR_ENC_709</code></td><td align="left" valign="top">Use the Rec. 709 Y'CbCr encoding.</td></tr><tr><td align="left" valign="top"><code class="constant">V4L2_YCBCR_ENC_XV601</code></td><td align="left" valign="top">Use the extended gamut xvYCC BT.601 encoding.</td></tr><tr><td align="left" valign="top"><code class="constant">V4L2_YCBCR_ENC_XV709</code></td><td align="left" valign="top">Use the extended gamut xvYCC Rec. 709 encoding.</td></tr><tr><td align="left" valign="top"><code class="constant">V4L2_YCBCR_ENC_SYCC</code></td><td align="left" valign="top">Use the extended gamut sYCC encoding.</td></tr><tr><td align="left" valign="top"><code class="constant">V4L2_YCBCR_ENC_BT2020</code></td><td align="left" valign="top">Use the default non-constant luminance BT.2020 Y'CbCr encoding.</td></tr><tr><td align="left" valign="top"><code class="constant">V4L2_YCBCR_ENC_BT2020_CONST_LUM</code></td><td align="left" valign="top">Use the constant luminance BT.2020 Yc'CbcCrc encoding.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-quantization"></a><p class="title"><b>Table 2.6. V4L2 Quantization Methods</b></p><div class="table-contents"><table summary="V4L2 Quantization Methods" width="100%" border="0"><colgroup><col align="left" class="c1"><col align="left" class="c2"></colgroup><thead><tr><th align="left">Identifier</th><th align="left">Details</th></tr></thead><tbody valign="top"><tr><td align="left" valign="top"><code class="constant">V4L2_QUANTIZATION_DEFAULT</code></td><td align="left" valign="top">Use the default quantization encoding as defined by the colorspace.
This is always full range for R'G'B' and usually limited range for Y'CbCr.</td></tr><tr><td align="left" valign="top"><code class="constant">V4L2_QUANTIZATION_FULL_RANGE</code></td><td align="left" valign="top">Use the full range quantization encoding. I.e. the range [0&#8230;1]
is mapped to [0&#8230;255] (with possible clipping to [1&#8230;254] to avoid the
0x00 and 0xff values). Cb and Cr are mapped from [-0.5&#8230;0.5] to [0&#8230;255]
(with possible clipping to [1&#8230;254] to avoid the 0x00 and 0xff values).</td></tr><tr><td align="left" valign="top"><code class="constant">V4L2_QUANTIZATION_LIM_RANGE</code></td><td align="left" valign="top">Use the limited range quantization encoding. I.e. the range [0&#8230;1]
is mapped to [16&#8230;235]. Cb and Cr are mapped from [-0.5&#8230;0.5] to [16&#8230;240].
</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp54232336"></a>Detailed Colorspace Descriptions</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#idp54233024">Colorspace SMPTE 170M (<code class="constant">V4L2_COLORSPACE_SMPTE170M</code>)</a></span></dt><dt><span class="section"><a href="media.html#idp54271504">Colorspace Rec. 709 (<code class="constant">V4L2_COLORSPACE_REC709</code>)</a></span></dt><dt><span class="section"><a href="media.html#idp54308064">Colorspace sRGB (<code class="constant">V4L2_COLORSPACE_SRGB</code>)</a></span></dt><dt><span class="section"><a href="media.html#idp54339536">Colorspace Adobe RGB (<code class="constant">V4L2_COLORSPACE_ADOBERGB</code>)</a></span></dt><dt><span class="section"><a href="media.html#idp54366256">Colorspace BT.2020 (<code class="constant">V4L2_COLORSPACE_BT2020</code>)</a></span></dt><dt><span class="section"><a href="media.html#idp54404656">Colorspace SMPTE 240M (<code class="constant">V4L2_COLORSPACE_SMPTE240M</code>)</a></span></dt><dt><span class="section"><a href="media.html#idp54432112">Colorspace NTSC 1953 (<code class="constant">V4L2_COLORSPACE_470_SYSTEM_M</code>)</a></span></dt><dt><span class="section"><a href="media.html#idp54459200">Colorspace EBU Tech. 3213 (<code class="constant">V4L2_COLORSPACE_470_SYSTEM_BG</code>)</a></span></dt><dt><span class="section"><a href="media.html#idp54486512">Colorspace JPEG (<code class="constant">V4L2_COLORSPACE_JPEG</code>)</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp54233024"></a>Colorspace SMPTE 170M (<code class="constant">V4L2_COLORSPACE_SMPTE170M</code>)</h3></div></div></div><p>The <a class="xref" href="media.html#smpte170m" title='SMPTE 170M-1999 "Television - Composite Analog Video Signal - NTSC for Studio Applications"'>[<abbr class="abbrev">SMPTE 170M</abbr>]</a> standard defines the colorspace used by NTSC and PAL and by SDTV
in general. The default Y'CbCr encoding is <code class="constant">V4L2_YCBCR_ENC_601</code>.
The default Y'CbCr quantization is limited range. The chromaticities of the primary colors and
the white reference are:</p><div class="table"><a name="idp54236320"></a><p class="title"><b>Table 2.7. SMPTE 170M Chromaticities</b></p><div class="table-contents"><table summary="SMPTE 170M Chromaticities" border="0"><colgroup><col align="left" class="c1"><col align="left" class="c2"><col align="left" class="c3"></colgroup><thead><tr><th align="left">Color</th><th align="left">x</th><th align="left">y</th></tr></thead><tbody valign="top"><tr><td align="left" valign="top">Red</td><td align="left" valign="top">0.630</td><td align="left" valign="top">0.340</td></tr><tr><td align="left" valign="top">Green</td><td align="left" valign="top">0.310</td><td align="left" valign="top">0.595</td></tr><tr><td align="left" valign="top">Blue</td><td align="left" valign="top">0.155</td><td align="left" valign="top">0.070</td></tr><tr><td align="left" valign="top">White Reference (D65)</td><td align="left" valign="top">0.3127</td><td align="left" valign="top">0.3290</td></tr></tbody></table></div></div><br class="table-break"><p>The red, green and blue chromaticities are also often referred to
as the SMPTE C set, so this colorspace is sometimes called SMPTE C as well.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">The transfer function defined for SMPTE 170M is the same as the
one defined in Rec. 709. Normally L is in the range [0&#8230;1], but for the extended
gamut xvYCC encoding values outside that range are allowed.</span></dt><dd><p>L' = -1.099(-L)<sup>0.45</sup> + 0.099 for L &#8804; -0.018</p><p>L' = 4.5L for -0.018 &lt; L &lt; 0.018</p><p>L' = 1.099L<sup>0.45</sup> - 0.099 for L &#8805; 0.018</p></dd></dl></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">Inverse Transfer function:</span></dt><dd><p>L = -((L' - 0.099) / -1.099)<sup>1/0.45</sup> for L' &#8804; -0.081</p><p>L = L' / 4.5 for -0.081 &lt; L' &lt; 0.081</p><p>L = ((L' + 0.099) / 1.099)<sup>1/0.45</sup> for L' &#8805; 0.081</p></dd></dl></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">The luminance (Y') and color difference (Cb and Cr) are obtained with
the following <code class="constant">V4L2_YCBCR_ENC_601</code> encoding:</span></dt><dd><p>Y' = 0.299R' + 0.587G' + 0.114B'</p><p>Cb = -0.169R' - 0.331G' + 0.5B'</p><p>Cr = 0.5R' - 0.419G' - 0.081B'</p></dd></dl></div><p>Y' is clamped to the range [0&#8230;1] and Cb and Cr are
clamped to the range [-0.5&#8230;0.5]. This conversion to Y'CbCr is identical to the one
defined in the <a class="xref" href="media.html#itu601" title='ITU-R Recommendation BT.601-5 "Studio Encoding Parameters of Digital Television for Standard 4:3 and Wide-Screen 16:9 Aspect Ratios"'>[<abbr class="abbrev">ITU BT.601</abbr>]</a> standard and this colorspace is sometimes called BT.601 as well, even
though BT.601 does not mention any color primaries.</p><p>The default quantization is limited range, but full range is possible although
rarely seen.</p><p>The <code class="constant">V4L2_YCBCR_ENC_601</code> encoding as described above is the
default for this colorspace, but it can be overridden with <code class="constant">V4L2_YCBCR_ENC_709</code>,
in which case the Rec. 709 Y'CbCr encoding is used.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">The xvYCC 601 encoding (<code class="constant">V4L2_YCBCR_ENC_XV601</code>, <a class="xref" href="media.html#xvycc" title='IEC 61966-2-4 ed1.0 "Multimedia systems and equipment - Colour measurement and management - Part 2-4: Colour management - Extended-gamut YCC colour space for video applications - xvYCC"'>[<abbr class="abbrev">xvYCC</abbr>]</a>) is similar
to the BT.601 encoding, but it allows for R', G' and B' values that are outside the range
[0&#8230;1]. The resulting Y', Cb and Cr values are scaled and offset:</span></dt><dd><p>Y' = (219 / 255) * (0.299R' + 0.587G' + 0.114B') + (16 / 255)</p><p>Cb = (224 / 255) * (-0.169R' - 0.331G' + 0.5B')</p><p>Cr = (224 / 255) * (0.5R' - 0.419G' - 0.081B')</p></dd></dl></div><p>Y' is clamped to the range [0&#8230;1] and Cb and Cr are clamped
to the range [-0.5&#8230;0.5]. The non-standard xvYCC 709 encoding can also be used by selecting
<code class="constant">V4L2_YCBCR_ENC_XV709</code>. The xvYCC encodings always use full range
quantization.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp54271504"></a>Colorspace Rec. 709 (<code class="constant">V4L2_COLORSPACE_REC709</code>)</h3></div></div></div><p>The <a class="xref" href="media.html#itu709" title='ITU-R Recommendation BT.709-5 "Parameter values for the HDTV standards for production and international programme exchange"'>[<abbr class="abbrev">ITU BT.709</abbr>]</a> standard defines the colorspace used by HDTV in general. The default
Y'CbCr encoding is <code class="constant">V4L2_YCBCR_ENC_709</code>. The default Y'CbCr quantization is
limited range. The chromaticities of the primary colors and the white reference are:</p><div class="table"><a name="idp54274736"></a><p class="title"><b>Table 2.8. Rec. 709 Chromaticities</b></p><div class="table-contents"><table summary="Rec. 709 Chromaticities" border="0"><colgroup><col align="left" class="c1"><col align="left" class="c2"><col align="left" class="c3"></colgroup><thead><tr><th align="left">Color</th><th align="left">x</th><th align="left">y</th></tr></thead><tbody valign="top"><tr><td align="left" valign="top">Red</td><td align="left" valign="top">0.640</td><td align="left" valign="top">0.330</td></tr><tr><td align="left" valign="top">Green</td><td align="left" valign="top">0.300</td><td align="left" valign="top">0.600</td></tr><tr><td align="left" valign="top">Blue</td><td align="left" valign="top">0.150</td><td align="left" valign="top">0.060</td></tr><tr><td align="left" valign="top">White Reference (D65)</td><td align="left" valign="top">0.3127</td><td align="left" valign="top">0.3290</td></tr></tbody></table></div></div><br class="table-break"><p>The full name of this standard is Rec. ITU-R BT.709-5.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Transfer function. Normally L is in the range [0&#8230;1], but for the extended
gamut xvYCC encoding values outside that range are allowed.</span></dt><dd><p>L' = -1.099(-L)<sup>0.45</sup> + 0.099 for L &#8804; -0.018</p><p>L' = 4.5L for -0.018 &lt; L &lt; 0.018</p><p>L' = 1.099L<sup>0.45</sup> - 0.099 for L &#8805; 0.018</p></dd></dl></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">Inverse Transfer function:</span></dt><dd><p>L = -((L' - 0.099) / -1.099)<sup>1/0.45</sup> for L' &#8804; -0.081</p><p>L = L' / 4.5 for -0.081 &lt; L' &lt; 0.081</p><p>L = ((L' + 0.099) / 1.099)<sup>1/0.45</sup> for L' &#8805; 0.081</p></dd></dl></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">The luminance (Y') and color difference (Cb and Cr) are obtained with the following
<code class="constant">V4L2_YCBCR_ENC_709</code> encoding:</span></dt><dd><p>Y' = 0.2126R' + 0.7152G' + 0.0722B'</p><p>Cb = -0.1146R' - 0.3854G' + 0.5B'</p><p>Cr = 0.5R' - 0.4542G' - 0.0458B'</p></dd></dl></div><p>Y' is clamped to the range [0&#8230;1] and Cb and Cr are
clamped to the range [-0.5&#8230;0.5].</p><p>The default quantization is limited range, but full range is possible although
rarely seen.</p><p>The <code class="constant">V4L2_YCBCR_ENC_709</code> encoding described above is the default
for this colorspace, but it can be overridden with <code class="constant">V4L2_YCBCR_ENC_601</code>, in which
case the BT.601 Y'CbCr encoding is used.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">The xvYCC 709 encoding (<code class="constant">V4L2_YCBCR_ENC_XV709</code>, <a class="xref" href="media.html#xvycc" title='IEC 61966-2-4 ed1.0 "Multimedia systems and equipment - Colour measurement and management - Part 2-4: Colour management - Extended-gamut YCC colour space for video applications - xvYCC"'>[<abbr class="abbrev">xvYCC</abbr>]</a>)
is similar to the Rec. 709 encoding, but it allows for R', G' and B' values that are outside the range
[0&#8230;1]. The resulting Y', Cb and Cr values are scaled and offset:</span></dt><dd><p>Y' = (219 / 255) * (0.2126R' + 0.7152G' + 0.0722B') + (16 / 255)</p><p>Cb = (224 / 255) * (-0.1146R' - 0.3854G' + 0.5B')</p><p>Cr = (224 / 255) * (0.5R' - 0.4542G' - 0.0458B')</p></dd></dl></div><p>Y' is clamped to the range [0&#8230;1] and Cb and Cr are clamped
to the range [-0.5&#8230;0.5]. The non-standard xvYCC 601 encoding can also be used by
selecting <code class="constant">V4L2_YCBCR_ENC_XV601</code>. The xvYCC encodings always use full
range quantization.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp54308064"></a>Colorspace sRGB (<code class="constant">V4L2_COLORSPACE_SRGB</code>)</h3></div></div></div><p>The <a class="xref" href="media.html#srgb" title='IEC 61966-2-1 ed1.0 "Multimedia systems and equipment - Colour measurement and management - Part 2-1: Colour management - Default RGB colour space - sRGB"'>[<abbr class="abbrev">sRGB</abbr>]</a> standard defines the colorspace used by most webcams and computer graphics. The
default Y'CbCr encoding is <code class="constant">V4L2_YCBCR_ENC_SYCC</code>. The default Y'CbCr quantization
is full range. The chromaticities of the primary colors and the white reference are:</p><div class="table"><a name="idp54311344"></a><p class="title"><b>Table 2.9. sRGB Chromaticities</b></p><div class="table-contents"><table summary="sRGB Chromaticities" border="0"><colgroup><col align="left" class="c1"><col align="left" class="c2"><col align="left" class="c3"></colgroup><thead><tr><th align="left">Color</th><th align="left">x</th><th align="left">y</th></tr></thead><tbody valign="top"><tr><td align="left" valign="top">Red</td><td align="left" valign="top">0.640</td><td align="left" valign="top">0.330</td></tr><tr><td align="left" valign="top">Green</td><td align="left" valign="top">0.300</td><td align="left" valign="top">0.600</td></tr><tr><td align="left" valign="top">Blue</td><td align="left" valign="top">0.150</td><td align="left" valign="top">0.060</td></tr><tr><td align="left" valign="top">White Reference (D65)</td><td align="left" valign="top">0.3127</td><td align="left" valign="top">0.3290</td></tr></tbody></table></div></div><br class="table-break"><p>These chromaticities are identical to the Rec. 709 colorspace.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Transfer function. Note that negative values for L are only used by the Y'CbCr conversion.</span></dt><dd><p>L' = -1.055(-L)<sup>1/2.4</sup> + 0.055 for L &lt; -0.0031308</p><p>L' = 12.92L for -0.0031308 &#8804; L &#8804; 0.0031308</p><p>L' = 1.055L<sup>1/2.4</sup> - 0.055 for 0.0031308 &lt; L &#8804; 1</p></dd><dt><span class="term">Inverse Transfer function:</span></dt><dd><p>L = -((-L' + 0.055) / 1.055)<sup>2.4</sup> for L' &lt; -0.04045</p><p>L = L' / 12.92 for -0.04045 &#8804; L' &#8804; 0.04045</p><p>L = ((L' + 0.055) / 1.055)<sup>2.4</sup> for L' &gt; 0.04045</p></dd></dl></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">The luminance (Y') and color difference (Cb and Cr) are obtained with the following
<code class="constant">V4L2_YCBCR_ENC_SYCC</code> encoding as defined by <a class="xref" href="media.html#sycc" title='IEC 61966-2-1-am1 ed1.0 "Amendment 1 - Multimedia systems and equipment - Colour measurement and management - Part 2-1: Colour management - Default RGB colour space - sRGB"'>[<abbr class="abbrev">sYCC</abbr>]</a>:</span></dt><dd><p>Y' = 0.2990R' + 0.5870G' + 0.1140B'</p><p>Cb = -0.1687R' - 0.3313G' + 0.5B'</p><p>Cr = 0.5R' - 0.4187G' - 0.0813B'</p></dd></dl></div><p>Y' is clamped to the range [0&#8230;1] and Cb and Cr are clamped
to the range [-0.5&#8230;0.5]. The <code class="constant">V4L2_YCBCR_ENC_SYCC</code> quantization is always
full range. Although this Y'CbCr encoding looks very similar to the <code class="constant">V4L2_YCBCR_ENC_XV601</code>
encoding, it is not. The <code class="constant">V4L2_YCBCR_ENC_XV601</code> scales and offsets the Y'CbCr
values before quantization, but this encoding does not do that.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp54339536"></a>Colorspace Adobe RGB (<code class="constant">V4L2_COLORSPACE_ADOBERGB</code>)</h3></div></div></div><p>The <a class="xref" href="media.html#adobergb" title="Adobe© RGB (1998) Color Image Encoding Version 2005-05">[<abbr class="abbrev">AdobeRGB</abbr>]</a> standard defines the colorspace used by computer graphics
that use the AdobeRGB colorspace. This is also known as the <a class="xref" href="media.html#oprgb" title='IEC 61966-2-5 "Multimedia systems and equipment - Colour measurement and management - Part 2-5: Colour management - Optional RGB colour space - opRGB"'>[<abbr class="abbrev">opRGB</abbr>]</a> standard.
The default Y'CbCr encoding is <code class="constant">V4L2_YCBCR_ENC_601</code>. The default Y'CbCr
quantization is limited range. The chromaticities of the primary colors and the white reference
are:</p><div class="table"><a name="idp54343696"></a><p class="title"><b>Table 2.10. Adobe RGB Chromaticities</b></p><div class="table-contents"><table summary="Adobe RGB Chromaticities" border="0"><colgroup><col align="left" class="c1"><col align="left" class="c2"><col align="left" class="c3"></colgroup><thead><tr><th align="left">Color</th><th align="left">x</th><th align="left">y</th></tr></thead><tbody valign="top"><tr><td align="left" valign="top">Red</td><td align="left" valign="top">0.6400</td><td align="left" valign="top">0.3300</td></tr><tr><td align="left" valign="top">Green</td><td align="left" valign="top">0.2100</td><td align="left" valign="top">0.7100</td></tr><tr><td align="left" valign="top">Blue</td><td align="left" valign="top">0.1500</td><td align="left" valign="top">0.0600</td></tr><tr><td align="left" valign="top">White Reference (D65)</td><td align="left" valign="top">0.3127</td><td align="left" valign="top">0.3290</td></tr></tbody></table></div></div><br class="table-break"><div class="variablelist"><dl class="variablelist"><dt><span class="term">Transfer function:</span></dt><dd><p>L' = L<sup>1/2.19921875</sup></p></dd><dt><span class="term">Inverse Transfer function:</span></dt><dd><p>L = L'<sup>2.19921875</sup></p></dd></dl></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">The luminance (Y') and color difference (Cb and Cr) are obtained with the
following <code class="constant">V4L2_YCBCR_ENC_601</code> encoding:</span></dt><dd><p>Y' = 0.299R' + 0.587G' + 0.114B'</p><p>Cb = -0.169R' - 0.331G' + 0.5B'</p><p>Cr = 0.5R' - 0.419G' - 0.081B'</p></dd></dl></div><p>Y' is clamped to the range [0&#8230;1] and Cb and Cr are
clamped to the range [-0.5&#8230;0.5]. This transform is identical to one defined in
SMPTE 170M/BT.601. The Y'CbCr quantization is limited range.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp54366256"></a>Colorspace BT.2020 (<code class="constant">V4L2_COLORSPACE_BT2020</code>)</h3></div></div></div><p>The <a class="xref" href="media.html#itu2020" title='ITU-R Recommendation BT.2020 (08/2012) "Parameter values for ultra-high definition television systems for production and international programme exchange"'>[<abbr class="abbrev">ITU BT.2020</abbr>]</a> standard defines the colorspace used by Ultra-high definition
television (UHDTV). The default Y'CbCr encoding is <code class="constant">V4L2_YCBCR_ENC_BT2020</code>.
The default Y'CbCr quantization is limited range. The chromaticities of the primary colors and
the white reference are:</p><div class="table"><a name="idp54369456"></a><p class="title"><b>Table 2.11. BT.2020 Chromaticities</b></p><div class="table-contents"><table summary="BT.2020 Chromaticities" border="0"><colgroup><col align="left" class="c1"><col align="left" class="c2"><col align="left" class="c3"></colgroup><thead><tr><th align="left">Color</th><th align="left">x</th><th align="left">y</th></tr></thead><tbody valign="top"><tr><td align="left" valign="top">Red</td><td align="left" valign="top">0.708</td><td align="left" valign="top">0.292</td></tr><tr><td align="left" valign="top">Green</td><td align="left" valign="top">0.170</td><td align="left" valign="top">0.797</td></tr><tr><td align="left" valign="top">Blue</td><td align="left" valign="top">0.131</td><td align="left" valign="top">0.046</td></tr><tr><td align="left" valign="top">White Reference (D65)</td><td align="left" valign="top">0.3127</td><td align="left" valign="top">0.3290</td></tr></tbody></table></div></div><br class="table-break"><div class="variablelist"><dl class="variablelist"><dt><span class="term">Transfer function (same as Rec. 709):</span></dt><dd><p>L' = 4.5L for 0 &#8804; L &lt; 0.018</p><p>L' = 1.099L<sup>0.45</sup> - 0.099 for 0.018 &#8804; L &#8804; 1</p></dd><dt><span class="term">Inverse Transfer function:</span></dt><dd><p>L = L' / 4.5 for L' &lt; 0.081</p><p>L = ((L' + 0.099) / 1.099)<sup>1/0.45</sup> for L' &#8805; 0.081</p></dd></dl></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">The luminance (Y') and color difference (Cb and Cr) are obtained with the
following <code class="constant">V4L2_YCBCR_ENC_BT2020</code> encoding:</span></dt><dd><p>Y' = 0.2627R' + 0.6789G' + 0.0593B'</p><p>Cb = -0.1396R' - 0.3604G' + 0.5B'</p><p>Cr = 0.5R' - 0.4598G' - 0.0402B'</p></dd></dl></div><p>Y' is clamped to the range [0&#8230;1] and Cb and Cr are
clamped to the range [-0.5&#8230;0.5]. The Y'CbCr quantization is limited range.</p><p>There is also an alternate constant luminance R'G'B' to Yc'CbcCrc
(<code class="constant">V4L2_YCBCR_ENC_BT2020_CONST_LUM</code>) encoding:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Luma:</span></dt><dd><p>Yc' = (0.2627R + 0.6789G + 0.0593B)'</p></dd></dl></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">B' - Yc' &#8804; 0:</span></dt><dd><p>Cbc = (B' - Y') / 1.9404</p></dd></dl></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">B' - Yc' &gt; 0:</span></dt><dd><p>Cbc = (B' - Y') / 1.5816</p></dd></dl></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">R' - Yc' &#8804; 0:</span></dt><dd><p>Crc = (R' - Y') / 1.7184</p></dd></dl></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">R' - Yc' &gt; 0:</span></dt><dd><p>Crc = (R' - Y') / 0.9936</p></dd></dl></div><p>Yc' is clamped to the range [0&#8230;1] and Cbc and Crc are
clamped to the range [-0.5&#8230;0.5]. The Yc'CbcCrc quantization is limited range.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp54404656"></a>Colorspace SMPTE 240M (<code class="constant">V4L2_COLORSPACE_SMPTE240M</code>)</h3></div></div></div><p>The <a class="xref" href="media.html#smpte240m" title='SMPTE 240M-1999 "Television - Signal Parameters - 1125-Line High-Definition Production"'>[<abbr class="abbrev">SMPTE 240M</abbr>]</a> standard was an interim standard used during the early days of HDTV (1988-1998).
It has been superseded by Rec. 709. The default Y'CbCr encoding is <code class="constant">V4L2_YCBCR_ENC_SMPTE240M</code>.
The default Y'CbCr quantization is limited range. The chromaticities of the primary colors and the
white reference are:</p><div class="table"><a name="idp54407904"></a><p class="title"><b>Table 2.12. SMPTE 240M Chromaticities</b></p><div class="table-contents"><table summary="SMPTE 240M Chromaticities" border="0"><colgroup><col align="left" class="c1"><col align="left" class="c2"><col align="left" class="c3"></colgroup><thead><tr><th align="left">Color</th><th align="left">x</th><th align="left">y</th></tr></thead><tbody valign="top"><tr><td align="left" valign="top">Red</td><td align="left" valign="top">0.630</td><td align="left" valign="top">0.340</td></tr><tr><td align="left" valign="top">Green</td><td align="left" valign="top">0.310</td><td align="left" valign="top">0.595</td></tr><tr><td align="left" valign="top">Blue</td><td align="left" valign="top">0.155</td><td align="left" valign="top">0.070</td></tr><tr><td align="left" valign="top">White Reference (D65)</td><td align="left" valign="top">0.3127</td><td align="left" valign="top">0.3290</td></tr></tbody></table></div></div><br class="table-break"><p>These chromaticities are identical to the SMPTE 170M colorspace.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Transfer function:</span></dt><dd><p>L' = 4L for 0 &#8804; L &lt; 0.0228</p><p>L' = 1.1115L<sup>0.45</sup> - 0.1115 for 0.0228 &#8804; L &#8804; 1</p></dd><dt><span class="term">Inverse Transfer function:</span></dt><dd><p>L = L' / 4 for 0 &#8804; L' &lt; 0.0913</p><p>L = ((L' + 0.1115) / 1.1115)<sup>1/0.45</sup> for L' &#8805; 0.0913</p></dd></dl></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">The luminance (Y') and color difference (Cb and Cr) are obtained with the
following <code class="constant">V4L2_YCBCR_ENC_SMPTE240M</code> encoding:</span></dt><dd><p>Y' = 0.2122R' + 0.7013G' + 0.0865B'</p><p>Cb = -0.1161R' - 0.3839G' + 0.5B'</p><p>Cr = 0.5R' - 0.4451G' - 0.0549B'</p></dd></dl></div><p>Yc' is clamped to the range [0&#8230;1] and Cbc and Crc are
clamped to the range [-0.5&#8230;0.5]. The Y'CbCr quantization is limited range.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp54432112"></a>Colorspace NTSC 1953 (<code class="constant">V4L2_COLORSPACE_470_SYSTEM_M</code>)</h3></div></div></div><p>This standard defines the colorspace used by NTSC in 1953. In practice this
colorspace is obsolete and SMPTE 170M should be used instead. The default Y'CbCr encoding
is <code class="constant">V4L2_YCBCR_ENC_601</code>. The default Y'CbCr quantization is limited range.
The chromaticities of the primary colors and the white reference are:</p><div class="table"><a name="idp54434672"></a><p class="title"><b>Table 2.13. NTSC 1953 Chromaticities</b></p><div class="table-contents"><table summary="NTSC 1953 Chromaticities" border="0"><colgroup><col align="left" class="c1"><col align="left" class="c2"><col align="left" class="c3"></colgroup><thead><tr><th align="left">Color</th><th align="left">x</th><th align="left">y</th></tr></thead><tbody valign="top"><tr><td align="left" valign="top">Red</td><td align="left" valign="top">0.67</td><td align="left" valign="top">0.33</td></tr><tr><td align="left" valign="top">Green</td><td align="left" valign="top">0.21</td><td align="left" valign="top">0.71</td></tr><tr><td align="left" valign="top">Blue</td><td align="left" valign="top">0.14</td><td align="left" valign="top">0.08</td></tr><tr><td align="left" valign="top">White Reference (C)</td><td align="left" valign="top">0.310</td><td align="left" valign="top">0.316</td></tr></tbody></table></div></div><br class="table-break"><p>Note that this colorspace uses Illuminant C instead of D65 as the
white reference. To correctly convert an image in this colorspace to another
that uses D65 you need to apply a chromatic adaptation algorithm such as the
Bradford method.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">The transfer function was never properly defined for NTSC 1953. The
Rec. 709 transfer function is recommended in the literature:</span></dt><dd><p>L' = 4.5L for 0 &#8804; L &lt; 0.018</p><p>L' = 1.099L<sup>0.45</sup> - 0.099 for 0.018 &#8804; L &#8804; 1</p></dd><dt><span class="term">Inverse Transfer function:</span></dt><dd><p>L = L' / 4.5 for L' &lt; 0.081</p><p>L = ((L' + 0.099) / 1.099)<sup>1/0.45</sup> for L' &#8805; 0.081</p></dd></dl></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">The luminance (Y') and color difference (Cb and Cr) are obtained with the
following <code class="constant">V4L2_YCBCR_ENC_601</code> encoding:</span></dt><dd><p>Y' = 0.299R' + 0.587G' + 0.114B'</p><p>Cb = -0.169R' - 0.331G' + 0.5B'</p><p>Cr = 0.5R' - 0.419G' - 0.081B'</p></dd></dl></div><p>Y' is clamped to the range [0&#8230;1] and Cb and Cr are
clamped to the range [-0.5&#8230;0.5]. The Y'CbCr quantization is limited range.
This transform is identical to one defined in SMPTE 170M/BT.601.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp54459200"></a>Colorspace EBU Tech. 3213 (<code class="constant">V4L2_COLORSPACE_470_SYSTEM_BG</code>)</h3></div></div></div><p>The <a class="xref" href="media.html#tech3213" title='E.B.U. Standard for Chromaticity Tolerances for Studio Monitors"'>[<abbr class="abbrev">EBU Tech 3213</abbr>]</a> standard defines the colorspace used by PAL/SECAM in 1975. In practice this
colorspace is obsolete and SMPTE 170M should be used instead. The default Y'CbCr encoding
is <code class="constant">V4L2_YCBCR_ENC_601</code>. The default Y'CbCr quantization is limited range.
The chromaticities of the primary colors and the white reference are:</p><div class="table"><a name="idp54462624"></a><p class="title"><b>Table 2.14. EBU Tech. 3213 Chromaticities</b></p><div class="table-contents"><table summary="EBU Tech. 3213 Chromaticities" border="0"><colgroup><col align="left" class="c1"><col align="left" class="c2"><col align="left" class="c3"></colgroup><thead><tr><th align="left">Color</th><th align="left">x</th><th align="left">y</th></tr></thead><tbody valign="top"><tr><td align="left" valign="top">Red</td><td align="left" valign="top">0.64</td><td align="left" valign="top">0.33</td></tr><tr><td align="left" valign="top">Green</td><td align="left" valign="top">0.29</td><td align="left" valign="top">0.60</td></tr><tr><td align="left" valign="top">Blue</td><td align="left" valign="top">0.15</td><td align="left" valign="top">0.06</td></tr><tr><td align="left" valign="top">White Reference (D65)</td><td align="left" valign="top">0.3127</td><td align="left" valign="top">0.3290</td></tr></tbody></table></div></div><br class="table-break"><div class="variablelist"><dl class="variablelist"><dt><span class="term">The transfer function was never properly defined for this colorspace.
The Rec. 709 transfer function is recommended in the literature:</span></dt><dd><p>L' = 4.5L for 0 &#8804; L &lt; 0.018</p><p>L' = 1.099L<sup>0.45</sup> - 0.099 for 0.018 &#8804; L &#8804; 1</p></dd><dt><span class="term">Inverse Transfer function:</span></dt><dd><p>L = L' / 4.5 for L' &lt; 0.081</p><p>L = ((L' + 0.099) / 1.099)<sup>1/0.45</sup> for L' &#8805; 0.081</p></dd></dl></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">The luminance (Y') and color difference (Cb and Cr) are obtained with the
following <code class="constant">V4L2_YCBCR_ENC_601</code> encoding:</span></dt><dd><p>Y' = 0.299R' + 0.587G' + 0.114B'</p><p>Cb = -0.169R' - 0.331G' + 0.5B'</p><p>Cr = 0.5R' - 0.419G' - 0.081B'</p></dd></dl></div><p>Y' is clamped to the range [0&#8230;1] and Cb and Cr are
clamped to the range [-0.5&#8230;0.5]. The Y'CbCr quantization is limited range.
This transform is identical to one defined in SMPTE 170M/BT.601.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp54486512"></a>Colorspace JPEG (<code class="constant">V4L2_COLORSPACE_JPEG</code>)</h3></div></div></div><p>This colorspace defines the colorspace used by most (Motion-)JPEG formats. The chromaticities
of the primary colors and the white reference are identical to sRGB. The Y'CbCr encoding is
<code class="constant">V4L2_YCBCR_ENC_601</code> with full range quantization where
Y' is scaled to [0&#8230;255] and Cb/Cr are scaled to [-128&#8230;128] and
then clipped to [-128&#8230;127].</p><p>Note that the JPEG standard does not actually store colorspace information.
So if something other than sRGB is used, then the driver will have to set that information
explicitly. Effectively <code class="constant">V4L2_COLORSPACE_JPEG</code> can be considered to be
an abbreviation for <code class="constant">V4L2_COLORSPACE_SRGB</code>, <code class="constant">V4L2_YCBCR_ENC_601</code>
and <code class="constant">V4L2_QUANTIZATION_FULL_RANGE</code>.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="pixfmt-indexed"></a>Indexed Format</h2></div></div></div><p>In this format each pixel is represented by an 8 bit index
into a 256 entry ARGB palette. It is intended for <a class="link" href="media.html#osd" title="Video Output Overlay Interface">Video Output Overlays</a> only. There are no ioctls to
access the palette, this must be done with ioctls of the Linux framebuffer API.</p><div class="table"><a name="idp54494304"></a><p class="title"><b>Table 2.15. Indexed Image Format</b></p><div class="table-contents"><table summary="Indexed Image Format" border="0"><colgroup><col align="left" class="id"><col align="center" class="fourcc"><col align="center" class="bit"><col align="center" class="b07"><col align="center" class="b06"><col align="center" class="b05"><col align="center" class="b04"><col align="center" class="b03"><col align="center" class="b02"><col align="center" class="b01"><col align="center" class="b00"><col><col><col><col><col><col><col><col><col><col><col><col><col><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th align="left">Identifier</th><th align="center">Code</th><th align="center"> </th><th colspan="8" align="center">Byte 0</th><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><th align="left"> </th><th align="center"> </th><th align="center">Bit</th><th align="center">7</th><th align="center">6</th><th align="center">5</th><th align="center">4</th><th align="center">3</th><th align="center">2</th><th align="center">1</th><th align="center">0</th><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr></thead><tbody valign="top"><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-PAL8"></a><code class="constant">V4L2_PIX_FMT_PAL8</code></td><td align="center" valign="top">'PAL8'</td><td align="center" valign="top"> </td><td align="center" valign="top">i<sub>7</sub></td><td align="center" valign="top">i<sub>6</sub></td><td align="center" valign="top">i<sub>5</sub></td><td align="center" valign="top">i<sub>4</sub></td><td align="center" valign="top">i<sub>3</sub></td><td align="center" valign="top">i<sub>2</sub></td><td align="center" valign="top">i<sub>1</sub></td><td align="center" valign="top">i<sub>0</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="pixfmt-rgb"></a>RGB Formats</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="refentrytitle"><a href="media.html#packed-rgb">Packed RGB formats</a></span><span class="refpurpose"> &#8212; Packed RGB formats</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-SBGGR8">V4L2_PIX_FMT_SBGGR8 ('BA81')</a></span><span class="refpurpose"> &#8212; Bayer RGB format</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-SGBRG8">V4L2_PIX_FMT_SGBRG8 ('GBRG')</a></span><span class="refpurpose"> &#8212; Bayer RGB format</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-SGRBG8">V4L2_PIX_FMT_SGRBG8 ('GRBG')</a></span><span class="refpurpose"> &#8212; Bayer RGB format</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-SRGGB8">V4L2_PIX_FMT_SRGGB8 ('RGGB')</a></span><span class="refpurpose"> &#8212; Bayer RGB format</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-SBGGR16">V4L2_PIX_FMT_SBGGR16 ('BYR2')</a></span><span class="refpurpose"> &#8212; Bayer RGB format</span></dt><dt><span class="refentrytitle"><a href="media.html#pixfmt-srggb10">V4L2_PIX_FMT_SRGGB10 ('RG10'),
	 V4L2_PIX_FMT_SGRBG10 ('BA10'),
	 V4L2_PIX_FMT_SGBRG10 ('GB10'),
	 V4L2_PIX_FMT_SBGGR10 ('BG10'),
	 </a></span><span class="refpurpose"> &#8212; 10-bit Bayer formats expanded to 16 bits</span></dt><dt><span class="refentrytitle"><a href="media.html#idp56012848">
	      V4L2_PIX_FMT_SBGGR10ALAW8 ('aBA8'),
	      V4L2_PIX_FMT_SGBRG10ALAW8 ('aGA8'),
	      V4L2_PIX_FMT_SGRBG10ALAW8 ('agA8'),
	      V4L2_PIX_FMT_SRGGB10ALAW8 ('aRA8'),
	    </a></span><span class="refpurpose"> &#8212; 10-bit Bayer formats compressed to 8 bits</span></dt><dt><span class="refentrytitle"><a href="media.html#pixfmt-srggb10dpcm8">
	 V4L2_PIX_FMT_SBGGR10DPCM8 ('bBA8'),
	 V4L2_PIX_FMT_SGBRG10DPCM8 ('bGA8'),
	 V4L2_PIX_FMT_SGRBG10DPCM8 ('BD10'),
	 V4L2_PIX_FMT_SRGGB10DPCM8 ('bRA8'),
	 </a></span><span class="refpurpose"> &#8212; 10-bit Bayer formats compressed to 8 bits</span></dt><dt><span class="refentrytitle"><a href="media.html#idp56032208">V4L2_PIX_FMT_SRGGB12 ('RG12'),
	 V4L2_PIX_FMT_SGRBG12 ('BA12'),
	 V4L2_PIX_FMT_SGBRG12 ('GB12'),
	 V4L2_PIX_FMT_SBGGR12 ('BG12'),
	 </a></span><span class="refpurpose"> &#8212; 12-bit Bayer formats expanded to 16 bits</span></dt></dl></div><div class="refentry"><a name="packed-rgb"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>Packed RGB formats &#8212; Packed RGB formats</p></div><div class="refsect1"><a name="idp54532000"></a><h2>Description</h2><p>These formats are designed to match the pixel formats of
typical PC graphics frame buffers. They occupy 8, 16, 24 or 32 bits
per pixel. These are all packed-pixel formats, meaning all the data
for a pixel lie next to each other in memory.</p><div class="table"><a name="rgb-formats"></a><p class="title"><b>Table 2.16. Packed RGB Image Formats</b></p><div class="table-contents"><table summary="Packed RGB Image Formats" width="100%" border="0"><colgroup><col align="left" class="id"><col align="center" class="fourcc"><col align="center" class="bit"><col align="center" class="b07"><col align="center" class="b06"><col align="center" class="b05"><col align="center" class="b04"><col align="center" class="b03"><col align="center" class="b02"><col align="center" class="b01"><col align="center" class="b00"><col><col align="center" class="b17"><col align="center" class="b16"><col align="center" class="b15"><col align="center" class="b14"><col align="center" class="b13"><col align="center" class="b12"><col align="center" class="b11"><col align="center" class="b10"><col><col align="center" class="b27"><col align="center" class="b26"><col align="center" class="b25"><col align="center" class="b24"><col align="center" class="b23"><col align="center" class="b22"><col align="center" class="b21"><col align="center" class="b20"><col><col align="center" class="b37"><col align="center" class="b36"><col align="center" class="b35"><col align="center" class="b34"><col align="center" class="b33"><col align="center" class="b32"><col align="center" class="b31"></colgroup><thead><tr><th align="left">Identifier</th><th align="center">Code</th><th align="center"> </th><th colspan="8" align="center">Byte 0 in memory</th><td class="auto-generated"> </td><th colspan="8" align="center">Byte 1</th><td class="auto-generated"> </td><th colspan="8" align="center">Byte 2</th><td class="auto-generated"> </td><th colspan="8" align="center">Byte 3</th></tr><tr><th align="left"> </th><th align="center"> </th><th align="center">Bit</th><th align="center">7</th><th align="center">6</th><th align="center">5</th><th align="center">4</th><th align="center">3</th><th align="center">2</th><th align="center">1</th><th align="center">0</th><th align="center"> </th><th align="center">7</th><th align="center">6</th><th align="center">5</th><th align="center">4</th><th align="center">3</th><th align="center">2</th><th align="center">1</th><th align="center">0</th><th align="center"> </th><th align="center">7</th><th align="center">6</th><th align="center">5</th><th align="center">4</th><th align="center">3</th><th align="center">2</th><th align="center">1</th><th align="center">0</th><th align="center"> </th><th align="center">7</th><th align="center">6</th><th align="center">5</th><th align="center">4</th><th align="center">3</th><th align="center">2</th><th align="center">1</th><th align="center">0</th></tr></thead><tbody valign="top"><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-RGB332"></a><code class="constant">V4L2_PIX_FMT_RGB332</code></td><td align="center" valign="top">'RGB1'</td><td align="center" valign="top"> </td><td align="center" valign="top">r<sub>2</sub></td><td align="center" valign="top">r<sub>1</sub></td><td align="center" valign="top">r<sub>0</sub></td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-ARGB444"></a><code class="constant">V4L2_PIX_FMT_ARGB444</code></td><td align="center" valign="top">'AR12'</td><td align="center" valign="top"> </td><td align="center" valign="top">g<sub>3</sub></td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td><td align="center" valign="top"> </td><td align="center" valign="top">a<sub>3</sub></td><td align="center" valign="top">a<sub>2</sub></td><td align="center" valign="top">a<sub>1</sub></td><td align="center" valign="top">a<sub>0</sub></td><td align="center" valign="top">r<sub>3</sub></td><td align="center" valign="top">r<sub>2</sub></td><td align="center" valign="top">r<sub>1</sub></td><td align="center" valign="top">r<sub>0</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-XRGB444"></a><code class="constant">V4L2_PIX_FMT_XRGB444</code></td><td align="center" valign="top">'XR12'</td><td align="center" valign="top"> </td><td align="center" valign="top">g<sub>3</sub></td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td><td align="center" valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">r<sub>3</sub></td><td align="center" valign="top">r<sub>2</sub></td><td align="center" valign="top">r<sub>1</sub></td><td align="center" valign="top">r<sub>0</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-ARGB555"></a><code class="constant">V4L2_PIX_FMT_ARGB555</code></td><td align="center" valign="top">'AR15'</td><td align="center" valign="top"> </td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td><td align="center" valign="top">b<sub>4</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td><td align="center" valign="top"> </td><td align="center" valign="top">a</td><td align="center" valign="top">r<sub>4</sub></td><td align="center" valign="top">r<sub>3</sub></td><td align="center" valign="top">r<sub>2</sub></td><td align="center" valign="top">r<sub>1</sub></td><td align="center" valign="top">r<sub>0</sub></td><td align="center" valign="top">g<sub>4</sub></td><td align="center" valign="top">g<sub>3</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-XRGB555"></a><code class="constant">V4L2_PIX_FMT_XRGB555</code></td><td align="center" valign="top">'XR15'</td><td align="center" valign="top"> </td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td><td align="center" valign="top">b<sub>4</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td><td align="center" valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">r<sub>4</sub></td><td align="center" valign="top">r<sub>3</sub></td><td align="center" valign="top">r<sub>2</sub></td><td align="center" valign="top">r<sub>1</sub></td><td align="center" valign="top">r<sub>0</sub></td><td align="center" valign="top">g<sub>4</sub></td><td align="center" valign="top">g<sub>3</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-RGB565"></a><code class="constant">V4L2_PIX_FMT_RGB565</code></td><td align="center" valign="top">'RGBP'</td><td align="center" valign="top"> </td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td><td align="center" valign="top">b<sub>4</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td><td align="center" valign="top"> </td><td align="center" valign="top">r<sub>4</sub></td><td align="center" valign="top">r<sub>3</sub></td><td align="center" valign="top">r<sub>2</sub></td><td align="center" valign="top">r<sub>1</sub></td><td align="center" valign="top">r<sub>0</sub></td><td align="center" valign="top">g<sub>5</sub></td><td align="center" valign="top">g<sub>4</sub></td><td align="center" valign="top">g<sub>3</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-ARGB555X"></a><code class="constant">V4L2_PIX_FMT_ARGB555X</code></td><td align="center" valign="top">'AR15' | (1 &lt;&lt; 31)</td><td align="center" valign="top"> </td><td align="center" valign="top">a</td><td align="center" valign="top">r<sub>4</sub></td><td align="center" valign="top">r<sub>3</sub></td><td align="center" valign="top">r<sub>2</sub></td><td align="center" valign="top">r<sub>1</sub></td><td align="center" valign="top">r<sub>0</sub></td><td align="center" valign="top">g<sub>4</sub></td><td align="center" valign="top">g<sub>3</sub></td><td align="center" valign="top"> </td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td><td align="center" valign="top">b<sub>4</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-XRGB555X"></a><code class="constant">V4L2_PIX_FMT_XRGB555X</code></td><td align="center" valign="top">'XR15' | (1 &lt;&lt; 31)</td><td align="center" valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">r<sub>4</sub></td><td align="center" valign="top">r<sub>3</sub></td><td align="center" valign="top">r<sub>2</sub></td><td align="center" valign="top">r<sub>1</sub></td><td align="center" valign="top">r<sub>0</sub></td><td align="center" valign="top">g<sub>4</sub></td><td align="center" valign="top">g<sub>3</sub></td><td align="center" valign="top"> </td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td><td align="center" valign="top">b<sub>4</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-RGB565X"></a><code class="constant">V4L2_PIX_FMT_RGB565X</code></td><td align="center" valign="top">'RGBR'</td><td align="center" valign="top"> </td><td align="center" valign="top">r<sub>4</sub></td><td align="center" valign="top">r<sub>3</sub></td><td align="center" valign="top">r<sub>2</sub></td><td align="center" valign="top">r<sub>1</sub></td><td align="center" valign="top">r<sub>0</sub></td><td align="center" valign="top">g<sub>5</sub></td><td align="center" valign="top">g<sub>4</sub></td><td align="center" valign="top">g<sub>3</sub></td><td align="center" valign="top"> </td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td><td align="center" valign="top">b<sub>4</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-BGR666"></a><code class="constant">V4L2_PIX_FMT_BGR666</code></td><td align="center" valign="top">'BGRH'</td><td align="center" valign="top"> </td><td align="center" valign="top">b<sub>5</sub></td><td align="center" valign="top">b<sub>4</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td><td align="center" valign="top">g<sub>5</sub></td><td align="center" valign="top">g<sub>4</sub></td><td align="center" valign="top"> </td><td align="center" valign="top">g<sub>3</sub></td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td><td align="center" valign="top">r<sub>5</sub></td><td align="center" valign="top">r<sub>4</sub></td><td align="center" valign="top">r<sub>3</sub></td><td align="center" valign="top">r<sub>2</sub></td><td align="center" valign="top"> </td><td align="center" valign="top">r<sub>1</sub></td><td align="center" valign="top">r<sub>0</sub></td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-BGR24"></a><code class="constant">V4L2_PIX_FMT_BGR24</code></td><td align="center" valign="top">'BGR3'</td><td align="center" valign="top"> </td><td align="center" valign="top">b<sub>7</sub></td><td align="center" valign="top">b<sub>6</sub></td><td align="center" valign="top">b<sub>5</sub></td><td align="center" valign="top">b<sub>4</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td><td align="center" valign="top"> </td><td align="center" valign="top">g<sub>7</sub></td><td align="center" valign="top">g<sub>6</sub></td><td align="center" valign="top">g<sub>5</sub></td><td align="center" valign="top">g<sub>4</sub></td><td align="center" valign="top">g<sub>3</sub></td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td><td align="center" valign="top"> </td><td align="center" valign="top">r<sub>7</sub></td><td align="center" valign="top">r<sub>6</sub></td><td align="center" valign="top">r<sub>5</sub></td><td align="center" valign="top">r<sub>4</sub></td><td align="center" valign="top">r<sub>3</sub></td><td align="center" valign="top">r<sub>2</sub></td><td align="center" valign="top">r<sub>1</sub></td><td align="center" valign="top">r<sub>0</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-RGB24"></a><code class="constant">V4L2_PIX_FMT_RGB24</code></td><td align="center" valign="top">'RGB3'</td><td align="center" valign="top"> </td><td align="center" valign="top">r<sub>7</sub></td><td align="center" valign="top">r<sub>6</sub></td><td align="center" valign="top">r<sub>5</sub></td><td align="center" valign="top">r<sub>4</sub></td><td align="center" valign="top">r<sub>3</sub></td><td align="center" valign="top">r<sub>2</sub></td><td align="center" valign="top">r<sub>1</sub></td><td align="center" valign="top">r<sub>0</sub></td><td align="center" valign="top"> </td><td align="center" valign="top">g<sub>7</sub></td><td align="center" valign="top">g<sub>6</sub></td><td align="center" valign="top">g<sub>5</sub></td><td align="center" valign="top">g<sub>4</sub></td><td align="center" valign="top">g<sub>3</sub></td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td><td align="center" valign="top"> </td><td align="center" valign="top">b<sub>7</sub></td><td align="center" valign="top">b<sub>6</sub></td><td align="center" valign="top">b<sub>5</sub></td><td align="center" valign="top">b<sub>4</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-ABGR32"></a><code class="constant">V4L2_PIX_FMT_ABGR32</code></td><td align="center" valign="top">'AR24'</td><td align="center" valign="top"> </td><td align="center" valign="top">b<sub>7</sub></td><td align="center" valign="top">b<sub>6</sub></td><td align="center" valign="top">b<sub>5</sub></td><td align="center" valign="top">b<sub>4</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td><td align="center" valign="top"> </td><td align="center" valign="top">g<sub>7</sub></td><td align="center" valign="top">g<sub>6</sub></td><td align="center" valign="top">g<sub>5</sub></td><td align="center" valign="top">g<sub>4</sub></td><td align="center" valign="top">g<sub>3</sub></td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td><td align="center" valign="top"> </td><td align="center" valign="top">r<sub>7</sub></td><td align="center" valign="top">r<sub>6</sub></td><td align="center" valign="top">r<sub>5</sub></td><td align="center" valign="top">r<sub>4</sub></td><td align="center" valign="top">r<sub>3</sub></td><td align="center" valign="top">r<sub>2</sub></td><td align="center" valign="top">r<sub>1</sub></td><td align="center" valign="top">r<sub>0</sub></td><td align="center" valign="top"> </td><td align="center" valign="top">a<sub>7</sub></td><td align="center" valign="top">a<sub>6</sub></td><td align="center" valign="top">a<sub>5</sub></td><td align="center" valign="top">a<sub>4</sub></td><td align="center" valign="top">a<sub>3</sub></td><td align="center" valign="top">a<sub>2</sub></td><td align="center" valign="top">a<sub>1</sub></td><td align="center" valign="top">a<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-XBGR32"></a><code class="constant">V4L2_PIX_FMT_XBGR32</code></td><td align="center" valign="top">'XR24'</td><td align="center" valign="top"> </td><td align="center" valign="top">b<sub>7</sub></td><td align="center" valign="top">b<sub>6</sub></td><td align="center" valign="top">b<sub>5</sub></td><td align="center" valign="top">b<sub>4</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td><td align="center" valign="top"> </td><td align="center" valign="top">g<sub>7</sub></td><td align="center" valign="top">g<sub>6</sub></td><td align="center" valign="top">g<sub>5</sub></td><td align="center" valign="top">g<sub>4</sub></td><td align="center" valign="top">g<sub>3</sub></td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td><td align="center" valign="top"> </td><td align="center" valign="top">r<sub>7</sub></td><td align="center" valign="top">r<sub>6</sub></td><td align="center" valign="top">r<sub>5</sub></td><td align="center" valign="top">r<sub>4</sub></td><td align="center" valign="top">r<sub>3</sub></td><td align="center" valign="top">r<sub>2</sub></td><td align="center" valign="top">r<sub>1</sub></td><td align="center" valign="top">r<sub>0</sub></td><td align="center" valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-ARGB32"></a><code class="constant">V4L2_PIX_FMT_ARGB32</code></td><td align="center" valign="top">'BA24'</td><td align="center" valign="top"> </td><td align="center" valign="top">a<sub>7</sub></td><td align="center" valign="top">a<sub>6</sub></td><td align="center" valign="top">a<sub>5</sub></td><td align="center" valign="top">a<sub>4</sub></td><td align="center" valign="top">a<sub>3</sub></td><td align="center" valign="top">a<sub>2</sub></td><td align="center" valign="top">a<sub>1</sub></td><td align="center" valign="top">a<sub>0</sub></td><td align="center" valign="top"> </td><td align="center" valign="top">r<sub>7</sub></td><td align="center" valign="top">r<sub>6</sub></td><td align="center" valign="top">r<sub>5</sub></td><td align="center" valign="top">r<sub>4</sub></td><td align="center" valign="top">r<sub>3</sub></td><td align="center" valign="top">r<sub>2</sub></td><td align="center" valign="top">r<sub>1</sub></td><td align="center" valign="top">r<sub>0</sub></td><td align="center" valign="top"> </td><td align="center" valign="top">g<sub>7</sub></td><td align="center" valign="top">g<sub>6</sub></td><td align="center" valign="top">g<sub>5</sub></td><td align="center" valign="top">g<sub>4</sub></td><td align="center" valign="top">g<sub>3</sub></td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td><td align="center" valign="top"> </td><td align="center" valign="top">b<sub>7</sub></td><td align="center" valign="top">b<sub>6</sub></td><td align="center" valign="top">b<sub>5</sub></td><td align="center" valign="top">b<sub>4</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-XRGB32"></a><code class="constant">V4L2_PIX_FMT_XRGB32</code></td><td align="center" valign="top">'BX24'</td><td align="center" valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top"> </td><td align="center" valign="top">r<sub>7</sub></td><td align="center" valign="top">r<sub>6</sub></td><td align="center" valign="top">r<sub>5</sub></td><td align="center" valign="top">r<sub>4</sub></td><td align="center" valign="top">r<sub>3</sub></td><td align="center" valign="top">r<sub>2</sub></td><td align="center" valign="top">r<sub>1</sub></td><td align="center" valign="top">r<sub>0</sub></td><td align="center" valign="top"> </td><td align="center" valign="top">g<sub>7</sub></td><td align="center" valign="top">g<sub>6</sub></td><td align="center" valign="top">g<sub>5</sub></td><td align="center" valign="top">g<sub>4</sub></td><td align="center" valign="top">g<sub>3</sub></td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td><td align="center" valign="top"> </td><td align="center" valign="top">b<sub>7</sub></td><td align="center" valign="top">b<sub>6</sub></td><td align="center" valign="top">b<sub>5</sub></td><td align="center" valign="top">b<sub>4</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td></tr></tbody></table></div></div><br class="table-break"><p>Bit 7 is the most significant bit.</p><p>The usage and value of the alpha bits (a) in the ARGB and ABGR formats
    (collectively referred to as alpha formats) depend on the device type and
    hardware operation. <a class="link" href="media.html#capture" title="Video Capture Interface">Capture</a> devices
    (including capture queues of mem-to-mem devices) fill the alpha component in
    memory. When the device outputs an alpha channel the alpha component will
    have a meaningful value. Otherwise, when the device doesn't output an alpha
    channel but can set the alpha bit to a user-configurable value, the <a class="link" href="media.html#v4l2-alpha-component"><code class="constant">V4L2_CID_ALPHA_COMPONENT</code>
    </a> control is used to specify that alpha value, and the alpha component
    of all pixels will be set to the value specified by that control. Otherwise
    a corresponding format without an alpha component (XRGB or XBGR) must be
    used instead of an alpha format.</p><p><a class="link" href="media.html#output" title="Video Output Interface">Output</a> devices (including output queues
    of mem-to-mem devices and <a class="link" href="media.html#osd" title="Video Output Overlay Interface">video output overlay</a>
    devices) read the alpha component from memory. When the device processes the
    alpha channel the alpha component must be filled with meaningful values by
    applications. Otherwise a corresponding format without an alpha component
    (XRGB or XBGR) must be used instead of an alpha format.</p><p>The XRGB and XBGR formats contain undefined bits (-). Applications,
    devices and drivers must ignore those bits, for both <a class="link" href="media.html#capture" title="Video Capture Interface">capture</a> and <a class="link" href="media.html#output" title="Video Output Interface">output</a>
    devices.</p><div class="example"><a name="idp54894256"></a><p class="title"><b>Example 2.1. <code class="constant">V4L2_PIX_FMT_BGR24</code> 4 × 4 pixel
image</b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte.
	      </p><div class="informaltable"><table border="0"><colgroup><col align="left"><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start + 0:</td><td align="center" valign="top">B<sub>00</sub></td><td align="center" valign="top">G<sub>00</sub></td><td align="center" valign="top">R<sub>00</sub></td><td align="center" valign="top">B<sub>01</sub></td><td align="center" valign="top">G<sub>01</sub></td><td align="center" valign="top">R<sub>01</sub></td><td align="center" valign="top">B<sub>02</sub></td><td align="center" valign="top">G<sub>02</sub></td><td align="center" valign="top">R<sub>02</sub></td><td align="center" valign="top">B<sub>03</sub></td><td align="center" valign="top">G<sub>03</sub></td><td align="center" valign="top">R<sub>03</sub></td></tr><tr><td align="left" valign="top">start + 12:</td><td align="center" valign="top">B<sub>10</sub></td><td align="center" valign="top">G<sub>10</sub></td><td align="center" valign="top">R<sub>10</sub></td><td align="center" valign="top">B<sub>11</sub></td><td align="center" valign="top">G<sub>11</sub></td><td align="center" valign="top">R<sub>11</sub></td><td align="center" valign="top">B<sub>12</sub></td><td align="center" valign="top">G<sub>12</sub></td><td align="center" valign="top">R<sub>12</sub></td><td align="center" valign="top">B<sub>13</sub></td><td align="center" valign="top">G<sub>13</sub></td><td align="center" valign="top">R<sub>13</sub></td></tr><tr><td align="left" valign="top">start + 24:</td><td align="center" valign="top">B<sub>20</sub></td><td align="center" valign="top">G<sub>20</sub></td><td align="center" valign="top">R<sub>20</sub></td><td align="center" valign="top">B<sub>21</sub></td><td align="center" valign="top">G<sub>21</sub></td><td align="center" valign="top">R<sub>21</sub></td><td align="center" valign="top">B<sub>22</sub></td><td align="center" valign="top">G<sub>22</sub></td><td align="center" valign="top">R<sub>22</sub></td><td align="center" valign="top">B<sub>23</sub></td><td align="center" valign="top">G<sub>23</sub></td><td align="center" valign="top">R<sub>23</sub></td></tr><tr><td align="left" valign="top">start + 36:</td><td align="center" valign="top">B<sub>30</sub></td><td align="center" valign="top">G<sub>30</sub></td><td align="center" valign="top">R<sub>30</sub></td><td align="center" valign="top">B<sub>31</sub></td><td align="center" valign="top">G<sub>31</sub></td><td align="center" valign="top">R<sub>31</sub></td><td align="center" valign="top">B<sub>32</sub></td><td align="center" valign="top">G<sub>32</sub></td><td align="center" valign="top">R<sub>32</sub></td><td align="center" valign="top">B<sub>33</sub></td><td align="center" valign="top">G<sub>33</sub></td><td align="center" valign="top">R<sub>33</sub></td></tr></tbody></table></div><p>
	    </p></div></div><br class="example-break"><p>Formats defined in <a class="xref" href="media.html#rgb-formats-deprecated" title="Table 2.17. Deprecated Packed RGB Image Formats">Table 2.17, &#8220;Deprecated Packed RGB Image Formats&#8221;</a> are
    deprecated and must not be used by new drivers. They are documented here for
    reference. The meaning of their alpha bits (a) is ill-defined and
    interpreted as in either the corresponding ARGB or XRGB format, depending on
    the driver.</p><div class="table"><a name="rgb-formats-deprecated"></a><p class="title"><b>Table 2.17. Deprecated Packed RGB Image Formats</b></p><div class="table-contents"><table summary="Deprecated Packed RGB Image Formats" width="100%" border="0"><colgroup><col align="left" class="id"><col align="center" class="fourcc"><col align="center" class="bit"><col align="center" class="b07"><col align="center" class="b06"><col align="center" class="b05"><col align="center" class="b04"><col align="center" class="b03"><col align="center" class="b02"><col align="center" class="b01"><col align="center" class="b00"><col><col align="center" class="b17"><col align="center" class="b16"><col align="center" class="b15"><col align="center" class="b14"><col align="center" class="b13"><col align="center" class="b12"><col align="center" class="b11"><col align="center" class="b10"><col><col align="center" class="b27"><col align="center" class="b26"><col align="center" class="b25"><col align="center" class="b24"><col align="center" class="b23"><col align="center" class="b22"><col align="center" class="b21"><col align="center" class="b20"><col><col align="center" class="b37"><col align="center" class="b36"><col align="center" class="b35"><col align="center" class="b34"><col align="center" class="b33"><col align="center" class="b32"><col align="center" class="b31"></colgroup><thead><tr><th align="left">Identifier</th><th align="center">Code</th><th align="center"> </th><th colspan="8" align="center">Byte 0 in memory</th><td class="auto-generated"> </td><th colspan="8" align="center">Byte 1</th><td class="auto-generated"> </td><th colspan="8" align="center">Byte 2</th><td class="auto-generated"> </td><th colspan="8" align="center">Byte 3</th></tr><tr><th align="left"> </th><th align="center"> </th><th align="center">Bit</th><th align="center">7</th><th align="center">6</th><th align="center">5</th><th align="center">4</th><th align="center">3</th><th align="center">2</th><th align="center">1</th><th align="center">0</th><th align="center"> </th><th align="center">7</th><th align="center">6</th><th align="center">5</th><th align="center">4</th><th align="center">3</th><th align="center">2</th><th align="center">1</th><th align="center">0</th><th align="center"> </th><th align="center">7</th><th align="center">6</th><th align="center">5</th><th align="center">4</th><th align="center">3</th><th align="center">2</th><th align="center">1</th><th align="center">0</th><th align="center"> </th><th align="center">7</th><th align="center">6</th><th align="center">5</th><th align="center">4</th><th align="center">3</th><th align="center">2</th><th align="center">1</th><th align="center">0</th></tr></thead><tbody><tr><td align="left"><a name="V4L2-PIX-FMT-RGB444"></a><code class="constant">V4L2_PIX_FMT_RGB444</code></td><td align="center">'R444'</td><td align="center"> </td><td align="center">g<sub>3</sub></td><td align="center">g<sub>2</sub></td><td align="center">g<sub>1</sub></td><td align="center">g<sub>0</sub></td><td align="center">b<sub>3</sub></td><td align="center">b<sub>2</sub></td><td align="center">b<sub>1</sub></td><td align="center">b<sub>0</sub></td><td align="center"> </td><td align="center">a<sub>3</sub></td><td align="center">a<sub>2</sub></td><td align="center">a<sub>1</sub></td><td align="center">a<sub>0</sub></td><td align="center">r<sub>3</sub></td><td align="center">r<sub>2</sub></td><td align="center">r<sub>1</sub></td><td align="center">r<sub>0</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left"><a name="V4L2-PIX-FMT-RGB555"></a><code class="constant">V4L2_PIX_FMT_RGB555</code></td><td align="center">'RGBO'</td><td align="center"> </td><td align="center">g<sub>2</sub></td><td align="center">g<sub>1</sub></td><td align="center">g<sub>0</sub></td><td align="center">b<sub>4</sub></td><td align="center">b<sub>3</sub></td><td align="center">b<sub>2</sub></td><td align="center">b<sub>1</sub></td><td align="center">b<sub>0</sub></td><td align="center"> </td><td align="center">a</td><td align="center">r<sub>4</sub></td><td align="center">r<sub>3</sub></td><td align="center">r<sub>2</sub></td><td align="center">r<sub>1</sub></td><td align="center">r<sub>0</sub></td><td align="center">g<sub>4</sub></td><td align="center">g<sub>3</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left"><a name="V4L2-PIX-FMT-RGB555X"></a><code class="constant">V4L2_PIX_FMT_RGB555X</code></td><td align="center">'RGBQ'</td><td align="center"> </td><td align="center">a</td><td align="center">r<sub>4</sub></td><td align="center">r<sub>3</sub></td><td align="center">r<sub>2</sub></td><td align="center">r<sub>1</sub></td><td align="center">r<sub>0</sub></td><td align="center">g<sub>4</sub></td><td align="center">g<sub>3</sub></td><td align="center"> </td><td align="center">g<sub>2</sub></td><td align="center">g<sub>1</sub></td><td align="center">g<sub>0</sub></td><td align="center">b<sub>4</sub></td><td align="center">b<sub>3</sub></td><td align="center">b<sub>2</sub></td><td align="center">b<sub>1</sub></td><td align="center">b<sub>0</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left"><a name="V4L2-PIX-FMT-BGR32"></a><code class="constant">V4L2_PIX_FMT_BGR32</code></td><td align="center">'BGR4'</td><td align="center"> </td><td align="center">b<sub>7</sub></td><td align="center">b<sub>6</sub></td><td align="center">b<sub>5</sub></td><td align="center">b<sub>4</sub></td><td align="center">b<sub>3</sub></td><td align="center">b<sub>2</sub></td><td align="center">b<sub>1</sub></td><td align="center">b<sub>0</sub></td><td align="center"> </td><td align="center">g<sub>7</sub></td><td align="center">g<sub>6</sub></td><td align="center">g<sub>5</sub></td><td align="center">g<sub>4</sub></td><td align="center">g<sub>3</sub></td><td align="center">g<sub>2</sub></td><td align="center">g<sub>1</sub></td><td align="center">g<sub>0</sub></td><td align="center"> </td><td align="center">r<sub>7</sub></td><td align="center">r<sub>6</sub></td><td align="center">r<sub>5</sub></td><td align="center">r<sub>4</sub></td><td align="center">r<sub>3</sub></td><td align="center">r<sub>2</sub></td><td align="center">r<sub>1</sub></td><td align="center">r<sub>0</sub></td><td align="center"> </td><td align="center">a<sub>7</sub></td><td align="center">a<sub>6</sub></td><td align="center">a<sub>5</sub></td><td align="center">a<sub>4</sub></td><td align="center">a<sub>3</sub></td><td align="center">a<sub>2</sub></td><td align="center">a<sub>1</sub></td><td align="center">a<sub>0</sub></td></tr><tr><td align="left"><a name="V4L2-PIX-FMT-RGB32"></a><code class="constant">V4L2_PIX_FMT_RGB32</code></td><td align="center">'RGB4'</td><td align="center"> </td><td align="center">a<sub>7</sub></td><td align="center">a<sub>6</sub></td><td align="center">a<sub>5</sub></td><td align="center">a<sub>4</sub></td><td align="center">a<sub>3</sub></td><td align="center">a<sub>2</sub></td><td align="center">a<sub>1</sub></td><td align="center">a<sub>0</sub></td><td align="center"> </td><td align="center">r<sub>7</sub></td><td align="center">r<sub>6</sub></td><td align="center">r<sub>5</sub></td><td align="center">r<sub>4</sub></td><td align="center">r<sub>3</sub></td><td align="center">r<sub>2</sub></td><td align="center">r<sub>1</sub></td><td align="center">r<sub>0</sub></td><td align="center"> </td><td align="center">g<sub>7</sub></td><td align="center">g<sub>6</sub></td><td align="center">g<sub>5</sub></td><td align="center">g<sub>4</sub></td><td align="center">g<sub>3</sub></td><td align="center">g<sub>2</sub></td><td align="center">g<sub>1</sub></td><td align="center">g<sub>0</sub></td><td align="center"> </td><td align="center">b<sub>7</sub></td><td align="center">b<sub>6</sub></td><td align="center">b<sub>5</sub></td><td align="center">b<sub>4</sub></td><td align="center">b<sub>3</sub></td><td align="center">b<sub>2</sub></td><td align="center">b<sub>1</sub></td><td align="center">b<sub>0</sub></td></tr></tbody></table></div></div><br class="table-break"><p>A test utility to determine which RGB formats a driver
actually supports is available from the LinuxTV v4l-dvb repository.
See <a class="ulink" href="http://linuxtv.org/repo/" target="_top">http://linuxtv.org/repo/</a> for access instructions.</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="V4L2-PIX-FMT-SBGGR8"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p><code class="constant">V4L2_PIX_FMT_SBGGR8</code> &#8212; Bayer RGB format</p></div><div class="refsect1"><a name="idp55612496"></a><h2>Description</h2><p>This is commonly the native format of digital cameras,
reflecting the arrangement of sensors on the CCD device. Only one red,
green or blue value is given for each pixel. Missing components must
be interpolated from neighbouring pixels. From left to right the first
row consists of a blue and green value, the second row of a green and
red value. This scheme repeats to the right and down for every two
columns and rows.</p><div class="example"><a name="idp55656960"></a><p class="title"><b>Example 2.2. <code class="constant">V4L2_PIX_FMT_SBGGR8</code> 4 × 4
pixel image</b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte.
	      </p><div class="informaltable"><table border="0"><colgroup><col align="left"><col><col><col><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start + 0:</td><td align="center" valign="top">B<sub>00</sub></td><td align="center" valign="top">G<sub>01</sub></td><td align="center" valign="top">B<sub>02</sub></td><td align="center" valign="top">G<sub>03</sub></td></tr><tr><td align="left" valign="top">start + 4:</td><td align="center" valign="top">G<sub>10</sub></td><td align="center" valign="top">R<sub>11</sub></td><td align="center" valign="top">G<sub>12</sub></td><td align="center" valign="top">R<sub>13</sub></td></tr><tr><td align="left" valign="top">start + 8:</td><td align="center" valign="top">B<sub>20</sub></td><td align="center" valign="top">G<sub>21</sub></td><td align="center" valign="top">B<sub>22</sub></td><td align="center" valign="top">G<sub>23</sub></td></tr><tr><td align="left" valign="top">start + 12:</td><td align="center" valign="top">G<sub>30</sub></td><td align="center" valign="top">R<sub>31</sub></td><td align="center" valign="top">G<sub>32</sub></td><td align="center" valign="top">R<sub>33</sub></td></tr></tbody></table></div><p>
	    </p></div></div><br class="example-break"></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="V4L2-PIX-FMT-SGBRG8"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p><code class="constant">V4L2_PIX_FMT_SGBRG8</code> &#8212; Bayer RGB format</p></div><div class="refsect1"><a name="idp55641888"></a><h2>Description</h2><p>This is commonly the native format of digital cameras,
reflecting the arrangement of sensors on the CCD device. Only one red,
green or blue value is given for each pixel. Missing components must
be interpolated from neighbouring pixels. From left to right the first
row consists of a green and blue value, the second row of a red and
green value. This scheme repeats to the right and down for every two
columns and rows.</p><div class="example"><a name="idp55643376"></a><p class="title"><b>Example 2.3. <code class="constant">V4L2_PIX_FMT_SGBRG8</code> 4 × 4
pixel image</b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte.
	      </p><div class="informaltable"><table border="0"><colgroup><col align="left"><col><col><col><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start + 0:</td><td align="center" valign="top">G<sub>00</sub></td><td align="center" valign="top">B<sub>01</sub></td><td align="center" valign="top">G<sub>02</sub></td><td align="center" valign="top">B<sub>03</sub></td></tr><tr><td align="left" valign="top">start + 4:</td><td align="center" valign="top">R<sub>10</sub></td><td align="center" valign="top">G<sub>11</sub></td><td align="center" valign="top">R<sub>12</sub></td><td align="center" valign="top">G<sub>13</sub></td></tr><tr><td align="left" valign="top">start + 8:</td><td align="center" valign="top">G<sub>20</sub></td><td align="center" valign="top">B<sub>21</sub></td><td align="center" valign="top">G<sub>22</sub></td><td align="center" valign="top">B<sub>23</sub></td></tr><tr><td align="left" valign="top">start + 12:</td><td align="center" valign="top">R<sub>30</sub></td><td align="center" valign="top">G<sub>31</sub></td><td align="center" valign="top">R<sub>32</sub></td><td align="center" valign="top">G<sub>33</sub></td></tr></tbody></table></div><p>
	    </p></div></div><br class="example-break"></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="V4L2-PIX-FMT-SGRBG8"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p><code class="constant">V4L2_PIX_FMT_SGRBG8</code> &#8212; Bayer RGB format</p></div><div class="refsect1"><a name="idp55695184"></a><h2>Description</h2><p>This is commonly the native format of digital cameras,
reflecting the arrangement of sensors on the CCD device. Only one red,
green or blue value is given for each pixel. Missing components must
be interpolated from neighbouring pixels. From left to right the first
row consists of a green and blue value, the second row of a red and
green value. This scheme repeats to the right and down for every two
columns and rows.</p><div class="example"><a name="idp55696672"></a><p class="title"><b>Example 2.4. <code class="constant">V4L2_PIX_FMT_SGRBG8</code> 4 ×
4 pixel image</b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte.
	      </p><div class="informaltable"><table border="0"><colgroup><col align="left"><col><col><col><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start + 0:</td><td align="center" valign="top">G<sub>00</sub></td><td align="center" valign="top">R<sub>01</sub></td><td align="center" valign="top">G<sub>02</sub></td><td align="center" valign="top">R<sub>03</sub></td></tr><tr><td align="left" valign="top">start + 4:</td><td align="center" valign="top">R<sub>10</sub></td><td align="center" valign="top">B<sub>11</sub></td><td align="center" valign="top">R<sub>12</sub></td><td align="center" valign="top">B<sub>13</sub></td></tr><tr><td align="left" valign="top">start + 8:</td><td align="center" valign="top">G<sub>20</sub></td><td align="center" valign="top">R<sub>21</sub></td><td align="center" valign="top">G<sub>22</sub></td><td align="center" valign="top">R<sub>23</sub></td></tr><tr><td align="left" valign="top">start + 12:</td><td align="center" valign="top">R<sub>30</sub></td><td align="center" valign="top">B<sub>31</sub></td><td align="center" valign="top">R<sub>32</sub></td><td align="center" valign="top">B<sub>33</sub></td></tr></tbody></table></div><p>
	    </p></div></div><br class="example-break"></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="V4L2-PIX-FMT-SRGGB8"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p><code class="constant">V4L2_PIX_FMT_SRGGB8</code> &#8212; Bayer RGB format</p></div><div class="refsect1"><a name="idp55745680"></a><h2>Description</h2><p>This is commonly the native format of digital cameras,
reflecting the arrangement of sensors on the CCD device. Only one red,
green or blue value is given for each pixel. Missing components must
be interpolated from neighbouring pixels. From left to right the first
row consists of a red and green value, the second row of a green and
blue value. This scheme repeats to the right and down for every two
columns and rows.</p><div class="example"><a name="idp55747168"></a><p class="title"><b>Example 2.5. <code class="constant">V4L2_PIX_FMT_SRGGB8</code> 4 × 4
pixel image</b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte.
	      </p><div class="informaltable"><table border="0"><colgroup><col align="left"><col><col><col><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start + 0:</td><td align="center" valign="top">R<sub>00</sub></td><td align="center" valign="top">G<sub>01</sub></td><td align="center" valign="top">R<sub>02</sub></td><td align="center" valign="top">G<sub>03</sub></td></tr><tr><td align="left" valign="top">start + 4:</td><td align="center" valign="top">G<sub>10</sub></td><td align="center" valign="top">B<sub>11</sub></td><td align="center" valign="top">G<sub>12</sub></td><td align="center" valign="top">B<sub>13</sub></td></tr><tr><td align="left" valign="top">start + 8:</td><td align="center" valign="top">R<sub>20</sub></td><td align="center" valign="top">G<sub>21</sub></td><td align="center" valign="top">R<sub>22</sub></td><td align="center" valign="top">G<sub>23</sub></td></tr><tr><td align="left" valign="top">start + 12:</td><td align="center" valign="top">G<sub>30</sub></td><td align="center" valign="top">B<sub>31</sub></td><td align="center" valign="top">G<sub>32</sub></td><td align="center" valign="top">B<sub>33</sub></td></tr></tbody></table></div><p>
	    </p></div></div><br class="example-break"></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="V4L2-PIX-FMT-SBGGR16"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p><code class="constant">V4L2_PIX_FMT_SBGGR16</code> &#8212; Bayer RGB format</p></div><div class="refsect1"><a name="idp55796144"></a><h2>Description</h2><p>This format is similar to <a class="link" href="media.html#V4L2-PIX-FMT-SBGGR8" title="V4L2_PIX_FMT_SBGGR8 ('BA81')">
<code class="constant">V4L2_PIX_FMT_SBGGR8</code></a>, except each pixel has
a depth of 16 bits. The least significant byte is stored at lower
memory addresses (little-endian). Note the actual sampling precision
may be lower than 16 bits, for example 10 bits per pixel with values
in range 0 to 1023.</p><div class="example"><a name="idp55860000"></a><p class="title"><b>Example 2.6. <code class="constant">V4L2_PIX_FMT_SBGGR16</code> 4 × 4
pixel image</b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte.
	  </p><div class="informaltable"><table border="0"><colgroup><col align="left"><col><col><col><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start + 0:</td><td align="center" valign="top">B<sub>00low</sub></td><td align="center" valign="top">B<sub>00high</sub></td><td align="center" valign="top">G<sub>01low</sub></td><td align="center" valign="top">G<sub>01high</sub></td><td align="center" valign="top">B<sub>02low</sub></td><td align="center" valign="top">B<sub>02high</sub></td><td align="center" valign="top">G<sub>03low</sub></td><td align="center" valign="top">G<sub>03high</sub></td></tr><tr><td align="left" valign="top">start + 8:</td><td align="center" valign="top">G<sub>10low</sub></td><td align="center" valign="top">G<sub>10high</sub></td><td align="center" valign="top">R<sub>11low</sub></td><td align="center" valign="top">R<sub>11high</sub></td><td align="center" valign="top">G<sub>12low</sub></td><td align="center" valign="top">G<sub>12high</sub></td><td align="center" valign="top">R<sub>13low</sub></td><td align="center" valign="top">R<sub>13high</sub></td></tr><tr><td align="left" valign="top">start + 16:</td><td align="center" valign="top">B<sub>20low</sub></td><td align="center" valign="top">B<sub>20high</sub></td><td align="center" valign="top">G<sub>21low</sub></td><td align="center" valign="top">G<sub>21high</sub></td><td align="center" valign="top">B<sub>22low</sub></td><td align="center" valign="top">B<sub>22high</sub></td><td align="center" valign="top">G<sub>23low</sub></td><td align="center" valign="top">G<sub>23high</sub></td></tr><tr><td align="left" valign="top">start + 24:</td><td align="center" valign="top">G<sub>30low</sub></td><td align="center" valign="top">G<sub>30high</sub></td><td align="center" valign="top">R<sub>31low</sub></td><td align="center" valign="top">R<sub>31high</sub></td><td align="center" valign="top">G<sub>32low</sub></td><td align="center" valign="top">G<sub>32high</sub></td><td align="center" valign="top">R<sub>33low</sub></td><td align="center" valign="top">R<sub>33high</sub></td></tr></tbody></table></div><p>
	</p></div></div><br class="example-break"></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="pixfmt-srggb10"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p><code class="constant">V4L2_PIX_FMT_SRGGB10</code>, <code class="constant">V4L2_PIX_FMT_SGRBG10</code>, <code class="constant">V4L2_PIX_FMT_SGBRG10</code>, <code class="constant">V4L2_PIX_FMT_SBGGR10</code> &#8212; 10-bit Bayer formats expanded to 16 bits</p></div><div class="refsect1"><a name="idp55935984"></a><h2>Description</h2><p>The following four pixel formats are raw sRGB / Bayer formats with
10 bits per colour. Each colour component is stored in a 16-bit word, with 6
unused high bits filled with zeros. Each n-pixel row contains n/2 green samples
and n/2 blue or red samples, with alternating red and blue rows. Bytes are
stored in memory in little endian order. They are conventionally described
as GRGR... BGBG..., RGRG... GBGB..., etc. Below is an example of one of these
formats</p><div class="example"><a name="idp55937488"></a><p class="title"><b>Example 2.7. <code class="constant">V4L2_PIX_FMT_SBGGR10</code> 4 × 4
pixel image</b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte, high 6 bits in high bytes are 0.
	  </p><div class="informaltable"><table border="0"><colgroup><col align="left"><col><col><col><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start + 0:</td><td align="center" valign="top">B<sub>00low</sub></td><td align="center" valign="top">B<sub>00high</sub></td><td align="center" valign="top">G<sub>01low</sub></td><td align="center" valign="top">G<sub>01high</sub></td><td align="center" valign="top">B<sub>02low</sub></td><td align="center" valign="top">B<sub>02high</sub></td><td align="center" valign="top">G<sub>03low</sub></td><td align="center" valign="top">G<sub>03high</sub></td></tr><tr><td align="left" valign="top">start + 8:</td><td align="center" valign="top">G<sub>10low</sub></td><td align="center" valign="top">G<sub>10high</sub></td><td align="center" valign="top">R<sub>11low</sub></td><td align="center" valign="top">R<sub>11high</sub></td><td align="center" valign="top">G<sub>12low</sub></td><td align="center" valign="top">G<sub>12high</sub></td><td align="center" valign="top">R<sub>13low</sub></td><td align="center" valign="top">R<sub>13high</sub></td></tr><tr><td align="left" valign="top">start + 16:</td><td align="center" valign="top">B<sub>20low</sub></td><td align="center" valign="top">B<sub>20high</sub></td><td align="center" valign="top">G<sub>21low</sub></td><td align="center" valign="top">G<sub>21high</sub></td><td align="center" valign="top">B<sub>22low</sub></td><td align="center" valign="top">B<sub>22high</sub></td><td align="center" valign="top">G<sub>23low</sub></td><td align="center" valign="top">G<sub>23high</sub></td></tr><tr><td align="left" valign="top">start + 24:</td><td align="center" valign="top">G<sub>30low</sub></td><td align="center" valign="top">G<sub>30high</sub></td><td align="center" valign="top">R<sub>31low</sub></td><td align="center" valign="top">R<sub>31high</sub></td><td align="center" valign="top">G<sub>32low</sub></td><td align="center" valign="top">G<sub>32high</sub></td><td align="center" valign="top">R<sub>33low</sub></td><td align="center" valign="top">R<sub>33high</sub></td></tr></tbody></table></div><p>
	</p></div></div><br class="example-break"></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="idp56012848"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>
	      <code class="constant">V4L2_PIX_FMT_SBGGR10ALAW8</code>
	    , 
	      <code class="constant">V4L2_PIX_FMT_SGBRG10ALAW8</code>
	    , 
	      <code class="constant">V4L2_PIX_FMT_SGRBG10ALAW8</code>
	    , 
	      <code class="constant">V4L2_PIX_FMT_SRGGB10ALAW8</code>
	     &#8212; 10-bit Bayer formats compressed to 8 bits</p></div><div class="refsect1"><a name="idp56017120"></a><h2>Description</h2><p>The following four pixel formats are raw sRGB / Bayer
	    formats with 10 bits per color compressed to 8 bits each,
	    using the A-LAW algorithm. Each color component consumes 8
	    bits of memory. In other respects this format is similar to
	    <a class="xref" href="media.html#V4L2-PIX-FMT-SRGGB8" title="V4L2_PIX_FMT_SRGGB8 ('RGGB')"><span class="refentrytitle">V4L2_PIX_FMT_SRGGB8 ('RGGB')</span>(2)</a>.</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="pixfmt-srggb10dpcm8"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p><code class="constant">V4L2_PIX_FMT_SBGGR10DPCM8</code>, <code class="constant">V4L2_PIX_FMT_SGBRG10DPCM8</code>, <code class="constant">V4L2_PIX_FMT_SGRBG10DPCM8</code>, <code class="constant">V4L2_PIX_FMT_SRGGB10DPCM8</code> &#8212; 10-bit Bayer formats compressed to 8 bits</p></div><div class="refsect1"><a name="idp56036512"></a><h2>Description</h2><p>The following four pixel formats are raw sRGB / Bayer formats
	with 10 bits per colour compressed to 8 bits each, using DPCM
	compression. DPCM, differential pulse-code modulation, is lossy.
	Each colour component consumes 8 bits of memory. In other respects
	this format is similar to <a class="xref" href="media.html#pixfmt-srggb10" title="V4L2_PIX_FMT_SRGGB10 ('RG10'), V4L2_PIX_FMT_SGRBG10 ('BA10'), V4L2_PIX_FMT_SGBRG10 ('GB10'), V4L2_PIX_FMT_SBGGR10 ('BG10'),"><span class="refentrytitle">V4L2_PIX_FMT_SRGGB10 ('RG10'),
	 V4L2_PIX_FMT_SGRBG10 ('BA10'),
	 V4L2_PIX_FMT_SGBRG10 ('GB10'),
	 V4L2_PIX_FMT_SBGGR10 ('BG10'),
	 </span>(2)</a>.</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="idp56032208"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p><code class="constant">V4L2_PIX_FMT_SRGGB12</code>, <code class="constant">V4L2_PIX_FMT_SGRBG12</code>, <code class="constant">V4L2_PIX_FMT_SGBRG12</code>, <code class="constant">V4L2_PIX_FMT_SBGGR12</code> &#8212; 12-bit Bayer formats expanded to 16 bits</p></div><div class="refsect1"><a name="idp56030912"></a><h2>Description</h2><p>The following four pixel formats are raw sRGB / Bayer formats with
12 bits per colour. Each colour component is stored in a 16-bit word, with 4
unused high bits filled with zeros. Each n-pixel row contains n/2 green samples
and n/2 blue or red samples, with alternating red and blue rows. Bytes are
stored in memory in little endian order. They are conventionally described
as GRGR... BGBG..., RGRG... GBGB..., etc. Below is an example of one of these
formats</p><div class="example"><a name="idp56056192"></a><p class="title"><b>Example 2.8. <code class="constant">V4L2_PIX_FMT_SBGGR12</code> 4 × 4
pixel image</b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte, high 6 bits in high bytes are 0.
	  </p><div class="informaltable"><table border="0"><colgroup><col align="left"><col><col><col><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start + 0:</td><td align="center" valign="top">B<sub>00low</sub></td><td align="center" valign="top">B<sub>00high</sub></td><td align="center" valign="top">G<sub>01low</sub></td><td align="center" valign="top">G<sub>01high</sub></td><td align="center" valign="top">B<sub>02low</sub></td><td align="center" valign="top">B<sub>02high</sub></td><td align="center" valign="top">G<sub>03low</sub></td><td align="center" valign="top">G<sub>03high</sub></td></tr><tr><td align="left" valign="top">start + 8:</td><td align="center" valign="top">G<sub>10low</sub></td><td align="center" valign="top">G<sub>10high</sub></td><td align="center" valign="top">R<sub>11low</sub></td><td align="center" valign="top">R<sub>11high</sub></td><td align="center" valign="top">G<sub>12low</sub></td><td align="center" valign="top">G<sub>12high</sub></td><td align="center" valign="top">R<sub>13low</sub></td><td align="center" valign="top">R<sub>13high</sub></td></tr><tr><td align="left" valign="top">start + 16:</td><td align="center" valign="top">B<sub>20low</sub></td><td align="center" valign="top">B<sub>20high</sub></td><td align="center" valign="top">G<sub>21low</sub></td><td align="center" valign="top">G<sub>21high</sub></td><td align="center" valign="top">B<sub>22low</sub></td><td align="center" valign="top">B<sub>22high</sub></td><td align="center" valign="top">G<sub>23low</sub></td><td align="center" valign="top">G<sub>23high</sub></td></tr><tr><td align="left" valign="top">start + 24:</td><td align="center" valign="top">G<sub>30low</sub></td><td align="center" valign="top">G<sub>30high</sub></td><td align="center" valign="top">R<sub>31low</sub></td><td align="center" valign="top">R<sub>31high</sub></td><td align="center" valign="top">G<sub>32low</sub></td><td align="center" valign="top">G<sub>32high</sub></td><td align="center" valign="top">R<sub>33low</sub></td><td align="center" valign="top">R<sub>33high</sub></td></tr></tbody></table></div><p>
	</p></div></div><br class="example-break"></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="yuv-formats"></a>YUV Formats</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="refentrytitle"><a href="media.html#packed-yuv">Packed YUV formats</a></span><span class="refpurpose"> &#8212; Packed YUV formats</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-GREY">V4L2_PIX_FMT_GREY ('GREY')</a></span><span class="refpurpose"> &#8212; Grey-scale image</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-Y10">V4L2_PIX_FMT_Y10 ('Y10 ')</a></span><span class="refpurpose"> &#8212; Grey-scale image</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-Y12">V4L2_PIX_FMT_Y12 ('Y12 ')</a></span><span class="refpurpose"> &#8212; Grey-scale image</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-Y10BPACK">V4L2_PIX_FMT_Y10BPACK ('Y10B')</a></span><span class="refpurpose"> &#8212; Grey-scale image as a bit-packed array</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-Y16">V4L2_PIX_FMT_Y16 ('Y16 ')</a></span><span class="refpurpose"> &#8212; Grey-scale image</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-UV8">V4L2_PIX_FMT_UV8  ('UV8')</a></span><span class="refpurpose"> &#8212; UV plane interleaved</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-YUYV">V4L2_PIX_FMT_YUYV ('YUYV')</a></span><span class="refpurpose"> &#8212; Packed format with ½ horizontal chroma
resolution, also known as YUV 4:2:2</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-UYVY">V4L2_PIX_FMT_UYVY ('UYVY')</a></span><span class="refpurpose"> &#8212; Variation of
<code class="constant">V4L2_PIX_FMT_YUYV</code> with different order of samples
in memory</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-YVYU">V4L2_PIX_FMT_YVYU ('YVYU')</a></span><span class="refpurpose"> &#8212; Variation of
<code class="constant">V4L2_PIX_FMT_YUYV</code> with different order of samples
in memory</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-VYUY">V4L2_PIX_FMT_VYUY ('VYUY')</a></span><span class="refpurpose"> &#8212; Variation of
<code class="constant">V4L2_PIX_FMT_YUYV</code> with different order of samples
in memory</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-Y41P">V4L2_PIX_FMT_Y41P ('Y41P')</a></span><span class="refpurpose"> &#8212; Format with ¼ horizontal chroma
resolution, also known as YUV 4:1:1</span></dt><dt><span class="refentrytitle"><a href="media.html#idp57342656">V4L2_PIX_FMT_YVU420 ('YV12'), V4L2_PIX_FMT_YUV420 ('YU12')</a></span><span class="refpurpose"> &#8212; Planar formats with ½ horizontal and
vertical chroma resolution, also known as YUV 4:2:0</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-YUV420M">V4L2_PIX_FMT_YUV420M ('YM12')</a></span><span class="refpurpose"> &#8212; Variation of <code class="constant">V4L2_PIX_FMT_YUV420</code>
	  with planes non contiguous in memory. </span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-YVU420M">V4L2_PIX_FMT_YVU420M ('YM21')</a></span><span class="refpurpose"> &#8212; Variation of <code class="constant">V4L2_PIX_FMT_YVU420</code>
	  with planes non contiguous in memory. </span></dt><dt><span class="refentrytitle"><a href="media.html#idp57708208">V4L2_PIX_FMT_YVU410 ('YVU9'), V4L2_PIX_FMT_YUV410 ('YUV9')</a></span><span class="refpurpose"> &#8212; Planar formats with ¼ horizontal and
vertical chroma resolution, also known as YUV 4:1:0</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-YUV422P">V4L2_PIX_FMT_YUV422P ('422P')</a></span><span class="refpurpose"> &#8212; Format with ½ horizontal chroma resolution,
also known as YUV 4:2:2. Planar layout as opposed to
<code class="constant">V4L2_PIX_FMT_YUYV</code></span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-YUV411P">V4L2_PIX_FMT_YUV411P ('411P')</a></span><span class="refpurpose"> &#8212; Format with ¼ horizontal chroma resolution,
also known as YUV 4:1:1. Planar layout as opposed to
<code class="constant">V4L2_PIX_FMT_Y41P</code></span></dt><dt><span class="refentrytitle"><a href="media.html#idp58050800">V4L2_PIX_FMT_NV12 ('NV12'), V4L2_PIX_FMT_NV21 ('NV21')</a></span><span class="refpurpose"> &#8212; Formats with ½ horizontal and vertical
chroma resolution, also known as YUV 4:2:0. One luminance and one
chrominance plane with alternating chroma samples as opposed to
<code class="constant">V4L2_PIX_FMT_YVU420</code></span></dt><dt><span class="refentrytitle"><a href="media.html#idp58169408">V4L2_PIX_FMT_NV12M ('NM12'), V4L2_PIX_FMT_NV21M ('NM21'), V4L2_PIX_FMT_NV12MT_16X16</a></span><span class="refpurpose"> &#8212; Variation of <code class="constant">V4L2_PIX_FMT_NV12</code> and <code class="constant">V4L2_PIX_FMT_NV21</code> with planes
	  non contiguous in memory. </span></dt><dt><span class="refentrytitle"><a href="media.html#idp58299328">V4L2_PIX_FMT_NV12MT ('TM12')</a></span><span class="refpurpose"> &#8212; Formats with ½ horizontal and vertical
chroma resolution. This format has two planes - one for luminance and one for
chrominance. Chroma samples are interleaved. The difference to
<code class="constant">V4L2_PIX_FMT_NV12</code> is the memory layout. Pixels are
grouped in macroblocks of 64x32 size. The order of macroblocks in memory is
also not standard.
	</span></dt><dt><span class="refentrytitle"><a href="media.html#idp58297872">V4L2_PIX_FMT_NV16 ('NV16'), V4L2_PIX_FMT_NV61 ('NV61')</a></span><span class="refpurpose"> &#8212; Formats with ½ horizontal
chroma resolution, also known as YUV 4:2:2. One luminance and one
chrominance plane with alternating chroma samples as opposed to
<code class="constant">V4L2_PIX_FMT_YVU420</code></span></dt><dt><span class="refentrytitle"><a href="media.html#idp58473760">V4L2_PIX_FMT_NV16M ('NM16'), V4L2_PIX_FMT_NV61M ('NM61')</a></span><span class="refpurpose"> &#8212; Variation of <code class="constant">V4L2_PIX_FMT_NV16</code> and <code class="constant">V4L2_PIX_FMT_NV61</code> with planes
	  non contiguous in memory. </span></dt><dt><span class="refentrytitle"><a href="media.html#idp58620656">V4L2_PIX_FMT_NV24 ('NV24'), V4L2_PIX_FMT_NV42 ('NV42')</a></span><span class="refpurpose"> &#8212; Formats with full horizontal and vertical
chroma resolutions, also known as YUV 4:4:4. One luminance and one
chrominance plane with alternating chroma samples as opposed to
<code class="constant">V4L2_PIX_FMT_YVU420</code></span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-PIX-FMT-M420">V4L2_PIX_FMT_M420 ('M420')</a></span><span class="refpurpose"> &#8212; Format with ½ horizontal and vertical chroma
	resolution, also known as YUV 4:2:0. Hybrid plane line-interleaved
	layout.</span></dt></dl></div><p>YUV is the format native to TV broadcast and composite video
signals. It separates the brightness information (Y) from the color
information (U and V or Cb and Cr). The color information consists of
red and blue <span class="emphasis"><em>color difference</em></span> signals, this way
the green component can be reconstructed by subtracting from the
brightness component. See <a class="xref" href="media.html#colorspaces" title="Colorspaces">the section called &#8220;Colorspaces&#8221;</a> for conversion
examples. YUV was chosen because early television would only transmit
brightness information. To add color in a way compatible with existing
receivers a new signal carrier was added to transmit the color
difference signals. Secondary in the YUV format the U and V components
usually have lower resolution than the Y component. This is an analog
video compression technique taking advantage of a property of the
human visual system, being more sensitive to brightness
information.</p><div class="refentry"><a name="packed-yuv"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>Packed YUV formats &#8212; Packed YUV formats</p></div><div class="refsect1"><a name="idp56091952"></a><h2>Description</h2><p>Similar to the packed RGB formats these formats store
the Y, Cb and Cr component of each pixel in one 16 or 32 bit
word.</p><div class="table"><a name="idp56093152"></a><p class="title"><b>Table 2.18. Packed YUV Image Formats</b></p><div class="table-contents"><table summary="Packed YUV Image Formats" width="100%" border="0"><colgroup><col align="left" class="id"><col align="center" class="fourcc"><col align="center" class="bit"><col align="center" class="b07"><col align="center" class="b06"><col align="center" class="b05"><col align="center" class="b04"><col align="center" class="b03"><col align="center" class="b02"><col align="center" class="b01"><col align="center" class="b00"><col><col align="center" class="b17"><col align="center" class="b16"><col align="center" class="b15"><col align="center" class="b14"><col align="center" class="b13"><col align="center" class="b12"><col align="center" class="b11"><col align="center" class="b10"><col><col align="center" class="b27"><col align="center" class="b26"><col align="center" class="b25"><col align="center" class="b24"><col align="center" class="b23"><col align="center" class="b22"><col align="center" class="b21"><col align="center" class="b20"><col><col align="center" class="b37"><col align="center" class="b36"><col align="center" class="b35"><col align="center" class="b34"><col align="center" class="b33"><col align="center" class="b32"><col align="center" class="b31"></colgroup><thead><tr><th align="left">Identifier</th><th align="center">Code</th><th align="center"> </th><th colspan="8" align="center">Byte 0 in memory</th><td class="auto-generated"> </td><th colspan="8" align="center">Byte 1</th><td class="auto-generated"> </td><th colspan="8" align="center">Byte 2</th><td class="auto-generated"> </td><th colspan="8" align="center">Byte 3</th></tr><tr><th align="left"> </th><th align="center"> </th><th align="center">Bit</th><th align="center">7</th><th align="center">6</th><th align="center">5</th><th align="center">4</th><th align="center">3</th><th align="center">2</th><th align="center">1</th><th align="center">0</th><th align="center"> </th><th align="center">7</th><th align="center">6</th><th align="center">5</th><th align="center">4</th><th align="center">3</th><th align="center">2</th><th align="center">1</th><th align="center">0</th><th align="center"> </th><th align="center">7</th><th align="center">6</th><th align="center">5</th><th align="center">4</th><th align="center">3</th><th align="center">2</th><th align="center">1</th><th align="center">0</th><th align="center"> </th><th align="center">7</th><th align="center">6</th><th align="center">5</th><th align="center">4</th><th align="center">3</th><th align="center">2</th><th align="center">1</th><th align="center">0</th></tr></thead><tbody valign="top"><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-YUV444"></a><code class="constant">V4L2_PIX_FMT_YUV444</code></td><td align="center" valign="top">'Y444'</td><td align="center" valign="top"> </td><td align="center" valign="top">Cb<sub>3</sub></td><td align="center" valign="top">Cb<sub>2</sub></td><td align="center" valign="top">Cb<sub>1</sub></td><td align="center" valign="top">Cb<sub>0</sub></td><td align="center" valign="top">Cr<sub>3</sub></td><td align="center" valign="top">Cr<sub>2</sub></td><td align="center" valign="top">Cr<sub>1</sub></td><td align="center" valign="top">Cr<sub>0</sub></td><td align="center" valign="top"> </td><td align="center" valign="top">a<sub>3</sub></td><td align="center" valign="top">a<sub>2</sub></td><td align="center" valign="top">a<sub>1</sub></td><td align="center" valign="top">a<sub>0</sub></td><td align="center" valign="top">Y'<sub>3</sub></td><td align="center" valign="top">Y'<sub>2</sub></td><td align="center" valign="top">Y'<sub>1</sub></td><td align="center" valign="top">Y'<sub>0</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-YUV555"></a><code class="constant">V4L2_PIX_FMT_YUV555</code></td><td align="center" valign="top">'YUVO'</td><td align="center" valign="top"> </td><td align="center" valign="top">Cb<sub>2</sub></td><td align="center" valign="top">Cb<sub>1</sub></td><td align="center" valign="top">Cb<sub>0</sub></td><td align="center" valign="top">Cr<sub>4</sub></td><td align="center" valign="top">Cr<sub>3</sub></td><td align="center" valign="top">Cr<sub>2</sub></td><td align="center" valign="top">Cr<sub>1</sub></td><td align="center" valign="top">Cr<sub>0</sub></td><td align="center" valign="top"> </td><td align="center" valign="top">a</td><td align="center" valign="top">Y'<sub>4</sub></td><td align="center" valign="top">Y'<sub>3</sub></td><td align="center" valign="top">Y'<sub>2</sub></td><td align="center" valign="top">Y'<sub>1</sub></td><td align="center" valign="top">Y'<sub>0</sub></td><td align="center" valign="top">Cb<sub>4</sub></td><td align="center" valign="top">Cb<sub>3</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-YUV565"></a><code class="constant">V4L2_PIX_FMT_YUV565</code></td><td align="center" valign="top">'YUVP'</td><td align="center" valign="top"> </td><td align="center" valign="top">Cb<sub>2</sub></td><td align="center" valign="top">Cb<sub>1</sub></td><td align="center" valign="top">Cb<sub>0</sub></td><td align="center" valign="top">Cr<sub>4</sub></td><td align="center" valign="top">Cr<sub>3</sub></td><td align="center" valign="top">Cr<sub>2</sub></td><td align="center" valign="top">Cr<sub>1</sub></td><td align="center" valign="top">Cr<sub>0</sub></td><td align="center" valign="top"> </td><td align="center" valign="top">Y'<sub>4</sub></td><td align="center" valign="top">Y'<sub>3</sub></td><td align="center" valign="top">Y'<sub>2</sub></td><td align="center" valign="top">Y'<sub>1</sub></td><td align="center" valign="top">Y'<sub>0</sub></td><td align="center" valign="top">Cb<sub>5</sub></td><td align="center" valign="top">Cb<sub>4</sub></td><td align="center" valign="top">Cb<sub>3</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-YUV32"></a><code class="constant">V4L2_PIX_FMT_YUV32</code></td><td align="center" valign="top">'YUV4'</td><td align="center" valign="top"> </td><td align="center" valign="top">a<sub>7</sub></td><td align="center" valign="top">a<sub>6</sub></td><td align="center" valign="top">a<sub>5</sub></td><td align="center" valign="top">a<sub>4</sub></td><td align="center" valign="top">a<sub>3</sub></td><td align="center" valign="top">a<sub>2</sub></td><td align="center" valign="top">a<sub>1</sub></td><td align="center" valign="top">a<sub>0</sub></td><td align="center" valign="top"> </td><td align="center" valign="top">Y'<sub>7</sub></td><td align="center" valign="top">Y'<sub>6</sub></td><td align="center" valign="top">Y'<sub>5</sub></td><td align="center" valign="top">Y'<sub>4</sub></td><td align="center" valign="top">Y'<sub>3</sub></td><td align="center" valign="top">Y'<sub>2</sub></td><td align="center" valign="top">Y'<sub>1</sub></td><td align="center" valign="top">Y'<sub>0</sub></td><td align="center" valign="top"> </td><td align="center" valign="top">Cb<sub>7</sub></td><td align="center" valign="top">Cb<sub>6</sub></td><td align="center" valign="top">Cb<sub>5</sub></td><td align="center" valign="top">Cb<sub>4</sub></td><td align="center" valign="top">Cb<sub>3</sub></td><td align="center" valign="top">Cb<sub>2</sub></td><td align="center" valign="top">Cb<sub>1</sub></td><td align="center" valign="top">Cb<sub>0</sub></td><td align="center" valign="top"> </td><td align="center" valign="top">Cr<sub>7</sub></td><td align="center" valign="top">Cr<sub>6</sub></td><td align="center" valign="top">Cr<sub>5</sub></td><td align="center" valign="top">Cr<sub>4</sub></td><td align="center" valign="top">Cr<sub>3</sub></td><td align="center" valign="top">Cr<sub>2</sub></td><td align="center" valign="top">Cr<sub>1</sub></td><td align="center" valign="top">Cr<sub>0</sub></td></tr></tbody></table></div></div><br class="table-break"><p>Bit 7 is the most significant bit. The value of a = alpha
bits is undefined when reading from the driver, ignored when writing
to the driver, except when alpha blending has been negotiated for a
<a class="link" href="media.html#overlay" title="Video Overlay Interface">Video Overlay</a> or <a class="link" href="media.html#osd" title="Video Output Overlay Interface">Video Output Overlay</a>.</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="V4L2-PIX-FMT-GREY"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p><code class="constant">V4L2_PIX_FMT_GREY</code> &#8212; Grey-scale image</p></div><div class="refsect1"><a name="idp56362512"></a><h2>Description</h2><p>This is a grey-scale image. It is really a degenerate
Y'CbCr format which simply contains no Cb or Cr data.</p><div class="example"><a name="idp56363696"></a><p class="title"><b>Example 2.9. <code class="constant">V4L2_PIX_FMT_GREY</code> 4 × 4
pixel image</b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte.
		</p><div class="informaltable"><table border="0"><colgroup><col align="left"><col><col><col><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start + 0:</td><td align="center" valign="top">Y'<sub>00</sub></td><td align="center" valign="top">Y'<sub>01</sub></td><td align="center" valign="top">Y'<sub>02</sub></td><td align="center" valign="top">Y'<sub>03</sub></td></tr><tr><td align="left" valign="top">start + 4:</td><td align="center" valign="top">Y'<sub>10</sub></td><td align="center" valign="top">Y'<sub>11</sub></td><td align="center" valign="top">Y'<sub>12</sub></td><td align="center" valign="top">Y'<sub>13</sub></td></tr><tr><td align="left" valign="top">start + 8:</td><td align="center" valign="top">Y'<sub>20</sub></td><td align="center" valign="top">Y'<sub>21</sub></td><td align="center" valign="top">Y'<sub>22</sub></td><td align="center" valign="top">Y'<sub>23</sub></td></tr><tr><td align="left" valign="top">start + 12:</td><td align="center" valign="top">Y'<sub>30</sub></td><td align="center" valign="top">Y'<sub>31</sub></td><td align="center" valign="top">Y'<sub>32</sub></td><td align="center" valign="top">Y'<sub>33</sub></td></tr></tbody></table></div><p>
	      </p></div></div><br class="example-break"></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="V4L2-PIX-FMT-Y10"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p><code class="constant">V4L2_PIX_FMT_Y10</code> &#8212; Grey-scale image</p></div><div class="refsect1"><a name="idp56391296"></a><h2>Description</h2><p>This is a grey-scale image with a depth of 10 bits per pixel. Pixels
are stored in 16-bit words with unused high bits padded with 0. The least
significant byte is stored at lower memory addresses (little-endian).</p><div class="example"><a name="idp56392576"></a><p class="title"><b>Example 2.10. <code class="constant">V4L2_PIX_FMT_Y10</code> 4 × 4
pixel image</b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte.
	  </p><div class="informaltable"><table border="0"><colgroup><col align="left"><col><col><col><col><col><col><col><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start + 0:</td><td align="center" valign="top">Y'<sub>00low</sub></td><td align="center" valign="top">Y'<sub>00high</sub></td><td align="center" valign="top">Y'<sub>01low</sub></td><td align="center" valign="top">Y'<sub>01high</sub></td><td align="center" valign="top">Y'<sub>02low</sub></td><td align="center" valign="top">Y'<sub>02high</sub></td><td align="center" valign="top">Y'<sub>03low</sub></td><td align="center" valign="top">Y'<sub>03high</sub></td></tr><tr><td align="left" valign="top">start + 8:</td><td align="center" valign="top">Y'<sub>10low</sub></td><td align="center" valign="top">Y'<sub>10high</sub></td><td align="center" valign="top">Y'<sub>11low</sub></td><td align="center" valign="top">Y'<sub>11high</sub></td><td align="center" valign="top">Y'<sub>12low</sub></td><td align="center" valign="top">Y'<sub>12high</sub></td><td align="center" valign="top">Y'<sub>13low</sub></td><td align="center" valign="top">Y'<sub>13high</sub></td></tr><tr><td align="left" valign="top">start + 16:</td><td align="center" valign="top">Y'<sub>20low</sub></td><td align="center" valign="top">Y'<sub>20high</sub></td><td align="center" valign="top">Y'<sub>21low</sub></td><td align="center" valign="top">Y'<sub>21high</sub></td><td align="center" valign="top">Y'<sub>22low</sub></td><td align="center" valign="top">Y'<sub>22high</sub></td><td align="center" valign="top">Y'<sub>23low</sub></td><td align="center" valign="top">Y'<sub>23high</sub></td></tr><tr><td align="left" valign="top">start + 24:</td><td align="center" valign="top">Y'<sub>30low</sub></td><td align="center" valign="top">Y'<sub>30high</sub></td><td align="center" valign="top">Y'<sub>31low</sub></td><td align="center" valign="top">Y'<sub>31high</sub></td><td align="center" valign="top">Y'<sub>32low</sub></td><td align="center" valign="top">Y'<sub>32high</sub></td><td align="center" valign="top">Y'<sub>33low</sub></td><td align="center" valign="top">Y'<sub>33high</sub></td></tr></tbody></table></div><p>
	</p></div></div><br class="example-break"></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="V4L2-PIX-FMT-Y12"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p><code class="constant">V4L2_PIX_FMT_Y12</code> &#8212; Grey-scale image</p></div><div class="refsect1"><a name="idp56488144"></a><h2>Description</h2><p>This is a grey-scale image with a depth of 12 bits per pixel. Pixels
are stored in 16-bit words with unused high bits padded with 0. The least
significant byte is stored at lower memory addresses (little-endian).</p><div class="example"><a name="idp56489424"></a><p class="title"><b>Example 2.11. <code class="constant">V4L2_PIX_FMT_Y12</code> 4 × 4
pixel image</b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte.
	  </p><div class="informaltable"><table border="0"><colgroup><col align="left"><col><col><col><col><col><col><col><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start + 0:</td><td align="center" valign="top">Y'<sub>00low</sub></td><td align="center" valign="top">Y'<sub>00high</sub></td><td align="center" valign="top">Y'<sub>01low</sub></td><td align="center" valign="top">Y'<sub>01high</sub></td><td align="center" valign="top">Y'<sub>02low</sub></td><td align="center" valign="top">Y'<sub>02high</sub></td><td align="center" valign="top">Y'<sub>03low</sub></td><td align="center" valign="top">Y'<sub>03high</sub></td></tr><tr><td align="left" valign="top">start + 8:</td><td align="center" valign="top">Y'<sub>10low</sub></td><td align="center" valign="top">Y'<sub>10high</sub></td><td align="center" valign="top">Y'<sub>11low</sub></td><td align="center" valign="top">Y'<sub>11high</sub></td><td align="center" valign="top">Y'<sub>12low</sub></td><td align="center" valign="top">Y'<sub>12high</sub></td><td align="center" valign="top">Y'<sub>13low</sub></td><td align="center" valign="top">Y'<sub>13high</sub></td></tr><tr><td align="left" valign="top">start + 16:</td><td align="center" valign="top">Y'<sub>20low</sub></td><td align="center" valign="top">Y'<sub>20high</sub></td><td align="center" valign="top">Y'<sub>21low</sub></td><td align="center" valign="top">Y'<sub>21high</sub></td><td align="center" valign="top">Y'<sub>22low</sub></td><td align="center" valign="top">Y'<sub>22high</sub></td><td align="center" valign="top">Y'<sub>23low</sub></td><td align="center" valign="top">Y'<sub>23high</sub></td></tr><tr><td align="left" valign="top">start + 24:</td><td align="center" valign="top">Y'<sub>30low</sub></td><td align="center" valign="top">Y'<sub>30high</sub></td><td align="center" valign="top">Y'<sub>31low</sub></td><td align="center" valign="top">Y'<sub>31high</sub></td><td align="center" valign="top">Y'<sub>32low</sub></td><td align="center" valign="top">Y'<sub>32high</sub></td><td align="center" valign="top">Y'<sub>33low</sub></td><td align="center" valign="top">Y'<sub>33high</sub></td></tr></tbody></table></div><p>
	</p></div></div><br class="example-break"></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="V4L2-PIX-FMT-Y10BPACK"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p><code class="constant">V4L2_PIX_FMT_Y10BPACK</code> &#8212; Grey-scale image as a bit-packed array</p></div><div class="refsect1"><a name="idp56561136"></a><h2>Description</h2><p>This is a packed grey-scale image format with a depth of 10 bits per
      pixel. Pixels are stored in a bit-packed array of 10bit bits per pixel,
      with no padding between them and with the most significant bits coming
      first from the left.</p><div class="example"><a name="idp56562464"></a><p class="title"><b>Example 2.12. <code class="constant">V4L2_PIX_FMT_Y10BPACK</code> 4 pixel data stream taking 5 bytes</b></p><div class="example-contents"><p><b>Bit-packed representation. </b>pixels cross the byte boundary and have a ratio of 5 bytes for each 4
          pixels.
	  </p><div class="informaltable"><table border="1"><colgroup><col align="left"><col><col><col><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">Y'<sub>00[9:2]</sub></td><td align="center" valign="top">Y'<sub>00[1:0]</sub>Y'<sub>01[9:4]</sub></td><td align="center" valign="top">Y'<sub>01[3:0]</sub>Y'<sub>02[9:6]</sub></td><td align="center" valign="top">Y'<sub>02[5:0]</sub>Y'<sub>03[9:8]</sub></td><td align="center" valign="top">Y'<sub>03[7:0]</sub></td></tr></tbody></table></div><p>
	</p></div></div><br class="example-break"></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="V4L2-PIX-FMT-Y16"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p><code class="constant">V4L2_PIX_FMT_Y16</code> &#8212; Grey-scale image</p></div><div class="refsect1"><a name="idp56579248"></a><h2>Description</h2><p>This is a grey-scale image with a depth of 16 bits per
pixel. The least significant byte is stored at lower memory addresses
(little-endian). Note the actual sampling precision may be lower than
16 bits, for example 10 bits per pixel with values in range 0 to
1023.</p><div class="example"><a name="idp56580592"></a><p class="title"><b>Example 2.13. <code class="constant">V4L2_PIX_FMT_Y16</code> 4 × 4
pixel image</b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte.
	  </p><div class="informaltable"><table border="0"><colgroup><col align="left"><col><col><col><col><col><col><col><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start + 0:</td><td align="center" valign="top">Y'<sub>00low</sub></td><td align="center" valign="top">Y'<sub>00high</sub></td><td align="center" valign="top">Y'<sub>01low</sub></td><td align="center" valign="top">Y'<sub>01high</sub></td><td align="center" valign="top">Y'<sub>02low</sub></td><td align="center" valign="top">Y'<sub>02high</sub></td><td align="center" valign="top">Y'<sub>03low</sub></td><td align="center" valign="top">Y'<sub>03high</sub></td></tr><tr><td align="left" valign="top">start + 8:</td><td align="center" valign="top">Y'<sub>10low</sub></td><td align="center" valign="top">Y'<sub>10high</sub></td><td align="center" valign="top">Y'<sub>11low</sub></td><td align="center" valign="top">Y'<sub>11high</sub></td><td align="center" valign="top">Y'<sub>12low</sub></td><td align="center" valign="top">Y'<sub>12high</sub></td><td align="center" valign="top">Y'<sub>13low</sub></td><td align="center" valign="top">Y'<sub>13high</sub></td></tr><tr><td align="left" valign="top">start + 16:</td><td align="center" valign="top">Y'<sub>20low</sub></td><td align="center" valign="top">Y'<sub>20high</sub></td><td align="center" valign="top">Y'<sub>21low</sub></td><td align="center" valign="top">Y'<sub>21high</sub></td><td align="center" valign="top">Y'<sub>22low</sub></td><td align="center" valign="top">Y'<sub>22high</sub></td><td align="center" valign="top">Y'<sub>23low</sub></td><td align="center" valign="top">Y'<sub>23high</sub></td></tr><tr><td align="left" valign="top">start + 24:</td><td align="center" valign="top">Y'<sub>30low</sub></td><td align="center" valign="top">Y'<sub>30high</sub></td><td align="center" valign="top">Y'<sub>31low</sub></td><td align="center" valign="top">Y'<sub>31high</sub></td><td align="center" valign="top">Y'<sub>32low</sub></td><td align="center" valign="top">Y'<sub>32high</sub></td><td align="center" valign="top">Y'<sub>33low</sub></td><td align="center" valign="top">Y'<sub>33high</sub></td></tr></tbody></table></div><p>
	</p></div></div><br class="example-break"></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="V4L2-PIX-FMT-UV8"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p><code class="constant">V4L2_PIX_FMT_UV8</code> &#8212; UV plane interleaved</p></div><div class="refsect1"><a name="idp56666384"></a><h2>Description</h2><p>In this format there is no Y plane, Only CbCr plane. ie
	    (UV interleaved)</p><div class="example"><a name="idp56667440"></a><p class="title"><b>Example 2.14. 
	      <code class="constant">V4L2_PIX_FMT_UV8</code>
	       pixel image
	    </b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte.
	        </p><div class="informaltable"><table border="0"><colgroup><col align="left"><col><col><col><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start + 0:</td><td align="center" valign="top">Cb<sub>00</sub></td><td align="center" valign="top">Cr<sub>00</sub></td><td align="center" valign="top">Cb<sub>01</sub></td><td align="center" valign="top">Cr<sub>01</sub></td></tr><tr><td align="left" valign="top">start + 4:</td><td align="center" valign="top">Cb<sub>10</sub></td><td align="center" valign="top">Cr<sub>10</sub></td><td align="center" valign="top">Cb<sub>11</sub></td><td align="center" valign="top">Cr<sub>11</sub></td></tr><tr><td align="left" valign="top">start + 8:</td><td align="center" valign="top">Cb<sub>20</sub></td><td align="center" valign="top">Cr<sub>20</sub></td><td align="center" valign="top">Cb<sub>21</sub></td><td align="center" valign="top">Cr<sub>21</sub></td></tr><tr><td align="left" valign="top">start + 12:</td><td align="center" valign="top">Cb<sub>30</sub></td><td align="center" valign="top">Cr<sub>30</sub></td><td align="center" valign="top">Cb<sub>31</sub></td><td align="center" valign="top">Cr<sub>31</sub></td></tr></tbody></table></div><p>
	      </p></div></div><br class="example-break"></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="V4L2-PIX-FMT-YUYV"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p><code class="constant">V4L2_PIX_FMT_YUYV</code> &#8212; Packed format with ½ horizontal chroma
resolution, also known as YUV 4:2:2</p></div><div class="refsect1"><a name="idp56697152"></a><h2>Description</h2><p>In this format each four bytes is two pixels. Each four
bytes is two Y's, a Cb and a Cr. Each Y goes to one of the pixels, and
the Cb and Cr belong to both pixels. As you can see, the Cr and Cb
components have half the horizontal resolution of the Y component.
<code class="constant">V4L2_PIX_FMT_YUYV </code> is known in the Windows
environment as YUY2.</p><div class="example"><a name="idp56758864"></a><p class="title"><b>Example 2.15. <code class="constant">V4L2_PIX_FMT_YUYV</code> 4 × 4
pixel image</b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte.
		</p><div class="informaltable"><table border="0"><colgroup><col align="left"><col><col><col><col><col><col><col><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start + 0:</td><td align="center" valign="top">Y'<sub>00</sub></td><td align="center" valign="top">Cb<sub>00</sub></td><td align="center" valign="top">Y'<sub>01</sub></td><td align="center" valign="top">Cr<sub>00</sub></td><td align="center" valign="top">Y'<sub>02</sub></td><td align="center" valign="top">Cb<sub>01</sub></td><td align="center" valign="top">Y'<sub>03</sub></td><td align="center" valign="top">Cr<sub>01</sub></td></tr><tr><td align="left" valign="top">start + 8:</td><td align="center" valign="top">Y'<sub>10</sub></td><td align="center" valign="top">Cb<sub>10</sub></td><td align="center" valign="top">Y'<sub>11</sub></td><td align="center" valign="top">Cr<sub>10</sub></td><td align="center" valign="top">Y'<sub>12</sub></td><td align="center" valign="top">Cb<sub>11</sub></td><td align="center" valign="top">Y'<sub>13</sub></td><td align="center" valign="top">Cr<sub>11</sub></td></tr><tr><td align="left" valign="top">start + 16:</td><td align="center" valign="top">Y'<sub>20</sub></td><td align="center" valign="top">Cb<sub>20</sub></td><td align="center" valign="top">Y'<sub>21</sub></td><td align="center" valign="top">Cr<sub>20</sub></td><td align="center" valign="top">Y'<sub>22</sub></td><td align="center" valign="top">Cb<sub>21</sub></td><td align="center" valign="top">Y'<sub>23</sub></td><td align="center" valign="top">Cr<sub>21</sub></td></tr><tr><td align="left" valign="top">start + 24:</td><td align="center" valign="top">Y'<sub>30</sub></td><td align="center" valign="top">Cb<sub>30</sub></td><td align="center" valign="top">Y'<sub>31</sub></td><td align="center" valign="top">Cr<sub>30</sub></td><td align="center" valign="top">Y'<sub>32</sub></td><td align="center" valign="top">Cb<sub>31</sub></td><td align="center" valign="top">Y'<sub>33</sub></td><td align="center" valign="top">Cr<sub>31</sub></td></tr></tbody></table></div><p>
	      </p><p><b>Color Sample Location. </b>
		</p><div class="informaltable"><table border="0"><colgroup><col><col><col><col><col><col><col></colgroup><tbody valign="top"><tr><td align="center" valign="top"> </td><td align="center" valign="top">0</td><td align="center" valign="top"> </td><td align="center" valign="top">1</td><td align="center" valign="top"> </td><td align="center" valign="top">2</td><td align="center" valign="top"> </td><td align="center" valign="top">3</td></tr><tr><td align="center" valign="top">0</td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top">1</td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top">2</td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top">3</td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td></tr></tbody></table></div><p>
	      </p></div></div><br class="example-break"></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="V4L2-PIX-FMT-UYVY"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p><code class="constant">V4L2_PIX_FMT_UYVY</code> &#8212; Variation of
<code class="constant">V4L2_PIX_FMT_YUYV</code> with different order of samples
in memory</p></div><div class="refsect1"><a name="idp56823184"></a><h2>Description</h2><p>In this format each four bytes is two pixels. Each four
bytes is two Y's, a Cb and a Cr. Each Y goes to one of the pixels, and
the Cb and Cr belong to both pixels. As you can see, the Cr and Cb
components have half the horizontal resolution of the Y
component.</p><div class="example"><a name="idp56866672"></a><p class="title"><b>Example 2.16. <code class="constant">V4L2_PIX_FMT_UYVY</code> 4 × 4
pixel image</b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte.
		</p><div class="informaltable"><table border="0"><colgroup><col align="left"><col><col><col><col><col><col><col><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start + 0:</td><td align="center" valign="top">Cb<sub>00</sub></td><td align="center" valign="top">Y'<sub>00</sub></td><td align="center" valign="top">Cr<sub>00</sub></td><td align="center" valign="top">Y'<sub>01</sub></td><td align="center" valign="top">Cb<sub>01</sub></td><td align="center" valign="top">Y'<sub>02</sub></td><td align="center" valign="top">Cr<sub>01</sub></td><td align="center" valign="top">Y'<sub>03</sub></td></tr><tr><td align="left" valign="top">start + 8:</td><td align="center" valign="top">Cb<sub>10</sub></td><td align="center" valign="top">Y'<sub>10</sub></td><td align="center" valign="top">Cr<sub>10</sub></td><td align="center" valign="top">Y'<sub>11</sub></td><td align="center" valign="top">Cb<sub>11</sub></td><td align="center" valign="top">Y'<sub>12</sub></td><td align="center" valign="top">Cr<sub>11</sub></td><td align="center" valign="top">Y'<sub>13</sub></td></tr><tr><td align="left" valign="top">start + 16:</td><td align="center" valign="top">Cb<sub>20</sub></td><td align="center" valign="top">Y'<sub>20</sub></td><td align="center" valign="top">Cr<sub>20</sub></td><td align="center" valign="top">Y'<sub>21</sub></td><td align="center" valign="top">Cb<sub>21</sub></td><td align="center" valign="top">Y'<sub>22</sub></td><td align="center" valign="top">Cr<sub>21</sub></td><td align="center" valign="top">Y'<sub>23</sub></td></tr><tr><td align="left" valign="top">start + 24:</td><td align="center" valign="top">Cb<sub>30</sub></td><td align="center" valign="top">Y'<sub>30</sub></td><td align="center" valign="top">Cr<sub>30</sub></td><td align="center" valign="top">Y'<sub>31</sub></td><td align="center" valign="top">Cb<sub>31</sub></td><td align="center" valign="top">Y'<sub>32</sub></td><td align="center" valign="top">Cr<sub>31</sub></td><td align="center" valign="top">Y'<sub>33</sub></td></tr></tbody></table></div><p>
	      </p><p><b>Color Sample Location. </b>
		</p><div class="informaltable"><table border="0"><colgroup><col><col><col><col><col><col><col></colgroup><tbody valign="top"><tr><td align="center" valign="top"> </td><td align="center" valign="top">0</td><td align="center" valign="top"> </td><td align="center" valign="top">1</td><td align="center" valign="top"> </td><td align="center" valign="top">2</td><td align="center" valign="top"> </td><td align="center" valign="top">3</td></tr><tr><td align="center" valign="top">0</td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top">1</td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top">2</td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top">3</td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td></tr></tbody></table></div><p>
	      </p></div></div><br class="example-break"></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="V4L2-PIX-FMT-YVYU"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p><code class="constant">V4L2_PIX_FMT_YVYU</code> &#8212; Variation of
<code class="constant">V4L2_PIX_FMT_YUYV</code> with different order of samples
in memory</p></div><div class="refsect1"><a name="idp56931184"></a><h2>Description</h2><p>In this format each four bytes is two pixels. Each four
bytes is two Y's, a Cb and a Cr. Each Y goes to one of the pixels, and
the Cb and Cr belong to both pixels. As you can see, the Cr and Cb
components have half the horizontal resolution of the Y
component.</p><div class="example"><a name="idp56974880"></a><p class="title"><b>Example 2.17. <code class="constant">V4L2_PIX_FMT_YVYU</code> 4 × 4
pixel image</b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte.
		</p><div class="informaltable"><table border="0"><colgroup><col align="left"><col><col><col><col><col><col><col><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start + 0:</td><td align="center" valign="top">Y'<sub>00</sub></td><td align="center" valign="top">Cr<sub>00</sub></td><td align="center" valign="top">Y'<sub>01</sub></td><td align="center" valign="top">Cb<sub>00</sub></td><td align="center" valign="top">Y'<sub>02</sub></td><td align="center" valign="top">Cr<sub>01</sub></td><td align="center" valign="top">Y'<sub>03</sub></td><td align="center" valign="top">Cb<sub>01</sub></td></tr><tr><td align="left" valign="top">start + 8:</td><td align="center" valign="top">Y'<sub>10</sub></td><td align="center" valign="top">Cr<sub>10</sub></td><td align="center" valign="top">Y'<sub>11</sub></td><td align="center" valign="top">Cb<sub>10</sub></td><td align="center" valign="top">Y'<sub>12</sub></td><td align="center" valign="top">Cr<sub>11</sub></td><td align="center" valign="top">Y'<sub>13</sub></td><td align="center" valign="top">Cb<sub>11</sub></td></tr><tr><td align="left" valign="top">start + 16:</td><td align="center" valign="top">Y'<sub>20</sub></td><td align="center" valign="top">Cr<sub>20</sub></td><td align="center" valign="top">Y'<sub>21</sub></td><td align="center" valign="top">Cb<sub>20</sub></td><td align="center" valign="top">Y'<sub>22</sub></td><td align="center" valign="top">Cr<sub>21</sub></td><td align="center" valign="top">Y'<sub>23</sub></td><td align="center" valign="top">Cb<sub>21</sub></td></tr><tr><td align="left" valign="top">start + 24:</td><td align="center" valign="top">Y'<sub>30</sub></td><td align="center" valign="top">Cr<sub>30</sub></td><td align="center" valign="top">Y'<sub>31</sub></td><td align="center" valign="top">Cb<sub>30</sub></td><td align="center" valign="top">Y'<sub>32</sub></td><td align="center" valign="top">Cr<sub>31</sub></td><td align="center" valign="top">Y'<sub>33</sub></td><td align="center" valign="top">Cb<sub>31</sub></td></tr></tbody></table></div><p>
	      </p><p><b>Color Sample Location. </b>
		</p><div class="informaltable"><table border="0"><colgroup><col><col><col><col><col><col><col></colgroup><tbody valign="top"><tr><td align="center" valign="top"> </td><td align="center" valign="top">0</td><td align="center" valign="top"> </td><td align="center" valign="top">1</td><td align="center" valign="top"> </td><td align="center" valign="top">2</td><td align="center" valign="top"> </td><td align="center" valign="top">3</td></tr><tr><td align="center" valign="top">0</td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top">1</td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top">2</td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top">3</td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td></tr></tbody></table></div><p>
	      </p></div></div><br class="example-break"></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="V4L2-PIX-FMT-VYUY"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p><code class="constant">V4L2_PIX_FMT_VYUY</code> &#8212; Variation of
<code class="constant">V4L2_PIX_FMT_YUYV</code> with different order of samples
in memory</p></div><div class="refsect1"><a name="idp57039360"></a><h2>Description</h2><p>In this format each four bytes is two pixels. Each four
bytes is two Y's, a Cb and a Cr. Each Y goes to one of the pixels, and
the Cb and Cr belong to both pixels. As you can see, the Cr and Cb
components have half the horizontal resolution of the Y
component.</p><div class="example"><a name="idp57082992"></a><p class="title"><b>Example 2.18. <code class="constant">V4L2_PIX_FMT_VYUY</code> 4 × 4
pixel image</b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte.
		</p><div class="informaltable"><table border="0"><colgroup><col align="left"><col><col><col><col><col><col><col><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start + 0:</td><td align="center" valign="top">Cr<sub>00</sub></td><td align="center" valign="top">Y'<sub>00</sub></td><td align="center" valign="top">Cb<sub>00</sub></td><td align="center" valign="top">Y'<sub>01</sub></td><td align="center" valign="top">Cr<sub>01</sub></td><td align="center" valign="top">Y'<sub>02</sub></td><td align="center" valign="top">Cb<sub>01</sub></td><td align="center" valign="top">Y'<sub>03</sub></td></tr><tr><td align="left" valign="top">start + 8:</td><td align="center" valign="top">Cr<sub>10</sub></td><td align="center" valign="top">Y'<sub>10</sub></td><td align="center" valign="top">Cb<sub>10</sub></td><td align="center" valign="top">Y'<sub>11</sub></td><td align="center" valign="top">Cr<sub>11</sub></td><td align="center" valign="top">Y'<sub>12</sub></td><td align="center" valign="top">Cb<sub>11</sub></td><td align="center" valign="top">Y'<sub>13</sub></td></tr><tr><td align="left" valign="top">start + 16:</td><td align="center" valign="top">Cr<sub>20</sub></td><td align="center" valign="top">Y'<sub>20</sub></td><td align="center" valign="top">Cb<sub>20</sub></td><td align="center" valign="top">Y'<sub>21</sub></td><td align="center" valign="top">Cr<sub>21</sub></td><td align="center" valign="top">Y'<sub>22</sub></td><td align="center" valign="top">Cb<sub>21</sub></td><td align="center" valign="top">Y'<sub>23</sub></td></tr><tr><td align="left" valign="top">start + 24:</td><td align="center" valign="top">Cr<sub>30</sub></td><td align="center" valign="top">Y'<sub>30</sub></td><td align="center" valign="top">Cb<sub>30</sub></td><td align="center" valign="top">Y'<sub>31</sub></td><td align="center" valign="top">Cr<sub>31</sub></td><td align="center" valign="top">Y'<sub>32</sub></td><td align="center" valign="top">Cb<sub>31</sub></td><td align="center" valign="top">Y'<sub>33</sub></td></tr></tbody></table></div><p>
	      </p><p><b>Color Sample Location. </b>
		</p><div class="informaltable"><table border="0"><colgroup><col><col><col><col><col><col><col></colgroup><tbody valign="top"><tr><td align="center" valign="top"> </td><td align="center" valign="top">0</td><td align="center" valign="top"> </td><td align="center" valign="top">1</td><td align="center" valign="top"> </td><td align="center" valign="top">2</td><td align="center" valign="top"> </td><td align="center" valign="top">3</td></tr><tr><td align="center" valign="top">0</td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top">1</td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top">2</td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top">3</td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td></tr></tbody></table></div><p>
	      </p></div></div><br class="example-break"></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="V4L2-PIX-FMT-Y41P"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p><code class="constant">V4L2_PIX_FMT_Y41P</code> &#8212; Format with ¼ horizontal chroma
resolution, also known as YUV 4:1:1</p></div><div class="refsect1"><a name="idp57147264"></a><h2>Description</h2><p>In this format each 12 bytes is eight pixels. In the
twelve bytes are two CbCr pairs and eight Y's. The first CbCr pair
goes with the first four Y's, and the second CbCr pair goes with the
other four Y's. The Cb and Cr components have one fourth the
horizontal resolution of the Y component.</p><p>Do not confuse this format with <a class="link" href="media.html#V4L2-PIX-FMT-YUV411P" title="V4L2_PIX_FMT_YUV411P ('411P')"><code class="constant">V4L2_PIX_FMT_YUV411P</code></a>.
Y41P is derived from "YUV 4:1:1 <span class="emphasis"><em>packed</em></span>", while
YUV411P stands for "YUV 4:1:1 <span class="emphasis"><em>planar</em></span>".</p><div class="example"><a name="idp57193696"></a><p class="title"><b>Example 2.19. <code class="constant">V4L2_PIX_FMT_Y41P</code> 8 × 4
pixel image</b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte.
		</p><div class="informaltable"><table border="0"><colgroup><col align="left"><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start + 0:</td><td align="center" valign="top">Cb<sub>00</sub></td><td align="center" valign="top">Y'<sub>00</sub></td><td align="center" valign="top">Cr<sub>00</sub></td><td align="center" valign="top">Y'<sub>01</sub></td><td align="center" valign="top">Cb<sub>01</sub></td><td align="center" valign="top">Y'<sub>02</sub></td><td align="center" valign="top">Cr<sub>01</sub></td><td align="center" valign="top">Y'<sub>03</sub></td><td align="center" valign="top">Y'<sub>04</sub></td><td align="center" valign="top">Y'<sub>05</sub></td><td align="center" valign="top">Y'<sub>06</sub></td><td align="center" valign="top">Y'<sub>07</sub></td></tr><tr><td align="left" valign="top">start + 12:</td><td align="center" valign="top">Cb<sub>10</sub></td><td align="center" valign="top">Y'<sub>10</sub></td><td align="center" valign="top">Cr<sub>10</sub></td><td align="center" valign="top">Y'<sub>11</sub></td><td align="center" valign="top">Cb<sub>11</sub></td><td align="center" valign="top">Y'<sub>12</sub></td><td align="center" valign="top">Cr<sub>11</sub></td><td align="center" valign="top">Y'<sub>13</sub></td><td align="center" valign="top">Y'<sub>14</sub></td><td align="center" valign="top">Y'<sub>15</sub></td><td align="center" valign="top">Y'<sub>16</sub></td><td align="center" valign="top">Y'<sub>17</sub></td></tr><tr><td align="left" valign="top">start + 24:</td><td align="center" valign="top">Cb<sub>20</sub></td><td align="center" valign="top">Y'<sub>20</sub></td><td align="center" valign="top">Cr<sub>20</sub></td><td align="center" valign="top">Y'<sub>21</sub></td><td align="center" valign="top">Cb<sub>21</sub></td><td align="center" valign="top">Y'<sub>22</sub></td><td align="center" valign="top">Cr<sub>21</sub></td><td align="center" valign="top">Y'<sub>23</sub></td><td align="center" valign="top">Y'<sub>24</sub></td><td align="center" valign="top">Y'<sub>25</sub></td><td align="center" valign="top">Y'<sub>26</sub></td><td align="center" valign="top">Y'<sub>27</sub></td></tr><tr><td align="left" valign="top">start + 36:</td><td align="center" valign="top">Cb<sub>30</sub></td><td align="center" valign="top">Y'<sub>30</sub></td><td align="center" valign="top">Cr<sub>30</sub></td><td align="center" valign="top">Y'<sub>31</sub></td><td align="center" valign="top">Cb<sub>31</sub></td><td align="center" valign="top">Y'<sub>32</sub></td><td align="center" valign="top">Cr<sub>31</sub></td><td align="center" valign="top">Y'<sub>33</sub></td><td align="center" valign="top">Y'<sub>34</sub></td><td align="center" valign="top">Y'<sub>35</sub></td><td align="center" valign="top">Y'<sub>36</sub></td><td align="center" valign="top">Y'<sub>37</sub></td></tr></tbody></table></div><p><b>Color Sample Location. </b>
		</p><div class="informaltable"><table border="0"><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><tbody valign="top"><tr><td align="center" valign="top"> </td><td align="center" valign="top">0</td><td align="center" valign="top"> </td><td align="center" valign="top">1</td><td align="center" valign="top"> </td><td align="center" valign="top">2</td><td align="center" valign="top"> </td><td align="center" valign="top">3</td><td align="center" valign="top"> </td><td align="center" valign="top">4</td><td align="center" valign="top"> </td><td align="center" valign="top">5</td><td align="center" valign="top"> </td><td align="center" valign="top">6</td><td align="center" valign="top"> </td><td align="center" valign="top">7</td></tr><tr><td align="center" valign="top">0</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top">1</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top">2</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top">3</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr></tbody></table></div><p>
	      </p></div></div><br class="example-break"></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="idp57342656"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p><code class="constant">V4L2_PIX_FMT_YVU420</code>, <code class="constant">V4L2_PIX_FMT_YUV420</code> &#8212; Planar formats with ½ horizontal and
vertical chroma resolution, also known as YUV 4:2:0</p></div><div class="refsect1"><a name="idp57300720"></a><h2>Description</h2><p>These are planar formats, as opposed to a packed format.
The three components are separated into three sub- images or planes.
The Y plane is first. The Y plane has one byte per pixel. For
<code class="constant">V4L2_PIX_FMT_YVU420</code>, the Cr plane immediately
follows the Y plane in memory. The Cr plane is half the width and half
the height of the Y plane (and of the image). Each Cr belongs to four
pixels, a two-by-two square of the image. For example,
Cr<sub>0</sub> belongs to Y'<sub>00</sub>,
Y'<sub>01</sub>, Y'<sub>10</sub>, and
Y'<sub>11</sub>. Following the Cr plane is the Cb plane,
just like the Cr plane. <code class="constant">V4L2_PIX_FMT_YUV420</code> is
the same except the Cb plane comes first, then the Cr plane.</p><p>If the Y plane has pad bytes after each row, then the Cr
and Cb planes have half as many pad bytes after their rows. In other
words, two Cx rows (including padding) is exactly as long as one Y row
(including padding).</p><div class="example"><a name="idp57348752"></a><p class="title"><b>Example 2.20. <code class="constant">V4L2_PIX_FMT_YVU420</code> 4 × 4
pixel image</b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte.
		</p><div class="informaltable"><table border="0"><colgroup><col align="left"><col><col><col><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start + 0:</td><td align="center" valign="top">Y'<sub>00</sub></td><td align="center" valign="top">Y'<sub>01</sub></td><td align="center" valign="top">Y'<sub>02</sub></td><td align="center" valign="top">Y'<sub>03</sub></td></tr><tr><td align="left" valign="top">start + 4:</td><td align="center" valign="top">Y'<sub>10</sub></td><td align="center" valign="top">Y'<sub>11</sub></td><td align="center" valign="top">Y'<sub>12</sub></td><td align="center" valign="top">Y'<sub>13</sub></td></tr><tr><td align="left" valign="top">start + 8:</td><td align="center" valign="top">Y'<sub>20</sub></td><td align="center" valign="top">Y'<sub>21</sub></td><td align="center" valign="top">Y'<sub>22</sub></td><td align="center" valign="top">Y'<sub>23</sub></td></tr><tr><td align="left" valign="top">start + 12:</td><td align="center" valign="top">Y'<sub>30</sub></td><td align="center" valign="top">Y'<sub>31</sub></td><td align="center" valign="top">Y'<sub>32</sub></td><td align="center" valign="top">Y'<sub>33</sub></td></tr><tr><td align="left" valign="top">start + 16:</td><td align="center" valign="top">Cr<sub>00</sub></td><td align="center" valign="top">Cr<sub>01</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top">start + 18:</td><td align="center" valign="top">Cr<sub>10</sub></td><td align="center" valign="top">Cr<sub>11</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top">start + 20:</td><td align="center" valign="top">Cb<sub>00</sub></td><td align="center" valign="top">Cb<sub>01</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top">start + 22:</td><td align="center" valign="top">Cb<sub>10</sub></td><td align="center" valign="top">Cb<sub>11</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr></tbody></table></div><p>
	      </p><p><b>Color Sample Location. </b>
		</p><div class="informaltable"><table border="0"><colgroup><col><col><col><col><col><col><col></colgroup><tbody valign="top"><tr><td align="center" valign="top"> </td><td align="center" valign="top">0</td><td align="center" valign="top"> </td><td align="center" valign="top">1</td><td align="center" valign="top"> </td><td align="center" valign="top">2</td><td align="center" valign="top"> </td><td align="center" valign="top">3</td></tr><tr><td align="center" valign="top">0</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td></tr><tr><td align="center" valign="top">1</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="center" valign="top">2</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td></tr><tr><td align="center" valign="top">3</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr></tbody></table></div><p>
	      </p></div></div><br class="example-break"></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="V4L2-PIX-FMT-YUV420M"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p> <code class="constant">V4L2_PIX_FMT_YUV420M</code> &#8212; Variation of <code class="constant">V4L2_PIX_FMT_YUV420</code>
	  with planes non contiguous in memory. </p></div><div class="refsect1"><a name="idp57421664"></a><h2>Description</h2><p>This is a multi-planar format, as opposed to a packed format.
The three components are separated into three sub- images or planes.

The Y plane is first. The Y plane has one byte per pixel. The Cb data
constitutes the second plane which is half the width and half
the height of the Y plane (and of the image). Each Cb belongs to four
pixels, a two-by-two square of the image. For example,
Cb<sub>0</sub> belongs to Y'<sub>00</sub>,
Y'<sub>01</sub>, Y'<sub>10</sub>, and
Y'<sub>11</sub>. The Cr data, just like the Cb plane, is
in the third plane. </p><p>If the Y plane has pad bytes after each row, then the Cb
and Cr planes have half as many pad bytes after their rows. In other
words, two Cx rows (including padding) is exactly as long as one Y row
(including padding).</p><p><code class="constant">V4L2_PIX_FMT_NV12M</code> is intended to be
used only in drivers and applications that support the multi-planar API,
described in <a class="xref" href="media.html#planar-apis" title="Single- and multi-planar APIs">the section called &#8220;Single- and multi-planar APIs&#8221;</a>. </p><div class="example"><a name="idp57469536"></a><p class="title"><b>Example 2.21. <code class="constant">V4L2_PIX_FMT_YVU420M</code> 4 × 4
pixel image</b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte.
		</p><div class="informaltable"><table border="0"><colgroup><col align="left"><col><col><col><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start0 + 0:</td><td align="center" valign="top">Y'<sub>00</sub></td><td align="center" valign="top">Y'<sub>01</sub></td><td align="center" valign="top">Y'<sub>02</sub></td><td align="center" valign="top">Y'<sub>03</sub></td></tr><tr><td align="left" valign="top">start0 + 4:</td><td align="center" valign="top">Y'<sub>10</sub></td><td align="center" valign="top">Y'<sub>11</sub></td><td align="center" valign="top">Y'<sub>12</sub></td><td align="center" valign="top">Y'<sub>13</sub></td></tr><tr><td align="left" valign="top">start0 + 8:</td><td align="center" valign="top">Y'<sub>20</sub></td><td align="center" valign="top">Y'<sub>21</sub></td><td align="center" valign="top">Y'<sub>22</sub></td><td align="center" valign="top">Y'<sub>23</sub></td></tr><tr><td align="left" valign="top">start0 + 12:</td><td align="center" valign="top">Y'<sub>30</sub></td><td align="center" valign="top">Y'<sub>31</sub></td><td align="center" valign="top">Y'<sub>32</sub></td><td align="center" valign="top">Y'<sub>33</sub></td></tr><tr><td align="left" valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top">start1 + 0:</td><td align="center" valign="top">Cb<sub>00</sub></td><td align="center" valign="top">Cb<sub>01</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top">start1 + 2:</td><td align="center" valign="top">Cb<sub>10</sub></td><td align="center" valign="top">Cb<sub>11</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top">start2 + 0:</td><td align="center" valign="top">Cr<sub>00</sub></td><td align="center" valign="top">Cr<sub>01</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top">start2 + 2:</td><td align="center" valign="top">Cr<sub>10</sub></td><td align="center" valign="top">Cr<sub>11</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr></tbody></table></div><p>
	      </p><p><b>Color Sample Location. </b>
		</p><div class="informaltable"><table border="0"><colgroup><col><col><col><col><col><col><col></colgroup><tbody valign="top"><tr><td align="center" valign="top"> </td><td align="center" valign="top">0</td><td align="center" valign="top"> </td><td align="center" valign="top">1</td><td align="center" valign="top"> </td><td align="center" valign="top">2</td><td align="center" valign="top"> </td><td align="center" valign="top">3</td></tr><tr><td align="center" valign="top">0</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td></tr><tr><td align="center" valign="top">1</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="center" valign="top">2</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td></tr><tr><td align="center" valign="top">3</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr></tbody></table></div><p>
	      </p></div></div><br class="example-break"></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="V4L2-PIX-FMT-YVU420M"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p> <code class="constant">V4L2_PIX_FMT_YVU420M</code> &#8212; Variation of <code class="constant">V4L2_PIX_FMT_YVU420</code>
	  with planes non contiguous in memory. </p></div><div class="refsect1"><a name="idp57544176"></a><h2>Description</h2><p>This is a multi-planar format, as opposed to a packed format.
The three components are separated into three sub-images or planes.

The Y plane is first. The Y plane has one byte per pixel. The Cr data
constitutes the second plane which is half the width and half
the height of the Y plane (and of the image). Each Cr belongs to four
pixels, a two-by-two square of the image. For example,
Cr<sub>0</sub> belongs to Y'<sub>00</sub>,
Y'<sub>01</sub>, Y'<sub>10</sub>, and
Y'<sub>11</sub>. The Cb data, just like the Cr plane, constitutes
the third plane. </p><p>If the Y plane has pad bytes after each row, then the Cr
and Cb planes have half as many pad bytes after their rows. In other
words, two Cx rows (including padding) is exactly as long as one Y row
(including padding).</p><p><code class="constant">V4L2_PIX_FMT_YVU420M</code> is intended to be
used only in drivers and applications that support the multi-planar API,
described in <a class="xref" href="media.html#planar-apis" title="Single- and multi-planar APIs">the section called &#8220;Single- and multi-planar APIs&#8221;</a>. </p><div class="example"><a name="idp57591952"></a><p class="title"><b>Example 2.22. <code class="constant">V4L2_PIX_FMT_YVU420M</code> 4 × 4
pixel image</b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte.
		</p><div class="informaltable"><table border="0"><colgroup><col align="left"><col><col><col><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start0 + 0:</td><td align="center" valign="top">Y'<sub>00</sub></td><td align="center" valign="top">Y'<sub>01</sub></td><td align="center" valign="top">Y'<sub>02</sub></td><td align="center" valign="top">Y'<sub>03</sub></td></tr><tr><td align="left" valign="top">start0 + 4:</td><td align="center" valign="top">Y'<sub>10</sub></td><td align="center" valign="top">Y'<sub>11</sub></td><td align="center" valign="top">Y'<sub>12</sub></td><td align="center" valign="top">Y'<sub>13</sub></td></tr><tr><td align="left" valign="top">start0 + 8:</td><td align="center" valign="top">Y'<sub>20</sub></td><td align="center" valign="top">Y'<sub>21</sub></td><td align="center" valign="top">Y'<sub>22</sub></td><td align="center" valign="top">Y'<sub>23</sub></td></tr><tr><td align="left" valign="top">start0 + 12:</td><td align="center" valign="top">Y'<sub>30</sub></td><td align="center" valign="top">Y'<sub>31</sub></td><td align="center" valign="top">Y'<sub>32</sub></td><td align="center" valign="top">Y'<sub>33</sub></td></tr><tr><td align="left" valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top">start1 + 0:</td><td align="center" valign="top">Cr<sub>00</sub></td><td align="center" valign="top">Cr<sub>01</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top">start1 + 2:</td><td align="center" valign="top">Cr<sub>10</sub></td><td align="center" valign="top">Cr<sub>11</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top">start2 + 0:</td><td align="center" valign="top">Cb<sub>00</sub></td><td align="center" valign="top">Cb<sub>01</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top">start2 + 2:</td><td align="center" valign="top">Cb<sub>10</sub></td><td align="center" valign="top">Cb<sub>11</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr></tbody></table></div><p>
	      </p><p><b>Color Sample Location. </b>
		</p><div class="informaltable"><table border="0"><colgroup><col><col><col><col><col><col><col></colgroup><tbody valign="top"><tr><td align="center" valign="top"> </td><td align="center" valign="top">0</td><td align="center" valign="top"> </td><td align="center" valign="top">1</td><td align="center" valign="top"> </td><td align="center" valign="top">2</td><td align="center" valign="top"> </td><td align="center" valign="top">3</td></tr><tr><td align="center" valign="top">0</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td></tr><tr><td align="center" valign="top">1</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="center" valign="top">2</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td></tr><tr><td align="center" valign="top">3</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr></tbody></table></div><p>
	      </p></div></div><br class="example-break"></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="idp57708208"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p><code class="constant">V4L2_PIX_FMT_YVU410</code>, <code class="constant">V4L2_PIX_FMT_YUV410</code> &#8212; Planar formats with ¼ horizontal and
vertical chroma resolution, also known as YUV 4:1:0</p></div><div class="refsect1"><a name="idp57667056"></a><h2>Description</h2><p>These are planar formats, as opposed to a packed format.
The three components are separated into three sub-images or planes.
The Y plane is first. The Y plane has one byte per pixel. For
<code class="constant">V4L2_PIX_FMT_YVU410</code>, the Cr plane immediately
follows the Y plane in memory. The Cr plane is ¼ the width and
¼ the height of the Y plane (and of the image). Each Cr belongs
to 16 pixels, a four-by-four square of the image. Following the Cr
plane is the Cb plane, just like the Cr plane.
<code class="constant">V4L2_PIX_FMT_YUV410</code> is the same, except the Cb
plane comes first, then the Cr plane.</p><p>If the Y plane has pad bytes after each row, then the Cr
and Cb planes have ¼ as many pad bytes after their rows. In
other words, four Cx rows (including padding) are exactly as long as
one Y row (including padding).</p><div class="example"><a name="idp57712480"></a><p class="title"><b>Example 2.23. <code class="constant">V4L2_PIX_FMT_YVU410</code> 4 × 4
pixel image</b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte.
		</p><div class="informaltable"><table border="0"><colgroup><col align="left"><col><col><col><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start + 0:</td><td align="center" valign="top">Y'<sub>00</sub></td><td align="center" valign="top">Y'<sub>01</sub></td><td align="center" valign="top">Y'<sub>02</sub></td><td align="center" valign="top">Y'<sub>03</sub></td></tr><tr><td align="left" valign="top">start + 4:</td><td align="center" valign="top">Y'<sub>10</sub></td><td align="center" valign="top">Y'<sub>11</sub></td><td align="center" valign="top">Y'<sub>12</sub></td><td align="center" valign="top">Y'<sub>13</sub></td></tr><tr><td align="left" valign="top">start + 8:</td><td align="center" valign="top">Y'<sub>20</sub></td><td align="center" valign="top">Y'<sub>21</sub></td><td align="center" valign="top">Y'<sub>22</sub></td><td align="center" valign="top">Y'<sub>23</sub></td></tr><tr><td align="left" valign="top">start + 12:</td><td align="center" valign="top">Y'<sub>30</sub></td><td align="center" valign="top">Y'<sub>31</sub></td><td align="center" valign="top">Y'<sub>32</sub></td><td align="center" valign="top">Y'<sub>33</sub></td></tr><tr><td align="left" valign="top">start + 16:</td><td align="center" valign="top">Cr<sub>00</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top">start + 17:</td><td align="center" valign="top">Cb<sub>00</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr></tbody></table></div><p>
	      </p><p><b>Color Sample Location. </b>
		</p><div class="informaltable"><table border="0"><colgroup><col><col><col><col><col><col><col></colgroup><tbody valign="top"><tr><td align="center" valign="top"> </td><td align="center" valign="top">0</td><td align="center" valign="top"> </td><td align="center" valign="top">1</td><td align="center" valign="top"> </td><td align="center" valign="top">2</td><td align="center" valign="top"> </td><td align="center" valign="top">3</td></tr><tr><td align="center" valign="top">0</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="center" valign="top">1</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td></tr><tr><td align="center" valign="top">2</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="center" valign="top">3</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr></tbody></table></div><p>
	      </p></div></div><br class="example-break"></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="V4L2-PIX-FMT-YUV422P"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p><code class="constant">V4L2_PIX_FMT_YUV422P</code> &#8212; Format with ½ horizontal chroma resolution,
also known as YUV 4:2:2. Planar layout as opposed to
<code class="constant">V4L2_PIX_FMT_YUYV</code></p></div><div class="refsect1"><a name="idp57767712"></a><h2>Description</h2><p>This format is not commonly used. This is a planar
version of the YUYV format. The three components are separated into
three sub-images or planes. The Y plane is first. The Y plane has one
byte per pixel. The Cb plane immediately follows the Y plane in
memory. The Cb plane is half the width of the Y plane (and of the
image). Each Cb belongs to two pixels. For example,
Cb<sub>0</sub> belongs to Y'<sub>00</sub>,
Y'<sub>01</sub>. Following the Cb plane is the Cr plane,
just like the Cb plane.</p><p>If the Y plane has pad bytes after each row, then the Cr
and Cb planes have half as many pad bytes after their rows. In other
words, two Cx rows (including padding) is exactly as long as one Y row
(including padding).</p><div class="example"><a name="idp57813248"></a><p class="title"><b>Example 2.24. <code class="constant">V4L2_PIX_FMT_YUV422P</code> 4 × 4
pixel image</b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte.
		</p><div class="informaltable"><table border="0"><colgroup><col align="left"><col><col><col><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start + 0:</td><td align="center" valign="top">Y'<sub>00</sub></td><td align="center" valign="top">Y'<sub>01</sub></td><td align="center" valign="top">Y'<sub>02</sub></td><td align="center" valign="top">Y'<sub>03</sub></td></tr><tr><td align="left" valign="top">start + 4:</td><td align="center" valign="top">Y'<sub>10</sub></td><td align="center" valign="top">Y'<sub>11</sub></td><td align="center" valign="top">Y'<sub>12</sub></td><td align="center" valign="top">Y'<sub>13</sub></td></tr><tr><td align="left" valign="top">start + 8:</td><td align="center" valign="top">Y'<sub>20</sub></td><td align="center" valign="top">Y'<sub>21</sub></td><td align="center" valign="top">Y'<sub>22</sub></td><td align="center" valign="top">Y'<sub>23</sub></td></tr><tr><td align="left" valign="top">start + 12:</td><td align="center" valign="top">Y'<sub>30</sub></td><td align="center" valign="top">Y'<sub>31</sub></td><td align="center" valign="top">Y'<sub>32</sub></td><td align="center" valign="top">Y'<sub>33</sub></td></tr><tr><td align="left" valign="top">start + 16:</td><td align="center" valign="top">Cb<sub>00</sub></td><td align="center" valign="top">Cb<sub>01</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top">start + 18:</td><td align="center" valign="top">Cb<sub>10</sub></td><td align="center" valign="top">Cb<sub>11</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top">start + 20:</td><td align="center" valign="top">Cb<sub>20</sub></td><td align="center" valign="top">Cb<sub>21</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top">start + 22:</td><td align="center" valign="top">Cb<sub>30</sub></td><td align="center" valign="top">Cb<sub>31</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top">start + 24:</td><td align="center" valign="top">Cr<sub>00</sub></td><td align="center" valign="top">Cr<sub>01</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top">start + 26:</td><td align="center" valign="top">Cr<sub>10</sub></td><td align="center" valign="top">Cr<sub>11</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top">start + 28:</td><td align="center" valign="top">Cr<sub>20</sub></td><td align="center" valign="top">Cr<sub>21</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top">start + 30:</td><td align="center" valign="top">Cr<sub>30</sub></td><td align="center" valign="top">Cr<sub>31</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr></tbody></table></div><p>
	      </p><p><b>Color Sample Location. </b>
		</p><div class="informaltable"><table border="0"><colgroup><col><col><col><col><col><col><col></colgroup><tbody valign="top"><tr><td align="center" valign="top"> </td><td align="center" valign="top">0</td><td align="center" valign="top"> </td><td align="center" valign="top">1</td><td align="center" valign="top"> </td><td align="center" valign="top">2</td><td align="center" valign="top"> </td><td align="center" valign="top">3</td></tr><tr><td align="center" valign="top">0</td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top">1</td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top">2</td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top">3</td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td></tr></tbody></table></div><p>
	      </p></div></div><br class="example-break"></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="V4L2-PIX-FMT-YUV411P"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p><code class="constant">V4L2_PIX_FMT_YUV411P</code> &#8212; Format with ¼ horizontal chroma resolution,
also known as YUV 4:1:1. Planar layout as opposed to
<code class="constant">V4L2_PIX_FMT_Y41P</code></p></div><div class="refsect1"><a name="idp57893344"></a><h2>Description</h2><p>This format is not commonly used. This is a planar
format similar to the 4:2:2 planar format except with half as many
chroma. The three components are separated into three sub-images or
planes. The Y plane is first. The Y plane has one byte per pixel. The
Cb plane immediately follows the Y plane in memory. The Cb plane is
¼ the width of the Y plane (and of the image). Each Cb belongs
to 4 pixels all on the same row. For example,
Cb<sub>0</sub> belongs to Y'<sub>00</sub>,
Y'<sub>01</sub>, Y'<sub>02</sub> and
Y'<sub>03</sub>. Following the Cb plane is the Cr plane,
just like the Cb plane.</p><p>If the Y plane has pad bytes after each row, then the Cr
and Cb planes have ¼ as many pad bytes after their rows. In
other words, four C x rows (including padding) is exactly as long as
one Y row (including padding).</p><div class="example"><a name="idp57939968"></a><p class="title"><b>Example 2.25. <code class="constant">V4L2_PIX_FMT_YUV411P</code> 4 × 4
pixel image</b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte.
		</p><div class="informaltable"><table border="0"><colgroup><col align="left"><col><col><col><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start + 0:</td><td align="center" valign="top">Y'<sub>00</sub></td><td align="center" valign="top">Y'<sub>01</sub></td><td align="center" valign="top">Y'<sub>02</sub></td><td align="center" valign="top">Y'<sub>03</sub></td></tr><tr><td align="left" valign="top">start + 4:</td><td align="center" valign="top">Y'<sub>10</sub></td><td align="center" valign="top">Y'<sub>11</sub></td><td align="center" valign="top">Y'<sub>12</sub></td><td align="center" valign="top">Y'<sub>13</sub></td></tr><tr><td align="left" valign="top">start + 8:</td><td align="center" valign="top">Y'<sub>20</sub></td><td align="center" valign="top">Y'<sub>21</sub></td><td align="center" valign="top">Y'<sub>22</sub></td><td align="center" valign="top">Y'<sub>23</sub></td></tr><tr><td align="left" valign="top">start + 12:</td><td align="center" valign="top">Y'<sub>30</sub></td><td align="center" valign="top">Y'<sub>31</sub></td><td align="center" valign="top">Y'<sub>32</sub></td><td align="center" valign="top">Y'<sub>33</sub></td></tr><tr><td align="left" valign="top">start + 16:</td><td align="center" valign="top">Cb<sub>00</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top">start + 17:</td><td align="center" valign="top">Cb<sub>10</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top">start + 18:</td><td align="center" valign="top">Cb<sub>20</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top">start + 19:</td><td align="center" valign="top">Cb<sub>30</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top">start + 20:</td><td align="center" valign="top">Cr<sub>00</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top">start + 21:</td><td align="center" valign="top">Cr<sub>10</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top">start + 22:</td><td align="center" valign="top">Cr<sub>20</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top">start + 23:</td><td align="center" valign="top">Cr<sub>30</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr></tbody></table></div><p>
	      </p><p><b>Color Sample Location. </b>
		</p><div class="informaltable"><table border="0"><colgroup><col><col><col><col><col><col><col></colgroup><tbody valign="top"><tr><td align="center" valign="top"> </td><td align="center" valign="top">0</td><td align="center" valign="top"> </td><td align="center" valign="top">1</td><td align="center" valign="top"> </td><td align="center" valign="top">2</td><td align="center" valign="top"> </td><td align="center" valign="top">3</td></tr><tr><td align="center" valign="top">0</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top">1</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top">2</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top">3</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top">C</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr></tbody></table></div><p>
	      </p></div></div><br class="example-break"></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="idp58050800"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p><code class="constant">V4L2_PIX_FMT_NV12</code>, <code class="constant">V4L2_PIX_FMT_NV21</code> &#8212; Formats with ½ horizontal and vertical
chroma resolution, also known as YUV 4:2:0. One luminance and one
chrominance plane with alternating chroma samples as opposed to
<code class="constant">V4L2_PIX_FMT_YVU420</code></p></div><div class="refsect1"><a name="idp58052432"></a><h2>Description</h2><p>These are two-plane versions of the YUV 4:2:0 format.
The three components are separated into two sub-images or planes. The
Y plane is first. The Y plane has one byte per pixel. For
<code class="constant">V4L2_PIX_FMT_NV12</code>, a combined CbCr plane
immediately follows the Y plane in memory.  The CbCr plane is the same
width, in bytes, as the Y plane (and of the image), but is half as
tall in pixels. Each CbCr pair belongs to four pixels. For example,
Cb<sub>0</sub>/Cr<sub>0</sub> belongs to
Y'<sub>00</sub>, Y'<sub>01</sub>,
Y'<sub>10</sub>, Y'<sub>11</sub>.
<code class="constant">V4L2_PIX_FMT_NV21</code> is the same except the Cb and
Cr bytes are swapped, the CrCb plane starts with a Cr byte.</p><p>If the Y plane has pad bytes after each row, then the
CbCr plane has as many pad bytes after its rows.</p><div class="example"><a name="idp58057584"></a><p class="title"><b>Example 2.26. <code class="constant">V4L2_PIX_FMT_NV12</code> 4 × 4
pixel image</b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte.
		</p><div class="informaltable"><table border="0"><colgroup><col align="left"><col><col><col><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start + 0:</td><td align="center" valign="top">Y'<sub>00</sub></td><td align="center" valign="top">Y'<sub>01</sub></td><td align="center" valign="top">Y'<sub>02</sub></td><td align="center" valign="top">Y'<sub>03</sub></td></tr><tr><td align="left" valign="top">start + 4:</td><td align="center" valign="top">Y'<sub>10</sub></td><td align="center" valign="top">Y'<sub>11</sub></td><td align="center" valign="top">Y'<sub>12</sub></td><td align="center" valign="top">Y'<sub>13</sub></td></tr><tr><td align="left" valign="top">start + 8:</td><td align="center" valign="top">Y'<sub>20</sub></td><td align="center" valign="top">Y'<sub>21</sub></td><td align="center" valign="top">Y'<sub>22</sub></td><td align="center" valign="top">Y'<sub>23</sub></td></tr><tr><td align="left" valign="top">start + 12:</td><td align="center" valign="top">Y'<sub>30</sub></td><td align="center" valign="top">Y'<sub>31</sub></td><td align="center" valign="top">Y'<sub>32</sub></td><td align="center" valign="top">Y'<sub>33</sub></td></tr><tr><td align="left" valign="top">start + 16:</td><td align="center" valign="top">Cb<sub>00</sub></td><td align="center" valign="top">Cr<sub>00</sub></td><td align="center" valign="top">Cb<sub>01</sub></td><td align="center" valign="top">Cr<sub>01</sub></td></tr><tr><td align="left" valign="top">start + 20:</td><td align="center" valign="top">Cb<sub>10</sub></td><td align="center" valign="top">Cr<sub>10</sub></td><td align="center" valign="top">Cb<sub>11</sub></td><td align="center" valign="top">Cr<sub>11</sub></td></tr></tbody></table></div><p>
	      </p><p><b>Color Sample Location. </b>
		</p><div class="informaltable"><table border="0"><colgroup><col><col><col><col><col><col><col></colgroup><tbody valign="top"><tr><td align="center" valign="top"> </td><td align="center" valign="top">0</td><td align="center" valign="top"> </td><td align="center" valign="top">1</td><td align="center" valign="top"> </td><td align="center" valign="top">2</td><td align="center" valign="top"> </td><td align="center" valign="top">3</td></tr><tr><td align="center" valign="top">0</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td></tr><tr><td align="center" valign="top">1</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="center" valign="top">2</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td></tr><tr><td align="center" valign="top">3</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr></tbody></table></div><p>
	      </p></div></div><br class="example-break"></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="idp58169408"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p><code class="constant">V4L2_PIX_FMT_NV12M</code>, <code class="constant">V4L2_PIX_FMT_NV21M</code>, <code class="constant">V4L2_PIX_FMT_NV12MT_16X16</code> &#8212; Variation of <code class="constant">V4L2_PIX_FMT_NV12</code> and <code class="constant">V4L2_PIX_FMT_NV21</code> with planes
	  non contiguous in memory. </p></div><div class="refsect1"><a name="idp58172288"></a><h2>Description</h2><p>This is a multi-planar, two-plane version of the YUV 4:2:0 format.
The three components are separated into two sub-images or planes.
<code class="constant">V4L2_PIX_FMT_NV12M</code> differs from <code class="constant">V4L2_PIX_FMT_NV12
</code> in that the two planes are non-contiguous in memory, i.e. the chroma
plane do not necessarily immediately follows the luma plane.
The luminance data occupies the first plane. The Y plane has one byte per pixel.
In the second plane there is a chrominance data with alternating chroma samples.
The CbCr plane is the same width, in bytes, as the Y plane (and of the image),
but is half as tall in pixels. Each CbCr pair belongs to four pixels. For example,
Cb<sub>0</sub>/Cr<sub>0</sub> belongs to
Y'<sub>00</sub>, Y'<sub>01</sub>,
Y'<sub>10</sub>, Y'<sub>11</sub>.
<code class="constant">V4L2_PIX_FMT_NV12MT_16X16</code> is the tiled version of
<code class="constant">V4L2_PIX_FMT_NV12M</code> with 16x16 macroblock tiles. Here pixels
are arranged in 16x16 2D tiles and tiles are arranged in linear order in memory.
<code class="constant">V4L2_PIX_FMT_NV21M</code> is the same as <code class="constant">V4L2_PIX_FMT_NV12M</code>
except the Cb and Cr bytes are swapped, the CrCb plane starts with a Cr byte.</p><p><code class="constant">V4L2_PIX_FMT_NV12M</code> is intended to be
used only in drivers and applications that support the multi-planar API,
described in <a class="xref" href="media.html#planar-apis" title="Single- and multi-planar APIs">the section called &#8220;Single- and multi-planar APIs&#8221;</a>. </p><p>If the Y plane has pad bytes after each row, then the
CbCr plane has as many pad bytes after its rows.</p><div class="example"><a name="idp58181232"></a><p class="title"><b>Example 2.27. <code class="constant">V4L2_PIX_FMT_NV12M</code> 4 × 4 pixel image</b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte.
		</p><div class="informaltable"><table border="0"><colgroup><col align="left"><col><col><col><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start0 + 0:</td><td align="center" valign="top">Y'<sub>00</sub></td><td align="center" valign="top">Y'<sub>01</sub></td><td align="center" valign="top">Y'<sub>02</sub></td><td align="center" valign="top">Y'<sub>03</sub></td></tr><tr><td align="left" valign="top">start0 + 4:</td><td align="center" valign="top">Y'<sub>10</sub></td><td align="center" valign="top">Y'<sub>11</sub></td><td align="center" valign="top">Y'<sub>12</sub></td><td align="center" valign="top">Y'<sub>13</sub></td></tr><tr><td align="left" valign="top">start0 + 8:</td><td align="center" valign="top">Y'<sub>20</sub></td><td align="center" valign="top">Y'<sub>21</sub></td><td align="center" valign="top">Y'<sub>22</sub></td><td align="center" valign="top">Y'<sub>23</sub></td></tr><tr><td align="left" valign="top">start0 + 12:</td><td align="center" valign="top">Y'<sub>30</sub></td><td align="center" valign="top">Y'<sub>31</sub></td><td align="center" valign="top">Y'<sub>32</sub></td><td align="center" valign="top">Y'<sub>33</sub></td></tr><tr><td align="left" valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top">start1 + 0:</td><td align="center" valign="top">Cb<sub>00</sub></td><td align="center" valign="top">Cr<sub>00</sub></td><td align="center" valign="top">Cb<sub>01</sub></td><td align="center" valign="top">Cr<sub>01</sub></td></tr><tr><td align="left" valign="top">start1 + 4:</td><td align="center" valign="top">Cb<sub>10</sub></td><td align="center" valign="top">Cr<sub>10</sub></td><td align="center" valign="top">Cb<sub>11</sub></td><td align="center" valign="top">Cr<sub>11</sub></td></tr></tbody></table></div><p>
	      </p><p><b>Color Sample Location. </b>
		</p><div class="informaltable"><table border="0"><colgroup><col><col><col><col><col><col><col></colgroup><tbody valign="top"><tr><td align="center" valign="top"> </td><td align="center" valign="top">0</td><td align="center" valign="top"> </td><td align="center" valign="top">1</td><td align="center" valign="top"> </td><td align="center" valign="top">2</td><td align="center" valign="top"> </td><td align="center" valign="top">3</td></tr><tr><td align="center" valign="top">0</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td></tr><tr><td align="center" valign="top">1</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="center" valign="top">2</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td></tr><tr><td align="center" valign="top">3</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr></tbody></table></div><p>
	      </p></div></div><br class="example-break"></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="idp58299328"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p><code class="constant">V4L2_PIX_FMT_NV12MT
</code> &#8212; Formats with ½ horizontal and vertical
chroma resolution. This format has two planes - one for luminance and one for
chrominance. Chroma samples are interleaved. The difference to
<code class="constant">V4L2_PIX_FMT_NV12</code> is the memory layout. Pixels are
grouped in macroblocks of 64x32 size. The order of macroblocks in memory is
also not standard.
	</p></div><div class="refsect1"><a name="idp58256976"></a><h2>Description</h2><p>This is the two-plane versions of the YUV 4:2:0 format where data
is grouped into 64x32 macroblocks. The three components are separated into two
sub-images or planes. The Y plane has one byte per pixel and pixels are grouped
into 64x32 macroblocks. The CbCr plane has the same width, in bytes, as the Y
plane (and the image), but is half as tall in pixels. The chroma plane is also
grouped into 64x32 macroblocks.</p><p>Width of the buffer has to be aligned to the multiple of 128, and
height alignment is 32. Every four adjacent buffers - two horizontally and two
vertically are grouped together and are located in memory in Z or flipped Z
order. </p><p>Layout of macroblocks in memory is presented in the following
figure.</p><div class="figure"><a name="nv12mt"></a><p class="title"><b>Figure 2.1. <code class="constant">V4L2_PIX_FMT_NV12MT</code> macroblock Z shape
memory layout</b></p><div class="figure-contents"><div class="mediaobject"><img src="nv12mt.gif" alt="V4L2_PIX_FMT_NV12MT macroblock Z shape memory layout"></div></div></div><p><br class="figure-break">
	The requirement that width is multiple of 128 is implemented because,
the Z shape cannot be cut in half horizontally. In case the vertical resolution
of macroblocks is odd then the last row of macroblocks is arranged in a linear
order.  </p><p>In case of chroma the layout is identical. Cb and Cr samples are
interleaved. Height of the buffer is aligned to 32.
	</p><div class="example"><a name="idp58306656"></a><p class="title"><b>Example 2.28. Memory layout of macroblocks in <code class="constant">V4L2_PIX_FMT_NV12
</code> format pixel image - extreme case</b></p><div class="example-contents"><p>
	</p><div class="figure"><a name="nv12mt_ex"></a><p class="title"><b>Figure 2.2. Example <code class="constant">V4L2_PIX_FMT_NV12MT</code> memory
layout of macroblocks</b></p><div class="figure-contents"><div class="mediaobject"><img src="nv12mt_example.gif" alt="Example V4L2_PIX_FMT_NV12MT memory layout of macroblocks"></div></div></div><p><br class="figure-break">
	Memory layout of macroblocks of <code class="constant">V4L2_PIX_FMT_NV12MT
</code> format in most extreme case.
	</p></div></div><br class="example-break"></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="idp58297872"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p><code class="constant">V4L2_PIX_FMT_NV16</code>, <code class="constant">V4L2_PIX_FMT_NV61</code> &#8212; Formats with ½ horizontal
chroma resolution, also known as YUV 4:2:2. One luminance and one
chrominance plane with alternating chroma samples as opposed to
<code class="constant">V4L2_PIX_FMT_YVU420</code></p></div><div class="refsect1"><a name="idp58278336"></a><h2>Description</h2><p>These are two-plane versions of the YUV 4:2:2 format.
The three components are separated into two sub-images or planes. The
Y plane is first. The Y plane has one byte per pixel. For
<code class="constant">V4L2_PIX_FMT_NV16</code>, a combined CbCr plane
immediately follows the Y plane in memory.  The CbCr plane is the same
width and height, in bytes, as the Y plane (and of the image).
Each CbCr pair belongs to two pixels. For example,
Cb<sub>0</sub>/Cr<sub>0</sub> belongs to
Y'<sub>00</sub>, Y'<sub>01</sub>.
<code class="constant">V4L2_PIX_FMT_NV61</code> is the same except the Cb and
Cr bytes are swapped, the CrCb plane starts with a Cr byte.</p><p>If the Y plane has pad bytes after each row, then the
CbCr plane has as many pad bytes after its rows.</p><div class="example"><a name="idp58339824"></a><p class="title"><b>Example 2.29. <code class="constant">V4L2_PIX_FMT_NV16</code> 4 × 4
pixel image</b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte.
		</p><div class="informaltable"><table border="0"><colgroup><col align="left"><col><col><col><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start + 0:</td><td align="center" valign="top">Y'<sub>00</sub></td><td align="center" valign="top">Y'<sub>01</sub></td><td align="center" valign="top">Y'<sub>02</sub></td><td align="center" valign="top">Y'<sub>03</sub></td></tr><tr><td align="left" valign="top">start + 4:</td><td align="center" valign="top">Y'<sub>10</sub></td><td align="center" valign="top">Y'<sub>11</sub></td><td align="center" valign="top">Y'<sub>12</sub></td><td align="center" valign="top">Y'<sub>13</sub></td></tr><tr><td align="left" valign="top">start + 8:</td><td align="center" valign="top">Y'<sub>20</sub></td><td align="center" valign="top">Y'<sub>21</sub></td><td align="center" valign="top">Y'<sub>22</sub></td><td align="center" valign="top">Y'<sub>23</sub></td></tr><tr><td align="left" valign="top">start + 12:</td><td align="center" valign="top">Y'<sub>30</sub></td><td align="center" valign="top">Y'<sub>31</sub></td><td align="center" valign="top">Y'<sub>32</sub></td><td align="center" valign="top">Y'<sub>33</sub></td></tr><tr><td align="left" valign="top">start + 16:</td><td align="center" valign="top">Cb<sub>00</sub></td><td align="center" valign="top">Cr<sub>00</sub></td><td align="center" valign="top">Cb<sub>01</sub></td><td align="center" valign="top">Cr<sub>01</sub></td></tr><tr><td align="left" valign="top">start + 20:</td><td align="center" valign="top">Cb<sub>10</sub></td><td align="center" valign="top">Cr<sub>10</sub></td><td align="center" valign="top">Cb<sub>11</sub></td><td align="center" valign="top">Cr<sub>11</sub></td></tr><tr><td align="left" valign="top">start + 24:</td><td align="center" valign="top">Cb<sub>20</sub></td><td align="center" valign="top">Cr<sub>20</sub></td><td align="center" valign="top">Cb<sub>21</sub></td><td align="center" valign="top">Cr<sub>21</sub></td></tr><tr><td align="left" valign="top">start + 28:</td><td align="center" valign="top">Cb<sub>30</sub></td><td align="center" valign="top">Cr<sub>30</sub></td><td align="center" valign="top">Cb<sub>31</sub></td><td align="center" valign="top">Cr<sub>31</sub></td></tr></tbody></table></div><p>
	      </p><p><b>Color Sample Location. </b>
		</p><div class="informaltable"><table border="0"><colgroup><col><col><col><col><col><col><col></colgroup><tbody valign="top"><tr><td align="center" valign="top"> </td><td align="center" valign="top">0</td><td align="center" valign="top"> </td><td align="center" valign="top">1</td><td align="center" valign="top"> </td><td align="center" valign="top">2</td><td align="center" valign="top"> </td><td align="center" valign="top">3</td></tr><tr><td align="center" valign="top">0</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td></tr><tr><td align="center" valign="top">1</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td></tr><tr><td align="center" valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="center" valign="top">2</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td></tr><tr><td align="center" valign="top">3</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td></tr></tbody></table></div><p>
	      </p></div></div><br class="example-break"></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="idp58473760"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p><code class="constant">V4L2_PIX_FMT_NV16M</code>, <code class="constant">V4L2_PIX_FMT_NV61M</code> &#8212; Variation of <code class="constant">V4L2_PIX_FMT_NV16</code> and <code class="constant">V4L2_PIX_FMT_NV61</code> with planes
	  non contiguous in memory. </p></div><div class="refsect1"><a name="idp58475520"></a><h2>Description</h2><p>This is a multi-planar, two-plane version of the YUV 4:2:2 format.
The three components are separated into two sub-images or planes.
<code class="constant">V4L2_PIX_FMT_NV16M</code> differs from <code class="constant">V4L2_PIX_FMT_NV16
</code> in that the two planes are non-contiguous in memory, i.e. the chroma
plane does not necessarily immediately follow the luma plane.
The luminance data occupies the first plane. The Y plane has one byte per pixel.
In the second plane there is chrominance data with alternating chroma samples.
The CbCr plane is the same width and height, in bytes, as the Y plane.
Each CbCr pair belongs to two pixels. For example,
Cb<sub>0</sub>/Cr<sub>0</sub> belongs to
Y'<sub>00</sub>, Y'<sub>01</sub>.
<code class="constant">V4L2_PIX_FMT_NV61M</code> is the same as <code class="constant">V4L2_PIX_FMT_NV16M</code>
except the Cb and Cr bytes are swapped, the CrCb plane starts with a Cr byte.</p><p><code class="constant">V4L2_PIX_FMT_NV16M</code> and
<code class="constant">V4L2_PIX_FMT_NV61M</code> are intended to be used only in drivers
and applications that support the multi-planar API, described in
<a class="xref" href="media.html#planar-apis" title="Single- and multi-planar APIs">the section called &#8220;Single- and multi-planar APIs&#8221;</a>. </p><div class="example"><a name="idp58482496"></a><p class="title"><b>Example 2.30. <code class="constant">V4L2_PIX_FMT_NV16M</code> 4 × 4 pixel image</b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte.
		</p><div class="informaltable"><table border="0"><colgroup><col align="left"><col><col><col><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start0 + 0:</td><td align="center" valign="top">Y'<sub>00</sub></td><td align="center" valign="top">Y'<sub>01</sub></td><td align="center" valign="top">Y'<sub>02</sub></td><td align="center" valign="top">Y'<sub>03</sub></td></tr><tr><td align="left" valign="top">start0 + 4:</td><td align="center" valign="top">Y'<sub>10</sub></td><td align="center" valign="top">Y'<sub>11</sub></td><td align="center" valign="top">Y'<sub>12</sub></td><td align="center" valign="top">Y'<sub>13</sub></td></tr><tr><td align="left" valign="top">start0 + 8:</td><td align="center" valign="top">Y'<sub>20</sub></td><td align="center" valign="top">Y'<sub>21</sub></td><td align="center" valign="top">Y'<sub>22</sub></td><td align="center" valign="top">Y'<sub>23</sub></td></tr><tr><td align="left" valign="top">start0 + 12:</td><td align="center" valign="top">Y'<sub>30</sub></td><td align="center" valign="top">Y'<sub>31</sub></td><td align="center" valign="top">Y'<sub>32</sub></td><td align="center" valign="top">Y'<sub>33</sub></td></tr><tr><td align="left" valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top">start1 + 0:</td><td align="center" valign="top">Cb<sub>00</sub></td><td align="center" valign="top">Cr<sub>00</sub></td><td align="center" valign="top">Cb<sub>02</sub></td><td align="center" valign="top">Cr<sub>02</sub></td></tr><tr><td align="left" valign="top">start1 + 4:</td><td align="center" valign="top">Cb<sub>10</sub></td><td align="center" valign="top">Cr<sub>10</sub></td><td align="center" valign="top">Cb<sub>12</sub></td><td align="center" valign="top">Cr<sub>12</sub></td></tr><tr><td align="left" valign="top">start1 + 8:</td><td align="center" valign="top">Cb<sub>20</sub></td><td align="center" valign="top">Cr<sub>20</sub></td><td align="center" valign="top">Cb<sub>22</sub></td><td align="center" valign="top">Cr<sub>22</sub></td></tr><tr><td align="left" valign="top">start1 + 12:</td><td align="center" valign="top">Cb<sub>30</sub></td><td align="center" valign="top">Cr<sub>30</sub></td><td align="center" valign="top">Cb<sub>32</sub></td><td align="center" valign="top">Cr<sub>32</sub></td></tr></tbody></table></div><p>
	      </p><p><b>Color Sample Location. </b>
		</p><div class="informaltable"><table border="0"><colgroup><col><col><col><col><col><col><col></colgroup><tbody valign="top"><tr><td align="center" valign="top"> </td><td align="center" valign="top">0</td><td align="center" valign="top"> </td><td align="center" valign="top">1</td><td align="center" valign="top"> </td><td align="center" valign="top">2</td><td align="center" valign="top"> </td><td align="center" valign="top">3</td></tr><tr><td align="center" valign="top">0</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td></tr><tr><td align="center" valign="top">1</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td></tr><tr><td align="center" valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="center" valign="top">2</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td></tr><tr><td align="center" valign="top">3</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td></tr></tbody></table></div><p>
	      </p></div></div><br class="example-break"></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="idp58620656"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p><code class="constant">V4L2_PIX_FMT_NV24</code>, <code class="constant">V4L2_PIX_FMT_NV42</code> &#8212; Formats with full horizontal and vertical
chroma resolutions, also known as YUV 4:4:4. One luminance and one
chrominance plane with alternating chroma samples as opposed to
<code class="constant">V4L2_PIX_FMT_YVU420</code></p></div><div class="refsect1"><a name="idp58622048"></a><h2>Description</h2><p>These are two-plane versions of the YUV 4:4:4 format. The three
	components are separated into two sub-images or planes. The Y plane is
	first, with each Y sample stored in one byte per pixel. For
	<code class="constant">V4L2_PIX_FMT_NV24</code>, a combined CbCr plane
	immediately follows the Y plane in memory. The CbCr plane has the same
	width and height, in pixels, as the Y plane (and the image). Each line
	contains one CbCr pair per pixel, with each Cb and Cr sample stored in
	one byte. <code class="constant">V4L2_PIX_FMT_NV42</code> is the same except that
	the Cb and Cr samples are swapped, the CrCb plane starts with a Cr
	sample.</p><p>If the Y plane has pad bytes after each row, then the CbCr plane
	has twice as many pad bytes after its rows.</p><div class="example"><a name="idp58624944"></a><p class="title"><b>Example 2.31. <code class="constant">V4L2_PIX_FMT_NV24</code> 4 × 4
pixel image</b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte.
		</p><div class="informaltable"><table border="0"><colgroup><col align="left"><col><col><col><col><col><col><col><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start + 0:</td><td align="center" valign="top">Y'<sub>00</sub></td><td align="center" valign="top">Y'<sub>01</sub></td><td align="center" valign="top">Y'<sub>02</sub></td><td align="center" valign="top">Y'<sub>03</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top">start + 4:</td><td align="center" valign="top">Y'<sub>10</sub></td><td align="center" valign="top">Y'<sub>11</sub></td><td align="center" valign="top">Y'<sub>12</sub></td><td align="center" valign="top">Y'<sub>13</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top">start + 8:</td><td align="center" valign="top">Y'<sub>20</sub></td><td align="center" valign="top">Y'<sub>21</sub></td><td align="center" valign="top">Y'<sub>22</sub></td><td align="center" valign="top">Y'<sub>23</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top">start + 12:</td><td align="center" valign="top">Y'<sub>30</sub></td><td align="center" valign="top">Y'<sub>31</sub></td><td align="center" valign="top">Y'<sub>32</sub></td><td align="center" valign="top">Y'<sub>33</sub></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="left" valign="top">start + 16:</td><td align="center" valign="top">Cb<sub>00</sub></td><td align="center" valign="top">Cr<sub>00</sub></td><td align="center" valign="top">Cb<sub>01</sub></td><td align="center" valign="top">Cr<sub>01</sub></td><td align="center" valign="top">Cb<sub>02</sub></td><td align="center" valign="top">Cr<sub>02</sub></td><td align="center" valign="top">Cb<sub>03</sub></td><td align="center" valign="top">Cr<sub>03</sub></td></tr><tr><td align="left" valign="top">start + 24:</td><td align="center" valign="top">Cb<sub>10</sub></td><td align="center" valign="top">Cr<sub>10</sub></td><td align="center" valign="top">Cb<sub>11</sub></td><td align="center" valign="top">Cr<sub>11</sub></td><td align="center" valign="top">Cb<sub>12</sub></td><td align="center" valign="top">Cr<sub>12</sub></td><td align="center" valign="top">Cb<sub>13</sub></td><td align="center" valign="top">Cr<sub>13</sub></td></tr><tr><td align="left" valign="top">start + 32:</td><td align="center" valign="top">Cb<sub>20</sub></td><td align="center" valign="top">Cr<sub>20</sub></td><td align="center" valign="top">Cb<sub>21</sub></td><td align="center" valign="top">Cr<sub>21</sub></td><td align="center" valign="top">Cb<sub>22</sub></td><td align="center" valign="top">Cr<sub>22</sub></td><td align="center" valign="top">Cb<sub>23</sub></td><td align="center" valign="top">Cr<sub>23</sub></td></tr><tr><td align="left" valign="top">start + 40:</td><td align="center" valign="top">Cb<sub>30</sub></td><td align="center" valign="top">Cr<sub>30</sub></td><td align="center" valign="top">Cb<sub>31</sub></td><td align="center" valign="top">Cr<sub>31</sub></td><td align="center" valign="top">Cb<sub>32</sub></td><td align="center" valign="top">Cr<sub>32</sub></td><td align="center" valign="top">Cb<sub>33</sub></td><td align="center" valign="top">Cr<sub>33</sub></td></tr></tbody></table></div><p>
	      </p></div></div><br class="example-break"></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="V4L2-PIX-FMT-M420"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p><code class="constant">V4L2_PIX_FMT_M420</code> &#8212; Format with ½ horizontal and vertical chroma
	resolution, also known as YUV 4:2:0. Hybrid plane line-interleaved
	layout.</p></div><div class="refsect1"><a name="idp58685328"></a><h2>Description</h2><p>M420 is a YUV format with ½ horizontal and vertical chroma
	subsampling (YUV 4:2:0). Pixels are organized as interleaved luma and
	chroma planes. Two lines of luma data are followed by one line of chroma
	data.</p><p>The luma plane has one byte per pixel. The chroma plane contains
	interleaved CbCr pixels subsampled by ½ in the horizontal and
	vertical directions. Each CbCr pair belongs to four pixels. For example,
Cb<sub>0</sub>/Cr<sub>0</sub> belongs to
Y'<sub>00</sub>, Y'<sub>01</sub>,
Y'<sub>10</sub>, Y'<sub>11</sub>.</p><p>All line lengths are identical: if the Y lines include pad bytes
	so do the CbCr lines.</p><div class="example"><a name="idp58732576"></a><p class="title"><b>Example 2.32. <code class="constant">V4L2_PIX_FMT_M420</code> 4 × 4
pixel image</b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte.
		</p><div class="informaltable"><table border="0"><colgroup><col align="left"><col><col><col><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start + 0:</td><td align="center" valign="top">Y'<sub>00</sub></td><td align="center" valign="top">Y'<sub>01</sub></td><td align="center" valign="top">Y'<sub>02</sub></td><td align="center" valign="top">Y'<sub>03</sub></td></tr><tr><td align="left" valign="top">start + 4:</td><td align="center" valign="top">Y'<sub>10</sub></td><td align="center" valign="top">Y'<sub>11</sub></td><td align="center" valign="top">Y'<sub>12</sub></td><td align="center" valign="top">Y'<sub>13</sub></td></tr><tr><td align="left" valign="top">start + 8:</td><td align="center" valign="top">Cb<sub>00</sub></td><td align="center" valign="top">Cr<sub>00</sub></td><td align="center" valign="top">Cb<sub>01</sub></td><td align="center" valign="top">Cr<sub>01</sub></td></tr><tr><td align="left" valign="top">start + 16:</td><td align="center" valign="top">Y'<sub>20</sub></td><td align="center" valign="top">Y'<sub>21</sub></td><td align="center" valign="top">Y'<sub>22</sub></td><td align="center" valign="top">Y'<sub>23</sub></td></tr><tr><td align="left" valign="top">start + 20:</td><td align="center" valign="top">Y'<sub>30</sub></td><td align="center" valign="top">Y'<sub>31</sub></td><td align="center" valign="top">Y'<sub>32</sub></td><td align="center" valign="top">Y'<sub>33</sub></td></tr><tr><td align="left" valign="top">start + 24:</td><td align="center" valign="top">Cb<sub>10</sub></td><td align="center" valign="top">Cr<sub>10</sub></td><td align="center" valign="top">Cb<sub>11</sub></td><td align="center" valign="top">Cr<sub>11</sub></td></tr></tbody></table></div><p>
	      </p><p><b>Color Sample Location. </b>
		</p><div class="informaltable"><table border="0"><colgroup><col><col><col><col><col><col><col></colgroup><tbody valign="top"><tr><td align="center" valign="top"> </td><td align="center" valign="top">0</td><td align="center" valign="top"> </td><td align="center" valign="top">1</td><td align="center" valign="top"> </td><td align="center" valign="top">2</td><td align="center" valign="top"> </td><td align="center" valign="top">3</td></tr><tr><td align="center" valign="top">0</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td></tr><tr><td align="center" valign="top">1</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td align="center" valign="top">2</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr><tr><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top"> </td><td align="center" valign="top">C</td><td align="center" valign="top"> </td></tr><tr><td align="center" valign="top">3</td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td><td align="center" valign="top"> </td><td align="center" valign="top">Y</td></tr></tbody></table></div><p>
	      </p></div></div><br class="example-break"></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp58796032"></a>Compressed Formats</h2></div></div></div><div class="table"><a name="compressed-formats"></a><p class="title"><b>Table 2.19. Compressed Image Formats</b></p><div class="table-contents"><table summary="Compressed Image Formats" width="100%" border="0"><colgroup><col align="left" class="c1"><col align="left" class="c2"><col align="left" class="c3"></colgroup><thead><tr><th align="left">Identifier</th><th align="left">Code</th><th align="left">Details</th></tr></thead><tbody valign="top"><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-JPEG"></a><code class="constant">V4L2_PIX_FMT_JPEG</code></td><td align="left" valign="top">'JPEG'</td><td align="left" valign="top">TBD. See also <a class="link" href="media.html#vidioc-g-jpegcomp" title="ioctl VIDIOC_G_JPEGCOMP, VIDIOC_S_JPEGCOMP"><code class="constant">VIDIOC_G_JPEGCOMP</code></a>,
	    <a class="link" href="media.html#vidioc-g-jpegcomp" title="ioctl VIDIOC_G_JPEGCOMP, VIDIOC_S_JPEGCOMP"><code class="constant">VIDIOC_S_JPEGCOMP</code></a>.</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-MPEG"></a><code class="constant">V4L2_PIX_FMT_MPEG</code></td><td align="left" valign="top">'MPEG'</td><td align="left" valign="top">MPEG multiplexed stream. The actual format is determined by
extended control <code class="constant">V4L2_CID_MPEG_STREAM_TYPE</code>, see
<a class="xref" href="media.html#mpeg-control-id" title="Table 1.2. Codec Control IDs">Table 1.2, &#8220;Codec Control IDs&#8221;</a>.</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-H264"></a><code class="constant">V4L2_PIX_FMT_H264</code></td><td align="left" valign="top">'H264'</td><td align="left" valign="top">H264 video elementary stream with start codes.</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-H264-NO-SC"></a><code class="constant">V4L2_PIX_FMT_H264_NO_SC</code></td><td align="left" valign="top">'AVC1'</td><td align="left" valign="top">H264 video elementary stream without start codes.</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-H264-MVC"></a><code class="constant">V4L2_PIX_FMT_H264_MVC</code></td><td align="left" valign="top">'M264'</td><td align="left" valign="top">H264 MVC video elementary stream.</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-H263"></a><code class="constant">V4L2_PIX_FMT_H263</code></td><td align="left" valign="top">'H263'</td><td align="left" valign="top">H263 video elementary stream.</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-MPEG1"></a><code class="constant">V4L2_PIX_FMT_MPEG1</code></td><td align="left" valign="top">'MPG1'</td><td align="left" valign="top">MPEG1 video elementary stream.</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-MPEG2"></a><code class="constant">V4L2_PIX_FMT_MPEG2</code></td><td align="left" valign="top">'MPG2'</td><td align="left" valign="top">MPEG2 video elementary stream.</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-MPEG4"></a><code class="constant">V4L2_PIX_FMT_MPEG4</code></td><td align="left" valign="top">'MPG4'</td><td align="left" valign="top">MPEG4 video elementary stream.</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-XVID"></a><code class="constant">V4L2_PIX_FMT_XVID</code></td><td align="left" valign="top">'XVID'</td><td align="left" valign="top">Xvid video elementary stream.</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-VC1-ANNEX-G"></a><code class="constant">V4L2_PIX_FMT_VC1_ANNEX_G</code></td><td align="left" valign="top">'VC1G'</td><td align="left" valign="top">VC1, SMPTE 421M Annex G compliant stream.</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-VC1-ANNEX-L"></a><code class="constant">V4L2_PIX_FMT_VC1_ANNEX_L</code></td><td align="left" valign="top">'VC1L'</td><td align="left" valign="top">VC1, SMPTE 421M Annex L compliant stream.</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-VP8"></a><code class="constant">V4L2_PIX_FMT_VP8</code></td><td align="left" valign="top">'VP80'</td><td align="left" valign="top">VP8 video elementary stream.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sdr-formats"></a>SDR Formats</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="refentrytitle"><a href="media.html#V4L2-SDR-FMT-CU08">V4L2_SDR_FMT_CU8 ('CU08')</a></span><span class="refpurpose"> &#8212; Complex unsigned 8-bit IQ sample</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-SDR-FMT-CU16LE">V4L2_SDR_FMT_CU16LE ('CU16')</a></span><span class="refpurpose"> &#8212; Complex unsigned 16-bit little endian IQ sample</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-SDR-FMT-CS08">V4L2_SDR_FMT_CS8 ('CS08')</a></span><span class="refpurpose"> &#8212; Complex signed 8-bit IQ sample</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-SDR-FMT-CS14LE">V4L2_SDR_FMT_CS14LE ('CS14')</a></span><span class="refpurpose"> &#8212; Complex signed 14-bit little endian IQ sample</span></dt><dt><span class="refentrytitle"><a href="media.html#V4L2-SDR-FMT-RU12LE">V4L2_SDR_FMT_RU12LE ('RU12')</a></span><span class="refpurpose"> &#8212; Real unsigned 12-bit little endian sample</span></dt></dl></div><p>These formats are used for <a class="link" href="media.html#sdr" title="Software Defined Radio Interface (SDR)">SDR Capture</a>
interface only.</p><div class="refentry"><a name="V4L2-SDR-FMT-CU08"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>
        <code class="constant">V4L2_SDR_FMT_CU8</code>
       &#8212; Complex unsigned 8-bit IQ sample</p></div><div class="refsect1"><a name="idp58845120"></a><h2>Description</h2><p>
This format contains sequence of complex number samples. Each complex number
consist two parts, called In-phase and Quadrature (IQ). Both I and Q are
represented as a 8 bit unsigned number. I value comes first and Q value after
that.
      </p><div class="example"><a name="idp58889216"></a><p class="title"><b>Example 2.33. <code class="constant">V4L2_SDR_FMT_CU8</code> 1 sample</b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte.
          </p><div class="informaltable"><table border="0"><colgroup><col align="left"><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start + 0:</td><td align="center" valign="top">I'<sub>0</sub></td></tr><tr><td align="left" valign="top">start + 1:</td><td align="center" valign="top">Q'<sub>0</sub></td></tr></tbody></table></div><p>
        </p></div></div><br class="example-break"></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="V4L2-SDR-FMT-CU16LE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>
        <code class="constant">V4L2_SDR_FMT_CU16LE</code>
       &#8212; Complex unsigned 16-bit little endian IQ sample</p></div><div class="refsect1"><a name="idp58863232"></a><h2>Description</h2><p>
This format contains sequence of complex number samples. Each complex number
consist two parts, called In-phase and Quadrature (IQ). Both I and Q are
represented as a 16 bit unsigned little endian number. I value comes first
and Q value after that.
      </p><div class="example"><a name="idp58883200"></a><p class="title"><b>Example 2.34. <code class="constant">V4L2_SDR_FMT_CU16LE</code> 1 sample</b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte.
          </p><div class="informaltable"><table border="0"><colgroup><col align="left"><col><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start + 0:</td><td align="center" valign="top">I'<sub>0[7:0]</sub></td><td align="center" valign="top">I'<sub>0[15:8]</sub></td></tr><tr><td align="left" valign="top">start + 2:</td><td align="center" valign="top">Q'<sub>0[7:0]</sub></td><td align="center" valign="top">Q'<sub>0[15:8]</sub></td></tr></tbody></table></div><p>
        </p></div></div><br class="example-break"></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="V4L2-SDR-FMT-CS08"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>
        <code class="constant">V4L2_SDR_FMT_CS8</code>
       &#8212; Complex signed 8-bit IQ sample</p></div><div class="refsect1"><a name="idp58898320"></a><h2>Description</h2><p>
This format contains sequence of complex number samples. Each complex number
consist two parts, called In-phase and Quadrature (IQ). Both I and Q are
represented as a 8 bit signed number. I value comes first and Q value after
that.
      </p><div class="example"><a name="idp58899632"></a><p class="title"><b>Example 2.35. <code class="constant">V4L2_SDR_FMT_CS8</code> 1 sample</b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte.
          </p><div class="informaltable"><table border="0"><colgroup><col align="left"><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start + 0:</td><td align="center" valign="top">I'<sub>0</sub></td></tr><tr><td align="left" valign="top">start + 1:</td><td align="center" valign="top">Q'<sub>0</sub></td></tr></tbody></table></div><p>
        </p></div></div><br class="example-break"></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="V4L2-SDR-FMT-CS14LE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>
        <code class="constant">V4L2_SDR_FMT_CS14LE</code>
       &#8212; Complex signed 14-bit little endian IQ sample</p></div><div class="refsect1"><a name="idp58949520"></a><h2>Description</h2><p>
This format contains sequence of complex number samples. Each complex number
consist two parts, called In-phase and Quadrature (IQ). Both I and Q are
represented as a 14 bit signed little endian number. I value comes first
and Q value after that. 14 bit value is stored in 16 bit space with unused
high bits padded with 0.
      </p><div class="example"><a name="idp58950928"></a><p class="title"><b>Example 2.36. <code class="constant">V4L2_SDR_FMT_CS14LE</code> 1 sample</b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte.
          </p><div class="informaltable"><table border="0"><colgroup><col align="left"><col><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start + 0:</td><td align="center" valign="top">I'<sub>0[7:0]</sub></td><td align="center" valign="top">I'<sub>0[13:8]</sub></td></tr><tr><td align="left" valign="top">start + 2:</td><td align="center" valign="top">Q'<sub>0[7:0]</sub></td><td align="center" valign="top">Q'<sub>0[13:8]</sub></td></tr></tbody></table></div><p>
        </p></div></div><br class="example-break"></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="V4L2-SDR-FMT-RU12LE"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>
        <code class="constant">V4L2_SDR_FMT_RU12LE</code>
       &#8212; Real unsigned 12-bit little endian sample</p></div><div class="refsect1"><a name="idp58957280"></a><h2>Description</h2><p>
This format contains sequence of real number samples. Each sample is
represented as a 12 bit unsigned little endian number. Sample is stored
in 16 bit space with unused high bits padded with 0.
      </p><div class="example"><a name="idp58958560"></a><p class="title"><b>Example 2.37. <code class="constant">V4L2_SDR_FMT_RU12LE</code> 1 sample</b></p><div class="example-contents"><p><b>Byte Order. </b>Each cell is one byte.
          </p><div class="informaltable"><table border="0"><colgroup><col align="left"><col><col></colgroup><tbody valign="top"><tr><td align="left" valign="top">start + 0:</td><td align="center" valign="top">I'<sub>0[7:0]</sub></td><td align="center" valign="top">I'<sub>0[11:8]</sub></td></tr></tbody></table></div><p>
        </p></div></div><br class="example-break"></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="pixfmt-reserved"></a>Reserved Format Identifiers</h2></div></div></div><p>These formats are not defined by this specification, they
are just listed for reference and to avoid naming conflicts. If you
want to register your own format, send an e-mail to the linux-media mailing
list <a class="ulink" href="http://www.linuxtv.org/lists.php" target="_top">http://www.linuxtv.org/lists.php</a> for inclusion in the <code class="filename">videodev2.h</code>
file. If you want to share your format with other developers add a
link to your documentation and send a copy to the linux-media mailing list
for inclusion in this section. If you think your format should be listed
in a standard format section please make a proposal on the linux-media mailing
list.</p><div class="table"><a name="reserved-formats"></a><p class="title"><b>Table 2.20. Reserved Image Formats</b></p><div class="table-contents"><table summary="Reserved Image Formats" width="100%" border="0"><colgroup><col align="left" class="c1"><col align="left" class="c2"><col align="left" class="c3"></colgroup><thead><tr><th align="left">Identifier</th><th align="left">Code</th><th align="left">Details</th></tr></thead><tbody valign="top"><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-DV"></a><code class="constant">V4L2_PIX_FMT_DV</code></td><td align="left" valign="top">'dvsd'</td><td align="left" valign="top">unknown</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-ET61X251"></a><code class="constant">V4L2_PIX_FMT_ET61X251</code></td><td align="left" valign="top">'E625'</td><td align="left" valign="top">Compressed format of the ET61X251 driver.</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-HI240"></a><code class="constant">V4L2_PIX_FMT_HI240</code></td><td align="left" valign="top">'HI24'</td><td align="left" valign="top"><p>8 bit RGB format used by the BTTV driver.</p></td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-HM12"></a><code class="constant">V4L2_PIX_FMT_HM12</code></td><td align="left" valign="top">'HM12'</td><td align="left" valign="top"><p>YUV 4:2:0 format used by the
IVTV driver, <a class="ulink" href="http://www.ivtvdriver.org/" target="_top">
http://www.ivtvdriver.org/</a></p><p>The format is documented in the
kernel sources in the file <code class="filename">Documentation/video4linux/cx2341x/README.hm12</code>
</p></td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-CPIA1"></a><code class="constant">V4L2_PIX_FMT_CPIA1</code></td><td align="left" valign="top">'CPIA'</td><td align="left" valign="top">YUV format used by the gspca cpia1 driver.</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-JPGL"></a><code class="constant">V4L2_PIX_FMT_JPGL</code></td><td align="left" valign="top">'JPGL'</td><td align="left" valign="top">JPEG-Light format (Pegasus Lossless JPEG)
			used in Divio webcams NW 80x.</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-SPCA501"></a><code class="constant">V4L2_PIX_FMT_SPCA501</code></td><td align="left" valign="top">'S501'</td><td align="left" valign="top">YUYV per line used by the gspca driver.</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-SPCA505"></a><code class="constant">V4L2_PIX_FMT_SPCA505</code></td><td align="left" valign="top">'S505'</td><td align="left" valign="top">YYUV per line used by the gspca driver.</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-SPCA508"></a><code class="constant">V4L2_PIX_FMT_SPCA508</code></td><td align="left" valign="top">'S508'</td><td align="left" valign="top">YUVY per line used by the gspca driver.</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-SPCA561"></a><code class="constant">V4L2_PIX_FMT_SPCA561</code></td><td align="left" valign="top">'S561'</td><td align="left" valign="top">Compressed GBRG Bayer format used by the gspca driver.</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-PAC207"></a><code class="constant">V4L2_PIX_FMT_PAC207</code></td><td align="left" valign="top">'P207'</td><td align="left" valign="top">Compressed BGGR Bayer format used by the gspca driver.</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-MR97310A"></a><code class="constant">V4L2_PIX_FMT_MR97310A</code></td><td align="left" valign="top">'M310'</td><td align="left" valign="top">Compressed BGGR Bayer format used by the gspca driver.</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-JL2005BCD"></a><code class="constant">V4L2_PIX_FMT_JL2005BCD</code></td><td align="left" valign="top">'JL20'</td><td align="left" valign="top">JPEG compressed RGGB Bayer format used by the gspca driver.</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-OV511"></a><code class="constant">V4L2_PIX_FMT_OV511</code></td><td align="left" valign="top">'O511'</td><td align="left" valign="top">OV511 JPEG format used by the gspca driver.</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-OV518"></a><code class="constant">V4L2_PIX_FMT_OV518</code></td><td align="left" valign="top">'O518'</td><td align="left" valign="top">OV518 JPEG format used by the gspca driver.</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-PJPG"></a><code class="constant">V4L2_PIX_FMT_PJPG</code></td><td align="left" valign="top">'PJPG'</td><td align="left" valign="top">Pixart 73xx JPEG format used by the gspca driver.</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-SE401"></a><code class="constant">V4L2_PIX_FMT_SE401</code></td><td align="left" valign="top">'S401'</td><td align="left" valign="top">Compressed RGB format used by the gspca se401 driver</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-SQ905C"></a><code class="constant">V4L2_PIX_FMT_SQ905C</code></td><td align="left" valign="top">'905C'</td><td align="left" valign="top">Compressed RGGB bayer format used by the gspca driver.</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-MJPEG"></a><code class="constant">V4L2_PIX_FMT_MJPEG</code></td><td align="left" valign="top">'MJPG'</td><td align="left" valign="top">Compressed format used by the Zoran driver</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-PWC1"></a><code class="constant">V4L2_PIX_FMT_PWC1</code></td><td align="left" valign="top">'PWC1'</td><td align="left" valign="top">Compressed format of the PWC driver.</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-PWC2"></a><code class="constant">V4L2_PIX_FMT_PWC2</code></td><td align="left" valign="top">'PWC2'</td><td align="left" valign="top">Compressed format of the PWC driver.</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-SN9C10X"></a><code class="constant">V4L2_PIX_FMT_SN9C10X</code></td><td align="left" valign="top">'S910'</td><td align="left" valign="top">Compressed format of the SN9C102 driver.</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-SN9C20X-I420"></a><code class="constant">V4L2_PIX_FMT_SN9C20X_I420</code></td><td align="left" valign="top">'S920'</td><td align="left" valign="top">YUV 4:2:0 format of the gspca sn9c20x driver.</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-SN9C2028"></a><code class="constant">V4L2_PIX_FMT_SN9C2028</code></td><td align="left" valign="top">'SONX'</td><td align="left" valign="top">Compressed GBRG bayer format of the gspca sn9c2028 driver.</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-STV0680"></a><code class="constant">V4L2_PIX_FMT_STV0680</code></td><td align="left" valign="top">'S680'</td><td align="left" valign="top">Bayer format of the gspca stv0680 driver.</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-WNVA"></a><code class="constant">V4L2_PIX_FMT_WNVA</code></td><td align="left" valign="top">'WNVA'</td><td align="left" valign="top"><p>Used by the Winnov Videum driver, <a class="ulink" href="http://www.thedirks.org/winnov/" target="_top">
http://www.thedirks.org/winnov/</a></p></td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-TM6000"></a><code class="constant">V4L2_PIX_FMT_TM6000</code></td><td align="left" valign="top">'TM60'</td><td align="left" valign="top"><p>Used by Trident tm6000</p></td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-CIT-YYVYUY"></a><code class="constant">V4L2_PIX_FMT_CIT_YYVYUY</code></td><td align="left" valign="top">'CITV'</td><td align="left" valign="top"><p>Used by xirlink CIT, found at IBM webcams.</p>
	           <p>Uses one line of Y then 1 line of VYUY</p>
	    </td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-KONICA420"></a><code class="constant">V4L2_PIX_FMT_KONICA420</code></td><td align="left" valign="top">'KONI'</td><td align="left" valign="top"><p>Used by Konica webcams.</p>
	           <p>YUV420 planar in blocks of 256 pixels.</p>
	    </td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-YYUV"></a><code class="constant">V4L2_PIX_FMT_YYUV</code></td><td align="left" valign="top">'YYUV'</td><td align="left" valign="top">unknown</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-Y4"></a><code class="constant">V4L2_PIX_FMT_Y4</code></td><td align="left" valign="top">'Y04 '</td><td align="left" valign="top">Old 4-bit greyscale format. Only the most significant 4 bits of each byte are used,
the other bits are set to 0.</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-Y6"></a><code class="constant">V4L2_PIX_FMT_Y6</code></td><td align="left" valign="top">'Y06 '</td><td align="left" valign="top">Old 6-bit greyscale format. Only the most significant 6 bits of each byte are used,
the other bits are set to 0.</td></tr><tr><td align="left" valign="top"><a name="V4L2-PIX-FMT-S5C-UYVY-JPG"></a><code class="constant">V4L2_PIX_FMT_S5C_UYVY_JPG</code></td><td align="left" valign="top">'S5CI'</td><td align="left" valign="top">Two-planar format used by Samsung S5C73MX cameras. The
first plane contains interleaved JPEG and UYVY image data, followed by meta data
in form of an array of offsets to the UYVY data blocks. The actual pointer array
follows immediately the interleaved JPEG/UYVY data, the number of entries in
this array equals the height of the UYVY image. Each entry is a 4-byte unsigned
integer in big endian order and it's an offset to a single pixel line of the
UYVY image. The first plane can start either with JPEG or UYVY data chunk. The
size of a single UYVY block equals the UYVY image's width multiplied by 2. The
size of a JPEG chunk depends on the image and can vary with each line.
<p>The second plane, at an offset of 4084 bytes, contains a 4-byte offset to
the pointer array in the first plane. This offset is followed by a 4-byte value
indicating size of the pointer array. All numbers in the second plane are also
in big endian order. Remaining data in the second plane is undefined. The
information in the second plane allows to easily find location of the pointer
array, which can be different for each frame. The size of the pointer array is
constant for given UYVY image height.</p>
<p>In order to extract UYVY and JPEG frames an application can initially set
a data pointer to the start of first plane and then add an offset from the first
entry of the pointers table. Such a pointer indicates start of an UYVY image
pixel line. Whole UYVY line can be copied to a separate buffer. These steps
should be repeated for each line, i.e. the number of entries in the pointer
array. Anything what's in between the UYVY lines is JPEG data and should be
concatenated to form the JPEG stream. </p>
</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="format-flags"></a><p class="title"><b>Table 2.21. Format Flags</b></p><div class="table-contents"><table summary="Format Flags" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_PIX_FMT_FLAG_PREMUL_ALPHA</code></td><td valign="top">0x00000001</td><td valign="top">The color values are premultiplied by the alpha channel
value. For example, if a light blue pixel with 50% transparency was described by
RGBA values (128, 192, 255, 128), the same pixel described with premultiplied
colors would be described by RGBA values (64, 96, 128, 128) </td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="io"></a>Chapter 3. Input/Output</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="media.html#rw">Read/Write</a></span></dt><dt><span class="section"><a href="media.html#mmap">Streaming I/O (Memory Mapping)</a></span></dt><dt><span class="section"><a href="media.html#userp">Streaming I/O (User Pointers)</a></span></dt><dt><span class="section"><a href="media.html#dmabuf">Streaming I/O (DMA buffer importing)</a></span></dt><dt><span class="section"><a href="media.html#async">Asynchronous I/O</a></span></dt><dt><span class="section"><a href="media.html#buffer">Buffers</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp62487856">Timecodes</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#field-order">Field Order</a></span></dt></dl></div><p>The V4L2 API defines several different methods to read from or
write to a device. All drivers exchanging data with applications must
support at least one of them.</p><p>The classic I/O method using the <code class="function">read()</code>
and <code class="function">write()</code> function is automatically selected
after opening a V4L2 device. When the driver does not support this
method attempts to read or write will fail at any time.</p><p>Other methods must be negotiated. To select the streaming I/O
method with memory mapped or user buffers applications call the
<a class="link" href="media.html#vidioc-reqbufs" title="ioctl VIDIOC_REQBUFS"><code class="constant">VIDIOC_REQBUFS</code></a> ioctl. The asynchronous I/O method is not defined
yet.</p><p>Video overlay can be considered another I/O method, although
the application does not directly receive the image data. It is
selected by initiating video overlay with the <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> ioctl.
For more information see <a class="xref" href="media.html#overlay" title="Video Overlay Interface">the section called &#8220;Video Overlay Interface&#8221;</a>.</p><p>Generally exactly one I/O method, including overlay, is
associated with each file descriptor. The only exceptions are
applications not exchanging data with a driver ("panel applications",
see <a class="xref" href="media.html#open" title="Opening and Closing Devices">the section called &#8220;Opening and Closing Devices&#8221;</a>) and drivers permitting simultaneous video capturing
and overlay using the same file descriptor, for compatibility with V4L
and earlier versions of V4L2.</p><p><code class="constant">VIDIOC_S_FMT</code> and
<code class="constant">VIDIOC_REQBUFS</code> would permit this to some degree,
but for simplicity drivers need not support switching the I/O method
(after first switching away from read/write) other than by closing
and reopening the device.</p><p>The following sections describe the various I/O methods in
more detail.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="rw"></a>Read/Write</h2></div></div></div><p>Input and output devices support the
<code class="function">read()</code> and <code class="function">write()</code> function,
respectively, when the <code class="constant">V4L2_CAP_READWRITE</code> flag in
the <em class="structfield"><code>capabilities</code></em> field of struct <a class="link" href="media.html#v4l2-capability" title="Table A.92. struct v4l2_capability">v4l2_capability</a>
returned by the <a class="link" href="media.html#vidioc-querycap" title="ioctl VIDIOC_QUERYCAP"><code class="constant">VIDIOC_QUERYCAP</code></a> ioctl is set.</p><p>Drivers may need the CPU to copy the data, but they may also
support DMA to or from user memory, so this I/O method is not
necessarily less efficient than other methods merely exchanging buffer
pointers. It is considered inferior though because no meta-information
like frame counters or timestamps are passed. This information is
necessary to recognize frame dropping and to synchronize with other
data streams. However this is also the simplest I/O method, requiring
little or no setup to exchange data. It permits command line stunts
like this (the <span class="application">vidctrl</span> tool is
fictitious):</p><div class="informalexample"><pre class="screen">
&gt; vidctrl /dev/video --input=0 --format=YUYV --size=352x288
&gt; dd if=/dev/video of=myimage.422 bs=202752 count=1
</pre></div><p>To read from the device applications use the
<a class="link" href="media.html#func-read" title="V4L2 read()"><code class="function">read()</code></a> function, to write the <a class="link" href="media.html#func-write" title="V4L2 write()"><code class="function">write()</code></a> function.
Drivers must implement one I/O method if they
exchange data with applications, but it need not be this.<a href="media.html#ftn.idp62090480" class="footnote" name="idp62090480"><sup class="footnote">[8]</sup></a> When reading or writing is supported, the driver
must also support the <a class="link" href="media.html#func-select" title="V4L2 select()"><code class="function">select()</code></a> and <a class="link" href="media.html#func-poll" title="V4L2 poll()"><code class="function">poll()</code></a>
function.<a href="media.html#ftn.idp62094256" class="footnote" name="idp62094256"><sup class="footnote">[9]</sup></a></p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mmap"></a>Streaming I/O (Memory Mapping)</h2></div></div></div><p>Input and output devices support this I/O method when the
<code class="constant">V4L2_CAP_STREAMING</code> flag in the
<em class="structfield"><code>capabilities</code></em> field of struct <a class="link" href="media.html#v4l2-capability" title="Table A.92. struct v4l2_capability">v4l2_capability</a>
returned by the <a class="link" href="media.html#vidioc-querycap" title="ioctl VIDIOC_QUERYCAP"><code class="constant">VIDIOC_QUERYCAP</code></a> ioctl is set. There are two
streaming methods, to determine if the memory mapping flavor is
supported applications must call the <a class="link" href="media.html#vidioc-reqbufs" title="ioctl VIDIOC_REQBUFS"><code class="constant">VIDIOC_REQBUFS</code></a> ioctl.</p><p>Streaming is an I/O method where only pointers to buffers
are exchanged between application and driver, the data itself is not
copied. Memory mapping is primarily intended to map buffers in device
memory into the application's address space. Device memory can be for
example the video memory on a graphics card with a video capture
add-on. However, being the most efficient I/O method available for a
long time, many other drivers support streaming as well, allocating
buffers in DMA-able main memory.</p><p>A driver can support many sets of buffers. Each set is
identified by a unique buffer type value. The sets are independent and
each set can hold a different type of data. To access different sets
at the same time different file descriptors must be used.<a href="media.html#ftn.idp62105648" class="footnote" name="idp62105648"><sup class="footnote">[10]</sup></a></p><p>To allocate device buffers applications call the
<a class="link" href="media.html#vidioc-reqbufs" title="ioctl VIDIOC_REQBUFS"><code class="constant">VIDIOC_REQBUFS</code></a> ioctl with the desired number of buffers and buffer
type, for example <code class="constant">V4L2_BUF_TYPE_VIDEO_CAPTURE</code>.
This ioctl can also be used to change the number of buffers or to free
the allocated memory, provided none of the buffers are still
mapped.</p><p>Before applications can access the buffers they must map
them into their address space with the <a class="link" href="media.html#func-mmap" title="V4L2 mmap()"><code class="function">mmap()</code></a> function. The
location of the buffers in device memory can be determined with the
<a class="link" href="media.html#vidioc-querybuf" title="ioctl VIDIOC_QUERYBUF"><code class="constant">VIDIOC_QUERYBUF</code></a> ioctl. In the single-planar API case, the
<em class="structfield"><code>m.offset</code></em> and <em class="structfield"><code>length</code></em>
returned in a struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a> are passed as sixth and second parameter to the
<code class="function">mmap()</code> function. When using the multi-planar API,
struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a> contains an array of struct <a class="link" href="media.html#v4l2-plane" title="Table 3.2. struct v4l2_plane">v4l2_plane</a> structures, each
containing its own <em class="structfield"><code>m.offset</code></em> and
<em class="structfield"><code>length</code></em>. When using the multi-planar API, every
plane of every buffer has to be mapped separately, so the number of
calls to <a class="link" href="media.html#func-mmap" title="V4L2 mmap()"><code class="function">mmap()</code></a> should be equal to number of buffers times number of
planes in each buffer. The offset and length values must not be modified.
Remember, the buffers are allocated in physical memory, as opposed to virtual
memory, which can be swapped out to disk. Applications should free the buffers
as soon as possible with the <a class="link" href="media.html#func-munmap" title="V4L2 munmap()"><code class="function">munmap()</code></a> function.</p><div class="example"><a name="idp62120640"></a><p class="title"><b>Example 3.1. Mapping buffers in the single-planar API</b></p><div class="example-contents"><pre class="programlisting">
struct <a class="link" href="media.html#v4l2-requestbuffers" title="Table A.99. struct v4l2_requestbuffers">v4l2_requestbuffers</a> reqbuf;
struct {
	void *start;
	size_t length;
} *buffers;
unsigned int i;

memset(&amp;reqbuf, 0, sizeof(reqbuf));
reqbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
reqbuf.memory = V4L2_MEMORY_MMAP;
reqbuf.count = 20;

if (-1 == ioctl (fd, <a class="link" href="media.html#vidioc-reqbufs" title="ioctl VIDIOC_REQBUFS"><code class="constant">VIDIOC_REQBUFS</code></a>, &amp;reqbuf)) {
	if (errno == EINVAL)
		printf("Video capturing or mmap-streaming is not supported\n");
	else
		perror("VIDIOC_REQBUFS");

	exit(EXIT_FAILURE);
}

/* We want at least five buffers. */

if (reqbuf.count &lt; 5) {
	/* You may need to free the buffers here. */
	printf("Not enough buffer memory\n");
	exit(EXIT_FAILURE);
}

buffers = calloc(reqbuf.count, sizeof(*buffers));
assert(buffers != NULL);

for (i = 0; i &lt; reqbuf.count; i++) {
	struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a> buffer;

	memset(&amp;buffer, 0, sizeof(buffer));
	buffer.type = reqbuf.type;
	buffer.memory = V4L2_MEMORY_MMAP;
	buffer.index = i;

	if (-1 == ioctl (fd, <a class="link" href="media.html#vidioc-querybuf" title="ioctl VIDIOC_QUERYBUF"><code class="constant">VIDIOC_QUERYBUF</code></a>, &amp;buffer)) {
		perror("VIDIOC_QUERYBUF");
		exit(EXIT_FAILURE);
	}

	buffers[i].length = buffer.length; /* remember for munmap() */

	buffers[i].start = mmap(NULL, buffer.length,
				PROT_READ | PROT_WRITE, /* recommended */
				MAP_SHARED,             /* recommended */
				fd, buffer.m.offset);

	if (MAP_FAILED == buffers[i].start) {
		/* If you do not exit here you should unmap() and free()
		   the buffers mapped so far. */
		perror("mmap");
		exit(EXIT_FAILURE);
	}
}

/* Cleanup. */

for (i = 0; i &lt; reqbuf.count; i++)
	munmap(buffers[i].start, buffers[i].length);
      </pre></div></div><br class="example-break"><div class="example"><a name="idp62130352"></a><p class="title"><b>Example 3.2. Mapping buffers in the multi-planar API</b></p><div class="example-contents"><pre class="programlisting">
struct <a class="link" href="media.html#v4l2-requestbuffers" title="Table A.99. struct v4l2_requestbuffers">v4l2_requestbuffers</a> reqbuf;
/* Our current format uses 3 planes per buffer */
#define FMT_NUM_PLANES = 3

struct {
	void *start[FMT_NUM_PLANES];
	size_t length[FMT_NUM_PLANES];
} *buffers;
unsigned int i, j;

memset(&amp;reqbuf, 0, sizeof(reqbuf));
reqbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
reqbuf.memory = V4L2_MEMORY_MMAP;
reqbuf.count = 20;

if (ioctl(fd, <a class="link" href="media.html#vidioc-reqbufs" title="ioctl VIDIOC_REQBUFS"><code class="constant">VIDIOC_REQBUFS</code></a>, &amp;reqbuf) &lt; 0) {
	if (errno == EINVAL)
		printf("Video capturing or mmap-streaming is not supported\n");
	else
		perror("VIDIOC_REQBUFS");

	exit(EXIT_FAILURE);
}

/* We want at least five buffers. */

if (reqbuf.count &lt; 5) {
	/* You may need to free the buffers here. */
	printf("Not enough buffer memory\n");
	exit(EXIT_FAILURE);
}

buffers = calloc(reqbuf.count, sizeof(*buffers));
assert(buffers != NULL);

for (i = 0; i &lt; reqbuf.count; i++) {
	struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a> buffer;
	struct <a class="link" href="media.html#v4l2-plane" title="Table 3.2. struct v4l2_plane">v4l2_plane</a> planes[FMT_NUM_PLANES];

	memset(&amp;buffer, 0, sizeof(buffer));
	buffer.type = reqbuf.type;
	buffer.memory = V4L2_MEMORY_MMAP;
	buffer.index = i;
	/* length in struct v4l2_buffer in multi-planar API stores the size
	 * of planes array. */
	buffer.length = FMT_NUM_PLANES;
	buffer.m.planes = planes;

	if (ioctl(fd, <a class="link" href="media.html#vidioc-querybuf" title="ioctl VIDIOC_QUERYBUF"><code class="constant">VIDIOC_QUERYBUF</code></a>, &amp;buffer) &lt; 0) {
		perror("VIDIOC_QUERYBUF");
		exit(EXIT_FAILURE);
	}

	/* Every plane has to be mapped separately */
	for (j = 0; j &lt; FMT_NUM_PLANES; j++) {
		buffers[i].length[j] = buffer.m.planes[j].length; /* remember for munmap() */

		buffers[i].start[j] = mmap(NULL, buffer.m.planes[j].length,
				 PROT_READ | PROT_WRITE, /* recommended */
				 MAP_SHARED,             /* recommended */
				 fd, buffer.m.planes[j].m.offset);

		if (MAP_FAILED == buffers[i].start[j]) {
			/* If you do not exit here you should unmap() and free()
			   the buffers and planes mapped so far. */
			perror("mmap");
			exit(EXIT_FAILURE);
		}
	}
}

/* Cleanup. */

for (i = 0; i &lt; reqbuf.count; i++)
	for (j = 0; j &lt; FMT_NUM_PLANES; j++)
		munmap(buffers[i].start[j], buffers[i].length[j]);
      </pre></div></div><br class="example-break"><p>Conceptually streaming drivers maintain two buffer queues, an incoming
and an outgoing queue. They separate the synchronous capture or output
operation locked to a video clock from the application which is
subject to random disk or network delays and preemption by
other processes, thereby reducing the probability of data loss.
The queues are organized as FIFOs, buffers will be
output in the order enqueued in the incoming FIFO, and were
captured in the order dequeued from the outgoing FIFO.</p><p>The driver may require a minimum number of buffers enqueued
at all times to function, apart of this no limit exists on the number
of buffers applications can enqueue in advance, or dequeue and
process. They can also enqueue in a different order than buffers have
been dequeued, and the driver can <span class="emphasis"><em>fill</em></span> enqueued
<span class="emphasis"><em>empty</em></span> buffers in any order. <a href="media.html#ftn.idp62141264" class="footnote" name="idp62141264"><sup class="footnote">[11]</sup></a> The index number of a buffer (struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a>
<em class="structfield"><code>index</code></em>) plays no role here, it only
identifies the buffer.</p><p>Initially all mapped buffers are in dequeued state,
inaccessible by the driver. For capturing applications it is customary
to first enqueue all mapped buffers, then to start capturing and enter
the read loop. Here the application waits until a filled buffer can be
dequeued, and re-enqueues the buffer when the data is no longer
needed. Output applications fill and enqueue buffers, when enough
buffers are stacked up the output is started with
<code class="constant">VIDIOC_STREAMON</code>. In the write loop, when
the application runs out of free buffers, it must wait until an empty
buffer can be dequeued and reused.</p><p>To enqueue and dequeue a buffer applications use the
<a class="link" href="media.html#vidioc-qbuf" title="ioctl VIDIOC_QBUF, VIDIOC_DQBUF"><code class="constant">VIDIOC_QBUF</code></a> and <a class="link" href="media.html#vidioc-qbuf" title="ioctl VIDIOC_QBUF, VIDIOC_DQBUF"><code class="constant">VIDIOC_DQBUF</code></a> ioctl. The status of a buffer being
mapped, enqueued, full or empty can be determined at any time using the
<a class="link" href="media.html#vidioc-querybuf" title="ioctl VIDIOC_QUERYBUF"><code class="constant">VIDIOC_QUERYBUF</code></a> ioctl. Two methods exist to suspend execution of the
application until one or more buffers can be dequeued. By default
<code class="constant">VIDIOC_DQBUF</code> blocks when no buffer is in the
outgoing queue. When the <code class="constant">O_NONBLOCK</code> flag was
given to the <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a> function, <code class="constant">VIDIOC_DQBUF</code>
returns immediately with an <span class="errorcode">EAGAIN</span> error code when no buffer is available. The
<a class="link" href="media.html#func-select" title="V4L2 select()"><code class="function">select()</code></a> or <a class="link" href="media.html#func-poll" title="V4L2 poll()"><code class="function">poll()</code></a> functions are always available.</p><p>To start and stop capturing or output applications call the
<a class="link" href="media.html#vidioc-streamon" title="ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF"><code class="constant">VIDIOC_STREAMON</code></a> and <a class="link" href="media.html#vidioc-streamon" title="ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF"><code class="constant">VIDIOC_STREAMOFF</code></a> ioctl. Note
<code class="constant">VIDIOC_STREAMOFF</code> removes all buffers from both
queues as a side effect. Since there is no notion of doing anything
"now" on a multitasking system, if an application needs to synchronize
with another event it should examine the struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a>
<em class="structfield"><code>timestamp</code></em> of captured or outputted buffers.
</p><p>Drivers implementing memory mapping I/O must
support the <code class="constant">VIDIOC_REQBUFS</code>,
<code class="constant">VIDIOC_QUERYBUF</code>,
<code class="constant">VIDIOC_QBUF</code>, <code class="constant">VIDIOC_DQBUF</code>,
<code class="constant">VIDIOC_STREAMON</code> and
<code class="constant">VIDIOC_STREAMOFF</code> ioctl, the
<code class="function">mmap()</code>, <code class="function">munmap()</code>,
<code class="function">select()</code> and <code class="function">poll()</code>
function.<a href="media.html#ftn.idp62165456" class="footnote" name="idp62165456"><sup class="footnote">[12]</sup></a></p><p>[capture example]</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="userp"></a>Streaming I/O (User Pointers)</h2></div></div></div><p>Input and output devices support this I/O method when the
<code class="constant">V4L2_CAP_STREAMING</code> flag in the
<em class="structfield"><code>capabilities</code></em> field of struct <a class="link" href="media.html#v4l2-capability" title="Table A.92. struct v4l2_capability">v4l2_capability</a>
returned by the <a class="link" href="media.html#vidioc-querycap" title="ioctl VIDIOC_QUERYCAP"><code class="constant">VIDIOC_QUERYCAP</code></a> ioctl is set. If the particular user
pointer method (not only memory mapping) is supported must be
determined by calling the <a class="link" href="media.html#vidioc-reqbufs" title="ioctl VIDIOC_REQBUFS"><code class="constant">VIDIOC_REQBUFS</code></a> ioctl.</p><p>This I/O method combines advantages of the read/write and
memory mapping methods. Buffers (planes) are allocated by the application
itself, and can reside for example in virtual or shared memory. Only
pointers to data are exchanged, these pointers and meta-information
are passed in struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a> (or in struct <a class="link" href="media.html#v4l2-plane" title="Table 3.2. struct v4l2_plane">v4l2_plane</a> in the multi-planar API case).
The driver must be switched into user pointer I/O mode by calling the
<a class="link" href="media.html#vidioc-reqbufs" title="ioctl VIDIOC_REQBUFS"><code class="constant">VIDIOC_REQBUFS</code></a> with the desired buffer type. No buffers (planes) are allocated
beforehand, consequently they are not indexed and cannot be queried like mapped
buffers with the <code class="constant">VIDIOC_QUERYBUF</code> ioctl.</p><div class="example"><a name="idp62177472"></a><p class="title"><b>Example 3.3. Initiating streaming I/O with user pointers</b></p><div class="example-contents"><pre class="programlisting">
struct <a class="link" href="media.html#v4l2-requestbuffers" title="Table A.99. struct v4l2_requestbuffers">v4l2_requestbuffers</a> reqbuf;

memset (&amp;reqbuf, 0, sizeof (reqbuf));
reqbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
reqbuf.memory = V4L2_MEMORY_USERPTR;

if (ioctl (fd, <a class="link" href="media.html#vidioc-reqbufs" title="ioctl VIDIOC_REQBUFS"><code class="constant">VIDIOC_REQBUFS</code></a>, &amp;reqbuf) == -1) {
	if (errno == EINVAL)
		printf ("Video capturing or user pointer streaming is not supported\n");
	else
		perror ("VIDIOC_REQBUFS");

	exit (EXIT_FAILURE);
}
      </pre></div></div><br class="example-break"><p>Buffer (plane) addresses and sizes are passed on the fly with the
<a class="link" href="media.html#vidioc-qbuf" title="ioctl VIDIOC_QBUF, VIDIOC_DQBUF"><code class="constant">VIDIOC_QBUF</code></a> ioctl. Although buffers are commonly cycled,
applications can pass different addresses and sizes at each
<code class="constant">VIDIOC_QBUF</code> call. If required by the hardware the
driver swaps memory pages within physical memory to create a
continuous area of memory. This happens transparently to the
application in the virtual memory subsystem of the kernel. When buffer
pages have been swapped out to disk they are brought back and finally
locked in physical memory for DMA.<a href="media.html#ftn.idp62183280" class="footnote" name="idp62183280"><sup class="footnote">[13]</sup></a></p><p>Filled or displayed buffers are dequeued with the
<a class="link" href="media.html#vidioc-qbuf" title="ioctl VIDIOC_QBUF, VIDIOC_DQBUF"><code class="constant">VIDIOC_DQBUF</code></a> ioctl. The driver can unlock the memory pages at any
time between the completion of the DMA and this ioctl. The memory is
also unlocked when <a class="link" href="media.html#vidioc-streamon" title="ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF"><code class="constant">VIDIOC_STREAMOFF</code></a> is called, <a class="link" href="media.html#vidioc-reqbufs" title="ioctl VIDIOC_REQBUFS"><code class="constant">VIDIOC_REQBUFS</code></a>, or
when the device is closed. Applications must take care not to free
buffers without dequeuing. For once, the buffers remain locked until
further, wasting physical memory. Second the driver will not be
notified when the memory is returned to the application's free list
and subsequently reused for other purposes, possibly completing the
requested DMA and overwriting valuable data.</p><p>For capturing applications it is customary to enqueue a
number of empty buffers, to start capturing and enter the read loop.
Here the application waits until a filled buffer can be dequeued, and
re-enqueues the buffer when the data is no longer needed. Output
applications fill and enqueue buffers, when enough buffers are stacked
up output is started. In the write loop, when the application
runs out of free buffers it must wait until an empty buffer can be
dequeued and reused. Two methods exist to suspend execution of the
application until one or more buffers can be dequeued. By default
<code class="constant">VIDIOC_DQBUF</code> blocks when no buffer is in the
outgoing queue. When the <code class="constant">O_NONBLOCK</code> flag was
given to the <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a> function, <code class="constant">VIDIOC_DQBUF</code>
returns immediately with an <span class="errorcode">EAGAIN</span> error code when no buffer is available. The
<a class="link" href="media.html#func-select" title="V4L2 select()"><code class="function">select()</code></a> or <a class="link" href="media.html#func-poll" title="V4L2 poll()"><code class="function">poll()</code></a> function are always available.</p><p>To start and stop capturing or output applications call the
<a class="link" href="media.html#vidioc-streamon" title="ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF"><code class="constant">VIDIOC_STREAMON</code></a> and <a class="link" href="media.html#vidioc-streamon" title="ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF"><code class="constant">VIDIOC_STREAMOFF</code></a> ioctl. Note
<code class="constant">VIDIOC_STREAMOFF</code> removes all buffers from both
queues and unlocks all buffers as a side effect. Since there is no
notion of doing anything "now" on a multitasking system, if an
application needs to synchronize with another event it should examine
the struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a> <em class="structfield"><code>timestamp</code></em> of captured
or outputted buffers.</p><p>Drivers implementing user pointer I/O must
support the <code class="constant">VIDIOC_REQBUFS</code>,
<code class="constant">VIDIOC_QBUF</code>, <code class="constant">VIDIOC_DQBUF</code>,
<code class="constant">VIDIOC_STREAMON</code> and
<code class="constant">VIDIOC_STREAMOFF</code> ioctl, the
<code class="function">select()</code> and <code class="function">poll()</code> function.<a href="media.html#ftn.idp62202416" class="footnote" name="idp62202416"><sup class="footnote">[14]</sup></a></p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dmabuf"></a>Streaming I/O (DMA buffer importing)</h2></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Experimental</h3><p>This is an <a class="link" href="media.html#experimental" title="Experimental API Elements">experimental</a>
      interface and may change in the future.</p></div><p>The DMABUF framework provides a generic method for sharing buffers
between multiple devices. Device drivers that support DMABUF can export a DMA
buffer to userspace as a file descriptor (known as the exporter role), import a
DMA buffer from userspace using a file descriptor previously exported for a
different or the same device (known as the importer role), or both. This
section describes the DMABUF importer role API in V4L2.</p><p>Refer to <a class="link" href="media.html#vidioc-expbuf" title="ioctl VIDIOC_EXPBUF">DMABUF exporting</a> for
details about exporting V4L2 buffers as DMABUF file descriptors.</p><p>Input and output devices support the streaming I/O method when the
<code class="constant">V4L2_CAP_STREAMING</code> flag in the
<em class="structfield"><code>capabilities</code></em> field of struct <a class="link" href="media.html#v4l2-capability" title="Table A.92. struct v4l2_capability">v4l2_capability</a> returned by
the <a class="link" href="media.html#vidioc-querycap" title="ioctl VIDIOC_QUERYCAP"><code class="constant">VIDIOC_QUERYCAP</code></a> ioctl is set. Whether importing DMA buffers through
DMABUF file descriptors is supported is determined by calling the
<a class="link" href="media.html#vidioc-reqbufs" title="ioctl VIDIOC_REQBUFS"><code class="constant">VIDIOC_REQBUFS</code></a> ioctl with the memory type set to
<code class="constant">V4L2_MEMORY_DMABUF</code>.</p><p>This I/O method is dedicated to sharing DMA buffers between different
devices, which may be V4L devices or other video-related devices (e.g. DRM).
Buffers (planes) are allocated by a driver on behalf of an application. Next,
these buffers are exported to the application as file descriptors using an API
which is specific for an allocator driver.  Only such file descriptor are
exchanged. The descriptors and meta-information are passed in struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a> (or
in struct <a class="link" href="media.html#v4l2-plane" title="Table 3.2. struct v4l2_plane">v4l2_plane</a> in the multi-planar API case).  The driver must be switched
into DMABUF I/O mode by calling the <a class="link" href="media.html#vidioc-reqbufs" title="ioctl VIDIOC_REQBUFS"><code class="constant">VIDIOC_REQBUFS</code></a> with the desired buffer
type.</p><div class="example"><a name="idp62218576"></a><p class="title"><b>Example 3.4. Initiating streaming I/O with DMABUF file descriptors</b></p><div class="example-contents"><pre class="programlisting">
struct <a class="link" href="media.html#v4l2-requestbuffers" title="Table A.99. struct v4l2_requestbuffers">v4l2_requestbuffers</a> reqbuf;

memset(&amp;reqbuf, 0, sizeof (reqbuf));
reqbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
reqbuf.memory = V4L2_MEMORY_DMABUF;
reqbuf.count = 1;

if (ioctl(fd, <a class="link" href="media.html#vidioc-reqbufs" title="ioctl VIDIOC_REQBUFS"><code class="constant">VIDIOC_REQBUFS</code></a>, &amp;reqbuf) == -1) {
	if (errno == EINVAL)
		printf("Video capturing or DMABUF streaming is not supported\n");
	else
		perror("VIDIOC_REQBUFS");

	exit(EXIT_FAILURE);
}
      </pre></div></div><br class="example-break"><p>The buffer (plane) file descriptor is passed on the fly with the
<a class="link" href="media.html#vidioc-qbuf" title="ioctl VIDIOC_QBUF, VIDIOC_DQBUF"><code class="constant">VIDIOC_QBUF</code></a> ioctl. In case of multiplanar buffers, every plane can be
associated with a different DMABUF descriptor. Although buffers are commonly
cycled, applications can pass a different DMABUF descriptor at each
<code class="constant">VIDIOC_QBUF</code> call.</p><div class="example"><a name="idp62224288"></a><p class="title"><b>Example 3.5. Queueing DMABUF using single plane API</b></p><div class="example-contents"><pre class="programlisting">
int buffer_queue(int v4lfd, int index, int dmafd)
{
	struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a> buf;

	memset(&amp;buf, 0, sizeof buf);
	buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
	buf.memory = V4L2_MEMORY_DMABUF;
	buf.index = index;
	buf.m.fd = dmafd;

	if (ioctl(v4lfd, <a class="link" href="media.html#vidioc-qbuf" title="ioctl VIDIOC_QBUF, VIDIOC_DQBUF"><code class="constant">VIDIOC_QBUF</code></a>, &amp;buf) == -1) {
		perror("VIDIOC_QBUF");
		return -1;
	}

	return 0;
}
      </pre></div></div><br class="example-break"><div class="example"><a name="idp62227968"></a><p class="title"><b>Example 3.6. Queueing DMABUF using multi plane API</b></p><div class="example-contents"><pre class="programlisting">
int buffer_queue_mp(int v4lfd, int index, int dmafd[], int n_planes)
{
	struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a> buf;
	struct <a class="link" href="media.html#v4l2-plane" title="Table 3.2. struct v4l2_plane">v4l2_plane</a> planes[VIDEO_MAX_PLANES];
	int i;

	memset(&amp;buf, 0, sizeof buf);
	buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
	buf.memory = V4L2_MEMORY_DMABUF;
	buf.index = index;
	buf.m.planes = planes;
	buf.length = n_planes;

	memset(&amp;planes, 0, sizeof planes);

	for (i = 0; i &lt; n_planes; ++i)
		buf.m.planes[i].m.fd = dmafd[i];

	if (ioctl(v4lfd, <a class="link" href="media.html#vidioc-qbuf" title="ioctl VIDIOC_QBUF, VIDIOC_DQBUF"><code class="constant">VIDIOC_QBUF</code></a>, &amp;buf) == -1) {
		perror("VIDIOC_QBUF");
		return -1;
	}

	return 0;
}
      </pre></div></div><br class="example-break"><p>Captured or displayed buffers are dequeued with the
<a class="link" href="media.html#vidioc-qbuf" title="ioctl VIDIOC_QBUF, VIDIOC_DQBUF"><code class="constant">VIDIOC_DQBUF</code></a> ioctl. The driver can unlock the buffer at any
time between the completion of the DMA and this ioctl. The memory is
also unlocked when <a class="link" href="media.html#vidioc-streamon" title="ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF"><code class="constant">VIDIOC_STREAMOFF</code></a> is called, <a class="link" href="media.html#vidioc-reqbufs" title="ioctl VIDIOC_REQBUFS"><code class="constant">VIDIOC_REQBUFS</code></a>, or
when the device is closed.</p><p>For capturing applications it is customary to enqueue a
number of empty buffers, to start capturing and enter the read loop.
Here the application waits until a filled buffer can be dequeued, and
re-enqueues the buffer when the data is no longer needed. Output
applications fill and enqueue buffers, when enough buffers are stacked
up output is started. In the write loop, when the application
runs out of free buffers it must wait until an empty buffer can be
dequeued and reused. Two methods exist to suspend execution of the
application until one or more buffers can be dequeued. By default
<code class="constant">VIDIOC_DQBUF</code> blocks when no buffer is in the
outgoing queue. When the <code class="constant">O_NONBLOCK</code> flag was
given to the <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a> function, <code class="constant">VIDIOC_DQBUF</code>
returns immediately with an <span class="errorcode">EAGAIN</span> error code when no buffer is available. The
<a class="link" href="media.html#func-select" title="V4L2 select()"><code class="function">select()</code></a> and <a class="link" href="media.html#func-poll" title="V4L2 poll()"><code class="function">poll()</code></a> functions are always available.</p><p>To start and stop capturing or displaying applications call the
<a class="link" href="media.html#vidioc-streamon" title="ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF"><code class="constant">VIDIOC_STREAMON</code></a> and <a class="link" href="media.html#vidioc-streamon" title="ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF"><code class="constant">VIDIOC_STREAMOFF</code></a> ioctls. Note that
<code class="constant">VIDIOC_STREAMOFF</code> removes all buffers from both queues and
unlocks all buffers as a side effect. Since there is no notion of doing
anything "now" on a multitasking system, if an application needs to synchronize
with another event it should examine the struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a>
<em class="structfield"><code>timestamp</code></em> of captured or outputted buffers.</p><p>Drivers implementing DMABUF importing I/O must support the
<code class="constant">VIDIOC_REQBUFS</code>, <code class="constant">VIDIOC_QBUF</code>,
<code class="constant">VIDIOC_DQBUF</code>, <code class="constant">VIDIOC_STREAMON</code> and
<code class="constant">VIDIOC_STREAMOFF</code> ioctls, and the
<code class="function">select()</code> and <code class="function">poll()</code> functions.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="async"></a>Asynchronous I/O</h2></div></div></div><p>This method is not defined yet.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="buffer"></a>Buffers</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#idp62487856">Timecodes</a></span></dt></dl></div><p>A buffer contains data exchanged by application and
driver using one of the Streaming I/O methods. In the multi-planar API, the
data is held in planes, while the buffer structure acts as a container
for the planes. Only pointers to buffers (planes) are exchanged, the data
itself is not copied. These pointers, together with meta-information like
timestamps or field parity, are stored in a struct
<span class="structname">v4l2_buffer</span>, argument to
the <a class="link" href="media.html#vidioc-querybuf" title="ioctl VIDIOC_QUERYBUF"><code class="constant">VIDIOC_QUERYBUF</code></a>, <a class="link" href="media.html#vidioc-qbuf" title="ioctl VIDIOC_QBUF, VIDIOC_DQBUF"><code class="constant">VIDIOC_QBUF</code></a> and <a class="link" href="media.html#vidioc-qbuf" title="ioctl VIDIOC_QBUF, VIDIOC_DQBUF"><code class="constant">VIDIOC_DQBUF</code></a> ioctl.
In the multi-planar API, some plane-specific members of struct
<span class="structname">v4l2_buffer</span>, such as pointers and sizes for each
plane, are stored in struct <span class="structname">v4l2_plane</span> instead.
In that case, struct <span class="structname">v4l2_buffer</span> contains an array of
plane structures.</p><p>Dequeued video buffers come with timestamps. The driver
    decides at which part of the frame and with which clock the
    timestamp is taken. Please see flags in the masks
    <code class="constant">V4L2_BUF_FLAG_TIMESTAMP_MASK</code> and
    <code class="constant">V4L2_BUF_FLAG_TSTAMP_SRC_MASK</code> in <a class="xref" href="media.html#buffer-flags" title="Table 3.4. Buffer Flags">Table 3.4, &#8220;Buffer Flags&#8221;</a>. These flags are always valid and constant
    across all buffers during the whole video stream. Changes in these
    flags may take place as a side effect of <a class="link" href="media.html#vidioc-g-input" title="ioctl VIDIOC_G_INPUT, VIDIOC_S_INPUT"><code class="constant">VIDIOC_S_INPUT</code></a> or
    <a class="link" href="media.html#vidioc-g-output" title="ioctl VIDIOC_G_OUTPUT, VIDIOC_S_OUTPUT"><code class="constant">VIDIOC_S_OUTPUT</code></a> however. The
    <code class="constant">V4L2_BUF_FLAG_TIMESTAMP_COPY</code> timestamp type
    which is used by e.g. on mem-to-mem devices is an exception to the
    rule: the timestamp source flags are copied from the OUTPUT video
    buffer to the CAPTURE video buffer.</p><div class="table"><a name="v4l2-buffer"></a><p class="title"><b>Table 3.1. struct <span class="structname">v4l2_buffer</span></b></p><div class="table-contents"><table summary="struct v4l2_buffer" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>index</code></em></td><td valign="top"> </td><td valign="top">Number of the buffer, set by the application except
when calling <a class="link" href="media.html#vidioc-qbuf" title="ioctl VIDIOC_QBUF, VIDIOC_DQBUF"><code class="constant">VIDIOC_DQBUF</code></a>, then it is set by the driver.
This field can range from zero to the number of buffers allocated
with the <a class="link" href="media.html#vidioc-reqbufs" title="ioctl VIDIOC_REQBUFS"><code class="constant">VIDIOC_REQBUFS</code></a> ioctl (struct <a class="link" href="media.html#v4l2-requestbuffers" title="Table A.99. struct v4l2_requestbuffers">v4l2_requestbuffers</a> <em class="structfield"><code>count</code></em>),
plus any buffers allocated with <a class="link" href="media.html#vidioc-create-bufs" title="ioctl VIDIOC_CREATE_BUFS"><code class="constant">VIDIOC_CREATE_BUFS</code></a> minus one.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>type</code></em></td><td valign="top"> </td><td valign="top">Type of the buffer, same as struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a>
<em class="structfield"><code>type</code></em> or struct <a class="link" href="media.html#v4l2-requestbuffers" title="Table A.99. struct v4l2_requestbuffers">v4l2_requestbuffers</a>
<em class="structfield"><code>type</code></em>, set by the application. See <a class="xref" href="media.html#v4l2-buf-type" title="Table 3.3. enum v4l2_buf_type">Table 3.3, &#8220;enum v4l2_buf_type&#8221;</a></td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>bytesused</code></em></td><td valign="top"> </td><td valign="top">The number of bytes occupied by the data in the
buffer. It depends on the negotiated data format and may change with
each buffer for compressed variable size data like JPEG images.
Drivers must set this field when <em class="structfield"><code>type</code></em>
refers to an input stream, applications when it refers to an output stream.
If the application sets this to 0 for an output stream, then
<em class="structfield"><code>bytesused</code></em> will be set to the size of the
buffer (see the <em class="structfield"><code>length</code></em> field of this struct) by
the driver. For multiplanar formats this field is ignored and the
<em class="structfield"><code>planes</code></em> pointer is used instead.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>flags</code></em></td><td valign="top"> </td><td valign="top">Flags set by the application or driver, see <a class="xref" href="media.html#buffer-flags" title="Table 3.4. Buffer Flags">Table 3.4, &#8220;Buffer Flags&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>field</code></em></td><td valign="top"> </td><td valign="top">Indicates the field order of the image in the
buffer, see <a class="xref" href="media.html#v4l2-field" title="Table 3.9. enum v4l2_field">Table 3.9, &#8220;enum v4l2_field&#8221;</a>. This field is not used when
the buffer contains VBI data. Drivers must set it when
<em class="structfield"><code>type</code></em> refers to an input stream,
applications when it refers to an output stream.</td></tr><tr><td valign="top">struct timeval</td><td valign="top"><em class="structfield"><code>timestamp</code></em></td><td valign="top"> </td><td valign="top"><p>For input streams this is time when the first data
	    byte was captured, as returned by the
	    <code class="function">clock_gettime()</code> function for the relevant
	    clock id; see <code class="constant">V4L2_BUF_FLAG_TIMESTAMP_*</code> in
	    <a class="xref" href="media.html#buffer-flags" title="Table 3.4. Buffer Flags">Table 3.4, &#8220;Buffer Flags&#8221;</a>. For output streams the driver
	    stores the time at which the last data byte was actually sent out
	    in the  <em class="structfield"><code>timestamp</code></em> field. This permits
	    applications to monitor the drift between the video and system
	    clock. For output streams that use <code class="constant">V4L2_BUF_FLAG_TIMESTAMP_COPY</code>
	    the application has to fill in the timestamp which will be copied
	    by the driver to the capture stream.</p></td></tr><tr><td valign="top">struct <a class="link" href="media.html#v4l2-timecode" title="Table 3.6. struct v4l2_timecode">v4l2_timecode</a></td><td valign="top"><em class="structfield"><code>timecode</code></em></td><td valign="top"> </td><td valign="top">When <em class="structfield"><code>type</code></em> is
<code class="constant">V4L2_BUF_TYPE_VIDEO_CAPTURE</code> and the
<code class="constant">V4L2_BUF_FLAG_TIMECODE</code> flag is set in
<em class="structfield"><code>flags</code></em>, this structure contains a frame
timecode. In <a class="link" href="media.html#v4l2-field" title="Table 3.9. enum v4l2_field">V4L2_FIELD_ALTERNATE</a>
mode the top and bottom field contain the same timecode.
Timecodes are intended to help video editing and are typically recorded on
video tapes, but also embedded in compressed formats like MPEG. This
field is independent of the <em class="structfield"><code>timestamp</code></em> and
<em class="structfield"><code>sequence</code></em> fields.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>sequence</code></em></td><td valign="top"> </td><td valign="top">Set by the driver, counting the frames (not fields!) in
sequence. This field is set for both input and output devices.</td></tr><tr><td colspan="4" valign="top"><p>In <a class="link" href="media.html#v4l2-field" title="Table 3.9. enum v4l2_field">V4L2_FIELD_ALTERNATE</a> mode the top and
bottom field have the same sequence number. The count starts at zero
and includes dropped or repeated frames. A dropped frame was received
by an input device but could not be stored due to lack of free buffer
space. A repeated frame was displayed again by an output device
because the application did not pass new data in
time.</p><p>Note this may count the frames received
e.g. over USB, without taking into account the frames dropped by the
remote hardware due to limited compression throughput or bus
bandwidth. These devices identify by not enumerating any video
standards, see <a class="xref" href="media.html#standard" title="Video Standards">the section called &#8220;Video Standards&#8221;</a>.</p></td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>memory</code></em></td><td valign="top"> </td><td valign="top">This field must be set by applications and/or drivers
in accordance with the selected I/O method. See <a class="xref" href="media.html#v4l2-memory" title="Table 3.5. enum v4l2_memory">Table 3.5, &#8220;enum v4l2_memory&#8221;</a></td></tr><tr><td valign="top">union</td><td valign="top"><em class="structfield"><code>m</code></em></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td valign="top"> </td><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>offset</code></em></td><td valign="top">For the single-planar API and when
<em class="structfield"><code>memory</code></em> is <code class="constant">V4L2_MEMORY_MMAP</code> this
is the offset of the buffer from the start of the device memory. The value is
returned by the driver and apart of serving as parameter to the <a class="link" href="media.html#func-mmap" title="V4L2 mmap()"><code class="function">mmap()</code></a>
function not useful for applications. See <a class="xref" href="media.html#mmap" title="Streaming I/O (Memory Mapping)">the section called &#8220;Streaming I/O (Memory Mapping)&#8221;</a> for details
	  </td></tr><tr><td valign="top"> </td><td valign="top">unsigned long</td><td valign="top"><em class="structfield"><code>userptr</code></em></td><td valign="top">For the single-planar API and when
<em class="structfield"><code>memory</code></em> is <code class="constant">V4L2_MEMORY_USERPTR</code>
this is a pointer to the buffer (casted to unsigned long type) in virtual
memory, set by the application. See <a class="xref" href="media.html#userp" title="Streaming I/O (User Pointers)">the section called &#8220;Streaming I/O (User Pointers)&#8221;</a> for details.
	    </td></tr><tr><td valign="top"> </td><td valign="top">struct v4l2_plane</td><td valign="top"><em class="structfield"><code>*planes</code></em></td><td valign="top">When using the multi-planar API, contains a userspace pointer
	    to an array of struct <a class="link" href="media.html#v4l2-plane" title="Table 3.2. struct v4l2_plane">v4l2_plane</a>. The size of the array should be put
	    in the <em class="structfield"><code>length</code></em> field of this
	    <span class="structname">v4l2_buffer</span> structure.</td></tr><tr><td valign="top"> </td><td valign="top">int</td><td valign="top"><em class="structfield"><code>fd</code></em></td><td valign="top">For the single-plane API and when
<em class="structfield"><code>memory</code></em> is <code class="constant">V4L2_MEMORY_DMABUF</code> this
is the file descriptor associated with a DMABUF buffer.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>length</code></em></td><td valign="top"> </td><td valign="top">Size of the buffer (not the payload) in bytes for the
	    single-planar API. This is set by the driver based on the calls to
	    <a class="link" href="media.html#vidioc-reqbufs" title="ioctl VIDIOC_REQBUFS"><code class="constant">VIDIOC_REQBUFS</code></a> and/or <a class="link" href="media.html#vidioc-create-bufs" title="ioctl VIDIOC_CREATE_BUFS"><code class="constant">VIDIOC_CREATE_BUFS</code></a>. For the multi-planar API the application sets
	    this to the number of elements in the <em class="structfield"><code>planes</code></em>
	    array. The driver will fill in the actual number of valid elements in
	    that array.
	    </td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved2</code></em></td><td valign="top"> </td><td valign="top">A place holder for future extensions. Applications
should set this to 0.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em></td><td valign="top"> </td><td valign="top">A place holder for future extensions. Applications
should set this to 0.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-plane"></a><p class="title"><b>Table 3.2. struct <span class="structname">v4l2_plane</span></b></p><div class="table-contents"><table summary="struct v4l2_plane" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>bytesused</code></em></td><td valign="top"> </td><td valign="top">The number of bytes occupied by data in the plane
	      (its payload). Drivers must set this field when <em class="structfield"><code>type</code></em>
	      refers to an input stream, applications when it refers to an output stream.
	      If the application sets this to 0 for an output stream, then
	      <em class="structfield"><code>bytesused</code></em> will be set to the size of the
	      plane (see the <em class="structfield"><code>length</code></em> field of this struct)
	      by the driver. Note that the actual image data starts at
	      <em class="structfield"><code>data_offset</code></em> which may not be 0.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>length</code></em></td><td valign="top"> </td><td valign="top">Size in bytes of the plane (not its payload). This is set by the driver
	    based on the calls to <a class="link" href="media.html#vidioc-reqbufs" title="ioctl VIDIOC_REQBUFS"><code class="constant">VIDIOC_REQBUFS</code></a> and/or <a class="link" href="media.html#vidioc-create-bufs" title="ioctl VIDIOC_CREATE_BUFS"><code class="constant">VIDIOC_CREATE_BUFS</code></a>.</td></tr><tr><td valign="top">union</td><td valign="top"><em class="structfield"><code>m</code></em></td><td valign="top"> </td><td valign="top"> </td></tr><tr><td valign="top"> </td><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>mem_offset</code></em></td><td valign="top">When the memory type in the containing struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a> is
	      <code class="constant">V4L2_MEMORY_MMAP</code>, this is the value that
	      should be passed to <a class="link" href="media.html#func-mmap" title="V4L2 mmap()"><code class="function">mmap()</code></a>, similar to the
	      <em class="structfield"><code>offset</code></em> field in struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a>.</td></tr><tr><td valign="top"> </td><td valign="top">unsigned long</td><td valign="top"><em class="structfield"><code>userptr</code></em></td><td valign="top">When the memory type in the containing struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a> is
	      <code class="constant">V4L2_MEMORY_USERPTR</code>, this is a userspace
	      pointer to the memory allocated for this plane by an application.
	      </td></tr><tr><td valign="top"> </td><td valign="top">int</td><td valign="top"><em class="structfield"><code>fd</code></em></td><td valign="top">When the memory type in the containing struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a> is
		<code class="constant">V4L2_MEMORY_DMABUF</code>, this is a file
		descriptor associated with a DMABUF buffer, similar to the
		<em class="structfield"><code>fd</code></em> field in struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>data_offset</code></em></td><td valign="top"> </td><td valign="top">Offset in bytes to video data in the plane.
	      Drivers must set this field when <em class="structfield"><code>type</code></em>
	      refers to an input stream, applications when it refers to an output stream.
	      Note that data_offset is included in <em class="structfield"><code>bytesused</code></em>.
	      So the size of the image in the plane is
	      <em class="structfield"><code>bytesused</code></em>-<em class="structfield"><code>data_offset</code></em> at
	      offset <em class="structfield"><code>data_offset</code></em> from the start of the plane.
	    </td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved[11]</code></em></td><td valign="top"> </td><td valign="top">Reserved for future use. Should be zeroed by an
	    application.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-buf-type"></a><p class="title"><b>Table 3.3. enum v4l2_buf_type</b></p><div class="table-contents"><table summary="enum v4l2_buf_type" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_BUF_TYPE_VIDEO_CAPTURE</code></td><td valign="top">1</td><td valign="top">Buffer of a single-planar video capture stream, see <a class="xref" href="media.html#capture" title="Video Capture Interface">the section called &#8220;Video Capture Interface&#8221;</a>.</td></tr><tr><td valign="top"><code class="constant">V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE</code>
	    </td><td valign="top">9</td><td valign="top">Buffer of a multi-planar video capture stream, see <a class="xref" href="media.html#capture" title="Video Capture Interface">the section called &#8220;Video Capture Interface&#8221;</a>.</td></tr><tr><td valign="top"><code class="constant">V4L2_BUF_TYPE_VIDEO_OUTPUT</code></td><td valign="top">2</td><td valign="top">Buffer of a single-planar video output stream, see <a class="xref" href="media.html#output" title="Video Output Interface">the section called &#8220;Video Output Interface&#8221;</a>.</td></tr><tr><td valign="top"><code class="constant">V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE</code>
	    </td><td valign="top">10</td><td valign="top">Buffer of a multi-planar video output stream, see <a class="xref" href="media.html#output" title="Video Output Interface">the section called &#8220;Video Output Interface&#8221;</a>.</td></tr><tr><td valign="top"><code class="constant">V4L2_BUF_TYPE_VIDEO_OVERLAY</code></td><td valign="top">3</td><td valign="top">Buffer for video overlay, see <a class="xref" href="media.html#overlay" title="Video Overlay Interface">the section called &#8220;Video Overlay Interface&#8221;</a>.</td></tr><tr><td valign="top"><code class="constant">V4L2_BUF_TYPE_VBI_CAPTURE</code></td><td valign="top">4</td><td valign="top">Buffer of a raw VBI capture stream, see <a class="xref" href="media.html#raw-vbi" title="Raw VBI Data Interface">the section called &#8220;Raw VBI Data Interface&#8221;</a>.</td></tr><tr><td valign="top"><code class="constant">V4L2_BUF_TYPE_VBI_OUTPUT</code></td><td valign="top">5</td><td valign="top">Buffer of a raw VBI output stream, see <a class="xref" href="media.html#raw-vbi" title="Raw VBI Data Interface">the section called &#8220;Raw VBI Data Interface&#8221;</a>.</td></tr><tr><td valign="top"><code class="constant">V4L2_BUF_TYPE_SLICED_VBI_CAPTURE</code></td><td valign="top">6</td><td valign="top">Buffer of a sliced VBI capture stream, see <a class="xref" href="media.html#sliced" title="Sliced VBI Data Interface">the section called &#8220;Sliced VBI Data Interface&#8221;</a>.</td></tr><tr><td valign="top"><code class="constant">V4L2_BUF_TYPE_SLICED_VBI_OUTPUT</code></td><td valign="top">7</td><td valign="top">Buffer of a sliced VBI output stream, see <a class="xref" href="media.html#sliced" title="Sliced VBI Data Interface">the section called &#8220;Sliced VBI Data Interface&#8221;</a>.</td></tr><tr><td valign="top"><code class="constant">V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY</code></td><td valign="top">8</td><td valign="top">Buffer for video output overlay (OSD), see <a class="xref" href="media.html#osd" title="Video Output Overlay Interface">the section called &#8220;Video Output Overlay Interface&#8221;</a>.</td></tr><tr><td valign="top"><code class="constant">V4L2_BUF_TYPE_SDR_CAPTURE</code></td><td valign="top">11</td><td valign="top">Buffer for Software Defined Radio (SDR), see <a class="xref" href="media.html#sdr" title="Software Defined Radio Interface (SDR)">the section called &#8220;Software Defined Radio Interface (SDR)&#8221;</a>.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="buffer-flags"></a><p class="title"><b>Table 3.4. Buffer Flags</b></p><div class="table-contents"><table summary="Buffer Flags" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_BUF_FLAG_MAPPED</code></td><td valign="top">0x00000001</td><td valign="top">The buffer resides in device memory and has been mapped
into the application's address space, see <a class="xref" href="media.html#mmap" title="Streaming I/O (Memory Mapping)">the section called &#8220;Streaming I/O (Memory Mapping)&#8221;</a> for details.
Drivers set or clear this flag when the
<a class="link" href="media.html#vidioc-querybuf" title="ioctl VIDIOC_QUERYBUF">VIDIOC_QUERYBUF</a>, <a class="link" href="media.html#vidioc-qbuf" title="ioctl VIDIOC_QBUF, VIDIOC_DQBUF">VIDIOC_QBUF</a> or <a class="link" href="media.html#vidioc-qbuf" title="ioctl VIDIOC_QBUF, VIDIOC_DQBUF">VIDIOC_DQBUF</a> ioctl is called. Set by the driver.</td></tr><tr><td valign="top"><code class="constant">V4L2_BUF_FLAG_QUEUED</code></td><td valign="top">0x00000002</td><td valign="top">Internally drivers maintain two buffer queues, an
incoming and outgoing queue. When this flag is set, the buffer is
currently on the incoming queue. It automatically moves to the
outgoing queue after the buffer has been filled (capture devices) or
displayed (output devices). Drivers set or clear this flag when the
<code class="constant">VIDIOC_QUERYBUF</code> ioctl is called. After
(successful) calling the <code class="constant">VIDIOC_QBUF </code>ioctl it is
always set and after <code class="constant">VIDIOC_DQBUF</code> always
cleared.</td></tr><tr><td valign="top"><code class="constant">V4L2_BUF_FLAG_DONE</code></td><td valign="top">0x00000004</td><td valign="top">When this flag is set, the buffer is currently on
the outgoing queue, ready to be dequeued from the driver. Drivers set
or clear this flag when the <code class="constant">VIDIOC_QUERYBUF</code> ioctl
is called. After calling the <code class="constant">VIDIOC_QBUF</code> or
<code class="constant">VIDIOC_DQBUF</code> it is always cleared. Of course a
buffer cannot be on both queues at the same time, the
<code class="constant">V4L2_BUF_FLAG_QUEUED</code> and
<code class="constant">V4L2_BUF_FLAG_DONE</code> flag are mutually exclusive.
They can be both cleared however, then the buffer is in "dequeued"
state, in the application domain so to say.</td></tr><tr><td valign="top"><code class="constant">V4L2_BUF_FLAG_ERROR</code></td><td valign="top">0x00000040</td><td valign="top">When this flag is set, the buffer has been dequeued
	    successfully, although the data might have been corrupted.
	    This is recoverable, streaming may continue as normal and
	    the buffer may be reused normally.
	    Drivers set this flag when the <code class="constant">VIDIOC_DQBUF</code>
	    ioctl is called.</td></tr><tr><td valign="top"><code class="constant">V4L2_BUF_FLAG_KEYFRAME</code></td><td valign="top">0x00000008</td><td valign="top">Drivers set or clear this flag when calling the
<code class="constant">VIDIOC_DQBUF</code> ioctl. It may be set by video
capture devices when the buffer contains a compressed image which is a
key frame (or field), i. e. can be decompressed on its own. Also known as
an I-frame.  Applications can set this bit when <em class="structfield"><code>type</code></em>
refers to an output stream.</td></tr><tr><td valign="top"><code class="constant">V4L2_BUF_FLAG_PFRAME</code></td><td valign="top">0x00000010</td><td valign="top">Similar to <code class="constant">V4L2_BUF_FLAG_KEYFRAME</code>
this flags predicted frames or fields which contain only differences to a
previous key frame. Applications can set this bit when <em class="structfield"><code>type</code></em>
refers to an output stream.</td></tr><tr><td valign="top"><code class="constant">V4L2_BUF_FLAG_BFRAME</code></td><td valign="top">0x00000020</td><td valign="top">Similar to <code class="constant">V4L2_BUF_FLAG_KEYFRAME</code>
this flags a bi-directional predicted frame or field which contains only
the differences between the current frame and both the preceding and following
key frames to specify its content. Applications can set this bit when
<em class="structfield"><code>type</code></em> refers to an output stream.</td></tr><tr><td valign="top"><code class="constant">V4L2_BUF_FLAG_TIMECODE</code></td><td valign="top">0x00000100</td><td valign="top">The <em class="structfield"><code>timecode</code></em> field is valid.
Drivers set or clear this flag when the <code class="constant">VIDIOC_DQBUF</code>
ioctl is called.  Applications can set this bit and the corresponding
<em class="structfield"><code>timecode</code></em> structure when <em class="structfield"><code>type</code></em>
refers to an output stream.</td></tr><tr><td valign="top"><code class="constant">V4L2_BUF_FLAG_PREPARED</code></td><td valign="top">0x00000400</td><td valign="top">The buffer has been prepared for I/O and can be queued by the
application. Drivers set or clear this flag when the
<a class="link" href="media.html#vidioc-querybuf" title="ioctl VIDIOC_QUERYBUF">VIDIOC_QUERYBUF</a>, <a class="link" href="media.html#vidioc-qbuf" title="ioctl VIDIOC_QBUF, VIDIOC_DQBUF">VIDIOC_PREPARE_BUF</a>, <a class="link" href="media.html#vidioc-qbuf" title="ioctl VIDIOC_QBUF, VIDIOC_DQBUF">VIDIOC_QBUF</a> or <a class="link" href="media.html#vidioc-qbuf" title="ioctl VIDIOC_QBUF, VIDIOC_DQBUF">VIDIOC_DQBUF</a> ioctl is called.</td></tr><tr><td valign="top"><code class="constant">V4L2_BUF_FLAG_NO_CACHE_INVALIDATE</code></td><td valign="top">0x00000800</td><td valign="top">Caches do not have to be invalidated for this buffer.
Typically applications shall use this flag if the data captured in the buffer
is not going to be touched by the CPU, instead the buffer will, probably, be
passed on to a DMA-capable hardware unit for further processing or output.
</td></tr><tr><td valign="top"><code class="constant">V4L2_BUF_FLAG_NO_CACHE_CLEAN</code></td><td valign="top">0x00001000</td><td valign="top">Caches do not have to be cleaned for this buffer.
Typically applications shall use this flag for output buffers if the data
in this buffer has not been created by the CPU but by some DMA-capable unit,
in which case caches have not been used.</td></tr><tr><td valign="top"><code class="constant">V4L2_BUF_FLAG_TIMESTAMP_MASK</code></td><td valign="top">0x0000e000</td><td valign="top">Mask for timestamp types below. To test the
	    timestamp type, mask out bits not belonging to timestamp
	    type by performing a logical and operation with buffer
	    flags and timestamp mask.</td></tr><tr><td valign="top"><code class="constant">V4L2_BUF_FLAG_TIMESTAMP_UNKNOWN</code></td><td valign="top">0x00000000</td><td valign="top">Unknown timestamp type. This type is used by
	    drivers before Linux 3.9 and may be either monotonic (see
	    below) or realtime (wall clock). Monotonic clock has been
	    favoured in embedded systems whereas most of the drivers
	    use the realtime clock. Either kinds of timestamps are
	    available in user space via
	    <code class="function">clock_gettime(2)</code> using clock IDs
	    <code class="constant">CLOCK_MONOTONIC</code> and
	    <code class="constant">CLOCK_REALTIME</code>, respectively.</td></tr><tr><td valign="top"><code class="constant">V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC</code></td><td valign="top">0x00002000</td><td valign="top">The buffer timestamp has been taken from the
	    <code class="constant">CLOCK_MONOTONIC</code> clock. To access the
	    same clock outside V4L2, use
	    <code class="function">clock_gettime(2)</code> .</td></tr><tr><td valign="top"><code class="constant">V4L2_BUF_FLAG_TIMESTAMP_COPY</code></td><td valign="top">0x00004000</td><td valign="top">The CAPTURE buffer timestamp has been taken from the
	    corresponding OUTPUT buffer. This flag applies only to mem2mem devices.</td></tr><tr><td valign="top"><code class="constant">V4L2_BUF_FLAG_TSTAMP_SRC_MASK</code></td><td valign="top">0x00070000</td><td valign="top">Mask for timestamp sources below. The timestamp source
	    defines the point of time the timestamp is taken in relation to
	    the frame. Logical 'and' operation between the
	    <em class="structfield"><code>flags</code></em> field and
	    <code class="constant">V4L2_BUF_FLAG_TSTAMP_SRC_MASK</code> produces the
	    value of the timestamp source. Applications must set the timestamp
	    source when <em class="structfield"><code>type</code></em> refers to an output stream
	    and <code class="constant">V4L2_BUF_FLAG_TIMESTAMP_COPY</code> is set.</td></tr><tr><td valign="top"><code class="constant">V4L2_BUF_FLAG_TSTAMP_SRC_EOF</code></td><td valign="top">0x00000000</td><td valign="top">End Of Frame. The buffer timestamp has been taken
	    when the last pixel of the frame has been received or the
	    last pixel of the frame has been transmitted. In practice,
	    software generated timestamps will typically be read from
	    the clock a small amount of time after the last pixel has
	    been received or transmitten, depending on the system and
	    other activity in it.</td></tr><tr><td valign="top"><code class="constant">V4L2_BUF_FLAG_TSTAMP_SRC_SOE</code></td><td valign="top">0x00010000</td><td valign="top">Start Of Exposure. The buffer timestamp has been
	    taken when the exposure of the frame has begun. This is
	    only valid for the
	    <code class="constant">V4L2_BUF_TYPE_VIDEO_CAPTURE</code> buffer
	    type.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-memory"></a><p class="title"><b>Table 3.5. enum v4l2_memory</b></p><div class="table-contents"><table summary="enum v4l2_memory" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MEMORY_MMAP</code></td><td valign="top">1</td><td valign="top">The buffer is used for <a class="link" href="media.html#mmap" title="Streaming I/O (Memory Mapping)">memory
mapping</a> I/O.</td></tr><tr><td valign="top"><code class="constant">V4L2_MEMORY_USERPTR</code></td><td valign="top">2</td><td valign="top">The buffer is used for <a class="link" href="media.html#userp" title="Streaming I/O (User Pointers)">user
pointer</a> I/O.</td></tr><tr><td valign="top"><code class="constant">V4L2_MEMORY_OVERLAY</code></td><td valign="top">3</td><td valign="top">[to do]</td></tr><tr><td valign="top"><code class="constant">V4L2_MEMORY_DMABUF</code></td><td valign="top">4</td><td valign="top">The buffer is used for <a class="link" href="media.html#dmabuf" title="Streaming I/O (DMA buffer importing)">DMA shared
buffer</a> I/O.</td></tr></tbody></table></div></div><br class="table-break"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp62487856"></a>Timecodes</h3></div></div></div><p>The <span class="structname">v4l2_timecode</span> structure is
designed to hold a <a class="xref" href="media.html#smpte12m" title='SMPTE 12M-1999 "Television, Audio and Film - Time and Control Code"'>[<abbr class="abbrev">SMPTE 12M</abbr>]</a> or similar timecode.
(struct <span class="structname">timeval</span> timestamps are stored in
struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a> field <em class="structfield"><code>timestamp</code></em>.)</p><div class="table"><a name="v4l2-timecode"></a><p class="title"><b>Table 3.6. struct <span class="structname">v4l2_timecode</span></b></p><div class="table-contents"><table summary="struct v4l2_timecode" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>type</code></em></td><td valign="top">Frame rate the timecodes are based on, see <a class="xref" href="media.html#timecode-type" title="Table 3.7. Timecode Types">Table 3.7, &#8220;Timecode Types&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>flags</code></em></td><td valign="top">Timecode flags, see <a class="xref" href="media.html#timecode-flags" title="Table 3.8. Timecode Flags">Table 3.8, &#8220;Timecode Flags&#8221;</a>.</td></tr><tr><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>frames</code></em></td><td valign="top">Frame count, 0 ... 23/24/29/49/59, depending on the
	    type of timecode.</td></tr><tr><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>seconds</code></em></td><td valign="top">Seconds count, 0 ... 59. This is a binary, not BCD number.</td></tr><tr><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>minutes</code></em></td><td valign="top">Minutes count, 0 ... 59. This is a binary, not BCD number.</td></tr><tr><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>hours</code></em></td><td valign="top">Hours count, 0 ... 29. This is a binary, not BCD number.</td></tr><tr><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>userbits</code></em>[4]</td><td valign="top">The "user group" bits from the timecode.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="timecode-type"></a><p class="title"><b>Table 3.7. Timecode Types</b></p><div class="table-contents"><table summary="Timecode Types" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_TC_TYPE_24FPS</code></td><td valign="top">1</td><td valign="top">24 frames per second, i. e. film.</td></tr><tr><td valign="top"><code class="constant">V4L2_TC_TYPE_25FPS</code></td><td valign="top">2</td><td valign="top">25 frames per second, i. e. PAL or SECAM video.</td></tr><tr><td valign="top"><code class="constant">V4L2_TC_TYPE_30FPS</code></td><td valign="top">3</td><td valign="top">30 frames per second, i. e. NTSC video.</td></tr><tr><td valign="top"><code class="constant">V4L2_TC_TYPE_50FPS</code></td><td valign="top">4</td><td valign="top"> </td></tr><tr><td valign="top"><code class="constant">V4L2_TC_TYPE_60FPS</code></td><td valign="top">5</td><td valign="top"> </td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="timecode-flags"></a><p class="title"><b>Table 3.8. Timecode Flags</b></p><div class="table-contents"><table summary="Timecode Flags" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_TC_FLAG_DROPFRAME</code></td><td valign="top">0x0001</td><td valign="top">Indicates "drop frame" semantics for counting frames
in 29.97 fps material. When set, frame numbers 0 and 1 at the start of
each minute, except minutes 0, 10, 20, 30, 40, 50 are omitted from the
count.</td></tr><tr><td valign="top"><code class="constant">V4L2_TC_FLAG_COLORFRAME</code></td><td valign="top">0x0002</td><td valign="top">The "color frame" flag.</td></tr><tr><td valign="top"><code class="constant">V4L2_TC_USERBITS_field</code></td><td valign="top">0x000C</td><td valign="top">Field mask for the "binary group flags".</td></tr><tr><td valign="top"><code class="constant">V4L2_TC_USERBITS_USERDEFINED</code></td><td valign="top">0x0000</td><td valign="top">Unspecified format.</td></tr><tr><td valign="top"><code class="constant">V4L2_TC_USERBITS_8BITCHARS</code></td><td valign="top">0x0008</td><td valign="top">8-bit ISO characters.</td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="field-order"></a>Field Order</h2></div></div></div><p>We have to distinguish between progressive and interlaced
video. Progressive video transmits all lines of a video image
sequentially. Interlaced video divides an image into two fields,
containing only the odd and even lines of the image, respectively.
Alternating the so called odd and even field are transmitted, and due
to a small delay between fields a cathode ray TV displays the lines
interleaved, yielding the original frame. This curious technique was
invented because at refresh rates similar to film the image would
fade out too quickly. Transmitting fields reduces the flicker without
the necessity of doubling the frame rate and with it the bandwidth
required for each channel.</p><p>It is important to understand a video camera does not expose
one frame at a time, merely transmitting the frames separated into
fields. The fields are in fact captured at two different instances in
time. An object on screen may well move between one field and the
next. For applications analysing motion it is of paramount importance
to recognize which field of a frame is older, the <span class="emphasis"><em>temporal
order</em></span>.</p><p>When the driver provides or accepts images field by field
rather than interleaved, it is also important applications understand
how the fields combine to frames. We distinguish between top (aka odd) and
bottom (aka even) fields, the <span class="emphasis"><em>spatial order</em></span>: The first line
of the top field is the first line of an interlaced frame, the first
line of the bottom field is the second line of that frame.</p><p>However because fields were captured one after the other,
arguing whether a frame commences with the top or bottom field is
pointless. Any two successive top and bottom, or bottom and top fields
yield a valid frame. Only when the source was progressive to begin
with, e. g. when transferring film to video, two fields may come from
the same frame, creating a natural order.</p><p>Counter to intuition the top field is not necessarily the
older field. Whether the older field contains the top or bottom lines
is a convention determined by the video standard. Hence the
distinction between temporal and spatial order of fields. The diagrams
below should make this clearer.</p><p>All video capture and output devices must report the current
field order. Some drivers may permit the selection of a different
order, to this end applications initialize the
<em class="structfield"><code>field</code></em> field of struct <a class="link" href="media.html#v4l2-pix-format" title="Table 2.1. struct v4l2_pix_format">v4l2_pix_format</a> before
calling the <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> ioctl. If this is not desired it should
have the value <code class="constant">V4L2_FIELD_ANY</code> (0).</p><div class="table"><a name="v4l2-field"></a><p class="title"><b>Table 3.9. enum v4l2_field</b></p><div class="table-contents"><table summary="enum v4l2_field" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_FIELD_ANY</code></td><td valign="top">0</td><td valign="top">Applications request this field order when any
one of the <code class="constant">V4L2_FIELD_NONE</code>,
<code class="constant">V4L2_FIELD_TOP</code>,
<code class="constant">V4L2_FIELD_BOTTOM</code>, or
<code class="constant">V4L2_FIELD_INTERLACED</code> formats is acceptable.
Drivers choose depending on hardware capabilities or e. g. the
requested image size, and return the actual field order. Drivers must
never return <code class="constant">V4L2_FIELD_ANY</code>. If multiple
field orders are possible the driver must choose one of the possible
field orders during <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> or <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_TRY_FMT</code></a>. struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a>
<em class="structfield"><code>field</code></em> can never be
<code class="constant">V4L2_FIELD_ANY</code>.</td></tr><tr><td valign="top"><code class="constant">V4L2_FIELD_NONE</code></td><td valign="top">1</td><td valign="top">Images are in progressive format, not interlaced.
The driver may also indicate this order when it cannot distinguish
between <code class="constant">V4L2_FIELD_TOP</code> and
<code class="constant">V4L2_FIELD_BOTTOM</code>.</td></tr><tr><td valign="top"><code class="constant">V4L2_FIELD_TOP</code></td><td valign="top">2</td><td valign="top">Images consist of the top (aka odd) field only.</td></tr><tr><td valign="top"><code class="constant">V4L2_FIELD_BOTTOM</code></td><td valign="top">3</td><td valign="top">Images consist of the bottom (aka even) field only.
Applications may wish to prevent a device from capturing interlaced
images because they will have "comb" or "feathering" artefacts around
moving objects.</td></tr><tr><td valign="top"><code class="constant">V4L2_FIELD_INTERLACED</code></td><td valign="top">4</td><td valign="top">Images contain both fields, interleaved line by
line. The temporal order of the fields (whether the top or bottom
field is first transmitted) depends on the current video standard.
M/NTSC transmits the bottom field first, all other standards the top
field first.</td></tr><tr><td valign="top"><code class="constant">V4L2_FIELD_SEQ_TB</code></td><td valign="top">5</td><td valign="top">Images contain both fields, the top field lines
are stored first in memory, immediately followed by the bottom field
lines. Fields are always stored in temporal order, the older one first
in memory. Image sizes refer to the frame, not fields.</td></tr><tr><td valign="top"><code class="constant">V4L2_FIELD_SEQ_BT</code></td><td valign="top">6</td><td valign="top">Images contain both fields, the bottom field
lines are stored first in memory, immediately followed by the top
field lines. Fields are always stored in temporal order, the older one
first in memory. Image sizes refer to the frame, not fields.</td></tr><tr><td valign="top"><code class="constant">V4L2_FIELD_ALTERNATE</code></td><td valign="top">7</td><td valign="top">The two fields of a frame are passed in separate
buffers, in temporal order, i. e. the older one first. To indicate the field
parity (whether the current field is a top or bottom field) the driver
or application, depending on data direction, must set struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a>
<em class="structfield"><code>field</code></em> to
<code class="constant">V4L2_FIELD_TOP</code> or
<code class="constant">V4L2_FIELD_BOTTOM</code>. Any two successive fields pair
to build a frame. If fields are successive, without any dropped fields
between them (fields can drop individually), can be determined from
the struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a> <em class="structfield"><code>sequence</code></em> field. This format
cannot be selected when using the read/write I/O method since there
is no way to communicate if a field was a top or bottom field.</td></tr><tr><td valign="top"><code class="constant">V4L2_FIELD_INTERLACED_TB</code></td><td valign="top">8</td><td valign="top">Images contain both fields, interleaved line by
line, top field first. The top field is transmitted first.</td></tr><tr><td valign="top"><code class="constant">V4L2_FIELD_INTERLACED_BT</code></td><td valign="top">9</td><td valign="top">Images contain both fields, interleaved line by
line, top field first. The bottom field is transmitted first.</td></tr></tbody></table></div></div><br class="table-break"><div class="figure"><a name="fieldseq-tb"></a><p class="title"><b>Figure 3.1. Field Order, Top Field First Transmitted</b></p><div class="figure-contents"><div class="mediaobject"><img src="fieldseq_tb.gif" alt="Field Order, Top Field First Transmitted"></div></div></div><br class="figure-break"><div class="figure"><a name="fieldseq-bt"></a><p class="title"><b>Figure 3.2. Field Order, Bottom Field First Transmitted</b></p><div class="figure-contents"><div class="mediaobject"><img src="fieldseq_bt.gif" alt="Field Order, Bottom Field First Transmitted"></div></div></div><br class="figure-break"></div><div class="footnotes"><br><hr style="width:100; text-align:left;margin-left: 0"><div id="ftn.idp62090480" class="footnote"><p><a href="media.html#idp62090480" class="para"><sup class="para">[8] </sup></a>It would be desirable if applications could depend on
drivers supporting all I/O interfaces, but as much as the complex
memory mapping I/O can be inadequate for some devices we have no
reason to require this interface, which is most useful for simple
applications capturing still images.</p></div><div id="ftn.idp62094256" class="footnote"><p><a href="media.html#idp62094256" class="para"><sup class="para">[9] </sup></a>At the driver level <code class="function">select()</code> and
<code class="function">poll()</code> are the same, and
<code class="function">select()</code> is too important to be optional.</p></div><div id="ftn.idp62105648" class="footnote"><p><a href="media.html#idp62105648" class="para"><sup class="para">[10] </sup></a>One could use one file descriptor and set the buffer
type field accordingly when calling <a class="link" href="media.html#vidioc-qbuf" title="ioctl VIDIOC_QBUF, VIDIOC_DQBUF"><code class="constant">VIDIOC_QBUF</code></a> etc., but it makes
the <code class="function">select()</code> function ambiguous. We also like the
clean approach of one file descriptor per logical stream. Video
overlay for example is also a logical stream, although the CPU is not
needed for continuous operation.</p></div><div id="ftn.idp62141264" class="footnote"><p><a href="media.html#idp62141264" class="para"><sup class="para">[11] </sup></a>Random enqueue order permits applications processing
images out of order (such as video codecs) to return buffers earlier,
reducing the probability of data loss. Random fill order allows
drivers to reuse buffers on a LIFO-basis, taking advantage of caches
holding scatter-gather lists and the like.</p></div><div id="ftn.idp62165456" class="footnote"><p><a href="media.html#idp62165456" class="para"><sup class="para">[12] </sup></a>At the driver level <code class="function">select()</code> and
<code class="function">poll()</code> are the same, and
<code class="function">select()</code> is too important to be optional. The
rest should be evident.</p></div><div id="ftn.idp62183280" class="footnote"><p><a href="media.html#idp62183280" class="para"><sup class="para">[13] </sup></a>We expect that frequently used buffers are typically not
swapped out. Anyway, the process of swapping, locking or generating
scatter-gather lists may be time consuming. The delay can be masked by
the depth of the incoming buffer queue, and perhaps by maintaining
caches assuming a buffer will be soon enqueued again. On the other
hand, to optimize memory usage drivers can limit the number of buffers
locked in advance and recycle the most recently used buffers first. Of
course, the pages of empty buffers in the incoming queue need not be
saved to disk. Output buffers must be saved on the incoming and
outgoing queue because an application may share them with other
processes.</p></div><div id="ftn.idp62202416" class="footnote"><p><a href="media.html#idp62202416" class="para"><sup class="para">[14] </sup></a>At the driver level <code class="function">select()</code> and
<code class="function">poll()</code> are the same, and
<code class="function">select()</code> is too important to be optional. The
rest should be evident.</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="devices"></a>Chapter 4. Interfaces</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="media.html#capture">Video Capture Interface</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp63129312">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp63135904">Supplemental Functions</a></span></dt><dt><span class="section"><a href="media.html#idp63143280">Image Format Negotiation</a></span></dt><dt><span class="section"><a href="media.html#idp63167408">Reading Images</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#overlay">Video Overlay Interface</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp63229152">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp63232944">Supplemental Functions</a></span></dt><dt><span class="section"><a href="media.html#idp63239936">Setup</a></span></dt><dt><span class="section"><a href="media.html#idp63255648">Overlay Window</a></span></dt><dt><span class="section"><a href="media.html#idp63352768">Enabling Overlay</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#output">Video Output Interface</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp63496272">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp63501584">Supplemental Functions</a></span></dt><dt><span class="section"><a href="media.html#idp63508576">Image Format Negotiation</a></span></dt><dt><span class="section"><a href="media.html#idp63532608">Writing Images</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#osd">Video Output Overlay Interface</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp63588592">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp63592736">Framebuffer</a></span></dt><dt><span class="section"><a href="media.html#idp63605568">Overlay Window and Scaling</a></span></dt><dt><span class="section"><a href="media.html#idp63623776">Enabling Overlay</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#codec">Codec Interface</a></span></dt><dt><span class="section"><a href="media.html#effect">Effect Devices Interface</a></span></dt><dt><span class="section"><a href="media.html#raw-vbi">Raw VBI Data Interface</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp63701712">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp63705984">Supplemental Functions</a></span></dt><dt><span class="section"><a href="media.html#idp63710576">Raw VBI Format Negotiation</a></span></dt><dt><span class="section"><a href="media.html#idp63809184">Reading and writing VBI images</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#sliced">Sliced VBI Data Interface</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp63939408">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp63944448">Supplemental Functions</a></span></dt><dt><span class="section"><a href="media.html#sliced-vbi-format-negotitation">Sliced VBI Format Negotiation</a></span></dt><dt><span class="section"><a href="media.html#idp64060256">Reading and writing sliced VBI data</a></span></dt><dt><span class="section"><a href="media.html#idp64099728">Sliced VBI Data in MPEG Streams</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#ttx">Teletext Interface</a></span></dt><dt><span class="section"><a href="media.html#radio">Radio Interface</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp64509616">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp64564896">Supplemental Functions</a></span></dt><dt><span class="section"><a href="media.html#idp64568384">Programming</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#rds">RDS Interface</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp64515536">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#reading-rds-data">Reading RDS data</a></span></dt><dt><span class="section"><a href="media.html#writing-rds-data">Writing RDS data</a></span></dt><dt><span class="section"><a href="media.html#idp64621536">RDS datastructures</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#sdr">Software Defined Radio Interface (SDR)</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp64752064">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp64756400">Supplemental Functions</a></span></dt><dt><span class="section"><a href="media.html#idp64761456">Data Format Negotiation</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#event">Event Interface</a></span></dt><dt><span class="section"><a href="media.html#subdev">Sub-device Interface</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp64863392">Controls</a></span></dt><dt><span class="section"><a href="media.html#idp64867520">Events</a></span></dt><dt><span class="section"><a href="media.html#pad-level-formats">Pad-level Formats</a></span></dt><dt><span class="section"><a href="media.html#v4l2-mbus-format">Media Bus Formats</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="capture"></a>Video Capture Interface</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#idp63129312">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp63135904">Supplemental Functions</a></span></dt><dt><span class="section"><a href="media.html#idp63143280">Image Format Negotiation</a></span></dt><dt><span class="section"><a href="media.html#idp63167408">Reading Images</a></span></dt></dl></div><p>Video capture devices sample an analog video signal and store
the digitized images in memory. Today nearly all devices can capture
at full 25 or 30 frames/second. With this interface applications can
control the capture process and move images from the driver into user
space.</p><p>Conventionally V4L2 video capture devices are accessed through
character device special files named <code class="filename">/dev/video</code>
and <code class="filename">/dev/video0</code> to
<code class="filename">/dev/video63</code> with major number 81 and minor
numbers 0 to 63. <code class="filename">/dev/video</code> is typically a
symbolic link to the preferred video device. Note the same device
files are used for video output devices.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp63129312"></a>Querying Capabilities</h3></div></div></div><p>Devices supporting the video capture interface set the
<code class="constant">V4L2_CAP_VIDEO_CAPTURE</code> or
<code class="constant">V4L2_CAP_VIDEO_CAPTURE_MPLANE</code> flag in the
<em class="structfield"><code>capabilities</code></em> field of struct <a class="link" href="media.html#v4l2-capability" title="Table A.92. struct v4l2_capability">v4l2_capability</a>
returned by the <a class="link" href="media.html#vidioc-querycap" title="ioctl VIDIOC_QUERYCAP"><code class="constant">VIDIOC_QUERYCAP</code></a> ioctl. As secondary device functions
they may also support the <a class="link" href="media.html#overlay" title="Video Overlay Interface">video overlay</a>
(<code class="constant">V4L2_CAP_VIDEO_OVERLAY</code>) and the <a class="link" href="media.html#raw-vbi" title="Raw VBI Data Interface">raw VBI capture</a>
(<code class="constant">V4L2_CAP_VBI_CAPTURE</code>) interface. At least one of
the read/write or streaming I/O methods must be supported. Tuners and
audio inputs are optional.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp63135904"></a>Supplemental Functions</h3></div></div></div><p>Video capture devices shall support <a class="link" href="media.html#audio" title="Audio Inputs and Outputs">audio input</a>, <a class="link" href="media.html#tuner" title="Tuners and Modulators">tuner</a>, <a class="link" href="media.html#control" title="User Controls">controls</a>,
<a class="link" href="media.html#crop" title="Image Cropping, Insertion and Scaling">cropping and scaling</a> and <a class="link" href="media.html#streaming-par" title="Streaming Parameters">streaming parameter</a> ioctls as needed.
The <a class="link" href="media.html#video" title="Video Inputs and Outputs">video input</a> and <a class="link" href="media.html#standard" title="Video Standards">video standard</a> ioctls must be supported by
all video capture devices.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp63143280"></a>Image Format Negotiation</h3></div></div></div><p>The result of a capture operation is determined by
cropping and image format parameters. The former select an area of the
video picture to capture, the latter how images are stored in memory,
i. e. in RGB or YUV format, the number of bits per pixel or width and
height. Together they also define how images are scaled in the
process.</p><p>As usual these parameters are <span class="emphasis"><em>not</em></span> reset
at <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a> time to permit Unix tool chains, programming a device
and then reading from it as if it was a plain file. Well written V4L2
applications ensure they really get what they want, including cropping
and scaling.</p><p>Cropping initialization at minimum requires to reset the
parameters to defaults. An example is given in <a class="xref" href="media.html#crop" title="Image Cropping, Insertion and Scaling">the section called &#8220;Image Cropping, Insertion and Scaling&#8221;</a>.</p><p>To query the current image format applications set the
<em class="structfield"><code>type</code></em> field of a struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a> to
<code class="constant">V4L2_BUF_TYPE_VIDEO_CAPTURE</code> or
<code class="constant">V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE</code> and call the
<a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_G_FMT</code></a> ioctl with a pointer to this structure. Drivers fill
the struct <a class="link" href="media.html#v4l2-pix-format" title="Table 2.1. struct v4l2_pix_format">v4l2_pix_format</a> <em class="structfield"><code>pix</code></em> or the
struct <a class="link" href="media.html#v4l2-pix-format-mplane" title="Table 2.3. struct v4l2_pix_format_mplane">v4l2_pix_format_mplane</a> <em class="structfield"><code>pix_mp</code></em> member of the
<em class="structfield"><code>fmt</code></em> union.</p><p>To request different parameters applications set the
<em class="structfield"><code>type</code></em> field of a struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a> as above and
initialize all fields of the struct <a class="link" href="media.html#v4l2-pix-format" title="Table 2.1. struct v4l2_pix_format">v4l2_pix_format</a>
<em class="structfield"><code>vbi</code></em> member of the
<em class="structfield"><code>fmt</code></em> union, or better just modify the
results of <code class="constant">VIDIOC_G_FMT</code>, and call the
<a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> ioctl with a pointer to this structure. Drivers may
adjust the parameters and finally return the actual parameters as
<code class="constant">VIDIOC_G_FMT</code> does.</p><p>Like <code class="constant">VIDIOC_S_FMT</code> the
<a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_TRY_FMT</code></a> ioctl can be used to learn about hardware limitations
without disabling I/O or possibly time consuming hardware
preparations.</p><p>The contents of struct <a class="link" href="media.html#v4l2-pix-format" title="Table 2.1. struct v4l2_pix_format">v4l2_pix_format</a> and struct <a class="link" href="media.html#v4l2-pix-format-mplane" title="Table 2.3. struct v4l2_pix_format_mplane">v4l2_pix_format_mplane</a>
are discussed in <a class="xref" href="media.html#pixfmt" title="Chapter 2. Image Formats">Chapter 2, <i>Image Formats</i></a>. See also the specification of the
<code class="constant">VIDIOC_G_FMT</code>, <code class="constant">VIDIOC_S_FMT</code>
and <code class="constant">VIDIOC_TRY_FMT</code> ioctls for details. Video
capture devices must implement both the
<code class="constant">VIDIOC_G_FMT</code> and
<code class="constant">VIDIOC_S_FMT</code> ioctl, even if
<code class="constant">VIDIOC_S_FMT</code> ignores all requests and always
returns default parameters as <code class="constant">VIDIOC_G_FMT</code> does.
<code class="constant">VIDIOC_TRY_FMT</code> is optional.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp63167408"></a>Reading Images</h3></div></div></div><p>A video capture device may support the <a class="link" href="media.html#rw" title="Read/Write">read() function</a> and/or streaming (<a class="link" href="media.html#mmap" title="Streaming I/O (Memory Mapping)">memory mapping</a> or <a class="link" href="media.html#userp" title="Streaming I/O (User Pointers)">user pointer</a>) I/O. See <a class="xref" href="media.html#io" title="Chapter 3. Input/Output">Chapter 3, <i>Input/Output</i></a> for details.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="overlay"></a>Video Overlay Interface</h2></div><div><h3 class="subtitle">Also known as Framebuffer Overlay or Previewing</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#idp63229152">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp63232944">Supplemental Functions</a></span></dt><dt><span class="section"><a href="media.html#idp63239936">Setup</a></span></dt><dt><span class="section"><a href="media.html#idp63255648">Overlay Window</a></span></dt><dt><span class="section"><a href="media.html#idp63352768">Enabling Overlay</a></span></dt></dl></div><p>Video overlay devices have the ability to genlock (TV-)video
into the (VGA-)video signal of a graphics card, or to store captured
images directly in video memory of a graphics card, typically with
clipping. This can be considerable more efficient than capturing
images and displaying them by other means. In the old days when only
nuclear power plants needed cooling towers this used to be the only
way to put live video into a window.</p><p>Video overlay devices are accessed through the same character
special files as <a class="link" href="media.html#capture" title="Video Capture Interface">video capture</a> devices.
Note the default function of a <code class="filename">/dev/video</code> device
is video capturing. The overlay function is only available after
calling the <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> ioctl.</p><p>The driver may support simultaneous overlay and capturing
using the read/write and streaming I/O methods. If so, operation at
the nominal frame rate of the video standard is not guaranteed. Frames
may be directed away from overlay to capture, or one field may be used
for overlay and the other for capture if the capture parameters permit
this.</p><p>Applications should use different file descriptors for
capturing and overlay. This must be supported by all drivers capable
of simultaneous capturing and overlay. Optionally these drivers may
also permit capturing and overlay with a single file descriptor for
compatibility with V4L and earlier versions of V4L2.<a href="media.html#ftn.idp63225440" class="footnote" name="idp63225440"><sup class="footnote">[15]</sup></a></p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp63229152"></a>Querying Capabilities</h3></div></div></div><p>Devices supporting the video overlay interface set the
<code class="constant">V4L2_CAP_VIDEO_OVERLAY</code> flag in the
<em class="structfield"><code>capabilities</code></em> field of struct <a class="link" href="media.html#v4l2-capability" title="Table A.92. struct v4l2_capability">v4l2_capability</a>
returned by the <a class="link" href="media.html#vidioc-querycap" title="ioctl VIDIOC_QUERYCAP"><code class="constant">VIDIOC_QUERYCAP</code></a> ioctl. The overlay I/O method specified
below must be supported. Tuners and audio inputs are optional.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp63232944"></a>Supplemental Functions</h3></div></div></div><p>Video overlay devices shall support <a class="link" href="media.html#audio" title="Audio Inputs and Outputs">audio input</a>, <a class="link" href="media.html#tuner" title="Tuners and Modulators">tuner</a>, <a class="link" href="media.html#control" title="User Controls">controls</a>,
<a class="link" href="media.html#crop" title="Image Cropping, Insertion and Scaling">cropping and scaling</a> and <a class="link" href="media.html#streaming-par" title="Streaming Parameters">streaming parameter</a> ioctls as needed.
The <a class="link" href="media.html#video" title="Video Inputs and Outputs">video input</a> and <a class="link" href="media.html#standard" title="Video Standards">video standard</a> ioctls must be supported by
all video overlay devices.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp63239936"></a>Setup</h3></div></div></div><p>Before overlay can commence applications must program the
driver with frame buffer parameters, namely the address and size of
the frame buffer and the image format, for example RGB 5:6:5. The
<a class="link" href="media.html#vidioc-g-fbuf" title="ioctl VIDIOC_G_FBUF, VIDIOC_S_FBUF"><code class="constant">VIDIOC_G_FBUF</code></a> and <a class="link" href="media.html#vidioc-g-fbuf" title="ioctl VIDIOC_G_FBUF, VIDIOC_S_FBUF"><code class="constant">VIDIOC_S_FBUF</code></a> ioctls are available to get
and set these parameters, respectively. The
<code class="constant">VIDIOC_S_FBUF</code> ioctl is privileged because it
allows to set up DMA into physical memory, bypassing the memory
protection mechanisms of the kernel. Only the superuser can change the
frame buffer address and size. Users are not supposed to run TV
applications as root or with SUID bit set. A small helper application
with suitable privileges should query the graphics system and program
the V4L2 driver at the appropriate time.</p><p>Some devices add the video overlay to the output signal
of the graphics card. In this case the frame buffer is not modified by
the video device, and the frame buffer address and pixel format are
not needed by the driver. The <code class="constant">VIDIOC_S_FBUF</code> ioctl
is not privileged. An application can check for this type of device by
calling the <code class="constant">VIDIOC_G_FBUF</code> ioctl.</p><p>A driver may support any (or none) of five clipping/blending
methods:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Chroma-keying displays the overlaid image only where
pixels in the primary graphics surface assume a certain color.</p></li><li class="listitem"><p>A bitmap can be specified where each bit corresponds
to a pixel in the overlaid image. When the bit is set, the
corresponding video pixel is displayed, otherwise a pixel of the
graphics surface.</p></li><li class="listitem"><p>A list of clipping rectangles can be specified. In
these regions <span class="emphasis"><em>no</em></span> video is displayed, so the
graphics surface can be seen here.</p></li><li class="listitem"><p>The framebuffer has an alpha channel that can be used
to clip or blend the framebuffer with the video.</p></li><li class="listitem"><p>A global alpha value can be specified to blend the
framebuffer contents with video images.</p></li></ol></div><p>When simultaneous capturing and overlay is supported and
the hardware prohibits different image and frame buffer formats, the
format requested first takes precedence. The attempt to capture
(<a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a>) or overlay (<a class="link" href="media.html#vidioc-g-fbuf" title="ioctl VIDIOC_G_FBUF, VIDIOC_S_FBUF"><code class="constant">VIDIOC_S_FBUF</code></a>) may fail with an
<span class="errorcode">EBUSY</span> error code or return accordingly modified parameters..</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp63255648"></a>Overlay Window</h3></div></div></div><p>The overlaid image is determined by cropping and overlay
window parameters. The former select an area of the video picture to
capture, the latter how images are overlaid and clipped. Cropping
initialization at minimum requires to reset the parameters to
defaults. An example is given in <a class="xref" href="media.html#crop" title="Image Cropping, Insertion and Scaling">the section called &#8220;Image Cropping, Insertion and Scaling&#8221;</a>.</p><p>The overlay window is described by a struct <a class="link" href="media.html#v4l2-window" title="Table 4.1. struct v4l2_window">v4l2_window</a>. It
defines the size of the image, its position over the graphics surface
and the clipping to be applied. To get the current parameters
applications set the <em class="structfield"><code>type</code></em> field of a
struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a> to <code class="constant">V4L2_BUF_TYPE_VIDEO_OVERLAY</code> and
call the <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_G_FMT</code></a> ioctl. The driver fills the
<span class="structname">v4l2_window</span> substructure named
<em class="structfield"><code>win</code></em>. It is not possible to retrieve a
previously programmed clipping list or bitmap.</p><p>To program the overlay window applications set the
<em class="structfield"><code>type</code></em> field of a struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a> to
<code class="constant">V4L2_BUF_TYPE_VIDEO_OVERLAY</code>, initialize the
<em class="structfield"><code>win</code></em> substructure and call the
<a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> ioctl. The driver adjusts the parameters against
hardware limits and returns the actual parameters as
<code class="constant">VIDIOC_G_FMT</code> does. Like
<code class="constant">VIDIOC_S_FMT</code>, the <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_TRY_FMT</code></a> ioctl can be
used to learn about driver capabilities without actually changing
driver state. Unlike <code class="constant">VIDIOC_S_FMT</code> this also works
after the overlay has been enabled.</p><p>The scaling factor of the overlaid image is implied by the
width and height given in struct <a class="link" href="media.html#v4l2-window" title="Table 4.1. struct v4l2_window">v4l2_window</a> and the size of the cropping
rectangle. For more information see <a class="xref" href="media.html#crop" title="Image Cropping, Insertion and Scaling">the section called &#8220;Image Cropping, Insertion and Scaling&#8221;</a>.</p><p>When simultaneous capturing and overlay is supported and
the hardware prohibits different image and window sizes, the size
requested first takes precedence. The attempt to capture or overlay as
well (<a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a>) may fail with an <span class="errorcode">EBUSY</span> error code or return accordingly
modified parameters.</p><div class="table"><a name="v4l2-window"></a><p class="title"><b>Table 4.1. struct <span class="structname">v4l2_window</span></b></p><div class="table-contents"><table summary="struct v4l2_window" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">struct <a class="link" href="media.html#v4l2-rect" title="Table 4.3. struct v4l2_rect">v4l2_rect</a></td><td valign="top"><em class="structfield"><code>w</code></em></td><td valign="top">Size and position of the window relative to the
top, left corner of the frame buffer defined with <a class="link" href="media.html#vidioc-g-fbuf" title="ioctl VIDIOC_G_FBUF, VIDIOC_S_FBUF"><code class="constant">VIDIOC_S_FBUF</code></a>. The
window can extend the frame buffer width and height, the
<em class="structfield"><code>x</code></em> and <em class="structfield"><code>y</code></em>
coordinates can be negative, and it can lie completely outside the
frame buffer. The driver clips the window accordingly, or if that is
not possible, modifies its size and/or position.</td></tr><tr><td valign="top">enum <a class="link" href="media.html#v4l2-field" title="Table 3.9. enum v4l2_field">v4l2_field</a></td><td valign="top"><em class="structfield"><code>field</code></em></td><td valign="top">Applications set this field to determine which
video field shall be overlaid, typically one of
<code class="constant">V4L2_FIELD_ANY</code> (0),
<code class="constant">V4L2_FIELD_TOP</code>,
<code class="constant">V4L2_FIELD_BOTTOM</code> or
<code class="constant">V4L2_FIELD_INTERLACED</code>. Drivers may have to choose
a different field order and return the actual setting here.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>chromakey</code></em></td><td valign="top">When chroma-keying has been negotiated with
<a class="link" href="media.html#vidioc-g-fbuf" title="ioctl VIDIOC_G_FBUF, VIDIOC_S_FBUF"><code class="constant">VIDIOC_S_FBUF</code></a> applications set this field to the desired pixel value
for the chroma key. The format is the same as the pixel format of the
framebuffer (struct <a class="link" href="media.html#v4l2-framebuffer" title="Table A.68. struct v4l2_framebuffer">v4l2_framebuffer</a>
<em class="structfield"><code>fmt.pixelformat</code></em> field), with bytes in host
order. E. g. for <a class="link" href="media.html#V4L2-PIX-FMT-BGR32"><code class="constant">V4L2_PIX_FMT_BGR24</code></a>
the value should be 0xRRGGBB on a little endian, 0xBBGGRR on a big
endian host.</td></tr><tr><td valign="top">struct <a class="link" href="media.html#v4l2-clip" title="Table 4.2. struct v4l2_clip">v4l2_clip</a> *</td><td valign="top"><em class="structfield"><code>clips</code></em></td><td valign="top">When chroma-keying has <span class="emphasis"><em>not</em></span>
been negotiated and <a class="link" href="media.html#vidioc-g-fbuf" title="ioctl VIDIOC_G_FBUF, VIDIOC_S_FBUF"><code class="constant">VIDIOC_G_FBUF</code></a> indicated this capability,
applications can set this field to point to an array of
clipping rectangles.</td></tr><tr><td valign="top"> </td><td valign="top"> </td><td valign="top">Like the window coordinates
<em class="structfield"><code>w</code></em>, clipping rectangles are defined relative
to the top, left corner of the frame buffer. However clipping
rectangles must not extend the frame buffer width and height, and they
must not overlap. If possible applications should merge adjacent
rectangles. Whether this must create x-y or y-x bands, or the order of
rectangles, is not defined. When clip lists are not supported the
driver ignores this field. Its contents after calling <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a>
are undefined.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>clipcount</code></em></td><td valign="top">When the application set the
<em class="structfield"><code>clips</code></em> field, this field must contain the
number of clipping rectangles in the list. When clip lists are not
supported the driver ignores this field, its contents after calling
<code class="constant">VIDIOC_S_FMT</code> are undefined. When clip lists are
supported but no clipping is desired this field must be set to
zero.</td></tr><tr><td valign="top">void *</td><td valign="top"><em class="structfield"><code>bitmap</code></em></td><td valign="top">When chroma-keying has
<span class="emphasis"><em>not</em></span> been negotiated and <a class="link" href="media.html#vidioc-g-fbuf" title="ioctl VIDIOC_G_FBUF, VIDIOC_S_FBUF"><code class="constant">VIDIOC_G_FBUF</code></a> indicated
this capability, applications can set this field to point to a
clipping bit mask.</td></tr><tr><td colspan="3" valign="top"><p>It must be of the same size
as the window, <em class="structfield"><code>w.width</code></em> and
<em class="structfield"><code>w.height</code></em>. Each bit corresponds to a pixel
in the overlaid image, which is displayed only when the bit is
<span class="emphasis"><em>set</em></span>. Pixel coordinates translate to bits like:
</p><pre class="programlisting">
((__u8 *) <em class="structfield"><code>bitmap</code></em>)[<em class="structfield"><code>w.width</code></em> * y + x / 8] &amp; (1 &lt;&lt; (x &amp; 7))</pre><p>where <em class="structfield"><code>0</code></em> &#8804; x &lt;
<em class="structfield"><code>w.width</code></em> and <em class="structfield"><code>0</code></em> &#8804;
y &lt;<em class="structfield"><code>w.height</code></em>.<a href="media.html#ftn.idp63313888" class="footnote" name="idp63313888"><sup class="footnote">[a]</sup></a></p><p>When a clipping
bit mask is not supported the driver ignores this field, its contents
after calling <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> are undefined. When a bit mask is supported
but no clipping is desired this field must be set to
<code class="constant">NULL</code>.</p><p>Applications need not create a
clip list or bit mask. When they pass both, or despite negotiating
chroma-keying, the results are undefined. Regardless of the chosen
method, the clipping abilities of the hardware may be limited in
quantity or quality. The results when these limits are exceeded are
undefined.<a href="media.html#ftn.idp63317456" class="footnote" name="idp63317456"><sup class="footnote">[b]</sup></a></p></td></tr><tr><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>global_alpha</code></em></td><td valign="top">The global alpha value used to blend the
framebuffer with video images, if global alpha blending has been
negotiated (<code class="constant">V4L2_FBUF_FLAG_GLOBAL_ALPHA</code>, see
<a class="link" href="media.html#vidioc-g-fbuf" title="ioctl VIDIOC_G_FBUF, VIDIOC_S_FBUF"><code class="constant">VIDIOC_S_FBUF</code></a>, <a class="xref" href="media.html#framebuffer-flags" title="Table A.70. Frame Buffer Flags">Table A.70, &#8220;Frame Buffer Flags&#8221;</a>).</td></tr><tr><td valign="top"> </td><td valign="top"> </td><td valign="top">Note this field was added in Linux 2.6.23, extending the structure. However
the <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT">VIDIOC_G/S/TRY_FMT</a> ioctls,
which take a pointer to a <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a> parent structure with padding
bytes at the end, are not affected.</td></tr></tbody><tbody class="footnotes"><tr><td colspan="3"><div id="ftn.idp63313888" class="footnote"><p><a href="media.html#idp63313888" class="para"><sup class="para">[a] </sup></a>Should we require
	      <em class="structfield"><code>w.width</code></em> to be a multiple of
	      eight?</p></div><div id="ftn.idp63317456" class="footnote"><p><a href="media.html#idp63317456" class="para"><sup class="para">[b] </sup></a>When the image is written into frame buffer
memory it will be undesirable if the driver clips out less pixels
than expected, because the application and graphics system are not
aware these regions need to be refreshed. The driver should clip out
more pixels or not write the image at all.</p></div></td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-clip"></a><p class="title"><b>Table 4.2. struct <span class="structname">v4l2_clip</span><a href="media.html#ftn.idp63327856" class="footnote" name="idp63327856"><sup class="footnote">[a]</sup></a></b></p><div class="table-contents"><table summary='struct v4l2_clipThe X Window system defines "regions" which are
vectors of struct BoxRec { short x1, y1, x2, y2; } with width = x2 -
x1 and height = y2 - y1, so one cannot pass X11 clip lists
directly.' width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">struct <a class="link" href="media.html#v4l2-rect" title="Table 4.3. struct v4l2_rect">v4l2_rect</a></td><td valign="top"><em class="structfield"><code>c</code></em></td><td valign="top">Coordinates of the clipping rectangle, relative to
the top, left corner of the frame buffer. Only window pixels
<span class="emphasis"><em>outside</em></span> all clipping rectangles are
displayed.</td></tr><tr><td valign="top">struct <a class="link" href="media.html#v4l2-clip" title="Table 4.2. struct v4l2_clip">v4l2_clip</a> *</td><td valign="top"><em class="structfield"><code>next</code></em></td><td valign="top">Pointer to the next clipping rectangle, NULL when
this is the last rectangle. Drivers ignore this field, it cannot be
used to pass a linked list of clipping rectangles.</td></tr></tbody><tbody class="footnotes"><tr><td colspan="3"><div id="ftn.idp63327856" class="footnote"><p><a href="media.html#idp63327856" class="para"><sup class="para">[a] </sup></a>The X Window system defines "regions" which are
vectors of struct BoxRec { short x1, y1, x2, y2; } with width = x2 -
x1 and height = y2 - y1, so one cannot pass X11 clip lists
directly.</p></div></td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-rect"></a><p class="title"><b>Table 4.3. struct <span class="structname">v4l2_rect</span></b></p><div class="table-contents"><table summary="struct v4l2_rect" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__s32</td><td valign="top"><em class="structfield"><code>left</code></em></td><td valign="top">Horizontal offset of the top, left corner of the
rectangle, in pixels.</td></tr><tr><td valign="top">__s32</td><td valign="top"><em class="structfield"><code>top</code></em></td><td valign="top">Vertical offset of the top, left corner of the
rectangle, in pixels. Offsets increase to the right and down.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>width</code></em></td><td valign="top">Width of the rectangle, in pixels.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>height</code></em></td><td valign="top">Height of the rectangle, in pixels.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp63352768"></a>Enabling Overlay</h3></div></div></div><p>To start or stop the frame buffer overlay applications call
the <a class="link" href="media.html#vidioc-overlay" title="ioctl VIDIOC_OVERLAY"><code class="constant">VIDIOC_OVERLAY</code></a> ioctl.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="output"></a>Video Output Interface</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#idp63496272">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp63501584">Supplemental Functions</a></span></dt><dt><span class="section"><a href="media.html#idp63508576">Image Format Negotiation</a></span></dt><dt><span class="section"><a href="media.html#idp63532608">Writing Images</a></span></dt></dl></div><p>Video output devices encode stills or image sequences as
analog video signal. With this interface applications can
control the encoding process and move images from user space to
the driver.</p><p>Conventionally V4L2 video output devices are accessed through
character device special files named <code class="filename">/dev/video</code>
and <code class="filename">/dev/video0</code> to
<code class="filename">/dev/video63</code> with major number 81 and minor
numbers 0 to 63. <code class="filename">/dev/video</code> is typically a
symbolic link to the preferred video device. Note the same device
files are used for video capture devices.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp63496272"></a>Querying Capabilities</h3></div></div></div><p>Devices supporting the video output interface set the
<code class="constant">V4L2_CAP_VIDEO_OUTPUT</code> or
<code class="constant">V4L2_CAP_VIDEO_OUTPUT_MPLANE</code> flag in the
<em class="structfield"><code>capabilities</code></em> field of struct <a class="link" href="media.html#v4l2-capability" title="Table A.92. struct v4l2_capability">v4l2_capability</a>
returned by the <a class="link" href="media.html#vidioc-querycap" title="ioctl VIDIOC_QUERYCAP"><code class="constant">VIDIOC_QUERYCAP</code></a> ioctl. As secondary device functions
they may also support the <a class="link" href="media.html#raw-vbi" title="Raw VBI Data Interface">raw VBI
output</a> (<code class="constant">V4L2_CAP_VBI_OUTPUT</code>) interface. At
least one of the read/write or streaming I/O methods must be
supported. Modulators and audio outputs are optional.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp63501584"></a>Supplemental Functions</h3></div></div></div><p>Video output devices shall support <a class="link" href="media.html#audio" title="Audio Inputs and Outputs">audio output</a>, <a class="link" href="media.html#tuner" title="Tuners and Modulators">modulator</a>, <a class="link" href="media.html#control" title="User Controls">controls</a>,
<a class="link" href="media.html#crop" title="Image Cropping, Insertion and Scaling">cropping and scaling</a> and <a class="link" href="media.html#streaming-par" title="Streaming Parameters">streaming parameter</a> ioctls as needed.
The <a class="link" href="media.html#video" title="Video Inputs and Outputs">video output</a> and <a class="link" href="media.html#standard" title="Video Standards">video standard</a> ioctls must be supported by
all video output devices.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp63508576"></a>Image Format Negotiation</h3></div></div></div><p>The output is determined by cropping and image format
parameters. The former select an area of the video picture where the
image will appear, the latter how images are stored in memory, i. e. in
RGB or YUV format, the number of bits per pixel or width and height.
Together they also define how images are scaled in the process.</p><p>As usual these parameters are <span class="emphasis"><em>not</em></span> reset
at <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a> time to permit Unix tool chains, programming a device
and then writing to it as if it was a plain file. Well written V4L2
applications ensure they really get what they want, including cropping
and scaling.</p><p>Cropping initialization at minimum requires to reset the
parameters to defaults. An example is given in <a class="xref" href="media.html#crop" title="Image Cropping, Insertion and Scaling">the section called &#8220;Image Cropping, Insertion and Scaling&#8221;</a>.</p><p>To query the current image format applications set the
<em class="structfield"><code>type</code></em> field of a struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a> to
<code class="constant">V4L2_BUF_TYPE_VIDEO_OUTPUT</code> or
<code class="constant">V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE</code> and call the
<a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_G_FMT</code></a> ioctl with a pointer to this structure. Drivers fill
the struct <a class="link" href="media.html#v4l2-pix-format" title="Table 2.1. struct v4l2_pix_format">v4l2_pix_format</a> <em class="structfield"><code>pix</code></em> or the
struct <a class="link" href="media.html#v4l2-pix-format-mplane" title="Table 2.3. struct v4l2_pix_format_mplane">v4l2_pix_format_mplane</a> <em class="structfield"><code>pix_mp</code></em> member of the
<em class="structfield"><code>fmt</code></em> union.</p><p>To request different parameters applications set the
<em class="structfield"><code>type</code></em> field of a struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a> as above and
initialize all fields of the struct <a class="link" href="media.html#v4l2-pix-format" title="Table 2.1. struct v4l2_pix_format">v4l2_pix_format</a>
<em class="structfield"><code>vbi</code></em> member of the
<em class="structfield"><code>fmt</code></em> union, or better just modify the
results of <code class="constant">VIDIOC_G_FMT</code>, and call the
<a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> ioctl with a pointer to this structure. Drivers may
adjust the parameters and finally return the actual parameters as
<code class="constant">VIDIOC_G_FMT</code> does.</p><p>Like <code class="constant">VIDIOC_S_FMT</code> the
<a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_TRY_FMT</code></a> ioctl can be used to learn about hardware limitations
without disabling I/O or possibly time consuming hardware
preparations.</p><p>The contents of struct <a class="link" href="media.html#v4l2-pix-format" title="Table 2.1. struct v4l2_pix_format">v4l2_pix_format</a> and struct <a class="link" href="media.html#v4l2-pix-format-mplane" title="Table 2.3. struct v4l2_pix_format_mplane">v4l2_pix_format_mplane</a>
are discussed in <a class="xref" href="media.html#pixfmt" title="Chapter 2. Image Formats">Chapter 2, <i>Image Formats</i></a>. See also the specification of the
<code class="constant">VIDIOC_G_FMT</code>, <code class="constant">VIDIOC_S_FMT</code>
and <code class="constant">VIDIOC_TRY_FMT</code> ioctls for details. Video
output devices must implement both the
<code class="constant">VIDIOC_G_FMT</code> and
<code class="constant">VIDIOC_S_FMT</code> ioctl, even if
<code class="constant">VIDIOC_S_FMT</code> ignores all requests and always
returns default parameters as <code class="constant">VIDIOC_G_FMT</code> does.
<code class="constant">VIDIOC_TRY_FMT</code> is optional.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp63532608"></a>Writing Images</h3></div></div></div><p>A video output device may support the <a class="link" href="media.html#rw" title="Read/Write">write() function</a> and/or streaming (<a class="link" href="media.html#mmap" title="Streaming I/O (Memory Mapping)">memory mapping</a> or <a class="link" href="media.html#userp" title="Streaming I/O (User Pointers)">user pointer</a>) I/O. See <a class="xref" href="media.html#io" title="Chapter 3. Input/Output">Chapter 3, <i>Input/Output</i></a> for details.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="osd"></a>Video Output Overlay Interface</h2></div><div><h3 class="subtitle">Also known as On-Screen Display (OSD)</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#idp63588592">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp63592736">Framebuffer</a></span></dt><dt><span class="section"><a href="media.html#idp63605568">Overlay Window and Scaling</a></span></dt><dt><span class="section"><a href="media.html#idp63623776">Enabling Overlay</a></span></dt></dl></div><p>Some video output devices can overlay a framebuffer image onto
the outgoing video signal. Applications can set up such an overlay
using this interface, which borrows structures and ioctls of the <a class="link" href="media.html#overlay" title="Video Overlay Interface">Video Overlay</a> interface.</p><p>The OSD function is accessible through the same character
special file as the <a class="link" href="media.html#capture" title="Video Capture Interface">Video Output</a> function.
Note the default function of such a <code class="filename">/dev/video</code> device
is video capturing or output. The OSD function is only available after
calling the <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> ioctl.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp63588592"></a>Querying Capabilities</h3></div></div></div><p>Devices supporting the <em class="wordasword">Video Output
Overlay</em> interface set the
<code class="constant">V4L2_CAP_VIDEO_OUTPUT_OVERLAY</code> flag in the
<em class="structfield"><code>capabilities</code></em> field of struct <a class="link" href="media.html#v4l2-capability" title="Table A.92. struct v4l2_capability">v4l2_capability</a>
returned by the <a class="link" href="media.html#vidioc-querycap" title="ioctl VIDIOC_QUERYCAP"><code class="constant">VIDIOC_QUERYCAP</code></a> ioctl.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp63592736"></a>Framebuffer</h3></div></div></div><p>Contrary to the <em class="wordasword">Video Overlay</em>
interface the framebuffer is normally implemented on the TV card and
not the graphics card. On Linux it is accessible as a framebuffer
device (<code class="filename">/dev/fbN</code>). Given a V4L2 device,
applications can find the corresponding framebuffer device by calling
the <a class="link" href="media.html#vidioc-g-fbuf" title="ioctl VIDIOC_G_FBUF, VIDIOC_S_FBUF"><code class="constant">VIDIOC_G_FBUF</code></a> ioctl. It returns, amongst other information, the
physical address of the framebuffer in the
<em class="structfield"><code>base</code></em> field of struct <a class="link" href="media.html#v4l2-framebuffer" title="Table A.68. struct v4l2_framebuffer">v4l2_framebuffer</a>. The
framebuffer device ioctl <code class="constant">FBIOGET_FSCREENINFO</code>
returns the same address in the <em class="structfield"><code>smem_start</code></em>
field of struct <span class="structname">fb_fix_screeninfo</span>. The
<code class="constant">FBIOGET_FSCREENINFO</code> ioctl and struct
<span class="structname">fb_fix_screeninfo</span> are defined in the
<code class="filename">linux/fb.h</code> header file.</p><p>The width and height of the framebuffer depends on the
current video standard. A V4L2 driver may reject attempts to change
the video standard (or any other ioctl which would imply a framebuffer
size change) with an <span class="errorcode">EBUSY</span> error code until all applications closed the
framebuffer device.</p><div class="example"><a name="idp63601616"></a><p class="title"><b>Example 4.1. Finding a framebuffer device for OSD</b></p><div class="example-contents"><pre class="programlisting">
#include &lt;linux/fb.h&gt;

struct <a class="link" href="media.html#v4l2-framebuffer" title="Table A.68. struct v4l2_framebuffer">v4l2_framebuffer</a> fbuf;
unsigned int i;
int fb_fd;

if (-1 == ioctl(fd, VIDIOC_G_FBUF, &amp;fbuf)) {
	perror("VIDIOC_G_FBUF");
	exit(EXIT_FAILURE);
}

for (i = 0; i &lt; 30; i++) {
	char dev_name[16];
	struct fb_fix_screeninfo si;

	snprintf(dev_name, sizeof(dev_name), "/dev/fb%u", i);

	fb_fd = open(dev_name, O_RDWR);
	if (-1 == fb_fd) {
		switch (errno) {
		case ENOENT: /* no such file */
		case ENXIO:  /* no driver */
			continue;

		default:
			perror("open");
			exit(EXIT_FAILURE);
		}
	}

	if (0 == ioctl(fb_fd, FBIOGET_FSCREENINFO, &amp;si)) {
		if (si.smem_start == (unsigned long)fbuf.base)
			break;
	} else {
		/* Apparently not a framebuffer device. */
	}

	close(fb_fd);
	fb_fd = -1;
}

/* fb_fd is the file descriptor of the framebuffer device
   for the video output overlay, or -1 if no device was found. */
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp63605568"></a>Overlay Window and Scaling</h3></div></div></div><p>The overlay is controlled by source and target rectangles.
The source rectangle selects a subsection of the framebuffer image to
be overlaid, the target rectangle an area in the outgoing video signal
where the image will appear. Drivers may or may not support scaling,
and arbitrary sizes and positions of these rectangles. Further drivers
may support any (or none) of the clipping/blending methods defined for
the <a class="link" href="media.html#overlay" title="Video Overlay Interface">Video Overlay</a> interface.</p><p>A struct <a class="link" href="media.html#v4l2-window" title="Table 4.1. struct v4l2_window">v4l2_window</a> defines the size of the source rectangle,
its position in the framebuffer and the clipping/blending method to be
used for the overlay. To get the current parameters applications set
the <em class="structfield"><code>type</code></em> field of a struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a> to
<code class="constant">V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY</code> and call the
<a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_G_FMT</code></a> ioctl. The driver fills the
<span class="structname">v4l2_window</span> substructure named
<em class="structfield"><code>win</code></em>. It is not possible to retrieve a
previously programmed clipping list or bitmap.</p><p>To program the source rectangle applications set the
<em class="structfield"><code>type</code></em> field of a struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a> to
<code class="constant">V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY</code>, initialize
the <em class="structfield"><code>win</code></em> substructure and call the
<a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> ioctl. The driver adjusts the parameters against
hardware limits and returns the actual parameters as
<code class="constant">VIDIOC_G_FMT</code> does. Like
<code class="constant">VIDIOC_S_FMT</code>, the <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_TRY_FMT</code></a> ioctl can be
used to learn about driver capabilities without actually changing
driver state. Unlike <code class="constant">VIDIOC_S_FMT</code> this also works
after the overlay has been enabled.</p><p>A struct <a class="link" href="media.html#v4l2-crop" title="Table A.54. struct v4l2_crop">v4l2_crop</a> defines the size and position of the target
rectangle. The scaling factor of the overlay is implied by the width
and height given in struct <a class="link" href="media.html#v4l2-window" title="Table 4.1. struct v4l2_window">v4l2_window</a> and struct <a class="link" href="media.html#v4l2-crop" title="Table A.54. struct v4l2_crop">v4l2_crop</a>. The cropping API
applies to <em class="wordasword">Video Output</em> and <em class="wordasword">Video
Output Overlay</em> devices in the same way as to
<em class="wordasword">Video Capture</em> and <em class="wordasword">Video
Overlay</em> devices, merely reversing the direction of the
data flow. For more information see <a class="xref" href="media.html#crop" title="Image Cropping, Insertion and Scaling">the section called &#8220;Image Cropping, Insertion and Scaling&#8221;</a>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp63623776"></a>Enabling Overlay</h3></div></div></div><p>There is no V4L2 ioctl to enable or disable the overlay,
however the framebuffer interface of the driver may support the
<code class="constant">FBIOBLANK</code> ioctl.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="codec"></a>Codec Interface</h2></div></div></div><p>A V4L2 codec can compress, decompress, transform, or otherwise
convert video data from one format into another format, in memory. Typically
such devices are memory-to-memory devices (i.e. devices with the
<code class="constant">V4L2_CAP_VIDEO_M2M</code> or <code class="constant">V4L2_CAP_VIDEO_M2M_MPLANE</code>
capability set).
</p><p>A memory-to-memory video node acts just like a normal video node, but it
supports both output (sending frames from memory to the codec hardware) and
capture (receiving the processed frames from the codec hardware into memory)
stream I/O. An application will have to setup the stream
I/O for both sides and finally call <a class="link" href="media.html#vidioc-streamon" title="ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF"><code class="constant">VIDIOC_STREAMON</code></a> for both capture and output
to start the codec.</p><p>Video compression codecs use the MPEG controls to setup their codec parameters
(note that the MPEG controls actually support many more codecs than just MPEG).
See <a class="xref" href="media.html#mpeg-controls" title="Codec Control Reference">the section called &#8220;Codec Control Reference&#8221;</a>.</p><p>Memory-to-memory devices can often be used as a shared resource: you can
open the video node multiple times, each application setting up their own codec properties
that are local to the file handle, and each can use it independently from the others.
The driver will arbitrate access to the codec and reprogram it whenever another file
handler gets access. This is different from the usual video node behavior where the video properties
are global to the device (i.e. changing something through one file handle is visible
through another file handle).</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="effect"></a>Effect Devices Interface</h2></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Suspended</h3><p>This interface has been be suspended from the V4L2 API
implemented in Linux 2.6 until we have more experience with effect
device interfaces.</p></div><p>A V4L2 video effect device can do image effects, filtering, or
combine two or more images or image streams. For example video
transitions or wipes. Applications send data to be processed and
receive the result data either with <a class="link" href="media.html#func-read" title="V4L2 read()"><code class="function">read()</code></a> and <a class="link" href="media.html#func-write" title="V4L2 write()"><code class="function">write()</code></a>
functions, or through the streaming I/O mechanism.</p><p>[to do]</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="raw-vbi"></a>Raw VBI Data Interface</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#idp63701712">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp63705984">Supplemental Functions</a></span></dt><dt><span class="section"><a href="media.html#idp63710576">Raw VBI Format Negotiation</a></span></dt><dt><span class="section"><a href="media.html#idp63809184">Reading and writing VBI images</a></span></dt></dl></div><p>VBI is an abbreviation of Vertical Blanking Interval, a gap
in the sequence of lines of an analog video signal. During VBI
no picture information is transmitted, allowing some time while the
electron beam of a cathode ray tube TV returns to the top of the
screen. Using an oscilloscope you will find here the vertical
synchronization pulses and short data packages ASK
modulated<a href="media.html#ftn.idp63663920" class="footnote" name="idp63663920"><sup class="footnote">[16]</sup></a>
onto the video signal. These are transmissions of services such as
Teletext or Closed Caption.</p><p>Subject of this interface type is raw VBI data, as sampled off
a video signal, or to be added to a signal for output.
The data format is similar to uncompressed video images, a number of
lines times a number of samples per line, we call this a VBI image.</p><p>Conventionally V4L2 VBI devices are accessed through character
device special files named <code class="filename">/dev/vbi</code> and
<code class="filename">/dev/vbi0</code> to <code class="filename">/dev/vbi31</code> with
major number 81 and minor numbers 224 to 255.
<code class="filename">/dev/vbi</code> is typically a symbolic link to the
preferred VBI device. This convention applies to both input and output
devices.</p><p>To address the problems of finding related video and VBI
devices VBI capturing and output is also available as device function
under <code class="filename">/dev/video</code>. To capture or output raw VBI
data with these devices applications must call the <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a>
ioctl. Accessed as <code class="filename">/dev/vbi</code>, raw VBI capturing
or output is the default device function.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp63701712"></a>Querying Capabilities</h3></div></div></div><p>Devices supporting the raw VBI capturing or output API set
the <code class="constant">V4L2_CAP_VBI_CAPTURE</code> or
<code class="constant">V4L2_CAP_VBI_OUTPUT</code> flags, respectively, in the
<em class="structfield"><code>capabilities</code></em> field of struct <a class="link" href="media.html#v4l2-capability" title="Table A.92. struct v4l2_capability">v4l2_capability</a>
returned by the <a class="link" href="media.html#vidioc-querycap" title="ioctl VIDIOC_QUERYCAP"><code class="constant">VIDIOC_QUERYCAP</code></a> ioctl. At least one of the
read/write, streaming or asynchronous I/O methods must be
supported. VBI devices may or may not have a tuner or modulator.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp63705984"></a>Supplemental Functions</h3></div></div></div><p>VBI devices shall support <a class="link" href="media.html#video" title="Video Inputs and Outputs">video
input or output</a>, <a class="link" href="media.html#tuner" title="Tuners and Modulators">tuner or
modulator</a>, and <a class="link" href="media.html#control" title="User Controls">controls</a> ioctls
as needed. The <a class="link" href="media.html#standard" title="Video Standards">video standard</a> ioctls provide
information vital to program a VBI device, therefore must be
supported.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp63710576"></a>Raw VBI Format Negotiation</h3></div></div></div><p>Raw VBI sampling abilities can vary, in particular the
sampling frequency. To properly interpret the data V4L2 specifies an
ioctl to query the sampling parameters. Moreover, to allow for some
flexibility applications can also suggest different parameters.</p><p>As usual these parameters are <span class="emphasis"><em>not</em></span>
reset at <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a> time to permit Unix tool chains, programming a
device and then reading from it as if it was a plain file. Well
written V4L2 applications should always ensure they really get what
they want, requesting reasonable parameters and then checking if the
actual parameters are suitable.</p><p>To query the current raw VBI capture parameters
applications set the <em class="structfield"><code>type</code></em> field of a
struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a> to <code class="constant">V4L2_BUF_TYPE_VBI_CAPTURE</code> or
<code class="constant">V4L2_BUF_TYPE_VBI_OUTPUT</code>, and call the
<a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_G_FMT</code></a> ioctl with a pointer to this structure. Drivers fill
the struct <a class="link" href="media.html#v4l2-vbi-format" title="Table 4.4. struct v4l2_vbi_format">v4l2_vbi_format</a> <em class="structfield"><code>vbi</code></em> member of the
<em class="structfield"><code>fmt</code></em> union.</p><p>To request different parameters applications set the
<em class="structfield"><code>type</code></em> field of a struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a> as above and
initialize all fields of the struct <a class="link" href="media.html#v4l2-vbi-format" title="Table 4.4. struct v4l2_vbi_format">v4l2_vbi_format</a>
<em class="structfield"><code>vbi</code></em> member of the
<em class="structfield"><code>fmt</code></em> union, or better just modify the
results of <code class="constant">VIDIOC_G_FMT</code>, and call the
<a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> ioctl with a pointer to this structure. Drivers return
an <span class="errorcode">EINVAL</span> error code only when the given parameters are ambiguous, otherwise
they modify the parameters according to the hardware capabilites and
return the actual parameters. When the driver allocates resources at
this point, it may return an <span class="errorcode">EBUSY</span> error code to indicate the returned
parameters are valid but the required resources are currently not
available. That may happen for instance when the video and VBI areas
to capture would overlap, or when the driver supports multiple opens
and another process already requested VBI capturing or output. Anyway,
applications must expect other resource allocation points which may
return <span class="errorcode">EBUSY</span>, at the <a class="link" href="media.html#vidioc-streamon" title="ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF"><code class="constant">VIDIOC_STREAMON</code></a> ioctl
and the first read(), write() and select() call.</p><p>VBI devices must implement both the
<code class="constant">VIDIOC_G_FMT</code> and
<code class="constant">VIDIOC_S_FMT</code> ioctl, even if
<code class="constant">VIDIOC_S_FMT</code> ignores all requests and always
returns default parameters as <code class="constant">VIDIOC_G_FMT</code> does.
<code class="constant">VIDIOC_TRY_FMT</code> is optional.</p><div class="table"><a name="v4l2-vbi-format"></a><p class="title"><b>Table 4.4. struct <span class="structname">v4l2_vbi_format</span></b></p><div class="table-contents"><table summary="struct v4l2_vbi_format" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>sampling_rate</code></em></td><td valign="top">Samples per second, i. e. unit 1 Hz.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>offset</code></em></td><td valign="top"><p>Horizontal offset of the VBI image,
relative to the leading edge of the line synchronization pulse and
counted in samples: The first sample in the VBI image will be located
<em class="structfield"><code>offset</code></em> /
<em class="structfield"><code>sampling_rate</code></em> seconds following the leading
edge. See also <a class="xref" href="media.html#vbi-hsync" title="Figure 4.1. Line synchronization">Figure 4.1, &#8220;Line synchronization&#8221;</a>.</p></td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>samples_per_line</code></em></td><td valign="top"> </td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>sample_format</code></em></td><td valign="top"><p>Defines the sample format as in <a class="xref" href="media.html#pixfmt" title="Chapter 2. Image Formats">Chapter 2, <i>Image Formats</i></a>, a four-character-code.<a href="media.html#ftn.idp63746432" class="footnote" name="idp63746432"><sup class="footnote">[a]</sup></a> Usually this is
<code class="constant">V4L2_PIX_FMT_GREY</code>, i. e. each sample
consists of 8 bits with lower values oriented towards the black level.
Do not assume any other correlation of values with the signal level.
For example, the MSB does not necessarily indicate if the signal is
'high' or 'low' because 128 may not be the mean value of the
signal. Drivers shall not convert the sample format by software.</p></td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>start</code></em>[2]</td><td valign="top">This is the scanning system line number
associated with the first line of the VBI image, of the first and the
second field respectively. See <a class="xref" href="media.html#vbi-525" title="Figure 4.2. ITU-R 525 line numbering (M/NTSC and M/PAL)">Figure 4.2, &#8220;ITU-R 525 line numbering (M/NTSC and M/PAL)&#8221;</a> and
<a class="xref" href="media.html#vbi-625" title="Figure 4.3. ITU-R 625 line numbering">Figure 4.3, &#8220;ITU-R 625 line numbering&#8221;</a> for valid values.
The <code class="constant">V4L2_VBI_ITU_525_F1_START</code>,
<code class="constant">V4L2_VBI_ITU_525_F2_START</code>,
<code class="constant">V4L2_VBI_ITU_625_F1_START</code> and
<code class="constant">V4L2_VBI_ITU_625_F2_START</code> defines give the start line
numbers for each field for each 525 or 625 line format as a convenience.
Don't forget that ITU line numbering starts at 1, not 0.
VBI input drivers can return start values 0 if the hardware cannot
reliable identify scanning lines, VBI acquisition may not require this
information.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>count</code></em>[2]</td><td valign="top">The number of lines in the first and second
field image, respectively.</td></tr><tr><td colspan="3" valign="top"><p>Drivers should be as
flexibility as possible. For example, it may be possible to extend or
move the VBI capture window down to the picture area, implementing a
'full field mode' to capture data service transmissions embedded in
the picture.</p><p>An application can set the first or second
<em class="structfield"><code>count</code></em> value to zero if no data is required
from the respective field; <em class="structfield"><code>count</code></em>[1] if the
scanning system is progressive, i. e. not interlaced. The
corresponding start value shall be ignored by the application and
driver. Anyway, drivers may not support single field capturing and
return both count values non-zero.</p><p>Both
<em class="structfield"><code>count</code></em> values set to zero, or line numbers
outside the bounds depicted in <a class="xref" href="media.html#vbi-525" title="Figure 4.2. ITU-R 525 line numbering (M/NTSC and M/PAL)">Figure 4.2, &#8220;ITU-R 525 line numbering (M/NTSC and M/PAL)&#8221;</a> and <a class="xref" href="media.html#vbi-625" title="Figure 4.3. ITU-R 625 line numbering">Figure 4.3, &#8220;ITU-R 625 line numbering&#8221;</a>, or a field image covering
lines of two fields, are invalid and shall not be returned by the
driver.</p><p>To initialize the <em class="structfield"><code>start</code></em>
and <em class="structfield"><code>count</code></em> fields, applications must first
determine the current video standard selection. The <a class="link" href="media.html#v4l2-std-id" title="Table A.47. typedef v4l2_std_id">v4l2_std_id</a> or
the <em class="structfield"><code>framelines</code></em> field of struct <a class="link" href="media.html#v4l2-standard" title="Table A.45. struct v4l2_standard">v4l2_standard</a> can
be evaluated for this purpose.</p></td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>flags</code></em></td><td valign="top">See <a class="xref" href="media.html#vbifmt-flags" title="Table 4.5. Raw VBI Format Flags">Table 4.5, &#8220;Raw VBI Format Flags&#8221;</a> below. Currently
only drivers set flags, applications must set this field to
zero.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[2]</td><td valign="top">This array is reserved for future extensions.
Drivers and applications must set it to zero.</td></tr></tbody><tbody class="footnotes"><tr><td colspan="3"><div id="ftn.idp63746432" class="footnote"><p><a href="media.html#idp63746432" class="para"><sup class="para">[a] </sup></a>A few devices may be unable to
sample VBI data at all but can extend the video capture window to the
VBI region.</p></div></td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="vbifmt-flags"></a><p class="title"><b>Table 4.5. Raw VBI Format Flags</b></p><div class="table-contents"><table summary="Raw VBI Format Flags" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_VBI_UNSYNC</code></td><td valign="top">0x0001</td><td valign="top"><p>This flag indicates hardware which does not
properly distinguish between fields. Normally the VBI image stores the
first field (lower scanning line numbers) first in memory. This may be
a top or bottom field depending on the video standard. When this flag
is set the first or second field may be stored first, however the
fields are still in correct temporal order with the older field first
in memory.<a href="media.html#ftn.idp63776384" class="footnote" name="idp63776384"><sup class="footnote">[a]</sup></a></p></td></tr><tr><td valign="top"><code class="constant">V4L2_VBI_INTERLACED</code></td><td valign="top">0x0002</td><td valign="top">By default the two field images will be passed
sequentially; all lines of the first field followed by all lines of
the second field (compare <a class="xref" href="media.html#field-order" title="Field Order">the section called &#8220;Field Order&#8221;</a>
<code class="constant">V4L2_FIELD_SEQ_TB</code> and
<code class="constant">V4L2_FIELD_SEQ_BT</code>, whether the top or bottom
field is first in memory depends on the video standard). When this
flag is set, the two fields are interlaced (cf.
<code class="constant">V4L2_FIELD_INTERLACED</code>). The first line of the
first field followed by the first line of the second field, then the
two second lines, and so on. Such a layout may be necessary when the
hardware has been programmed to capture or output interlaced video
images and is unable to separate the fields for VBI capturing at
the same time. For simplicity setting this flag implies that both
<em class="structfield"><code>count</code></em> values are equal and non-zero.</td></tr></tbody><tbody class="footnotes"><tr><td colspan="3"><div id="ftn.idp63776384" class="footnote"><p><a href="media.html#idp63776384" class="para"><sup class="para">[a] </sup></a>Most VBI services transmit on both fields, but
some have different semantics depending on the field number. These
cannot be reliable decoded or encoded when
<code class="constant">V4L2_VBI_UNSYNC</code> is set.</p></div></td></tr></tbody></table></div></div><br class="table-break"><div class="figure"><a name="vbi-hsync"></a><p class="title"><b>Figure 4.1. Line synchronization</b></p><div class="figure-contents"><div class="mediaobject"><img src="vbi_hsync.gif" alt="Line synchronization diagram"></div></div></div><br class="figure-break"><div class="figure"><a name="vbi-525"></a><p class="title"><b>Figure 4.2. ITU-R 525 line numbering (M/NTSC and M/PAL)</b></p><div class="figure-contents"><div class="mediaobject"><img src="vbi_525.gif" alt="NTSC field synchronization diagram"><div class="caption"><p>(1) For the purpose of this specification field 2
starts in line 264 and not 263.5 because half line capturing is not
supported.</p></div></div></div></div><br class="figure-break"><div class="figure"><a name="vbi-625"></a><p class="title"><b>Figure 4.3. ITU-R 625 line numbering</b></p><div class="figure-contents"><div class="mediaobject"><img src="vbi_625.gif" alt="PAL/SECAM field synchronization diagram"><div class="caption"><p>(1) For the purpose of this specification field 2
starts in line 314 and not 313.5 because half line capturing is not
supported.</p></div></div></div></div><br class="figure-break"><p>Remember the VBI image format depends on the selected
video standard, therefore the application must choose a new standard or
query the current standard first. Attempts to read or write data ahead
of format negotiation, or after switching the video standard which may
invalidate the negotiated VBI parameters, should be refused by the
driver. A format change during active I/O is not permitted.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp63809184"></a>Reading and writing VBI images</h3></div></div></div><p>To assure synchronization with the field number and easier
implementation, the smallest unit of data passed at a time is one
frame, consisting of two fields of VBI images immediately following in
memory.</p><p>The total size of a frame computes as follows:</p><pre class="programlisting">
(<em class="structfield"><code>count</code></em>[0] + <em class="structfield"><code>count</code></em>[1]) *
<em class="structfield"><code>samples_per_line</code></em> * sample size in bytes</pre><p>The sample size is most likely always one byte,
applications must check the <em class="structfield"><code>sample_format</code></em>
field though, to function properly with other drivers.</p><p>A VBI device may support <a class="link" href="media.html#rw" title="Read/Write">read/write</a> and/or streaming (<a class="link" href="media.html#mmap" title="Streaming I/O (Memory Mapping)">memory mapping</a> or <a class="link" href="media.html#userp" title="Streaming I/O (User Pointers)">user pointer</a>) I/O. The latter bears the
possibility of synchronizing video and
VBI data by using buffer timestamps.</p><p>Remember the <a class="link" href="media.html#vidioc-streamon" title="ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF"><code class="constant">VIDIOC_STREAMON</code></a> ioctl and the first read(),
write() and select() call can be resource allocation points returning
an <span class="errorcode">EBUSY</span> error code if the required hardware resources are temporarily
unavailable, for example the device is already in use by another
process.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sliced"></a>Sliced VBI Data Interface</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#idp63939408">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp63944448">Supplemental Functions</a></span></dt><dt><span class="section"><a href="media.html#sliced-vbi-format-negotitation">Sliced VBI Format Negotiation</a></span></dt><dt><span class="section"><a href="media.html#idp64060256">Reading and writing sliced VBI data</a></span></dt><dt><span class="section"><a href="media.html#idp64099728">Sliced VBI Data in MPEG Streams</a></span></dt></dl></div><p>VBI stands for Vertical Blanking Interval, a gap in the
sequence of lines of an analog video signal. During VBI no picture
information is transmitted, allowing some time while the electron beam
of a cathode ray tube TV returns to the top of the screen.</p><p>Sliced VBI devices use hardware to demodulate data transmitted
in the VBI. V4L2 drivers shall <span class="emphasis"><em>not</em></span> do this by
software, see also the <a class="link" href="media.html#raw-vbi" title="Raw VBI Data Interface">raw VBI
interface</a>. The data is passed as short packets of fixed size,
covering one scan line each. The number of packets per video frame is
variable.</p><p>Sliced VBI capture and output devices are accessed through the
same character special files as raw VBI devices. When a driver
supports both interfaces, the default function of a
<code class="filename">/dev/vbi</code> device is <span class="emphasis"><em>raw</em></span> VBI
capturing or output, and the sliced VBI function is only available
after calling the <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> ioctl as defined below. Likewise a
<code class="filename">/dev/video</code> device may support the sliced VBI API,
however the default function here is video capturing or output.
Different file descriptors must be used to pass raw and sliced VBI
data simultaneously, if this is supported by the driver.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp63939408"></a>Querying Capabilities</h3></div></div></div><p>Devices supporting the sliced VBI capturing or output API
set the <code class="constant">V4L2_CAP_SLICED_VBI_CAPTURE</code> or
<code class="constant">V4L2_CAP_SLICED_VBI_OUTPUT</code> flag respectively, in
the <em class="structfield"><code>capabilities</code></em> field of struct <a class="link" href="media.html#v4l2-capability" title="Table A.92. struct v4l2_capability">v4l2_capability</a>
returned by the <a class="link" href="media.html#vidioc-querycap" title="ioctl VIDIOC_QUERYCAP"><code class="constant">VIDIOC_QUERYCAP</code></a> ioctl. At least one of the
read/write, streaming or asynchronous <a class="link" href="media.html#io" title="Chapter 3. Input/Output">I/O
methods</a> must be supported. Sliced VBI devices may have a tuner
or modulator.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp63944448"></a>Supplemental Functions</h3></div></div></div><p>Sliced VBI devices shall support <a class="link" href="media.html#video" title="Video Inputs and Outputs">video
input or output</a> and <a class="link" href="media.html#tuner" title="Tuners and Modulators">tuner or
modulator</a> ioctls if they have these capabilities, and they may
support <a class="link" href="media.html#control" title="User Controls">control</a> ioctls. The <a class="link" href="media.html#standard" title="Video Standards">video standard</a> ioctls provide information
vital to program a sliced VBI device, therefore must be
supported.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sliced-vbi-format-negotitation"></a>Sliced VBI Format Negotiation</h3></div></div></div><p>To find out which data services are supported by the
hardware applications can call the <a class="link" href="media.html#vidioc-g-sliced-vbi-cap" title="ioctl VIDIOC_G_SLICED_VBI_CAP"><code class="constant">VIDIOC_G_SLICED_VBI_CAP</code></a> ioctl.
All drivers implementing the sliced VBI interface must support this
ioctl. The results may differ from those of the <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> ioctl
when the number of VBI lines the hardware can capture or output per
frame, or the number of services it can identify on a given line are
limited. For example on PAL line 16 the hardware may be able to look
for a VPS or Teletext signal, but not both at the same time.</p><p>To determine the currently selected services applications
set the <em class="structfield"><code>type </code></em> field of struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a> to
<code class="constant"> V4L2_BUF_TYPE_SLICED_VBI_CAPTURE</code> or <code class="constant">
V4L2_BUF_TYPE_SLICED_VBI_OUTPUT</code>, and the <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_G_FMT</code></a>
ioctl fills the <em class="structfield"><code>fmt.sliced</code></em> member, a
struct <a class="link" href="media.html#v4l2-sliced-vbi-format" title="Table 4.6. struct v4l2_sliced_vbi_format">v4l2_sliced_vbi_format</a>.</p><p>Applications can request different parameters by
initializing or modifying the <em class="structfield"><code>fmt.sliced</code></em>
member and calling the <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> ioctl with a pointer to the
<span class="structname">v4l2_format</span> structure.</p><p>The sliced VBI API is more complicated than the raw VBI API
because the hardware must be told which VBI service to expect on each
scan line. Not all services may be supported by the hardware on all
lines (this is especially true for VBI output where Teletext is often
unsupported and other services can only be inserted in one specific
line). In many cases, however, it is sufficient to just set the
<em class="structfield"><code>service_set</code></em> field to the required services
and let the driver fill the <em class="structfield"><code>service_lines</code></em>
array according to hardware capabilities. Only if more precise control
is needed should the programmer set the
<em class="structfield"><code>service_lines</code></em> array explicitly.</p><p>The <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> ioctl modifies the parameters
according to hardware capabilities. When the driver allocates
resources at this point, it may return an <span class="errorcode">EBUSY</span> error code if the required
resources are temporarily unavailable. Other resource allocation
points which may return <span class="errorcode">EBUSY</span> can be the
<a class="link" href="media.html#vidioc-streamon" title="ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF"><code class="constant">VIDIOC_STREAMON</code></a> ioctl and the first <a class="link" href="media.html#func-read" title="V4L2 read()"><code class="function">read()</code></a>, <a class="link" href="media.html#func-write" title="V4L2 write()"><code class="function">write()</code></a> and
<a class="link" href="media.html#func-select" title="V4L2 select()"><code class="function">select()</code></a> call.</p><div class="table"><a name="v4l2-sliced-vbi-format"></a><p class="title"><b>Table 4.6. struct
<span class="structname">v4l2_sliced_vbi_format</span></b></p><div class="table-contents"><table summary="struct
v4l2_sliced_vbi_format" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"><col class="c5"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>service_set</code></em></td><td colspan="3" valign="top"><p>If
<em class="structfield"><code>service_set</code></em> is non-zero when passed with
<a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> or <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_TRY_FMT</code></a>, the
<em class="structfield"><code>service_lines</code></em> array will be filled by the
driver according to the services specified in this field. For example,
if <em class="structfield"><code>service_set</code></em> is initialized with
<code class="constant">V4L2_SLICED_TELETEXT_B | V4L2_SLICED_WSS_625</code>, a
driver for the cx25840 video decoder sets lines 7-22 of both
fields<a href="media.html#ftn.idp63984144" class="footnote" name="idp63984144"><sup class="footnote">[a]</sup></a> to <code class="constant">V4L2_SLICED_TELETEXT_B</code>
and line 23 of the first field to
<code class="constant">V4L2_SLICED_WSS_625</code>. If
<em class="structfield"><code>service_set</code></em> is set to zero, then the values
of <em class="structfield"><code>service_lines</code></em> will be used instead.
</p><p>On return the driver sets this field to the union of all
elements of the returned <em class="structfield"><code>service_lines</code></em>
array. It may contain less services than requested, perhaps just one,
if the hardware cannot handle more services simultaneously. It may be
empty (zero) if none of the requested services are supported by the
hardware.</p></td></tr><tr><td valign="top">__u16</td><td valign="top"><em class="structfield"><code>service_lines</code></em>[2][24]</td><td colspan="3" valign="top"><p>Applications initialize this
array with sets of data services the driver shall look for or insert
on the respective scan line. Subject to hardware capabilities drivers
return the requested set, a subset, which may be just a single
service, or an empty set. When the hardware cannot handle multiple
services on the same line the driver shall choose one. No assumptions
can be made on which service the driver chooses.</p><p>Data
services are defined in <a class="xref" href="media.html#vbi-services2" title="Table 4.7. Sliced VBI services">Table 4.7, &#8220;Sliced VBI services&#8221;</a>. Array indices
map to ITU-R line numbers (see also <a class="xref" href="media.html#vbi-525" title="Figure 4.2. ITU-R 525 line numbering (M/NTSC and M/PAL)">Figure 4.2, &#8220;ITU-R 525 line numbering (M/NTSC and M/PAL)&#8221;</a> and <a class="xref" href="media.html#vbi-625" title="Figure 4.3. ITU-R 625 line numbering">Figure 4.3, &#8220;ITU-R 625 line numbering&#8221;</a>) as follows: </p></td></tr><tr><td valign="top"> </td><td valign="top"> </td><td valign="top">Element</td><td valign="top">525 line systems</td><td valign="top">625 line systems</td></tr><tr><td valign="top"> </td><td valign="top"> </td><td valign="top"><em class="structfield"><code>service_lines</code></em>[0][1]</td><td align="center" valign="top">1</td><td align="center" valign="top">1</td></tr><tr><td valign="top"> </td><td valign="top"> </td><td valign="top"><em class="structfield"><code>service_lines</code></em>[0][23]</td><td align="center" valign="top">23</td><td align="center" valign="top">23</td></tr><tr><td valign="top"> </td><td valign="top"> </td><td valign="top"><em class="structfield"><code>service_lines</code></em>[1][1]</td><td align="center" valign="top">264</td><td align="center" valign="top">314</td></tr><tr><td valign="top"> </td><td valign="top"> </td><td valign="top"><em class="structfield"><code>service_lines</code></em>[1][23]</td><td align="center" valign="top">286</td><td align="center" valign="top">336</td></tr><tr><td valign="top"> </td><td valign="top"> </td><td colspan="3" valign="top">Drivers must set
<em class="structfield"><code>service_lines</code></em>[0][0] and
<em class="structfield"><code>service_lines</code></em>[1][0] to zero.
The <code class="constant">V4L2_VBI_ITU_525_F1_START</code>,
<code class="constant">V4L2_VBI_ITU_525_F2_START</code>,
<code class="constant">V4L2_VBI_ITU_625_F1_START</code> and
<code class="constant">V4L2_VBI_ITU_625_F2_START</code> defines give the start
line numbers for each field for each 525 or 625 line format as a
convenience.  Don't forget that ITU line numbering starts at 1, not 0.
</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>io_size</code></em></td><td colspan="3" valign="top">Maximum number of bytes passed by
one <a class="link" href="media.html#func-read" title="V4L2 read()"><code class="function">read()</code></a> or <a class="link" href="media.html#func-write" title="V4L2 write()"><code class="function">write()</code></a> call, and the buffer size in bytes for
the <a class="link" href="media.html#vidioc-qbuf" title="ioctl VIDIOC_QBUF, VIDIOC_DQBUF"><code class="constant">VIDIOC_QBUF</code></a> and <a class="link" href="media.html#vidioc-qbuf" title="ioctl VIDIOC_QBUF, VIDIOC_DQBUF"><code class="constant">VIDIOC_DQBUF</code></a> ioctl. Drivers set this field to
the size of struct <a class="link" href="media.html#v4l2-sliced-vbi-data" title="Table 4.8. struct v4l2_sliced_vbi_data">v4l2_sliced_vbi_data</a> times the number of non-zero
elements in the returned <em class="structfield"><code>service_lines</code></em>
array (that is the number of lines potentially carrying data).</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[2]</td><td colspan="3" valign="top">This array is reserved for future
extensions. Applications and drivers must set it to zero.</td></tr></tbody><tbody class="footnotes"><tr><td colspan="5"><div id="ftn.idp63984144" class="footnote"><p><a href="media.html#idp63984144" class="para"><sup class="para">[a] </sup></a>According to <a class="link" href="media.html#ets300706" title='ETS 300 706 "Enhanced Teletext specification"'>ETS 300 706</a> lines 6-22 of the
first field and lines 5-22 of the second field may carry Teletext
data.</p></div></td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="vbi-services2"></a><p class="title"><b>Table 4.7. Sliced VBI services</b></p><div class="table-contents"><table summary="Sliced VBI services" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"><col class="c5"></colgroup><thead><tr><th>Symbol</th><th>Value</th><th>Reference</th><th>Lines, usually</th><th>Payload</th></tr></thead><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_SLICED_TELETEXT_B</code>
(Teletext System B)</td><td valign="top">0x0001</td><td valign="top"><a class="xref" href="media.html#ets300706" title='ETS 300 706 "Enhanced Teletext specification"'>[<abbr class="abbrev">ETS 300 706</abbr>]</a>, <a class="xref" href="media.html#itu653" title='ITU-R Recommendation BT.653-3 "Teletext systems"'>[<abbr class="abbrev">ITU BT.653</abbr>]</a></td><td valign="top">PAL/SECAM line 7-22, 320-335 (second field 7-22)</td><td valign="top">Last 42 of the 45 byte Teletext packet, that is
without clock run-in and framing code, lsb first transmitted.</td></tr><tr><td valign="top"><code class="constant">V4L2_SLICED_VPS</code></td><td valign="top">0x0400</td><td valign="top"><a class="xref" href="media.html#ets300231" title='ETS 300 231 "Specification of the domestic video Programme Delivery Control system (PDC)"'>[<abbr class="abbrev">ETS 300 231</abbr>]</a></td><td valign="top">PAL line 16</td><td valign="top">Byte number 3 to 15 according to Figure 9 of
ETS 300 231, lsb first transmitted.</td></tr><tr><td valign="top"><code class="constant">V4L2_SLICED_CAPTION_525</code></td><td valign="top">0x1000</td><td valign="top"><a class="xref" href="media.html#eia608" title='EIA 608-B "Recommended Practice for Line 21 Data Service"'>[<abbr class="abbrev">EIA 608-B</abbr>]</a></td><td valign="top">NTSC line 21, 284 (second field 21)</td><td valign="top">Two bytes in transmission order, including parity
bit, lsb first transmitted.</td></tr><tr><td valign="top"><code class="constant">V4L2_SLICED_WSS_625</code></td><td valign="top">0x4000</td><td valign="top"><a class="xref" href="media.html#itu1119" title='ITU-R Recommendation BT.1119 "625-line television Wide Screen Signalling (WSS)"'>[<abbr class="abbrev">ITU BT.1119</abbr>]</a>, <a class="xref" href="media.html#en300294" title='EN 300 294 "625-line television Wide Screen Signalling (WSS)"'>[<abbr class="abbrev">EN 300 294</abbr>]</a></td><td valign="top">PAL/SECAM line 23</td><td valign="top"><pre class="screen">
Byte         0                 1
      msb         lsb  msb           lsb
 Bit  7 6 5 4 3 2 1 0  x x 13 12 11 10 9
</pre></td></tr><tr><td valign="top"><code class="constant">V4L2_SLICED_VBI_525</code></td><td valign="top">0x1000</td><td colspan="3" valign="top">Set of services applicable to 525
line systems.</td></tr><tr><td valign="top"><code class="constant">V4L2_SLICED_VBI_625</code></td><td valign="top">0x4401</td><td colspan="3" valign="top">Set of services applicable to 625
line systems.</td></tr></tbody></table></div></div><br class="table-break"><p>Drivers may return an <span class="errorcode">EINVAL</span> error code when applications attempt to
read or write data without prior format negotiation, after switching
the video standard (which may invalidate the negotiated VBI
parameters) and after switching the video input (which may change the
video standard as a side effect). The <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> ioctl may return
an <span class="errorcode">EBUSY</span> error code when applications attempt to change the format while i/o is
in progress (between a <a class="link" href="media.html#vidioc-streamon" title="ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF"><code class="constant">VIDIOC_STREAMON</code></a> and <a class="link" href="media.html#vidioc-streamon" title="ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF"><code class="constant">VIDIOC_STREAMOFF</code></a> call,
and after the first <a class="link" href="media.html#func-read" title="V4L2 read()"><code class="function">read()</code></a> or <a class="link" href="media.html#func-write" title="V4L2 write()"><code class="function">write()</code></a> call).</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp64060256"></a>Reading and writing sliced VBI data</h3></div></div></div><p>A single <a class="link" href="media.html#func-read" title="V4L2 read()"><code class="function">read()</code></a> or <a class="link" href="media.html#func-write" title="V4L2 write()"><code class="function">write()</code></a> call must pass all data
belonging to one video frame. That is an array of
<span class="structname">v4l2_sliced_vbi_data</span> structures with one or
more elements and a total size not exceeding
<em class="structfield"><code>io_size</code></em> bytes. Likewise in streaming I/O
mode one buffer of <em class="structfield"><code>io_size</code></em> bytes must
contain data of one video frame. The <em class="structfield"><code>id</code></em> of
unused <span class="structname">v4l2_sliced_vbi_data</span> elements must be
zero.</p><div class="table"><a name="v4l2-sliced-vbi-data"></a><p class="title"><b>Table 4.8. struct
<span class="structname">v4l2_sliced_vbi_data</span></b></p><div class="table-contents"><table summary="struct
v4l2_sliced_vbi_data" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>id</code></em></td><td valign="top">A flag from <a class="xref" href="media.html#vbi-services" title="Table A.85. Sliced VBI services">Table A.85, &#8220;Sliced VBI services&#8221;</a>
identifying the type of data in this packet. Only a single bit must be
set. When the <em class="structfield"><code>id</code></em> of a captured packet is
zero, the packet is empty and the contents of other fields are
undefined. Applications shall ignore empty packets. When the
<em class="structfield"><code>id</code></em> of a packet for output is zero the
contents of the <em class="structfield"><code>data</code></em> field are undefined
and the driver must no longer insert data on the requested
<em class="structfield"><code>field</code></em> and
<em class="structfield"><code>line</code></em>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>field</code></em></td><td valign="top">The video field number this data has been captured
from, or shall be inserted at. <code class="constant">0</code> for the first
field, <code class="constant">1</code> for the second field.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>line</code></em></td><td valign="top">The field (as opposed to frame) line number this
data has been captured from, or shall be inserted at. See <a class="xref" href="media.html#vbi-525" title="Figure 4.2. ITU-R 525 line numbering (M/NTSC and M/PAL)">Figure 4.2, &#8220;ITU-R 525 line numbering (M/NTSC and M/PAL)&#8221;</a> and <a class="xref" href="media.html#vbi-625" title="Figure 4.3. ITU-R 625 line numbering">Figure 4.3, &#8220;ITU-R 625 line numbering&#8221;</a> for valid
values. Sliced VBI capture devices can set the line number of all
packets to <code class="constant">0</code> if the hardware cannot reliably
identify scan lines. The field number must always be valid.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em></td><td valign="top">This field is reserved for future extensions.
Applications and drivers must set it to zero.</td></tr><tr><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>data</code></em>[48]</td><td valign="top">The packet payload. See <a class="xref" href="media.html#vbi-services" title="Table A.85. Sliced VBI services">Table A.85, &#8220;Sliced VBI services&#8221;</a> for the contents and number of
bytes passed for each data type. The contents of padding bytes at the
end of this array are undefined, drivers and applications shall ignore
them.</td></tr></tbody></table></div></div><br class="table-break"><p>Packets are always passed in ascending line number order,
without duplicate line numbers. The <a class="link" href="media.html#func-write" title="V4L2 write()"><code class="function">write()</code></a> function and the
<a class="link" href="media.html#vidioc-qbuf" title="ioctl VIDIOC_QBUF, VIDIOC_DQBUF"><code class="constant">VIDIOC_QBUF</code></a> ioctl must return an <span class="errorcode">EINVAL</span> error code when applications violate
this rule. They must also return an <span class="errorcode">EINVAL</span> error code when applications pass an
incorrect field or line number, or a combination of
<em class="structfield"><code>field</code></em>, <em class="structfield"><code>line</code></em> and
<em class="structfield"><code>id</code></em> which has not been negotiated with the
<a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_G_FMT</code></a> or <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> ioctl. When the line numbers are
unknown the driver must pass the packets in transmitted order. The
driver can insert empty packets with <em class="structfield"><code>id</code></em> set
to zero anywhere in the packet array.</p><p>To assure synchronization and to distinguish from frame
dropping, when a captured frame does not carry any of the requested
data services drivers must pass one or more empty packets. When an
application fails to pass VBI data in time for output, the driver
must output the last VPS and WSS packet again, and disable the output
of Closed Caption and Teletext data, or output data which is ignored
by Closed Caption and Teletext decoders.</p><p>A sliced VBI device may support <a class="link" href="media.html#rw" title="Read/Write">read/write</a> and/or streaming (<a class="link" href="media.html#mmap" title="Streaming I/O (Memory Mapping)">memory mapping</a> and/or <a class="link" href="media.html#userp" title="Streaming I/O (User Pointers)">user
pointer</a>) I/O. The latter bears the possibility of synchronizing
video and VBI data by using buffer timestamps.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp64099728"></a>Sliced VBI Data in MPEG Streams</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#idp64108208">MPEG Stream Embedded, Sliced VBI Data Format: NONE</a></span></dt><dt><span class="section"><a href="media.html#idp64110768">MPEG Stream Embedded, Sliced VBI Data Format: IVTV</a></span></dt></dl></div><p>If a device can produce an MPEG output stream, it may be
capable of providing <a class="link" href="media.html#sliced-vbi-format-negotitation" title="Sliced VBI Format Negotiation">negotiated sliced VBI
services</a> as data embedded in the MPEG stream.  Users or
applications control this sliced VBI data insertion with the <a class="link" href="media.html#v4l2-mpeg-stream-vbi-fmt">V4L2_CID_MPEG_STREAM_VBI_FMT</a>
control.</p><p>If the driver does not provide the <a class="link" href="media.html#v4l2-mpeg-stream-vbi-fmt">V4L2_CID_MPEG_STREAM_VBI_FMT</a>
control, or only allows that control to be set to <a class="link" href="media.html#v4l2-mpeg-stream-vbi-fmt"><code class="constant">
V4L2_MPEG_STREAM_VBI_FMT_NONE</code></a>, then the device
cannot embed sliced VBI data in the MPEG stream.</p><p>The <a class="link" href="media.html#v4l2-mpeg-stream-vbi-fmt">
V4L2_CID_MPEG_STREAM_VBI_FMT</a> control does not implicitly set
the device driver to capture nor cease capturing sliced VBI data.  The
control only indicates to embed sliced VBI data in the MPEG stream, if
an application has negotiated sliced VBI service be captured.</p><p>It may also be the case that a device can embed sliced VBI
data in only certain types of MPEG streams: for example in an MPEG-2
PS but not an MPEG-2 TS.  In this situation, if sliced VBI data
insertion is requested, the sliced VBI data will be embedded in MPEG
stream types when supported, and silently omitted from MPEG stream
types where sliced VBI data insertion is not supported by the device.
</p><p>The following subsections specify the format of the
embedded sliced VBI data.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp64108208"></a>MPEG Stream Embedded, Sliced VBI Data Format: NONE</h4></div></div></div><p>The <a class="link" href="media.html#v4l2-mpeg-stream-vbi-fmt"><code class="constant">
V4L2_MPEG_STREAM_VBI_FMT_NONE</code></a> embedded sliced VBI
format shall be interpreted by drivers as a control to cease
embedding sliced VBI data in MPEG streams.  Neither the device nor
driver shall insert "empty" embedded sliced VBI data packets in the
MPEG stream when this format is set.  No MPEG stream data structures
are specified for this format.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp64110768"></a>MPEG Stream Embedded, Sliced VBI Data Format: IVTV</h4></div></div></div><p>The <a class="link" href="media.html#v4l2-mpeg-stream-vbi-fmt"><code class="constant">
V4L2_MPEG_STREAM_VBI_FMT_IVTV</code></a> embedded sliced VBI
format, when supported, indicates to the driver to embed up to 36
lines of sliced VBI data per frame in an MPEG-2 <span class="emphasis"><em>Private
Stream 1 PES</em></span> packet encapsulated in an MPEG-2 <span class="emphasis"><em>
Program Pack</em></span> in the MPEG stream.</p><p><span class="emphasis"><em>Historical context</em></span>: This format
specification originates from a custom, embedded, sliced VBI data
format used by the <code class="filename">ivtv</code> driver.  This format
has already been informally specified in the kernel sources in the
file <code class="filename">Documentation/video4linux/cx2341x/README.vbi</code>
.  The maximum size of the payload and other aspects of this format
are driven by the CX23415 MPEG decoder's capabilities and limitations
with respect to extracting, decoding, and displaying sliced VBI data
embedded within an MPEG stream.</p><p>This format's use is <span class="emphasis"><em>not</em></span> exclusive to
the <code class="filename">ivtv</code> driver <span class="emphasis"><em>nor</em></span>
exclusive to CX2341x devices, as the sliced VBI data packet insertion
into the MPEG stream is implemented in driver software.  At least the
<code class="filename">cx18</code> driver provides sliced VBI data insertion
into an MPEG-2 PS in this format as well.</p><p>The following definitions specify the payload of the
MPEG-2 <span class="emphasis"><em>Private Stream 1 PES</em></span> packets that contain
sliced VBI data when <a class="link" href="media.html#v4l2-mpeg-stream-vbi-fmt">
<code class="constant">V4L2_MPEG_STREAM_VBI_FMT_IVTV</code></a> is set.
(The MPEG-2 <span class="emphasis"><em>Private Stream 1 PES</em></span> packet header
and encapsulating MPEG-2 <span class="emphasis"><em>Program Pack</em></span> header are
not detailed here.  Please refer to the MPEG-2 specifications for
details on those packet headers.)</p><p>The payload of the MPEG-2 <span class="emphasis"><em>Private Stream 1 PES
</em></span> packets that contain sliced VBI data is specified by
struct <a class="link" href="media.html#v4l2-mpeg-vbi-fmt-ivtv" title="Table 4.9. struct v4l2_mpeg_vbi_fmt_ivtv">v4l2_mpeg_vbi_fmt_ivtv</a>.  The payload is variable
length, depending on the actual number of lines of sliced VBI data
present in a video frame.  The payload may be padded at the end with
unspecified fill bytes to align the end of the payload to a 4-byte
boundary.  The payload shall never exceed 1552 bytes (2 fields with
18 lines/field with 43 bytes of data/line and a 4 byte magic number).
</p><div class="table"><a name="v4l2-mpeg-vbi-fmt-ivtv"></a><p class="title"><b>Table 4.9. struct <span class="structname">v4l2_mpeg_vbi_fmt_ivtv</span>
      </b></p><div class="table-contents"><table summary="struct v4l2_mpeg_vbi_fmt_ivtv
      " width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"></colgroup><tbody valign="top"><tr><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>magic</code></em>[4]</td><td valign="top"> </td><td valign="top">A "magic" constant from <a class="xref" href="media.html#v4l2-mpeg-vbi-fmt-ivtv-magic" title="Table 4.10. Magic Constants for struct v4l2_mpeg_vbi_fmt_ivtv magic field">Table 4.10, &#8220;Magic Constants for struct v4l2_mpeg_vbi_fmt_ivtv
	<em class="structfield"><code>magic</code></em> field&#8221;</a> that indicates
this is a valid sliced VBI data payload and also indicates which
member of the anonymous union, <em class="structfield"><code>itv0</code></em> or
<em class="structfield"><code>ITV0</code></em>, to use for the payload data.</td></tr><tr><td valign="top">union</td><td valign="top">(anonymous)</td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td valign="top"> </td><td valign="top">struct <a class="link" href="media.html#v4l2-mpeg-vbi-itv0" title="Table 4.11. struct v4l2_mpeg_vbi_itv0">
	      <span class="structname">v4l2_mpeg_vbi_itv0</span></a>
	    </td><td valign="top"><em class="structfield"><code>itv0</code></em></td><td valign="top">The primary form of the sliced VBI data payload
that contains anywhere from 1 to 35 lines of sliced VBI data.
Line masks are provided in this form of the payload indicating
which VBI lines are provided.</td></tr><tr><td valign="top"> </td><td valign="top">struct <a class="link" href="media.html#v4l2-mpeg-vbi-itv0-1" title="Table 4.12. struct v4l2_mpeg_vbi_ITV0">
	      <span class="structname">v4l2_mpeg_vbi_ITV0</span></a>
	    </td><td valign="top"><em class="structfield"><code>ITV0</code></em></td><td valign="top">An alternate form of the sliced VBI data payload
used when 36 lines of sliced VBI data are present.  No line masks are
provided in this form of the payload; all valid line mask bits are
implcitly set.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-mpeg-vbi-fmt-ivtv-magic"></a><p class="title"><b>Table 4.10. Magic Constants for struct <a class="link" href="media.html#v4l2-mpeg-vbi-fmt-ivtv" title="Table 4.9. struct v4l2_mpeg_vbi_fmt_ivtv">v4l2_mpeg_vbi_fmt_ivtv</a>
	<em class="structfield"><code>magic</code></em> field</b></p><div class="table-contents"><table summary="Magic Constants for struct v4l2_mpeg_vbi_fmt_ivtv
	magic field" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><thead><tr><th align="left">Defined Symbol</th><th align="left">Value</th><th align="left">Description</th></tr></thead><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_VBI_IVTV_MAGIC0</code>
	    </td><td valign="top">"itv0"</td><td valign="top">Indicates the <em class="structfield"><code>itv0</code></em>
member of the union in struct <a class="link" href="media.html#v4l2-mpeg-vbi-fmt-ivtv" title="Table 4.9. struct v4l2_mpeg_vbi_fmt_ivtv">v4l2_mpeg_vbi_fmt_ivtv</a> is valid.</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VBI_IVTV_MAGIC1</code>
	    </td><td valign="top">"ITV0"</td><td valign="top">Indicates the <em class="structfield"><code>ITV0</code></em>
member of the union in struct <a class="link" href="media.html#v4l2-mpeg-vbi-fmt-ivtv" title="Table 4.9. struct v4l2_mpeg_vbi_fmt_ivtv">v4l2_mpeg_vbi_fmt_ivtv</a> is valid and
that 36 lines of sliced VBI data are present.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-mpeg-vbi-itv0"></a><p class="title"><b>Table 4.11. struct <span class="structname">v4l2_mpeg_vbi_itv0</span>
      </b></p><div class="table-contents"><table summary="struct v4l2_mpeg_vbi_itv0
      " width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__le32</td><td valign="top"><em class="structfield"><code>linemask</code></em>[2]</td><td valign="top"><p>Bitmasks indicating the VBI service lines
present.  These <em class="structfield"><code>linemask</code></em> values are stored
in little endian byte order in the MPEG stream.  Some reference
<em class="structfield"><code>linemask</code></em> bit positions with their
corresponding VBI line number and video field are given below.
b<sub>0</sub> indicates the least significant bit of a
<em class="structfield"><code>linemask</code></em> value:</p><pre class="screen">
<em class="structfield"><code>linemask</code></em>[0] b<sub>0</sub>:		line  6		first field
<em class="structfield"><code>linemask</code></em>[0] b<sub>17</sub>:		line 23		first field
<em class="structfield"><code>linemask</code></em>[0] b<sub>18</sub>:		line  6		second field
<em class="structfield"><code>linemask</code></em>[0] b<sub>31</sub>:		line 19		second field
<em class="structfield"><code>linemask</code></em>[1] b<sub>0</sub>:		line 20		second field
<em class="structfield"><code>linemask</code></em>[1] b<sub>3</sub>:		line 23		second field
<em class="structfield"><code>linemask</code></em>[1] b<sub>4</sub>-b<sub>31</sub>:	unused and set to 0</pre></td></tr><tr><td valign="top">struct <a class="link" href="media.html#v4l2-mpeg-vbi-itv0-line" title="Table 4.13. struct v4l2_mpeg_vbi_itv0_line">
	      <span class="structname">v4l2_mpeg_vbi_itv0_line</span></a>
	    </td><td valign="top"><em class="structfield"><code>line</code></em>[35]</td><td valign="top">This is a variable length array that holds from 1
to 35 lines of sliced VBI data.  The sliced VBI data lines present
correspond to the bits set in the <em class="structfield"><code>linemask</code></em>
array, starting from b<sub>0</sub> of <em class="structfield"><code>
linemask</code></em>[0] up through b<sub>31</sub> of
<em class="structfield"><code>linemask</code></em>[0], and from b<sub>0
</sub> of <em class="structfield"><code>linemask</code></em>[1] up through b
<sub>3</sub> of <em class="structfield"><code>linemask</code></em>[1].
<em class="structfield"><code>line</code></em>[0] corresponds to the first bit
found set in the <em class="structfield"><code>linemask</code></em> array,
<em class="structfield"><code>line</code></em>[1] corresponds to the second bit
found set in the <em class="structfield"><code>linemask</code></em> array, etc.
If no <em class="structfield"><code>linemask</code></em> array bits are set, then
<em class="structfield"><code>line</code></em>[0] may contain one line of
unspecified data that should be ignored by applications.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-mpeg-vbi-itv0-1"></a><p class="title"><b>Table 4.12. struct <span class="structname">v4l2_mpeg_vbi_ITV0</span>
      </b></p><div class="table-contents"><table summary="struct v4l2_mpeg_vbi_ITV0
      " width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">struct <a class="link" href="media.html#v4l2-mpeg-vbi-itv0-line" title="Table 4.13. struct v4l2_mpeg_vbi_itv0_line">
	      <span class="structname">v4l2_mpeg_vbi_itv0_line</span></a>
	    </td><td valign="top"><em class="structfield"><code>line</code></em>[36]</td><td valign="top">A fixed length array of 36 lines of sliced VBI
data.  <em class="structfield"><code>line</code></em>[0] through <em class="structfield"><code>line
</code></em>[17] correspond to lines 6 through 23 of the
first field.  <em class="structfield"><code>line</code></em>[18] through
<em class="structfield"><code>line</code></em>[35] corresponds to lines 6
through 23 of the second field.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-mpeg-vbi-itv0-line"></a><p class="title"><b>Table 4.13. struct <span class="structname">v4l2_mpeg_vbi_itv0_line</span>
      </b></p><div class="table-contents"><table summary="struct v4l2_mpeg_vbi_itv0_line
      " width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>id</code></em></td><td valign="top">A line identifier value from
<a class="xref" href="media.html#ITV0-Line-Identifier-Constants" title="Table 4.14. Line Identifiers for struct v4l2_mpeg_vbi_itv0_line id field">Table 4.14, &#8220;Line Identifiers for struct <span class="structname">
v4l2_mpeg_vbi_itv0_line</span> <em class="structfield"><code>id
</code></em> field&#8221;</a> that indicates
the type of sliced VBI data stored on this line.</td></tr><tr><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>data</code></em>[42]</td><td valign="top">The sliced VBI data for the line.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="ITV0-Line-Identifier-Constants"></a><p class="title"><b>Table 4.14. Line Identifiers for struct <a class="link" href="media.html#v4l2-mpeg-vbi-itv0-line" title="Table 4.13. struct v4l2_mpeg_vbi_itv0_line"><span class="structname">
v4l2_mpeg_vbi_itv0_line</span></a> <em class="structfield"><code>id
</code></em> field</b></p><div class="table-contents"><table summary="Line Identifiers for struct 
v4l2_mpeg_vbi_itv0_line id
 field" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><thead><tr><th align="left">Defined Symbol</th><th align="left">Value</th><th align="left">Description</th></tr></thead><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MPEG_VBI_IVTV_TELETEXT_B</code>
	    </td><td valign="top">1</td><td valign="top">Refer to <a class="link" href="media.html#vbi-services2" title="Table 4.7. Sliced VBI services">
Sliced VBI services</a> for a description of the line payload.</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VBI_IVTV_CAPTION_525</code>
	    </td><td valign="top">4</td><td valign="top">Refer to <a class="link" href="media.html#vbi-services2" title="Table 4.7. Sliced VBI services">
Sliced VBI services</a> for a description of the line payload.</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VBI_IVTV_WSS_625</code>
	    </td><td valign="top">5</td><td valign="top">Refer to <a class="link" href="media.html#vbi-services2" title="Table 4.7. Sliced VBI services">
Sliced VBI services</a> for a description of the line payload.</td></tr><tr><td valign="top"><code class="constant">V4L2_MPEG_VBI_IVTV_VPS</code>
	    </td><td valign="top">7</td><td valign="top">Refer to <a class="link" href="media.html#vbi-services2" title="Table 4.7. Sliced VBI services">
Sliced VBI services</a> for a description of the line payload.</td></tr></tbody></table></div></div><br class="table-break"></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ttx"></a>Teletext Interface</h2></div></div></div><p>This interface was aimed at devices receiving and demodulating
Teletext data [<a class="xref" href="media.html#ets300706" title='ETS 300 706 "Enhanced Teletext specification"'>[<abbr class="abbrev">ETS 300 706</abbr>]</a>, <a class="xref" href="media.html#itu653" title='ITU-R Recommendation BT.653-3 "Teletext systems"'>[<abbr class="abbrev">ITU BT.653</abbr>]</a>], evaluating the
Teletext packages and storing formatted pages in cache memory. Such
devices are usually implemented as microcontrollers with serial
interface (I<sup>2</sup>C) and could be found on old
TV cards, dedicated Teletext decoding cards and home-brew devices
connected to the PC parallel port.</p><p>The Teletext API was designed by Martin Buck. It was defined in
the kernel header file <code class="filename">linux/videotext.h</code>, the
specification is available from <a class="ulink" href="ftp://ftp.gwdg.de/pub/linux/misc/videotext/" target="_top">
ftp://ftp.gwdg.de/pub/linux/misc/videotext/</a>. (Videotext is the name of
the German public television Teletext service.)</p><p>Eventually the Teletext API was integrated into the V4L API
with character device file names <code class="filename">/dev/vtx0</code> to
<code class="filename">/dev/vtx31</code>, device major number 81, minor numbers
192 to 223.</p><p>However, teletext decoders were quickly replaced by more
generic VBI demodulators and those dedicated teletext decoders no longer exist.
For many years the vtx devices were still around, even though nobody used
them. So the decision was made to finally remove support for the Teletext API in
kernel 2.6.37.</p><p>Modern devices all use the <a class="link" href="media.html#raw-vbi" title="Raw VBI Data Interface">raw</a> or
<a class="link" href="media.html#sliced" title="Sliced VBI Data Interface">sliced</a> VBI API.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="radio"></a>Radio Interface</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#idp64509616">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp64564896">Supplemental Functions</a></span></dt><dt><span class="section"><a href="media.html#idp64568384">Programming</a></span></dt></dl></div><p>This interface is intended for AM and FM (analog) radio
receivers and transmitters.</p><p>Conventionally V4L2 radio devices are accessed through
character device special files named <code class="filename">/dev/radio</code>
and <code class="filename">/dev/radio0</code> to
<code class="filename">/dev/radio63</code> with major number 81 and minor
numbers 64 to 127.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp64509616"></a>Querying Capabilities</h3></div></div></div><p>Devices supporting the radio interface set the
<code class="constant">V4L2_CAP_RADIO</code> and
<code class="constant">V4L2_CAP_TUNER</code> or
<code class="constant">V4L2_CAP_MODULATOR</code> flag in the
<em class="structfield"><code>capabilities</code></em> field of struct <a class="link" href="media.html#v4l2-capability" title="Table A.92. struct v4l2_capability">v4l2_capability</a>
returned by the <a class="link" href="media.html#vidioc-querycap" title="ioctl VIDIOC_QUERYCAP"><code class="constant">VIDIOC_QUERYCAP</code></a> ioctl. Other combinations of
capability flags are reserved for future extensions.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp64564896"></a>Supplemental Functions</h3></div></div></div><p>Radio devices can support <a class="link" href="media.html#control" title="User Controls">controls</a>, and must support the <a class="link" href="media.html#tuner" title="Tuners and Modulators">tuner or modulator</a> ioctls.</p><p>They do not support the video input or output, audio input
or output, video standard, cropping and scaling, compression and
streaming parameter, or overlay ioctls. All other ioctls and I/O
methods are reserved for future extensions.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp64568384"></a>Programming</h3></div></div></div><p>Radio devices may have a couple audio controls (as discussed
in <a class="xref" href="media.html#control" title="User Controls">the section called &#8220;User Controls&#8221;</a>) such as a volume control, possibly custom
controls. Further all radio devices have one tuner or modulator (these are
discussed in <a class="xref" href="media.html#tuner" title="Tuners and Modulators">the section called &#8220;Tuners and Modulators&#8221;</a>) with index number zero to select
the radio frequency and to determine if a monaural or FM stereo
program is received/emitted. Drivers switch automatically between AM and FM
depending on the selected frequency. The <a class="link" href="media.html#vidioc-g-tuner" title="ioctl VIDIOC_G_TUNER, VIDIOC_S_TUNER"><code class="constant">VIDIOC_G_TUNER</code></a> or
<a class="link" href="media.html#vidioc-g-modulator" title="ioctl VIDIOC_G_MODULATOR, VIDIOC_S_MODULATOR"><code class="constant">VIDIOC_G_MODULATOR</code></a> ioctl
reports the supported frequency range.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="rds"></a>RDS Interface</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#idp64515536">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#reading-rds-data">Reading RDS data</a></span></dt><dt><span class="section"><a href="media.html#writing-rds-data">Writing RDS data</a></span></dt><dt><span class="section"><a href="media.html#idp64621536">RDS datastructures</a></span></dt></dl></div><p>The Radio Data System transmits supplementary
information in binary format, for example the station name or travel
information, on an inaudible audio subcarrier of a radio program. This
interface is aimed at devices capable of receiving and/or transmitting RDS
information.</p><p>For more information see the core RDS standard <a class="xref" href="media.html#iec62106" title="Specification of the radio data system (RDS) for VHF/FM sound broadcasting in the frequency range from 87,5 to 108,0 MHz">[<abbr class="abbrev">IEC 62106</abbr>]</a>
and the RBDS standard <a class="xref" href="media.html#nrsc4" title="NRSC-4-B: United States RBDS Standard">[<abbr class="abbrev">NRSC-4-B</abbr>]</a>.</p><p>Note that the RBDS standard as is used in the USA is almost identical
to the RDS standard. Any RDS decoder/encoder can also handle RBDS. Only some of the
fields have slightly different meanings. See the RBDS standard for more
information.</p><p>The RBDS standard also specifies support for MMBS (Modified Mobile Search).
This is a proprietary format which seems to be discontinued. The RDS interface does not
support this format. Should support for MMBS (or the so-called 'E blocks' in general)
be needed, then please contact the linux-media mailing list: <a class="ulink" href="http://www.linuxtv.org/lists.php" target="_top">http://www.linuxtv.org/lists.php</a>.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp64515536"></a>Querying Capabilities</h3></div></div></div><p>Devices supporting the RDS capturing API set
the <code class="constant">V4L2_CAP_RDS_CAPTURE</code> flag in
the <em class="structfield"><code>capabilities</code></em> field of struct <a class="link" href="media.html#v4l2-capability" title="Table A.92. struct v4l2_capability">v4l2_capability</a>
returned by the <a class="link" href="media.html#vidioc-querycap" title="ioctl VIDIOC_QUERYCAP"><code class="constant">VIDIOC_QUERYCAP</code></a> ioctl.  Any tuner that supports RDS
will set the <code class="constant">V4L2_TUNER_CAP_RDS</code> flag in
the <em class="structfield"><code>capability</code></em> field of struct <a class="link" href="media.html#v4l2-tuner" title="Table A.86. struct v4l2_tuner">v4l2_tuner</a>.  If
the driver only passes RDS blocks without interpreting the data
the <code class="constant">V4L2_TUNER_CAP_RDS_BLOCK_IO</code> flag has to be
set, see <a class="link" href="media.html#reading-rds-data" title="Reading RDS data">Reading RDS data</a>.
For future use the
flag <code class="constant">V4L2_TUNER_CAP_RDS_CONTROLS</code> has also been
defined. However, a driver for a radio tuner with this capability does
not yet exist, so if you are planning to write such a driver you
should discuss this on the linux-media mailing list: <a class="ulink" href="http://www.linuxtv.org/lists.php" target="_top">http://www.linuxtv.org/lists.php</a>.</p><p> Whether an RDS signal is present can be detected by looking
at the <em class="structfield"><code>rxsubchans</code></em> field of struct <a class="link" href="media.html#v4l2-tuner" title="Table A.86. struct v4l2_tuner">v4l2_tuner</a>:
the <code class="constant">V4L2_TUNER_SUB_RDS</code> will be set if RDS data
was detected.</p><p>Devices supporting the RDS output API
set the <code class="constant">V4L2_CAP_RDS_OUTPUT</code> flag in
the <em class="structfield"><code>capabilities</code></em> field of struct <a class="link" href="media.html#v4l2-capability" title="Table A.92. struct v4l2_capability">v4l2_capability</a>
returned by the <a class="link" href="media.html#vidioc-querycap" title="ioctl VIDIOC_QUERYCAP"><code class="constant">VIDIOC_QUERYCAP</code></a> ioctl.
Any modulator that supports RDS will set the
<code class="constant">V4L2_TUNER_CAP_RDS</code> flag in the <em class="structfield"><code>capability</code></em>
field of struct <a class="link" href="media.html#v4l2-modulator" title="Table A.75. struct v4l2_modulator">v4l2_modulator</a>.
In order to enable the RDS transmission one must set the <code class="constant">V4L2_TUNER_SUB_RDS</code>
bit in the <em class="structfield"><code>txsubchans</code></em> field of struct <a class="link" href="media.html#v4l2-modulator" title="Table A.75. struct v4l2_modulator">v4l2_modulator</a>.
If the driver only passes RDS blocks without interpreting the data
the <code class="constant">V4L2_TUNER_CAP_RDS_BLOCK_IO</code> flag has to be set. If the
tuner is capable of handling RDS entities like program identification codes and radio
text, the flag <code class="constant">V4L2_TUNER_CAP_RDS_CONTROLS</code> should be set,
see <a class="link" href="media.html#writing-rds-data" title="Writing RDS data">Writing RDS data</a> and
<a class="link" href="media.html#fm-tx-controls" title="FM Transmitter Control Reference">FM Transmitter Control Reference</a>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="reading-rds-data"></a>Reading RDS data</h3></div></div></div><p>RDS data can be read from the radio device
with the <a class="link" href="media.html#func-read" title="V4L2 read()"><code class="function">read()</code></a> function. The data is packed in groups of three bytes.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="writing-rds-data"></a>Writing RDS data</h3></div></div></div><p>RDS data can be written to the radio device
with the <a class="link" href="media.html#func-write" title="V4L2 write()"><code class="function">write()</code></a> function. The data is packed in groups of three bytes,
as follows:</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp64621536"></a>RDS datastructures</h3></div></div></div><div class="table"><a name="v4l2-rds-data"></a><p class="title"><b>Table 4.15. struct
<span class="structname">v4l2_rds_data</span></b></p><div class="table-contents"><table summary="struct
v4l2_rds_data" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>lsb</code></em></td><td valign="top">Least Significant Byte of RDS Block</td></tr><tr><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>msb</code></em></td><td valign="top">Most Significant Byte of RDS Block</td></tr><tr><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>block</code></em></td><td valign="top">Block description</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-rds-block"></a><p class="title"><b>Table 4.16. Block description</b></p><div class="table-contents"><table summary="Block description" width="100%" border="0"><colgroup><col class="c1"><col class="c2"></colgroup><tbody valign="top"><tr><td valign="top">Bits 0-2</td><td valign="top">Block (aka offset) of the received data.</td></tr><tr><td valign="top">Bits 3-5</td><td valign="top">Deprecated. Currently identical to bits 0-2. Do not use these bits.</td></tr><tr><td valign="top">Bit 6</td><td valign="top">Corrected bit. Indicates that an error was corrected for this data block.</td></tr><tr><td valign="top">Bit 7</td><td valign="top">Error bit. Indicates that an uncorrectable error occurred during reception of this block.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-rds-block-codes"></a><p class="title"><b>Table 4.17. Block defines</b></p><div class="table-contents"><table summary="Block defines" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"></colgroup><tbody valign="top"><tr><td valign="top">V4L2_RDS_BLOCK_MSK</td><td valign="top"> </td><td valign="top">7</td><td valign="top">Mask for bits 0-2 to get the block ID.</td></tr><tr><td valign="top">V4L2_RDS_BLOCK_A</td><td valign="top"> </td><td valign="top">0</td><td valign="top">Block A.</td></tr><tr><td valign="top">V4L2_RDS_BLOCK_B</td><td valign="top"> </td><td valign="top">1</td><td valign="top">Block B.</td></tr><tr><td valign="top">V4L2_RDS_BLOCK_C</td><td valign="top"> </td><td valign="top">2</td><td valign="top">Block C.</td></tr><tr><td valign="top">V4L2_RDS_BLOCK_D</td><td valign="top"> </td><td valign="top">3</td><td valign="top">Block D.</td></tr><tr><td valign="top">V4L2_RDS_BLOCK_C_ALT</td><td valign="top"> </td><td valign="top">4</td><td valign="top">Block C'.</td></tr><tr><td valign="top">V4L2_RDS_BLOCK_INVALID</td><td valign="top">read-only</td><td valign="top">7</td><td valign="top">An invalid block.</td></tr><tr><td valign="top">V4L2_RDS_BLOCK_CORRECTED</td><td valign="top">read-only</td><td valign="top">0x40</td><td valign="top">A bit error was detected but corrected.</td></tr><tr><td valign="top">V4L2_RDS_BLOCK_ERROR</td><td valign="top">read-only</td><td valign="top">0x80</td><td valign="top">An uncorrectable error occurred.</td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sdr"></a>Software Defined Radio Interface (SDR)</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#idp64752064">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp64756400">Supplemental Functions</a></span></dt><dt><span class="section"><a href="media.html#idp64761456">Data Format Negotiation</a></span></dt></dl></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Experimental</h3><p>This is an <a class="link" href="media.html#experimental" title="Experimental API Elements"> experimental </a>
    interface and may change in the future.</p></div><p>
SDR is an abbreviation of Software Defined Radio, the radio device
which uses application software for modulation or demodulation. This interface
is intended for controlling and data streaming of such devices.
  </p><p>
SDR devices are accessed through character device special files named
<code class="filename">/dev/swradio0</code> to <code class="filename">/dev/swradio255</code>
with major number 81 and dynamically allocated minor numbers 0 to 255.
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp64752064"></a>Querying Capabilities</h3></div></div></div><p>
Devices supporting the SDR receiver interface set the
<code class="constant">V4L2_CAP_SDR_CAPTURE</code> and
<code class="constant">V4L2_CAP_TUNER</code> flag in the
<em class="structfield"><code>capabilities</code></em> field of struct <a class="link" href="media.html#v4l2-capability" title="Table A.92. struct v4l2_capability">v4l2_capability</a>
returned by the <a class="link" href="media.html#vidioc-querycap" title="ioctl VIDIOC_QUERYCAP"><code class="constant">VIDIOC_QUERYCAP</code></a> ioctl. That flag means the device has an
Analog to Digital Converter (ADC), which is a mandatory element for the SDR receiver.
At least one of the read/write, streaming or asynchronous I/O methods must
be supported.
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp64756400"></a>Supplemental Functions</h3></div></div></div><p>
SDR devices can support <a class="link" href="media.html#control" title="User Controls">controls</a>, and must
support the <a class="link" href="media.html#tuner" title="Tuners and Modulators">tuner</a> ioctls. Tuner ioctls are used
for setting the ADC sampling rate (sampling frequency) and the possible RF tuner
frequency.
    </p><p>
The <code class="constant">V4L2_TUNER_ADC</code> tuner type is used for ADC tuners, and
the <code class="constant">V4L2_TUNER_RF</code> tuner type is used for RF tuners. The
tuner index of the RF tuner (if any) must always follow the ADC tuner index.
Normally the ADC tuner is #0 and the RF tuner is #1.
    </p><p>
The <a class="link" href="media.html#vidioc-s-hw-freq-seek" title="ioctl VIDIOC_S_HW_FREQ_SEEK"><code class="constant">VIDIOC_S_HW_FREQ_SEEK</code></a> ioctl is not supported.
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp64761456"></a>Data Format Negotiation</h3></div></div></div><p>
The SDR capture device uses the <a class="link" href="media.html#format" title="Data Formats">format</a> ioctls to
select the capture format. Both the sampling resolution and the data streaming
format are bound to that selectable format. In addition to the basic
<a class="link" href="media.html#format" title="Data Formats">format</a> ioctls, the <a class="link" href="media.html#vidioc-enum-fmt" title="ioctl VIDIOC_ENUM_FMT"><code class="constant">VIDIOC_ENUM_FMT</code></a> ioctl
must be supported as well.
    </p><p>
To use the <a class="link" href="media.html#format" title="Data Formats">format</a> ioctls applications set the
<em class="structfield"><code>type</code></em> field of a struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a> to
<code class="constant">V4L2_BUF_TYPE_SDR_CAPTURE</code> and use the struct <a class="link" href="media.html#v4l2-sdr-format" title="Table 4.18. struct v4l2_sdr_format">v4l2_sdr_format</a>
<em class="structfield"><code>sdr</code></em> member of the <em class="structfield"><code>fmt</code></em>
union as needed per the desired operation.
Currently there is two fields, <em class="structfield"><code>pixelformat</code></em> and
<em class="structfield"><code>buffersize</code></em>, of struct struct <a class="link" href="media.html#v4l2-sdr-format" title="Table 4.18. struct v4l2_sdr_format">v4l2_sdr_format</a> which are
used. Content of the <em class="structfield"><code>pixelformat</code></em> is V4L2 FourCC
code of the data format. The <em class="structfield"><code>buffersize</code></em> field is
maximum buffer size in bytes required for data transfer, set by the driver in
order to inform application.
    </p><div class="table"><a name="v4l2-sdr-format"></a><p class="title"><b>Table 4.18. struct <span class="structname">v4l2_sdr_format</span></b></p><div class="table-contents"><table summary="struct v4l2_sdr_format" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>pixelformat</code></em></td><td valign="top">
The data format or type of compression, set by the application. This is a
little endian <a class="link" href="media.html#v4l2-fourcc">four character code</a>.
V4L2 defines SDR formats in <a class="xref" href="media.html#sdr-formats" title="SDR Formats">the section called &#8220;SDR Formats&#8221;</a>.
           </td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>buffersize</code></em></td><td valign="top">
Maximum size in bytes required for data. Value is set by the driver.
           </td></tr><tr><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>reserved[24]</code></em></td><td valign="top">This array is reserved for future extensions.
Drivers and applications must set it to zero.</td></tr></tbody></table></div></div><br class="table-break"><p>
An SDR device may support <a class="link" href="media.html#rw" title="Read/Write">read/write</a>
and/or streaming (<a class="link" href="media.html#mmap" title="Streaming I/O (Memory Mapping)">memory mapping</a>
or <a class="link" href="media.html#userp" title="Streaming I/O (User Pointers)">user pointer</a>) I/O.
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="event"></a>Event Interface</h2></div></div></div><p>The V4L2 event interface provides a means for a user to get
  immediately notified on certain conditions taking place on a device.
  This might include start of frame or loss of signal events, for
  example. Changes in the value or state of a V4L2 control can also be
  reported through events.
  </p><p>To receive events, the events the user is interested in first must
  be subscribed using the <a class="link" href="media.html#vidioc-subscribe-event" title="ioctl VIDIOC_SUBSCRIBE_EVENT, VIDIOC_UNSUBSCRIBE_EVENT"><code class="constant">VIDIOC_SUBSCRIBE_EVENT</code></a> ioctl. Once an event is
  subscribed, the events of subscribed types are dequeueable using the
  <a class="link" href="media.html#vidioc-dqevent" title="ioctl VIDIOC_DQEVENT"><code class="constant">VIDIOC_DQEVENT</code></a> ioctl. Events may be unsubscribed using
  VIDIOC_UNSUBSCRIBE_EVENT ioctl. The special event type V4L2_EVENT_ALL may
  be used to unsubscribe all the events the driver supports.</p><p>The event subscriptions and event queues are specific to file
  handles. Subscribing an event on one file handle does not affect
  other file handles.</p><p>The information on dequeueable events is obtained by using select or
  poll system calls on video devices. The V4L2 events use POLLPRI events on
  poll system call and exceptions on select system call.</p><p>Starting with kernel 3.1 certain guarantees can be given with
  regards to events:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Each subscribed event has its own internal dedicated event queue.
This means that flooding of one event type will not interfere with other
event types.</p></li><li class="listitem"><p>If the internal event queue for a particular subscribed event
becomes full, then the oldest event in that queue will be dropped.</p></li><li class="listitem"><p>Where applicable, certain event types can ensure that the payload
of the oldest event that is about to be dropped will be merged with the payload
of the next oldest event. Thus ensuring that no information is lost, but only an
intermediate step leading up to that information. See the documentation for the
event you want to subscribe to whether this is applicable for that event or not.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="subdev"></a>Sub-device Interface</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#idp64863392">Controls</a></span></dt><dt><span class="section"><a href="media.html#idp64867520">Events</a></span></dt><dt><span class="section"><a href="media.html#pad-level-formats">Pad-level Formats</a></span></dt><dt><span class="section"><a href="media.html#v4l2-mbus-format">Media Bus Formats</a></span></dt></dl></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Experimental</h3><p>This is an <a class="link" href="media.html#experimental" title="Experimental API Elements">experimental</a>
    interface and may change in the future.</p></div><p>The complex nature of V4L2 devices, where hardware is often made of
  several integrated circuits that need to interact with each other in a
  controlled way, leads to complex V4L2 drivers. The drivers usually reflect
  the hardware model in software, and model the different hardware components
  as software blocks called sub-devices.</p><p>V4L2 sub-devices are usually kernel-only objects. If the V4L2 driver
  implements the media device API, they will automatically inherit from media
  entities. Applications will be able to enumerate the sub-devices and discover
  the hardware topology using the media entities, pads and links enumeration
  API.</p><p>In addition to make sub-devices discoverable, drivers can also choose
  to make them directly configurable by applications. When both the sub-device
  driver and the V4L2 device driver support this, sub-devices will feature a
  character device node on which ioctls can be called to
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>query, read and write sub-devices controls</p></li><li class="listitem"><p>subscribe and unsubscribe to events and retrieve them</p></li><li class="listitem"><p>negotiate image formats on individual pads</p></li></ul></div><p>
  </p><p>Sub-device character device nodes, conventionally named
  <code class="filename">/dev/v4l-subdev*</code>, use major number 81.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp64863392"></a>Controls</h3></div></div></div><p>Most V4L2 controls are implemented by sub-device hardware. Drivers
    usually merge all controls and expose them through video device nodes.
    Applications can control all sub-devices through a single interface.</p><p>Complex devices sometimes implement the same control in different
    pieces of hardware. This situation is common in embedded platforms, where
    both sensors and image processing hardware implement identical functions,
    such as contrast adjustment, white balance or faulty pixels correction. As
    the V4L2 controls API doesn't support several identical controls in a single
    device, all but one of the identical controls are hidden.</p><p>Applications can access those hidden controls through the sub-device
    node with the V4L2 control API described in <a class="xref" href="media.html#control" title="User Controls">the section called &#8220;User Controls&#8221;</a>. The
    ioctls behave identically as when issued on V4L2 device nodes, with the
    exception that they deal only with controls implemented in the sub-device.
    </p><p>Depending on the driver, those controls might also be exposed through
    one (or several) V4L2 device nodes.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp64867520"></a>Events</h3></div></div></div><p>V4L2 sub-devices can notify applications of events as described in
    <a class="xref" href="media.html#event" title="Event Interface">the section called &#8220;Event Interface&#8221;</a>. The API behaves identically as when used on V4L2
    device nodes, with the exception that it only deals with events generated by
    the sub-device. Depending on the driver, those events might also be reported
    on one (or several) V4L2 device nodes.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="pad-level-formats"></a>Pad-level Formats</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#idp64896816">Format Negotiation</a></span></dt><dt><span class="section"><a href="media.html#v4l2-subdev-selections">Selections: cropping, scaling and composition</a></span></dt><dt><span class="section"><a href="media.html#idp64950816">Types of selection targets</a></span></dt><dt><span class="section"><a href="media.html#idp64954496">Order of configuration and format propagation</a></span></dt></dl></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>Pad-level formats are only applicable to very complex device that
    need to expose low-level format configuration to user space. Generic V4L2
    applications do <span class="emphasis"><em>not</em></span> need to use the API described in
    this section.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>For the purpose of this section, the term
    <em class="wordasword">format</em> means the combination of media bus data
    format, frame width and frame height.</p></div><p>Image formats are typically negotiated on video capture and
    output devices using the format and <a class="link" href="media.html#vidioc-subdev-g-selection" title="ioctl VIDIOC_SUBDEV_G_SELECTION, VIDIOC_SUBDEV_S_SELECTION">selection</a> ioctls. The
    driver is responsible for configuring every block in the video
    pipeline according to the requested format at the pipeline input
    and/or output.</p><p>For complex devices, such as often found in embedded systems,
    identical image sizes at the output of a pipeline can be achieved using
    different hardware configurations. One such example is shown on
    <a class="xref" href="media.html#pipeline-scaling" title="Figure 4.4. Image Format Negotiation on Pipelines">Figure 4.4, &#8220;Image Format Negotiation on Pipelines&#8221;</a>, where
    image scaling can be performed on both the video sensor and the host image
    processing hardware.</p><div class="figure"><a name="pipeline-scaling"></a><p class="title"><b>Figure 4.4. Image Format Negotiation on Pipelines</b></p><div class="figure-contents"><div class="mediaobject"><img src="pipeline.png" alt="High quality and high speed pipeline configuration"></div></div></div><br class="figure-break"><p>The sensor scaler is usually of less quality than the host scaler, but
    scaling on the sensor is required to achieve higher frame rates. Depending
    on the use case (quality vs. speed), the pipeline must be configured
    differently. Applications need to configure the formats at every point in
    the pipeline explicitly.</p><p>Drivers that implement the <a class="link" href="media.html#media-controller-intro" title="Introduction">media
    API</a> can expose pad-level image format configuration to applications.
    When they do, applications can use the <a class="link" href="media.html#vidioc-subdev-g-fmt" title="ioctl VIDIOC_SUBDEV_G_FMT, VIDIOC_SUBDEV_S_FMT"><code class="constant">VIDIOC_SUBDEV_G_FMT</code></a> and
    <a class="link" href="media.html#vidioc-subdev-g-fmt" title="ioctl VIDIOC_SUBDEV_G_FMT, VIDIOC_SUBDEV_S_FMT"><code class="constant">VIDIOC_SUBDEV_S_FMT</code></a> ioctls. to negotiate formats on a per-pad basis.</p><p>Applications are responsible for configuring coherent parameters on
    the whole pipeline and making sure that connected pads have compatible
    formats. The pipeline is checked for formats mismatch at <a class="link" href="media.html#vidioc-streamon" title="ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF"><code class="constant">VIDIOC_STREAMON</code></a>
    time, and an <span class="errorcode">EPIPE</span> error code is then returned if the configuration is
    invalid.</p><p>Pad-level image format configuration support can be tested by calling
    the <a class="link" href="media.html#vidioc-subdev-g-fmt" title="ioctl VIDIOC_SUBDEV_G_FMT, VIDIOC_SUBDEV_S_FMT"><code class="constant">VIDIOC_SUBDEV_G_FMT</code></a> ioctl on pad 0. If the driver returns an <span class="errorcode">EINVAL</span> error code
    pad-level format configuration is not supported by the sub-device.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp64896816"></a>Format Negotiation</h4></div></div></div><p>Acceptable formats on pads can (and usually do) depend on a number
      of external parameters, such as formats on other pads, active links, or
      even controls. Finding a combination of formats on all pads in a video
      pipeline, acceptable to both application and driver, can't rely on formats
      enumeration only. A format negotiation mechanism is required.</p><p>Central to the format negotiation mechanism are the get/set format
      operations. When called with the <em class="structfield"><code>which</code></em> argument
      set to <code class="constant">V4L2_SUBDEV_FORMAT_TRY</code>, the
      <a class="link" href="media.html#vidioc-subdev-g-fmt" title="ioctl VIDIOC_SUBDEV_G_FMT, VIDIOC_SUBDEV_S_FMT"><code class="constant">VIDIOC_SUBDEV_G_FMT</code></a> and <a class="link" href="media.html#vidioc-subdev-g-fmt" title="ioctl VIDIOC_SUBDEV_G_FMT, VIDIOC_SUBDEV_S_FMT"><code class="constant">VIDIOC_SUBDEV_S_FMT</code></a> ioctls operate on a set of
      formats parameters that are not connected to the hardware configuration.
      Modifying those 'try' formats leaves the device state untouched (this
      applies to both the software state stored in the driver and the hardware
      state stored in the device itself).</p><p>While not kept as part of the device state, try formats are stored
      in the sub-device file handles. A <a class="link" href="media.html#vidioc-subdev-g-fmt" title="ioctl VIDIOC_SUBDEV_G_FMT, VIDIOC_SUBDEV_S_FMT"><code class="constant">VIDIOC_SUBDEV_G_FMT</code></a> call will return
      the last try format set <span class="emphasis"><em>on the same sub-device file
      handle</em></span>. Several applications querying the same sub-device at
      the same time will thus not interact with each other.</p><p>To find out whether a particular format is supported by the device,
      applications use the <a class="link" href="media.html#vidioc-subdev-g-fmt" title="ioctl VIDIOC_SUBDEV_G_FMT, VIDIOC_SUBDEV_S_FMT"><code class="constant">VIDIOC_SUBDEV_S_FMT</code></a> ioctl. Drivers verify and, if
      needed, change the requested <em class="structfield"><code>format</code></em> based on
      device requirements and return the possibly modified value. Applications
      can then choose to try a different format or accept the returned value and
      continue.</p><p>Formats returned by the driver during a negotiation iteration are
      guaranteed to be supported by the device. In particular, drivers guarantee
      that a returned format will not be further changed if passed to an
      <a class="link" href="media.html#vidioc-subdev-g-fmt" title="ioctl VIDIOC_SUBDEV_G_FMT, VIDIOC_SUBDEV_S_FMT"><code class="constant">VIDIOC_SUBDEV_S_FMT</code></a> call as-is (as long as external parameters, such as
      formats on other pads or links' configuration are not changed).</p><p>Drivers automatically propagate formats inside sub-devices. When a
      try or active format is set on a pad, corresponding formats on other pads
      of the same sub-device can be modified by the driver. Drivers are free to
      modify formats as required by the device. However, they should comply with
      the following rules when possible:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Formats should be propagated from sink pads to source pads.
	Modifying a format on a source pad should not modify the format on any
	sink pad.</p></li><li class="listitem"><p>Sub-devices that scale frames using variable scaling factors
	should reset the scale factors to default values when sink pads formats
	are modified. If the 1:1 scaling ratio is supported, this means that
	source pads formats should be reset to the sink pads formats.</p></li></ul></div><p>
      </p><p>Formats are not propagated across links, as that would involve
      propagating them from one sub-device file handle to another. Applications
      must then take care to configure both ends of every link explicitly with
      compatible formats. Identical formats on the two ends of a link are
      guaranteed to be compatible. Drivers are free to accept different formats
      matching device requirements as being compatible.</p><p><a class="xref" href="media.html#sample-pipeline-config" title="Table 4.19. Sample Pipeline Configuration">Table 4.19, &#8220;Sample Pipeline Configuration&#8221;</a>
      shows a sample configuration sequence for the pipeline described in
      <a class="xref" href="media.html#pipeline-scaling" title="Figure 4.4. Image Format Negotiation on Pipelines">Figure 4.4, &#8220;Image Format Negotiation on Pipelines&#8221;</a> (table
      columns list entity names and pad numbers).</p><div class="table"><a name="sample-pipeline-config"></a><p class="title"><b>Table 4.19. Sample Pipeline Configuration</b></p><div class="table-contents"><table summary="Sample Pipeline Configuration" border="0"><colgroup><col class="what"><col class="sensor-0 format"><col class="frontend-0 format"></colgroup><thead><tr><th> </th><th>Sensor/0 format</th><th>Frontend/0 format</th><th>Frontend/1 format</th><th>Scaler/0 format</th><th>Scaler/0 compose selection rectangle</th><th>Scaler/1 format</th></tr></thead><tbody valign="top"><tr><td valign="top">Initial state</td><td valign="top">2048x1536/SGRBG8_1X8</td><td valign="top">(default)</td><td valign="top">(default)</td><td valign="top">(default)</td><td valign="top">(default)</td><td valign="top">(default)</td></tr><tr><td valign="top">Configure frontend sink format</td><td valign="top">2048x1536/SGRBG8_1X8</td><td valign="top"><span class="emphasis"><em>2048x1536/SGRBG8_1X8</em></span></td><td valign="top"><span class="emphasis"><em>2046x1534/SGRBG8_1X8</em></span></td><td valign="top">(default)</td><td valign="top">(default)</td><td valign="top">(default)</td></tr><tr><td valign="top">Configure scaler sink format</td><td valign="top">2048x1536/SGRBG8_1X8</td><td valign="top">2048x1536/SGRBG8_1X8</td><td valign="top">2046x1534/SGRBG8_1X8</td><td valign="top"><span class="emphasis"><em>2046x1534/SGRBG8_1X8</em></span></td><td valign="top"><span class="emphasis"><em>0,0/2046x1534</em></span></td><td valign="top"><span class="emphasis"><em>2046x1534/SGRBG8_1X8</em></span></td></tr><tr><td valign="top">Configure scaler sink compose selection</td><td valign="top">2048x1536/SGRBG8_1X8</td><td valign="top">2048x1536/SGRBG8_1X8</td><td valign="top">2046x1534/SGRBG8_1X8</td><td valign="top">2046x1534/SGRBG8_1X8</td><td valign="top"><span class="emphasis"><em>0,0/1280x960</em></span></td><td valign="top"><span class="emphasis"><em>1280x960/SGRBG8_1X8</em></span></td></tr></tbody></table></div></div><br class="table-break"><p>
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Initial state. The sensor source pad format is
	set to its native 3MP size and V4L2_MBUS_FMT_SGRBG8_1X8
	media bus code. Formats on the host frontend and scaler sink
	and source pads have the default values, as well as the
	compose rectangle on the scaler's sink pad.</p></li><li class="listitem"><p>The application configures the frontend sink
	pad format's size to 2048x1536 and its media bus code to
	V4L2_MBUS_FMT_SGRBG_1X8. The driver propagates the format to
	the frontend source pad.</p></li><li class="listitem"><p>The application configures the scaler sink pad
	format's size to 2046x1534 and the media bus code to
	V4L2_MBUS_FMT_SGRBG_1X8 to match the frontend source size and
	media bus code. The media bus code on the sink pad is set to
	V4L2_MBUS_FMT_SGRBG_1X8. The driver propagates the size to the
	compose selection rectangle on the scaler's sink pad, and the
	format to the scaler source pad.</p></li><li class="listitem"><p>The application configures the size of the compose
	selection rectangle of the scaler's sink pad 1280x960. The driver
	propagates the size to the scaler's source pad
	format.</p></li></ol></div><p>
      </p><p>When satisfied with the try results, applications can set the active
      formats by setting the <em class="structfield"><code>which</code></em> argument to
      <code class="constant">V4L2_SUBDEV_FORMAT_ACTIVE</code>. Active formats are changed
      exactly as try formats by drivers. To avoid modifying the hardware state
      during format negotiation, applications should negotiate try formats first
      and then modify the active settings using the try formats returned during
      the last negotiation iteration. This guarantees that the active format
      will be applied as-is by the driver without being modified.
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="v4l2-subdev-selections"></a>Selections: cropping, scaling and composition</h4></div></div></div><p>Many sub-devices support cropping frames on their input or output
      pads (or possible even on both). Cropping is used to select the area of
      interest in an image, typically on an image sensor or a video decoder. It can
      also be used as part of digital zoom implementations to select the area of
      the image that will be scaled up.</p><p>Crop settings are defined by a crop rectangle and represented in a
      struct <a class="link" href="media.html#v4l2-rect" title="Table 4.3. struct v4l2_rect">v4l2_rect</a> by the coordinates of the top left corner and the rectangle
      size. Both the coordinates and sizes are expressed in pixels.</p><p>As for pad formats, drivers store try and active
      rectangles for the selection targets <a class="xref" href="media.html#v4l2-selections-common" title="Common selection definitions">the section called &#8220;Common selection definitions&#8221;</a>.</p><p>On sink pads, cropping is applied relative to the
      current pad format. The pad format represents the image size as
      received by the sub-device from the previous block in the
      pipeline, and the crop rectangle represents the sub-image that
      will be transmitted further inside the sub-device for
      processing.</p><p>The scaling operation changes the size of the image by
      scaling it to new dimensions. The scaling ratio isn't specified
      explicitly, but is implied from the original and scaled image
      sizes. Both sizes are represented by struct <a class="link" href="media.html#v4l2-rect" title="Table 4.3. struct v4l2_rect">v4l2_rect</a>.</p><p>Scaling support is optional. When supported by a subdev,
      the crop rectangle on the subdev's sink pad is scaled to the
      size configured using the <a class="link" href="media.html#vidioc-subdev-g-selection" title="ioctl VIDIOC_SUBDEV_G_SELECTION, VIDIOC_SUBDEV_S_SELECTION"><code class="constant">VIDIOC_SUBDEV_S_SELECTION</code></a> IOCTL
      using <code class="constant">V4L2_SEL_TGT_COMPOSE</code>
      selection target on the same pad. If the subdev supports scaling
      but not composing, the top and left values are not used and must
      always be set to zero.</p><p>On source pads, cropping is similar to sink pads, with the
      exception that the source size from which the cropping is
      performed, is the COMPOSE rectangle on the sink pad. In both
      sink and source pads, the crop rectangle must be entirely
      contained inside the source image size for the crop
      operation.</p><p>The drivers should always use the closest possible
      rectangle the user requests on all selection targets, unless
      specifically told otherwise.
      <code class="constant">V4L2_SEL_FLAG_GE</code> and
      <code class="constant">V4L2_SEL_FLAG_LE</code> flags may be
      used to round the image size either up or down. <a class="xref" href="media.html#v4l2-selection-flags" title="Selection flags">the section called &#8220;Selection flags&#8221;</a></p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp64950816"></a>Types of selection targets</h4></div></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idp64951504"></a>Actual targets</h5></div></div></div><p>Actual targets (without a postfix) reflect the actual
	hardware configuration at any point of time. There is a BOUNDS
	target corresponding to every actual target.</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idp64952832"></a>BOUNDS targets</h5></div></div></div><p>BOUNDS targets is the smallest rectangle that contains all
	valid actual rectangles. It may not be possible to set the actual
	rectangle as large as the BOUNDS rectangle, however. This may be
	because e.g. a sensor's pixel array is not rectangular but
	cross-shaped or round. The maximum size may also be smaller than the
	BOUNDS rectangle.</p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp64954496"></a>Order of configuration and format propagation</h4></div></div></div><p>Inside subdevs, the order of image processing steps will
      always be from the sink pad towards the source pad. This is also
      reflected in the order in which the configuration must be
      performed by the user: the changes made will be propagated to
      any subsequent stages. If this behaviour is not desired, the
      user must set
      <code class="constant">V4L2_SEL_FLAG_KEEP_CONFIG</code> flag. This
      flag causes no propagation of the changes are allowed in any
      circumstances. This may also cause the accessed rectangle to be
      adjusted by the driver, depending on the properties of the
      underlying hardware.</p><p>The coordinates to a step always refer to the actual size
      of the previous step. The exception to this rule is the source
      compose rectangle, which refers to the sink compose bounds
      rectangle --- if it is supported by the hardware.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Sink pad format. The user configures the sink pad
	format. This format defines the parameters of the image the
	entity receives through the pad for further processing.</p></li><li class="listitem"><p>Sink pad actual crop selection. The sink pad crop
	defines the crop performed to the sink pad format.</p></li><li class="listitem"><p>Sink pad actual compose selection. The size of the
	sink pad compose rectangle defines the scaling ratio compared
	to the size of the sink pad crop rectangle. The location of
	the compose rectangle specifies the location of the actual
	sink compose rectangle in the sink compose bounds
	rectangle.</p></li><li class="listitem"><p>Source pad actual crop selection. Crop on the source
	pad defines crop performed to the image in the sink compose
	bounds rectangle.</p></li><li class="listitem"><p>Source pad format. The source pad format defines the
	output pixel format of the subdev, as well as the other
	parameters with the exception of the image width and height.
	Width and height are defined by the size of the source pad
	actual crop selection.</p></li></ol></div><p>Accessing any of the above rectangles not supported by the
      subdev will return <code class="constant">EINVAL</code>. Any rectangle
      referring to a previous unsupported rectangle coordinates will
      instead refer to the previous supported rectangle. For example,
      if sink crop is not supported, the compose selection will refer
      to the sink pad format dimensions instead.</p><div class="figure"><a name="subdev-image-processing-crop"></a><p class="title"><b>Figure 4.5. Image processing in subdevs: simple crop example</b></p><div class="figure-contents"><div class="mediaobject"><object type="image/svg+xml" data="subdev-image-processing-crop.svg" width="1080"></object></div></div></div><br class="figure-break"><p>In the above example, the subdev supports cropping on its
      sink pad. To configure it, the user sets the media bus format on
      the subdev's sink pad. Now the actual crop rectangle can be set
      on the sink pad --- the location and size of this rectangle
      reflect the location and size of a rectangle to be cropped from
      the sink format. The size of the sink crop rectangle will also
      be the size of the format of the subdev's source pad.</p><div class="figure"><a name="subdev-image-processing-scaling-multi-source"></a><p class="title"><b>Figure 4.6. Image processing in subdevs: scaling with multiple sources</b></p><div class="figure-contents"><div class="mediaobject"><object type="image/svg+xml" data="subdev-image-processing-scaling-multi-source.svg" width="1080"></object></div></div></div><br class="figure-break"><p>In this example, the subdev is capable of first cropping,
      then scaling and finally cropping for two source pads
      individually from the resulting scaled image. The location of
      the scaled image in the cropped image is ignored in sink compose
      target. Both of the locations of the source crop rectangles
      refer to the sink scaling rectangle, independently cropping an
      area at location specified by the source crop rectangle from
      it.</p><div class="figure"><a name="subdev-image-processing-full"></a><p class="title"><b>Figure 4.7. Image processing in subdevs: scaling and composition
	with multiple sinks and sources</b></p><div class="figure-contents"><div class="mediaobject"><object type="image/svg+xml" data="subdev-image-processing-full.svg" width="1080"></object></div></div></div><br class="figure-break"><p>The subdev driver supports two sink pads and two source
      pads. The images from both of the sink pads are individually
      cropped, then scaled and further composed on the composition
      bounds rectangle. From that, two independent streams are cropped
      and sent out of the subdev from the source pads.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="v4l2-mbus-format"></a>Media Bus Formats</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#v4l2-mbus-pixelcode">Media Bus Pixel Codes</a></span></dt></dl></div><div class="table"><a name="v4l2-mbus-framefmt"></a><p class="title"><b>Table 4.20. struct <span class="structname">v4l2_mbus_framefmt</span></b></p><div class="table-contents"><table summary="struct v4l2_mbus_framefmt" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>width</code></em></td><td valign="top">Image width, in pixels.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>height</code></em></td><td valign="top">Image height, in pixels.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>code</code></em></td><td valign="top">Format code, from enum <a class="link" href="media.html#v4l2-mbus-pixelcode" title="Media Bus Pixel Codes">v4l2_mbus_pixelcode</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>field</code></em></td><td valign="top">Field order, from enum <a class="link" href="media.html#v4l2-field" title="Table 3.9. enum v4l2_field">v4l2_field</a>. See
	  <a class="xref" href="media.html#field-order" title="Field Order">the section called &#8220;Field Order&#8221;</a> for details.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>colorspace</code></em></td><td valign="top">Image colorspace, from enum <a class="link" href="media.html#v4l2-colorspace" title="Table 2.4. V4L2 Colorspaces">v4l2_colorspace</a>. See
	  <a class="xref" href="media.html#colorspaces" title="Colorspaces">the section called &#8220;Colorspaces&#8221;</a> for details.</td></tr><tr><td valign="top">enum <a class="link" href="media.html#v4l2-ycbcr-encoding" title="Table 2.5. V4L2 Y'CbCr Encodings">v4l2_ycbcr_encoding</a></td><td valign="top"><em class="structfield"><code>ycbcr_enc</code></em></td><td valign="top">This information supplements the
<em class="structfield"><code>colorspace</code></em> and must be set by the driver for
capture streams and by the application for output streams,
see <a class="xref" href="media.html#colorspaces" title="Colorspaces">the section called &#8220;Colorspaces&#8221;</a>.</td></tr><tr><td valign="top">enum <a class="link" href="media.html#v4l2-quantization" title="Table 2.6. V4L2 Quantization Methods">v4l2_quantization</a></td><td valign="top"><em class="structfield"><code>quantization</code></em></td><td valign="top">This information supplements the
<em class="structfield"><code>colorspace</code></em> and must be set by the driver for
capture streams and by the application for output streams,
see <a class="xref" href="media.html#colorspaces" title="Colorspaces">the section called &#8220;Colorspaces&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[6]</td><td valign="top">Reserved for future extensions. Applications and drivers must
	  set the array to zero.</td></tr></tbody></table></div></div><br class="table-break"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="v4l2-mbus-pixelcode"></a>Media Bus Pixel Codes</h4></div></div></div><p>The media bus pixel codes describe image formats as flowing over
    physical busses (both between separate physical components and inside SoC
    devices). This should not be confused with the V4L2 pixel formats that
    describe, using four character codes, image formats as stored in memory.
    </p><p>While there is a relationship between image formats on busses and
    image formats in memory (a raw Bayer image won't be magically converted to
    JPEG just by storing it to memory), there is no one-to-one correspondance
    between them.</p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idp65051200"></a>Packed RGB Formats</h5></div></div></div><p>Those formats transfer pixel data as red, green and blue components.
      The format code is made of the following information.
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The red, green and blue components order code, as encoded in a
	pixel sample. Possible values are RGB and BGR.</p></li><li class="listitem"><p>The number of bits per component, for each component. The values
	can be different for all components. Common values are 555 and 565.</p></li><li class="listitem"><p>The number of bus samples per pixel. Pixels that are wider than
	the bus width must be transferred in multiple samples. Common values are
	1 and 2.</p></li><li class="listitem"><p>The bus width.</p></li><li class="listitem"><p>For formats where the total number of bits per pixel is smaller
	than the number of bus samples per pixel times the bus width, a padding
	value stating if the bytes are padded in their most high order bits
	(PADHI) or low order bits (PADLO).</p></li><li class="listitem"><p>For formats where the number of bus samples per pixel is larger
	than 1, an endianness value stating if the pixel is transferred MSB first
	(BE) or LSB first (LE).</p></li></ul></div><p>
      </p><p>For instance, a format where pixels are encoded as 5-bits red, 5-bits
      green and 5-bit blue values padded on the high bit, transferred as 2 8-bit
      samples per pixel with the most significant bits (padding, red and half of
      the green value) transferred first will be named
      <code class="constant">MEDIA_BUS_FMT_RGB555_2X8_PADHI_BE</code>.
      </p><p>The following tables list existing packed RGB formats.</p><div class="table"><a name="v4l2-mbus-pixelcode-rgb"></a><p class="title"><b>Table 4.21. RGB formats</b></p><div class="table-contents"><table summary="RGB formats" border="0"><colgroup><col align="left" class="id"><col align="center" class="code"><col class="bit"><col align="center" class="b31"><col align="center" class="b20"><col align="center" class="b29"><col align="center" class="b28"><col align="center" class="b27"><col align="center" class="b26"><col align="center" class="b25"><col align="center" class="b24"><col align="center" class="b23"><col align="center" class="b22"><col align="center" class="b21"><col align="center" class="b20"><col align="center" class="b19"><col align="center" class="b18"><col align="center" class="b17"><col align="center" class="b16"><col align="center" class="b15"><col align="center" class="b14"><col align="center" class="b13"><col align="center" class="b12"><col align="center" class="b11"><col align="center" class="b10"><col align="center" class="b09"><col align="center" class="b08"></colgroup><thead><tr><th align="left">Identifier</th><th align="center">Code</th><th> </th><th colspan="32" align="center">Data organization</th></tr><tr><th align="left"> </th><th align="center"> </th><th>Bit</th><th align="center">31</th><th align="center">30</th><th align="center">29</th><th align="center">28</th><th align="center">27</th><th align="center">26</th><th align="center">25</th><th align="center">24</th><th align="center">23</th><th align="center">22</th><th align="center">21</th><th align="center">20</th><th align="center">19</th><th align="center">18</th><th align="center">17</th><th align="center">16</th><th align="center">15</th><th align="center">14</th><th align="center">13</th><th align="center">12</th><th align="center">11</th><th align="center">10</th><th align="center">9</th><th align="center">8</th><th align="center">7</th><th align="center">6</th><th align="center">5</th><th align="center">4</th><th align="center">3</th><th align="center">2</th><th align="center">1</th><th align="center">0</th></tr></thead><tbody valign="top"><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-RGB444-2X8-PADHI-BE"></a>MEDIA_BUS_FMT_RGB444_2X8_PADHI_BE</td><td align="center" valign="top">0x1001</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">0</td><td align="center" valign="top">0</td><td align="center" valign="top">0</td><td align="center" valign="top">0</td><td align="center" valign="top">r<sub>3</sub></td><td align="center" valign="top">r<sub>2</sub></td><td align="center" valign="top">r<sub>1</sub></td><td align="center" valign="top">r<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">g<sub>3</sub></td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-RGB444-2X8-PADHI-LE"></a>MEDIA_BUS_FMT_RGB444_2X8_PADHI_LE</td><td align="center" valign="top">0x1002</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">g<sub>3</sub></td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">0</td><td align="center" valign="top">0</td><td align="center" valign="top">0</td><td align="center" valign="top">0</td><td align="center" valign="top">r<sub>3</sub></td><td align="center" valign="top">r<sub>2</sub></td><td align="center" valign="top">r<sub>1</sub></td><td align="center" valign="top">r<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-RGB555-2X8-PADHI-BE"></a>MEDIA_BUS_FMT_RGB555_2X8_PADHI_BE</td><td align="center" valign="top">0x1003</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">0</td><td align="center" valign="top">r<sub>4</sub></td><td align="center" valign="top">r<sub>3</sub></td><td align="center" valign="top">r<sub>2</sub></td><td align="center" valign="top">r<sub>1</sub></td><td align="center" valign="top">r<sub>0</sub></td><td align="center" valign="top">g<sub>4</sub></td><td align="center" valign="top">g<sub>3</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td><td align="center" valign="top">b<sub>4</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-RGB555-2X8-PADHI-LE"></a>MEDIA_BUS_FMT_RGB555_2X8_PADHI_LE</td><td align="center" valign="top">0x1004</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td><td align="center" valign="top">b<sub>4</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">0</td><td align="center" valign="top">r<sub>4</sub></td><td align="center" valign="top">r<sub>3</sub></td><td align="center" valign="top">r<sub>2</sub></td><td align="center" valign="top">r<sub>1</sub></td><td align="center" valign="top">r<sub>0</sub></td><td align="center" valign="top">g<sub>4</sub></td><td align="center" valign="top">g<sub>3</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-BGR565-2X8-BE"></a>MEDIA_BUS_FMT_BGR565_2X8_BE</td><td align="center" valign="top">0x1005</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">b<sub>4</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td><td align="center" valign="top">g<sub>5</sub></td><td align="center" valign="top">g<sub>4</sub></td><td align="center" valign="top">g<sub>3</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td><td align="center" valign="top">r<sub>4</sub></td><td align="center" valign="top">r<sub>3</sub></td><td align="center" valign="top">r<sub>2</sub></td><td align="center" valign="top">r<sub>1</sub></td><td align="center" valign="top">r<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-BGR565-2X8-LE"></a>MEDIA_BUS_FMT_BGR565_2X8_LE</td><td align="center" valign="top">0x1006</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td><td align="center" valign="top">r<sub>4</sub></td><td align="center" valign="top">r<sub>3</sub></td><td align="center" valign="top">r<sub>2</sub></td><td align="center" valign="top">r<sub>1</sub></td><td align="center" valign="top">r<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">b<sub>4</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td><td align="center" valign="top">g<sub>5</sub></td><td align="center" valign="top">g<sub>4</sub></td><td align="center" valign="top">g<sub>3</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-RGB565-2X8-BE"></a>MEDIA_BUS_FMT_RGB565_2X8_BE</td><td align="center" valign="top">0x1007</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">r<sub>4</sub></td><td align="center" valign="top">r<sub>3</sub></td><td align="center" valign="top">r<sub>2</sub></td><td align="center" valign="top">r<sub>1</sub></td><td align="center" valign="top">r<sub>0</sub></td><td align="center" valign="top">g<sub>5</sub></td><td align="center" valign="top">g<sub>4</sub></td><td align="center" valign="top">g<sub>3</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td><td align="center" valign="top">b<sub>4</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-RGB565-2X8-LE"></a>MEDIA_BUS_FMT_RGB565_2X8_LE</td><td align="center" valign="top">0x1008</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td><td align="center" valign="top">b<sub>4</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">r<sub>4</sub></td><td align="center" valign="top">r<sub>3</sub></td><td align="center" valign="top">r<sub>2</sub></td><td align="center" valign="top">r<sub>1</sub></td><td align="center" valign="top">r<sub>0</sub></td><td align="center" valign="top">g<sub>5</sub></td><td align="center" valign="top">g<sub>4</sub></td><td align="center" valign="top">g<sub>3</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-RGB666-1X18"></a>MEDIA_BUS_FMT_RGB666_1X18</td><td align="center" valign="top">0x1009</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">r<sub>5</sub></td><td align="center" valign="top">r<sub>4</sub></td><td align="center" valign="top">r<sub>3</sub></td><td align="center" valign="top">r<sub>2</sub></td><td align="center" valign="top">r<sub>1</sub></td><td align="center" valign="top">r<sub>0</sub></td><td align="center" valign="top">g<sub>5</sub></td><td align="center" valign="top">g<sub>4</sub></td><td align="center" valign="top">g<sub>3</sub></td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td><td align="center" valign="top">b<sub>5</sub></td><td align="center" valign="top">b<sub>4</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-RGB888-1X24"></a>MEDIA_BUS_FMT_RGB888_1X24</td><td align="center" valign="top">0x100a</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">r<sub>7</sub></td><td align="center" valign="top">r<sub>6</sub></td><td align="center" valign="top">r<sub>5</sub></td><td align="center" valign="top">r<sub>4</sub></td><td align="center" valign="top">r<sub>3</sub></td><td align="center" valign="top">r<sub>2</sub></td><td align="center" valign="top">r<sub>1</sub></td><td align="center" valign="top">r<sub>0</sub></td><td align="center" valign="top">g<sub>7</sub></td><td align="center" valign="top">g<sub>6</sub></td><td align="center" valign="top">g<sub>5</sub></td><td align="center" valign="top">g<sub>4</sub></td><td align="center" valign="top">g<sub>3</sub></td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td><td align="center" valign="top">b<sub>7</sub></td><td align="center" valign="top">b<sub>6</sub></td><td align="center" valign="top">b<sub>5</sub></td><td align="center" valign="top">b<sub>4</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-RGB888-2X12-BE"></a>MEDIA_BUS_FMT_RGB888_2X12_BE</td><td align="center" valign="top">0x100b</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">r<sub>7</sub></td><td align="center" valign="top">r<sub>6</sub></td><td align="center" valign="top">r<sub>5</sub></td><td align="center" valign="top">r<sub>4</sub></td><td align="center" valign="top">r<sub>3</sub></td><td align="center" valign="top">r<sub>2</sub></td><td align="center" valign="top">r<sub>1</sub></td><td align="center" valign="top">r<sub>0</sub></td><td align="center" valign="top">g<sub>7</sub></td><td align="center" valign="top">g<sub>6</sub></td><td align="center" valign="top">g<sub>5</sub></td><td align="center" valign="top">g<sub>4</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">g<sub>3</sub></td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td><td align="center" valign="top">b<sub>7</sub></td><td align="center" valign="top">b<sub>6</sub></td><td align="center" valign="top">b<sub>5</sub></td><td align="center" valign="top">b<sub>4</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-RGB888-2X12-LE"></a>MEDIA_BUS_FMT_RGB888_2X12_LE</td><td align="center" valign="top">0x100c</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">g<sub>3</sub></td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td><td align="center" valign="top">b<sub>7</sub></td><td align="center" valign="top">b<sub>6</sub></td><td align="center" valign="top">b<sub>5</sub></td><td align="center" valign="top">b<sub>4</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">r<sub>7</sub></td><td align="center" valign="top">r<sub>6</sub></td><td align="center" valign="top">r<sub>5</sub></td><td align="center" valign="top">r<sub>4</sub></td><td align="center" valign="top">r<sub>3</sub></td><td align="center" valign="top">r<sub>2</sub></td><td align="center" valign="top">r<sub>1</sub></td><td align="center" valign="top">r<sub>0</sub></td><td align="center" valign="top">g<sub>7</sub></td><td align="center" valign="top">g<sub>6</sub></td><td align="center" valign="top">g<sub>5</sub></td><td align="center" valign="top">g<sub>4</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-ARGB888-1X32"></a>MEDIA_BUS_FMT_ARGB888_1X32</td><td align="center" valign="top">0x100d</td><td valign="top"> </td><td align="center" valign="top">a<sub>7</sub></td><td align="center" valign="top">a<sub>6</sub></td><td align="center" valign="top">a<sub>5</sub></td><td align="center" valign="top">a<sub>4</sub></td><td align="center" valign="top">a<sub>3</sub></td><td align="center" valign="top">a<sub>2</sub></td><td align="center" valign="top">a<sub>1</sub></td><td align="center" valign="top">a<sub>0</sub></td><td align="center" valign="top">r<sub>7</sub></td><td align="center" valign="top">r<sub>6</sub></td><td align="center" valign="top">r<sub>5</sub></td><td align="center" valign="top">r<sub>4</sub></td><td align="center" valign="top">r<sub>3</sub></td><td align="center" valign="top">r<sub>2</sub></td><td align="center" valign="top">r<sub>1</sub></td><td align="center" valign="top">r<sub>0</sub></td><td align="center" valign="top">g<sub>7</sub></td><td align="center" valign="top">g<sub>6</sub></td><td align="center" valign="top">g<sub>5</sub></td><td align="center" valign="top">g<sub>4</sub></td><td align="center" valign="top">g<sub>3</sub></td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td><td align="center" valign="top">b<sub>7</sub></td><td align="center" valign="top">b<sub>6</sub></td><td align="center" valign="top">b<sub>5</sub></td><td align="center" valign="top">b<sub>4</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idp65468112"></a>Bayer Formats</h5></div></div></div><p>Those formats transfer pixel data as red, green and blue components.
      The format code is made of the following information.
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The red, green and blue components order code, as encoded in a
	pixel sample. The possible values are shown in <a class="xref" href="media.html#bayer-patterns" title="Figure 4.8. Bayer Patterns">Figure 4.8, &#8220;Bayer Patterns&#8221;</a>.</p></li><li class="listitem"><p>The number of bits per pixel component. All components are
	transferred on the same number of bits. Common values are 8, 10 and 12.</p></li><li class="listitem"><p>The compression (optional). If the pixel components are
	ALAW- or DPCM-compressed, a mention of the compression scheme and the
	number of bits per compressed pixel component.</p></li><li class="listitem"><p>The number of bus samples per pixel. Pixels that are wider than
	the bus width must be transferred in multiple samples. Common values are
	1 and 2.</p></li><li class="listitem"><p>The bus width.</p></li><li class="listitem"><p>For formats where the total number of bits per pixel is smaller
	than the number of bus samples per pixel times the bus width, a padding
	value stating if the bytes are padded in their most high order bits
	(PADHI) or low order bits (PADLO).</p></li><li class="listitem"><p>For formats where the number of bus samples per pixel is larger
	than 1, an endianness value stating if the pixel is transferred MSB first
	(BE) or LSB first (LE).</p></li></ul></div><p>
      </p><p>For instance, a format with uncompressed 10-bit Bayer components
      arranged in a red, green, green, blue pattern transferred as 2 8-bit
      samples per pixel with the least significant bits transferred first will
      be named <code class="constant">MEDIA_BUS_FMT_SRGGB10_2X8_PADHI_LE</code>.
      </p><div class="figure"><a name="bayer-patterns"></a><p class="title"><b>Figure 4.8. Bayer Patterns</b></p><div class="figure-contents"><div class="mediaobject"><img src="bayer.png" alt="Bayer filter color patterns"></div></div></div><br class="figure-break"><p>The following table lists existing packed Bayer formats. The data
      organization is given as an example for the first pixel only.</p><div class="table"><a name="v4l2-mbus-pixelcode-bayer"></a><p class="title"><b>Table 4.22. Bayer Formats</b></p><div class="table-contents"><table summary="Bayer Formats" border="0"><colgroup><col align="left" class="id"><col align="center" class="code"><col class="bit"><col align="center" class="b11"><col align="center" class="b10"><col align="center" class="b09"><col align="center" class="b08"><col align="center" class="b07"><col align="center" class="b06"><col align="center" class="b05"><col align="center" class="b04"><col align="center" class="b03"><col align="center" class="b02"><col align="center" class="b01"><col align="center" class="b00"></colgroup><thead><tr><th align="left">Identifier</th><th align="center">Code</th><th> </th><th colspan="12" align="center">Data organization</th></tr><tr><th align="left"> </th><th align="center"> </th><th>Bit</th><th align="center">11</th><th align="center">10</th><th align="center">9</th><th align="center">8</th><th align="center">7</th><th align="center">6</th><th align="center">5</th><th align="center">4</th><th align="center">3</th><th align="center">2</th><th align="center">1</th><th align="center">0</th></tr></thead><tbody valign="top"><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-SBGGR8-1X8"></a>MEDIA_BUS_FMT_SBGGR8_1X8</td><td align="center" valign="top">0x3001</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">b<sub>7</sub></td><td align="center" valign="top">b<sub>6</sub></td><td align="center" valign="top">b<sub>5</sub></td><td align="center" valign="top">b<sub>4</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-SGBRG8-1X8"></a>MEDIA_BUS_FMT_SGBRG8_1X8</td><td align="center" valign="top">0x3013</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">g<sub>7</sub></td><td align="center" valign="top">g<sub>6</sub></td><td align="center" valign="top">g<sub>5</sub></td><td align="center" valign="top">g<sub>4</sub></td><td align="center" valign="top">g<sub>3</sub></td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-SGRBG8-1X8"></a>MEDIA_BUS_FMT_SGRBG8_1X8</td><td align="center" valign="top">0x3002</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">g<sub>7</sub></td><td align="center" valign="top">g<sub>6</sub></td><td align="center" valign="top">g<sub>5</sub></td><td align="center" valign="top">g<sub>4</sub></td><td align="center" valign="top">g<sub>3</sub></td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-SRGGB8-1X8"></a>MEDIA_BUS_FMT_SRGGB8_1X8</td><td align="center" valign="top">0x3014</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">r<sub>7</sub></td><td align="center" valign="top">r<sub>6</sub></td><td align="center" valign="top">r<sub>5</sub></td><td align="center" valign="top">r<sub>4</sub></td><td align="center" valign="top">r<sub>3</sub></td><td align="center" valign="top">r<sub>2</sub></td><td align="center" valign="top">r<sub>1</sub></td><td align="center" valign="top">r<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-SBGGR10-ALAW8-1X8"></a>MEDIA_BUS_FMT_SBGGR10_ALAW8_1X8</td><td align="center" valign="top">0x3015</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">b<sub>7</sub></td><td align="center" valign="top">b<sub>6</sub></td><td align="center" valign="top">b<sub>5</sub></td><td align="center" valign="top">b<sub>4</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-SGBRG10-ALAW8-1X8"></a>MEDIA_BUS_FMT_SGBRG10_ALAW8_1X8</td><td align="center" valign="top">0x3016</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">g<sub>7</sub></td><td align="center" valign="top">g<sub>6</sub></td><td align="center" valign="top">g<sub>5</sub></td><td align="center" valign="top">g<sub>4</sub></td><td align="center" valign="top">g<sub>3</sub></td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-SGRBG10-ALAW8-1X8"></a>MEDIA_BUS_FMT_SGRBG10_ALAW8_1X8</td><td align="center" valign="top">0x3017</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">g<sub>7</sub></td><td align="center" valign="top">g<sub>6</sub></td><td align="center" valign="top">g<sub>5</sub></td><td align="center" valign="top">g<sub>4</sub></td><td align="center" valign="top">g<sub>3</sub></td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-SRGGB10-ALAW8-1X8"></a>MEDIA_BUS_FMT_SRGGB10_ALAW8_1X8</td><td align="center" valign="top">0x3018</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">r<sub>7</sub></td><td align="center" valign="top">r<sub>6</sub></td><td align="center" valign="top">r<sub>5</sub></td><td align="center" valign="top">r<sub>4</sub></td><td align="center" valign="top">r<sub>3</sub></td><td align="center" valign="top">r<sub>2</sub></td><td align="center" valign="top">r<sub>1</sub></td><td align="center" valign="top">r<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-SBGGR10-DPCM8-1X8"></a>MEDIA_BUS_FMT_SBGGR10_DPCM8_1X8</td><td align="center" valign="top">0x300b</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">b<sub>7</sub></td><td align="center" valign="top">b<sub>6</sub></td><td align="center" valign="top">b<sub>5</sub></td><td align="center" valign="top">b<sub>4</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-SGBRG10-DPCM8-1X8"></a>MEDIA_BUS_FMT_SGBRG10_DPCM8_1X8</td><td align="center" valign="top">0x300c</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">g<sub>7</sub></td><td align="center" valign="top">g<sub>6</sub></td><td align="center" valign="top">g<sub>5</sub></td><td align="center" valign="top">g<sub>4</sub></td><td align="center" valign="top">g<sub>3</sub></td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-SGRBG10-DPCM8-1X8"></a>MEDIA_BUS_FMT_SGRBG10_DPCM8_1X8</td><td align="center" valign="top">0x3009</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">g<sub>7</sub></td><td align="center" valign="top">g<sub>6</sub></td><td align="center" valign="top">g<sub>5</sub></td><td align="center" valign="top">g<sub>4</sub></td><td align="center" valign="top">g<sub>3</sub></td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-SRGGB10-DPCM8-1X8"></a>MEDIA_BUS_FMT_SRGGB10_DPCM8_1X8</td><td align="center" valign="top">0x300d</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">r<sub>7</sub></td><td align="center" valign="top">r<sub>6</sub></td><td align="center" valign="top">r<sub>5</sub></td><td align="center" valign="top">r<sub>4</sub></td><td align="center" valign="top">r<sub>3</sub></td><td align="center" valign="top">r<sub>2</sub></td><td align="center" valign="top">r<sub>1</sub></td><td align="center" valign="top">r<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-SBGGR10-2X8-PADHI-BE"></a>MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_BE</td><td align="center" valign="top">0x3003</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">0</td><td align="center" valign="top">0</td><td align="center" valign="top">0</td><td align="center" valign="top">0</td><td align="center" valign="top">0</td><td align="center" valign="top">0</td><td align="center" valign="top">b<sub>9</sub></td><td align="center" valign="top">b<sub>8</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">b<sub>7</sub></td><td align="center" valign="top">b<sub>6</sub></td><td align="center" valign="top">b<sub>5</sub></td><td align="center" valign="top">b<sub>4</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-SBGGR10-2X8-PADHI-LE"></a>MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_LE</td><td align="center" valign="top">0x3004</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">b<sub>7</sub></td><td align="center" valign="top">b<sub>6</sub></td><td align="center" valign="top">b<sub>5</sub></td><td align="center" valign="top">b<sub>4</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">0</td><td align="center" valign="top">0</td><td align="center" valign="top">0</td><td align="center" valign="top">0</td><td align="center" valign="top">0</td><td align="center" valign="top">0</td><td align="center" valign="top">b<sub>9</sub></td><td align="center" valign="top">b<sub>8</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-SBGGR10-2X8-PADLO-BE"></a>MEDIA_BUS_FMT_SBGGR10_2X8_PADLO_BE</td><td align="center" valign="top">0x3005</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">b<sub>9</sub></td><td align="center" valign="top">b<sub>8</sub></td><td align="center" valign="top">b<sub>7</sub></td><td align="center" valign="top">b<sub>6</sub></td><td align="center" valign="top">b<sub>5</sub></td><td align="center" valign="top">b<sub>4</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td><td align="center" valign="top">0</td><td align="center" valign="top">0</td><td align="center" valign="top">0</td><td align="center" valign="top">0</td><td align="center" valign="top">0</td><td align="center" valign="top">0</td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-SBGGR10-2X8-PADLO-LE"></a>MEDIA_BUS_FMT_SBGGR10_2X8_PADLO_LE</td><td align="center" valign="top">0x3006</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td><td align="center" valign="top">0</td><td align="center" valign="top">0</td><td align="center" valign="top">0</td><td align="center" valign="top">0</td><td align="center" valign="top">0</td><td align="center" valign="top">0</td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">b<sub>9</sub></td><td align="center" valign="top">b<sub>8</sub></td><td align="center" valign="top">b<sub>7</sub></td><td align="center" valign="top">b<sub>6</sub></td><td align="center" valign="top">b<sub>5</sub></td><td align="center" valign="top">b<sub>4</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-SBGGR10-1X10"></a>MEDIA_BUS_FMT_SBGGR10_1X10</td><td align="center" valign="top">0x3007</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">b<sub>9</sub></td><td align="center" valign="top">b<sub>8</sub></td><td align="center" valign="top">b<sub>7</sub></td><td align="center" valign="top">b<sub>6</sub></td><td align="center" valign="top">b<sub>5</sub></td><td align="center" valign="top">b<sub>4</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-SGBRG10-1X10"></a>MEDIA_BUS_FMT_SGBRG10_1X10</td><td align="center" valign="top">0x300e</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">g<sub>9</sub></td><td align="center" valign="top">g<sub>8</sub></td><td align="center" valign="top">g<sub>7</sub></td><td align="center" valign="top">g<sub>6</sub></td><td align="center" valign="top">g<sub>5</sub></td><td align="center" valign="top">g<sub>4</sub></td><td align="center" valign="top">g<sub>3</sub></td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-SGRBG10-1X10"></a>MEDIA_BUS_FMT_SGRBG10_1X10</td><td align="center" valign="top">0x300a</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">g<sub>9</sub></td><td align="center" valign="top">g<sub>8</sub></td><td align="center" valign="top">g<sub>7</sub></td><td align="center" valign="top">g<sub>6</sub></td><td align="center" valign="top">g<sub>5</sub></td><td align="center" valign="top">g<sub>4</sub></td><td align="center" valign="top">g<sub>3</sub></td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-SRGGB10-1X10"></a>MEDIA_BUS_FMT_SRGGB10_1X10</td><td align="center" valign="top">0x300f</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">r<sub>9</sub></td><td align="center" valign="top">r<sub>8</sub></td><td align="center" valign="top">r<sub>7</sub></td><td align="center" valign="top">r<sub>6</sub></td><td align="center" valign="top">r<sub>5</sub></td><td align="center" valign="top">r<sub>4</sub></td><td align="center" valign="top">r<sub>3</sub></td><td align="center" valign="top">r<sub>2</sub></td><td align="center" valign="top">r<sub>1</sub></td><td align="center" valign="top">r<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-SBGGR12-1X12"></a>MEDIA_BUS_FMT_SBGGR12_1X12</td><td align="center" valign="top">0x3008</td><td valign="top"> </td><td align="center" valign="top">b<sub>11</sub></td><td align="center" valign="top">b<sub>10</sub></td><td align="center" valign="top">b<sub>9</sub></td><td align="center" valign="top">b<sub>8</sub></td><td align="center" valign="top">b<sub>7</sub></td><td align="center" valign="top">b<sub>6</sub></td><td align="center" valign="top">b<sub>5</sub></td><td align="center" valign="top">b<sub>4</sub></td><td align="center" valign="top">b<sub>3</sub></td><td align="center" valign="top">b<sub>2</sub></td><td align="center" valign="top">b<sub>1</sub></td><td align="center" valign="top">b<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-SGBRG12-1X12"></a>MEDIA_BUS_FMT_SGBRG12_1X12</td><td align="center" valign="top">0x3010</td><td valign="top"> </td><td align="center" valign="top">g<sub>11</sub></td><td align="center" valign="top">g<sub>10</sub></td><td align="center" valign="top">g<sub>9</sub></td><td align="center" valign="top">g<sub>8</sub></td><td align="center" valign="top">g<sub>7</sub></td><td align="center" valign="top">g<sub>6</sub></td><td align="center" valign="top">g<sub>5</sub></td><td align="center" valign="top">g<sub>4</sub></td><td align="center" valign="top">g<sub>3</sub></td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-SGRBG12-1X12"></a>MEDIA_BUS_FMT_SGRBG12_1X12</td><td align="center" valign="top">0x3011</td><td valign="top"> </td><td align="center" valign="top">g<sub>11</sub></td><td align="center" valign="top">g<sub>10</sub></td><td align="center" valign="top">g<sub>9</sub></td><td align="center" valign="top">g<sub>8</sub></td><td align="center" valign="top">g<sub>7</sub></td><td align="center" valign="top">g<sub>6</sub></td><td align="center" valign="top">g<sub>5</sub></td><td align="center" valign="top">g<sub>4</sub></td><td align="center" valign="top">g<sub>3</sub></td><td align="center" valign="top">g<sub>2</sub></td><td align="center" valign="top">g<sub>1</sub></td><td align="center" valign="top">g<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-SRGGB12-1X12"></a>MEDIA_BUS_FMT_SRGGB12_1X12</td><td align="center" valign="top">0x3012</td><td valign="top"> </td><td align="center" valign="top">r<sub>11</sub></td><td align="center" valign="top">r<sub>10</sub></td><td align="center" valign="top">r<sub>9</sub></td><td align="center" valign="top">r<sub>8</sub></td><td align="center" valign="top">r<sub>7</sub></td><td align="center" valign="top">r<sub>6</sub></td><td align="center" valign="top">r<sub>5</sub></td><td align="center" valign="top">r<sub>4</sub></td><td align="center" valign="top">r<sub>3</sub></td><td align="center" valign="top">r<sub>2</sub></td><td align="center" valign="top">r<sub>1</sub></td><td align="center" valign="top">r<sub>0</sub></td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idp65745376"></a>Packed YUV Formats</h5></div></div></div><p>Those data formats transfer pixel data as (possibly downsampled) Y, U
      and V components. Some formats include dummy bits in some of their samples
      and are collectively referred to as "YDYC" (Y-Dummy-Y-Chroma) formats.
      One cannot rely on the values of these dummy bits as those are undefined.
      </p><p>The format code is made of the following information.
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The Y, U and V components order code, as transferred on the
	bus. Possible values are YUYV, UYVY, YVYU and VYUY for formats with no
	dummy bit, and YDYUYDYV, YDYVYDYU, YUYDYVYD and YVYDYUYD for YDYC formats.
	</p></li><li class="listitem"><p>The number of bits per pixel component. All components are
	transferred on the same number of bits. Common values are 8, 10 and 12.</p></li><li class="listitem"><p>The number of bus samples per pixel. Pixels that are wider than
	the bus width must be transferred in multiple samples. Common values are
	1, 1.5 (encoded as 1_5) and 2.</p></li><li class="listitem"><p>The bus width. When the bus width is larger than the number of
	bits per pixel component, several components are packed in a single bus
	sample. The components are ordered as specified by the order code, with
	components on the left of the code transferred in the high order bits.
	Common values are 8 and 16.</p></li></ul></div><p>
      </p><p>For instance, a format where pixels are encoded as 8-bit YUV values
      downsampled to 4:2:2 and transferred as 2 8-bit bus samples per pixel in the
      U, Y, V, Y order will be named <code class="constant">MEDIA_BUS_FMT_UYVY8_2X8</code>.
      </p><p><a class="xref" href="media.html#v4l2-mbus-pixelcode-yuv8" title="Table 4.23. YUV Formats">Table 4.23, &#8220;YUV Formats&#8221;</a> lists existing packed YUV
	formats and describes the organization of each pixel data in each sample.
	When a format pattern is split across multiple samples each of the samples
	in the pattern is described.</p><p>The role of each bit transferred over the bus is identified by one
	of the following codes.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>y<sub>x</sub> for luma component bit number x</p></li><li class="listitem"><p>u<sub>x</sub> for blue chroma component bit number x</p></li><li class="listitem"><p>v<sub>x</sub> for red chroma component bit number x</p></li><li class="listitem"><p>a<sub>x</sub> for alpha component bit number x</p></li><li class="listitem"><p>- for non-available bits (for positions higher than the bus width)</p></li><li class="listitem"><p>d for dummy bits</p></li></ul></div><div class="table"><a name="v4l2-mbus-pixelcode-yuv8"></a><p class="title"><b>Table 4.23. YUV Formats</b></p><div class="table-contents"><table summary="YUV Formats" border="0"><colgroup><col align="left" class="id"><col align="center" class="code"><col class="bit"><col align="center" class="b31"><col align="center" class="b20"><col align="center" class="b29"><col align="center" class="b28"><col align="center" class="b27"><col align="center" class="b26"><col align="center" class="b25"><col align="center" class="b24"><col align="center" class="b23"><col align="center" class="b22"><col align="center" class="b21"><col align="center" class="b20"><col align="center" class="b19"><col align="center" class="b18"><col align="center" class="b17"><col align="center" class="b16"><col align="center" class="b15"><col align="center" class="b14"><col align="center" class="b13"><col align="center" class="b12"></colgroup><thead><tr><th align="left">Identifier</th><th align="center">Code</th><th> </th><th colspan="32" align="center">Data organization</th></tr><tr><th align="left"> </th><th align="center"> </th><th>Bit</th><th align="center">31</th><th align="center">30</th><th align="center">29</th><th align="center">28</th><th align="center">27</th><th align="center">26</th><th align="center">25</th><th align="center">24</th><th align="center">23</th><th align="center">22</th><th align="center">21</th><th align="center">10</th><th align="center">19</th><th align="center">18</th><th align="center">17</th><th align="center">16</th><th align="center">15</th><th align="center">14</th><th align="center">13</th><th align="center">12</th><th align="center">11</th><th align="center">10</th><th align="center">9</th><th align="center">8</th><th align="center">7</th><th align="center">6</th><th align="center">5</th><th align="center">4</th><th align="center">3</th><th align="center">2</th><th align="center">1</th><th align="center">0</th></tr></thead><tbody valign="top"><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-Y8-1X8"></a>MEDIA_BUS_FMT_Y8_1X8</td><td align="center" valign="top">0x2001</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-UV8-1X8"></a>MEDIA_BUS_FMT_UV8_1X8</td><td align="center" valign="top">0x2015</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">u<sub>7</sub></td><td align="center" valign="top">u<sub>6</sub></td><td align="center" valign="top">u<sub>5</sub></td><td align="center" valign="top">u<sub>4</sub></td><td align="center" valign="top">u<sub>3</sub></td><td align="center" valign="top">u<sub>2</sub></td><td align="center" valign="top">u<sub>1</sub></td><td align="center" valign="top">u<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">v<sub>7</sub></td><td align="center" valign="top">v<sub>6</sub></td><td align="center" valign="top">v<sub>5</sub></td><td align="center" valign="top">v<sub>4</sub></td><td align="center" valign="top">v<sub>3</sub></td><td align="center" valign="top">v<sub>2</sub></td><td align="center" valign="top">v<sub>1</sub></td><td align="center" valign="top">v<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-UYVY8-1_5X8"></a>MEDIA_BUS_FMT_UYVY8_1_5X8</td><td align="center" valign="top">0x2002</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">u<sub>7</sub></td><td align="center" valign="top">u<sub>6</sub></td><td align="center" valign="top">u<sub>5</sub></td><td align="center" valign="top">u<sub>4</sub></td><td align="center" valign="top">u<sub>3</sub></td><td align="center" valign="top">u<sub>2</sub></td><td align="center" valign="top">u<sub>1</sub></td><td align="center" valign="top">u<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">v<sub>7</sub></td><td align="center" valign="top">v<sub>6</sub></td><td align="center" valign="top">v<sub>5</sub></td><td align="center" valign="top">v<sub>4</sub></td><td align="center" valign="top">v<sub>3</sub></td><td align="center" valign="top">v<sub>2</sub></td><td align="center" valign="top">v<sub>1</sub></td><td align="center" valign="top">v<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-VYUY8-1_5X8"></a>MEDIA_BUS_FMT_VYUY8_1_5X8</td><td align="center" valign="top">0x2003</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">v<sub>7</sub></td><td align="center" valign="top">v<sub>6</sub></td><td align="center" valign="top">v<sub>5</sub></td><td align="center" valign="top">v<sub>4</sub></td><td align="center" valign="top">v<sub>3</sub></td><td align="center" valign="top">v<sub>2</sub></td><td align="center" valign="top">v<sub>1</sub></td><td align="center" valign="top">v<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">u<sub>7</sub></td><td align="center" valign="top">u<sub>6</sub></td><td align="center" valign="top">u<sub>5</sub></td><td align="center" valign="top">u<sub>4</sub></td><td align="center" valign="top">u<sub>3</sub></td><td align="center" valign="top">u<sub>2</sub></td><td align="center" valign="top">u<sub>1</sub></td><td align="center" valign="top">u<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-YUYV8-1_5X8"></a>MEDIA_BUS_FMT_YUYV8_1_5X8</td><td align="center" valign="top">0x2004</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">u<sub>7</sub></td><td align="center" valign="top">u<sub>6</sub></td><td align="center" valign="top">u<sub>5</sub></td><td align="center" valign="top">u<sub>4</sub></td><td align="center" valign="top">u<sub>3</sub></td><td align="center" valign="top">u<sub>2</sub></td><td align="center" valign="top">u<sub>1</sub></td><td align="center" valign="top">u<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">v<sub>7</sub></td><td align="center" valign="top">v<sub>6</sub></td><td align="center" valign="top">v<sub>5</sub></td><td align="center" valign="top">v<sub>4</sub></td><td align="center" valign="top">v<sub>3</sub></td><td align="center" valign="top">v<sub>2</sub></td><td align="center" valign="top">v<sub>1</sub></td><td align="center" valign="top">v<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-YVYU8-1_5X8"></a>MEDIA_BUS_FMT_YVYU8_1_5X8</td><td align="center" valign="top">0x2005</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">v<sub>7</sub></td><td align="center" valign="top">v<sub>6</sub></td><td align="center" valign="top">v<sub>5</sub></td><td align="center" valign="top">v<sub>4</sub></td><td align="center" valign="top">v<sub>3</sub></td><td align="center" valign="top">v<sub>2</sub></td><td align="center" valign="top">v<sub>1</sub></td><td align="center" valign="top">v<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">u<sub>7</sub></td><td align="center" valign="top">u<sub>6</sub></td><td align="center" valign="top">u<sub>5</sub></td><td align="center" valign="top">u<sub>4</sub></td><td align="center" valign="top">u<sub>3</sub></td><td align="center" valign="top">u<sub>2</sub></td><td align="center" valign="top">u<sub>1</sub></td><td align="center" valign="top">u<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-UYVY8-2X8"></a>MEDIA_BUS_FMT_UYVY8_2X8</td><td align="center" valign="top">0x2006</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">u<sub>7</sub></td><td align="center" valign="top">u<sub>6</sub></td><td align="center" valign="top">u<sub>5</sub></td><td align="center" valign="top">u<sub>4</sub></td><td align="center" valign="top">u<sub>3</sub></td><td align="center" valign="top">u<sub>2</sub></td><td align="center" valign="top">u<sub>1</sub></td><td align="center" valign="top">u<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">v<sub>7</sub></td><td align="center" valign="top">v<sub>6</sub></td><td align="center" valign="top">v<sub>5</sub></td><td align="center" valign="top">v<sub>4</sub></td><td align="center" valign="top">v<sub>3</sub></td><td align="center" valign="top">v<sub>2</sub></td><td align="center" valign="top">v<sub>1</sub></td><td align="center" valign="top">v<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-VYUY8-2X8"></a>MEDIA_BUS_FMT_VYUY8_2X8</td><td align="center" valign="top">0x2007</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">v<sub>7</sub></td><td align="center" valign="top">v<sub>6</sub></td><td align="center" valign="top">v<sub>5</sub></td><td align="center" valign="top">v<sub>4</sub></td><td align="center" valign="top">v<sub>3</sub></td><td align="center" valign="top">v<sub>2</sub></td><td align="center" valign="top">v<sub>1</sub></td><td align="center" valign="top">v<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">u<sub>7</sub></td><td align="center" valign="top">u<sub>6</sub></td><td align="center" valign="top">u<sub>5</sub></td><td align="center" valign="top">u<sub>4</sub></td><td align="center" valign="top">u<sub>3</sub></td><td align="center" valign="top">u<sub>2</sub></td><td align="center" valign="top">u<sub>1</sub></td><td align="center" valign="top">u<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-YUYV8-2X8"></a>MEDIA_BUS_FMT_YUYV8_2X8</td><td align="center" valign="top">0x2008</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">u<sub>7</sub></td><td align="center" valign="top">u<sub>6</sub></td><td align="center" valign="top">u<sub>5</sub></td><td align="center" valign="top">u<sub>4</sub></td><td align="center" valign="top">u<sub>3</sub></td><td align="center" valign="top">u<sub>2</sub></td><td align="center" valign="top">u<sub>1</sub></td><td align="center" valign="top">u<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">v<sub>7</sub></td><td align="center" valign="top">v<sub>6</sub></td><td align="center" valign="top">v<sub>5</sub></td><td align="center" valign="top">v<sub>4</sub></td><td align="center" valign="top">v<sub>3</sub></td><td align="center" valign="top">v<sub>2</sub></td><td align="center" valign="top">v<sub>1</sub></td><td align="center" valign="top">v<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-YVYU8-2X8"></a>MEDIA_BUS_FMT_YVYU8_2X8</td><td align="center" valign="top">0x2009</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">v<sub>7</sub></td><td align="center" valign="top">v<sub>6</sub></td><td align="center" valign="top">v<sub>5</sub></td><td align="center" valign="top">v<sub>4</sub></td><td align="center" valign="top">v<sub>3</sub></td><td align="center" valign="top">v<sub>2</sub></td><td align="center" valign="top">v<sub>1</sub></td><td align="center" valign="top">v<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">u<sub>7</sub></td><td align="center" valign="top">u<sub>6</sub></td><td align="center" valign="top">u<sub>5</sub></td><td align="center" valign="top">u<sub>4</sub></td><td align="center" valign="top">u<sub>3</sub></td><td align="center" valign="top">u<sub>2</sub></td><td align="center" valign="top">u<sub>1</sub></td><td align="center" valign="top">u<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-Y10-1X10"></a>MEDIA_BUS_FMT_Y10_1X10</td><td align="center" valign="top">0x200a</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-UYVY10-2X10"></a>MEDIA_BUS_FMT_UYVY10_2X10</td><td align="center" valign="top">0x2018</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">u<sub>9</sub></td><td align="center" valign="top">u<sub>8</sub></td><td align="center" valign="top">u<sub>7</sub></td><td align="center" valign="top">u<sub>6</sub></td><td align="center" valign="top">u<sub>5</sub></td><td align="center" valign="top">u<sub>4</sub></td><td align="center" valign="top">u<sub>3</sub></td><td align="center" valign="top">u<sub>2</sub></td><td align="center" valign="top">u<sub>1</sub></td><td align="center" valign="top">u<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">v<sub>9</sub></td><td align="center" valign="top">v<sub>8</sub></td><td align="center" valign="top">v<sub>7</sub></td><td align="center" valign="top">v<sub>6</sub></td><td align="center" valign="top">v<sub>5</sub></td><td align="center" valign="top">v<sub>4</sub></td><td align="center" valign="top">v<sub>3</sub></td><td align="center" valign="top">v<sub>2</sub></td><td align="center" valign="top">v<sub>1</sub></td><td align="center" valign="top">v<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-VYUY10-2X10"></a>MEDIA_BUS_FMT_VYUY10_2X10</td><td align="center" valign="top">0x2019</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">v<sub>9</sub></td><td align="center" valign="top">v<sub>8</sub></td><td align="center" valign="top">v<sub>7</sub></td><td align="center" valign="top">v<sub>6</sub></td><td align="center" valign="top">v<sub>5</sub></td><td align="center" valign="top">v<sub>4</sub></td><td align="center" valign="top">v<sub>3</sub></td><td align="center" valign="top">v<sub>2</sub></td><td align="center" valign="top">v<sub>1</sub></td><td align="center" valign="top">v<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">u<sub>9</sub></td><td align="center" valign="top">u<sub>8</sub></td><td align="center" valign="top">u<sub>7</sub></td><td align="center" valign="top">u<sub>6</sub></td><td align="center" valign="top">u<sub>5</sub></td><td align="center" valign="top">u<sub>4</sub></td><td align="center" valign="top">u<sub>3</sub></td><td align="center" valign="top">u<sub>2</sub></td><td align="center" valign="top">u<sub>1</sub></td><td align="center" valign="top">u<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-YUYV10-2X10"></a>MEDIA_BUS_FMT_YUYV10_2X10</td><td align="center" valign="top">0x200b</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">u<sub>9</sub></td><td align="center" valign="top">u<sub>8</sub></td><td align="center" valign="top">u<sub>7</sub></td><td align="center" valign="top">u<sub>6</sub></td><td align="center" valign="top">u<sub>5</sub></td><td align="center" valign="top">u<sub>4</sub></td><td align="center" valign="top">u<sub>3</sub></td><td align="center" valign="top">u<sub>2</sub></td><td align="center" valign="top">u<sub>1</sub></td><td align="center" valign="top">u<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">v<sub>9</sub></td><td align="center" valign="top">v<sub>8</sub></td><td align="center" valign="top">v<sub>7</sub></td><td align="center" valign="top">v<sub>6</sub></td><td align="center" valign="top">v<sub>5</sub></td><td align="center" valign="top">v<sub>4</sub></td><td align="center" valign="top">v<sub>3</sub></td><td align="center" valign="top">v<sub>2</sub></td><td align="center" valign="top">v<sub>1</sub></td><td align="center" valign="top">v<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-YVYU10-2X10"></a>MEDIA_BUS_FMT_YVYU10_2X10</td><td align="center" valign="top">0x200c</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">v<sub>9</sub></td><td align="center" valign="top">v<sub>8</sub></td><td align="center" valign="top">v<sub>7</sub></td><td align="center" valign="top">v<sub>6</sub></td><td align="center" valign="top">v<sub>5</sub></td><td align="center" valign="top">v<sub>4</sub></td><td align="center" valign="top">v<sub>3</sub></td><td align="center" valign="top">v<sub>2</sub></td><td align="center" valign="top">v<sub>1</sub></td><td align="center" valign="top">v<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">u<sub>9</sub></td><td align="center" valign="top">u<sub>8</sub></td><td align="center" valign="top">u<sub>7</sub></td><td align="center" valign="top">u<sub>6</sub></td><td align="center" valign="top">u<sub>5</sub></td><td align="center" valign="top">u<sub>4</sub></td><td align="center" valign="top">u<sub>3</sub></td><td align="center" valign="top">u<sub>2</sub></td><td align="center" valign="top">u<sub>1</sub></td><td align="center" valign="top">u<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-Y12-1X12"></a>MEDIA_BUS_FMT_Y12_1X12</td><td align="center" valign="top">0x2013</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>11</sub></td><td align="center" valign="top">y<sub>10</sub></td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-UYVY8-1X16"></a>MEDIA_BUS_FMT_UYVY8_1X16</td><td align="center" valign="top">0x200f</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">u<sub>7</sub></td><td align="center" valign="top">u<sub>6</sub></td><td align="center" valign="top">u<sub>5</sub></td><td align="center" valign="top">u<sub>4</sub></td><td align="center" valign="top">u<sub>3</sub></td><td align="center" valign="top">u<sub>2</sub></td><td align="center" valign="top">u<sub>1</sub></td><td align="center" valign="top">u<sub>0</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">v<sub>7</sub></td><td align="center" valign="top">v<sub>6</sub></td><td align="center" valign="top">v<sub>5</sub></td><td align="center" valign="top">v<sub>4</sub></td><td align="center" valign="top">v<sub>3</sub></td><td align="center" valign="top">v<sub>2</sub></td><td align="center" valign="top">v<sub>1</sub></td><td align="center" valign="top">v<sub>0</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-VYUY8-1X16"></a>MEDIA_BUS_FMT_VYUY8_1X16</td><td align="center" valign="top">0x2010</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">v<sub>7</sub></td><td align="center" valign="top">v<sub>6</sub></td><td align="center" valign="top">v<sub>5</sub></td><td align="center" valign="top">v<sub>4</sub></td><td align="center" valign="top">v<sub>3</sub></td><td align="center" valign="top">v<sub>2</sub></td><td align="center" valign="top">v<sub>1</sub></td><td align="center" valign="top">v<sub>0</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">u<sub>7</sub></td><td align="center" valign="top">u<sub>6</sub></td><td align="center" valign="top">u<sub>5</sub></td><td align="center" valign="top">u<sub>4</sub></td><td align="center" valign="top">u<sub>3</sub></td><td align="center" valign="top">u<sub>2</sub></td><td align="center" valign="top">u<sub>1</sub></td><td align="center" valign="top">u<sub>0</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-YUYV8-1X16"></a>MEDIA_BUS_FMT_YUYV8_1X16</td><td align="center" valign="top">0x2011</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td><td align="center" valign="top">u<sub>7</sub></td><td align="center" valign="top">u<sub>6</sub></td><td align="center" valign="top">u<sub>5</sub></td><td align="center" valign="top">u<sub>4</sub></td><td align="center" valign="top">u<sub>3</sub></td><td align="center" valign="top">u<sub>2</sub></td><td align="center" valign="top">u<sub>1</sub></td><td align="center" valign="top">u<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td><td align="center" valign="top">v<sub>7</sub></td><td align="center" valign="top">v<sub>6</sub></td><td align="center" valign="top">v<sub>5</sub></td><td align="center" valign="top">v<sub>4</sub></td><td align="center" valign="top">v<sub>3</sub></td><td align="center" valign="top">v<sub>2</sub></td><td align="center" valign="top">v<sub>1</sub></td><td align="center" valign="top">v<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-YVYU8-1X16"></a>MEDIA_BUS_FMT_YVYU8_1X16</td><td align="center" valign="top">0x2012</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td><td align="center" valign="top">v<sub>7</sub></td><td align="center" valign="top">v<sub>6</sub></td><td align="center" valign="top">v<sub>5</sub></td><td align="center" valign="top">v<sub>4</sub></td><td align="center" valign="top">v<sub>3</sub></td><td align="center" valign="top">v<sub>2</sub></td><td align="center" valign="top">v<sub>1</sub></td><td align="center" valign="top">v<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td><td align="center" valign="top">u<sub>7</sub></td><td align="center" valign="top">u<sub>6</sub></td><td align="center" valign="top">u<sub>5</sub></td><td align="center" valign="top">u<sub>4</sub></td><td align="center" valign="top">u<sub>3</sub></td><td align="center" valign="top">u<sub>2</sub></td><td align="center" valign="top">u<sub>1</sub></td><td align="center" valign="top">u<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-YDYUYDYV8-1X16"></a>MEDIA_BUS_FMT_YDYUYDYV8_1X16</td><td align="center" valign="top">0x2014</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td><td align="center" valign="top">d</td><td align="center" valign="top">d</td><td align="center" valign="top">d</td><td align="center" valign="top">d</td><td align="center" valign="top">d</td><td align="center" valign="top">d</td><td align="center" valign="top">d</td><td align="center" valign="top">d</td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td><td align="center" valign="top">u<sub>7</sub></td><td align="center" valign="top">u<sub>6</sub></td><td align="center" valign="top">u<sub>5</sub></td><td align="center" valign="top">u<sub>4</sub></td><td align="center" valign="top">u<sub>3</sub></td><td align="center" valign="top">u<sub>2</sub></td><td align="center" valign="top">u<sub>1</sub></td><td align="center" valign="top">u<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td><td align="center" valign="top">d</td><td align="center" valign="top">d</td><td align="center" valign="top">d</td><td align="center" valign="top">d</td><td align="center" valign="top">d</td><td align="center" valign="top">d</td><td align="center" valign="top">d</td><td align="center" valign="top">d</td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td><td align="center" valign="top">v<sub>7</sub></td><td align="center" valign="top">v<sub>6</sub></td><td align="center" valign="top">v<sub>5</sub></td><td align="center" valign="top">v<sub>4</sub></td><td align="center" valign="top">v<sub>3</sub></td><td align="center" valign="top">v<sub>2</sub></td><td align="center" valign="top">v<sub>1</sub></td><td align="center" valign="top">v<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-UYVY10-1X20"></a>MEDIA_BUS_FMT_UYVY10_1X20</td><td align="center" valign="top">0x201a</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">u<sub>9</sub></td><td align="center" valign="top">u<sub>8</sub></td><td align="center" valign="top">u<sub>7</sub></td><td align="center" valign="top">u<sub>6</sub></td><td align="center" valign="top">u<sub>5</sub></td><td align="center" valign="top">u<sub>4</sub></td><td align="center" valign="top">u<sub>3</sub></td><td align="center" valign="top">u<sub>2</sub></td><td align="center" valign="top">u<sub>1</sub></td><td align="center" valign="top">u<sub>0</sub></td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">v<sub>9</sub></td><td align="center" valign="top">v<sub>8</sub></td><td align="center" valign="top">v<sub>7</sub></td><td align="center" valign="top">v<sub>6</sub></td><td align="center" valign="top">v<sub>5</sub></td><td align="center" valign="top">v<sub>4</sub></td><td align="center" valign="top">v<sub>3</sub></td><td align="center" valign="top">v<sub>2</sub></td><td align="center" valign="top">v<sub>1</sub></td><td align="center" valign="top">v<sub>0</sub></td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-VYUY10-1X20"></a>MEDIA_BUS_FMT_VYUY10_1X20</td><td align="center" valign="top">0x201b</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">v<sub>9</sub></td><td align="center" valign="top">v<sub>8</sub></td><td align="center" valign="top">v<sub>7</sub></td><td align="center" valign="top">v<sub>6</sub></td><td align="center" valign="top">v<sub>5</sub></td><td align="center" valign="top">v<sub>4</sub></td><td align="center" valign="top">v<sub>3</sub></td><td align="center" valign="top">v<sub>2</sub></td><td align="center" valign="top">v<sub>1</sub></td><td align="center" valign="top">v<sub>0</sub></td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">u<sub>9</sub></td><td align="center" valign="top">u<sub>8</sub></td><td align="center" valign="top">u<sub>7</sub></td><td align="center" valign="top">u<sub>6</sub></td><td align="center" valign="top">u<sub>5</sub></td><td align="center" valign="top">u<sub>4</sub></td><td align="center" valign="top">u<sub>3</sub></td><td align="center" valign="top">u<sub>2</sub></td><td align="center" valign="top">u<sub>1</sub></td><td align="center" valign="top">u<sub>0</sub></td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-YUYV10-1X20"></a>MEDIA_BUS_FMT_YUYV10_1X20</td><td align="center" valign="top">0x200d</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td><td align="center" valign="top">u<sub>9</sub></td><td align="center" valign="top">u<sub>8</sub></td><td align="center" valign="top">u<sub>7</sub></td><td align="center" valign="top">u<sub>6</sub></td><td align="center" valign="top">u<sub>5</sub></td><td align="center" valign="top">u<sub>4</sub></td><td align="center" valign="top">u<sub>3</sub></td><td align="center" valign="top">u<sub>2</sub></td><td align="center" valign="top">u<sub>1</sub></td><td align="center" valign="top">u<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td><td align="center" valign="top">v<sub>9</sub></td><td align="center" valign="top">v<sub>8</sub></td><td align="center" valign="top">v<sub>7</sub></td><td align="center" valign="top">v<sub>6</sub></td><td align="center" valign="top">v<sub>5</sub></td><td align="center" valign="top">v<sub>4</sub></td><td align="center" valign="top">v<sub>3</sub></td><td align="center" valign="top">v<sub>2</sub></td><td align="center" valign="top">v<sub>1</sub></td><td align="center" valign="top">v<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-YVYU10-1X20"></a>MEDIA_BUS_FMT_YVYU10_1X20</td><td align="center" valign="top">0x200e</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td><td align="center" valign="top">v<sub>9</sub></td><td align="center" valign="top">v<sub>8</sub></td><td align="center" valign="top">v<sub>7</sub></td><td align="center" valign="top">v<sub>6</sub></td><td align="center" valign="top">v<sub>5</sub></td><td align="center" valign="top">v<sub>4</sub></td><td align="center" valign="top">v<sub>3</sub></td><td align="center" valign="top">v<sub>2</sub></td><td align="center" valign="top">v<sub>1</sub></td><td align="center" valign="top">v<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td><td align="center" valign="top">u<sub>9</sub></td><td align="center" valign="top">u<sub>8</sub></td><td align="center" valign="top">u<sub>7</sub></td><td align="center" valign="top">u<sub>6</sub></td><td align="center" valign="top">u<sub>5</sub></td><td align="center" valign="top">u<sub>4</sub></td><td align="center" valign="top">u<sub>3</sub></td><td align="center" valign="top">u<sub>2</sub></td><td align="center" valign="top">u<sub>1</sub></td><td align="center" valign="top">u<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-YUV10-1X30"></a>MEDIA_BUS_FMT_YUV10_1X30</td><td align="center" valign="top">0x2016</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td><td align="center" valign="top">u<sub>9</sub></td><td align="center" valign="top">u<sub>8</sub></td><td align="center" valign="top">u<sub>7</sub></td><td align="center" valign="top">u<sub>6</sub></td><td align="center" valign="top">u<sub>5</sub></td><td align="center" valign="top">u<sub>4</sub></td><td align="center" valign="top">u<sub>3</sub></td><td align="center" valign="top">u<sub>2</sub></td><td align="center" valign="top">u<sub>1</sub></td><td align="center" valign="top">u<sub>0</sub></td><td align="center" valign="top">v<sub>9</sub></td><td align="center" valign="top">v<sub>8</sub></td><td align="center" valign="top">v<sub>7</sub></td><td align="center" valign="top">v<sub>6</sub></td><td align="center" valign="top">v<sub>5</sub></td><td align="center" valign="top">v<sub>4</sub></td><td align="center" valign="top">v<sub>3</sub></td><td align="center" valign="top">v<sub>2</sub></td><td align="center" valign="top">v<sub>1</sub></td><td align="center" valign="top">v<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-AYUV8-1X32"></a>MEDIA_BUS_FMT_AYUV8_1X32</td><td align="center" valign="top">0x2017</td><td valign="top"> </td><td align="center" valign="top">a<sub>7</sub></td><td align="center" valign="top">a<sub>6</sub></td><td align="center" valign="top">a<sub>5</sub></td><td align="center" valign="top">a<sub>4</sub></td><td align="center" valign="top">a<sub>3</sub></td><td align="center" valign="top">a<sub>2</sub></td><td align="center" valign="top">a<sub>1</sub></td><td align="center" valign="top">a<sub>0</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td><td align="center" valign="top">u<sub>7</sub></td><td align="center" valign="top">u<sub>6</sub></td><td align="center" valign="top">u<sub>5</sub></td><td align="center" valign="top">u<sub>4</sub></td><td align="center" valign="top">u<sub>3</sub></td><td align="center" valign="top">u<sub>2</sub></td><td align="center" valign="top">u<sub>1</sub></td><td align="center" valign="top">u<sub>0</sub></td><td align="center" valign="top">v<sub>7</sub></td><td align="center" valign="top">v<sub>6</sub></td><td align="center" valign="top">v<sub>5</sub></td><td align="center" valign="top">v<sub>4</sub></td><td align="center" valign="top">v<sub>3</sub></td><td align="center" valign="top">v<sub>2</sub></td><td align="center" valign="top">v<sub>1</sub></td><td align="center" valign="top">v<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-UYVY12-2X12"></a>MEDIA_BUS_FMT_UYVY12_2X12</td><td align="center" valign="top">0x201c</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">u<sub>11</sub></td><td align="center" valign="top">u<sub>10</sub></td><td align="center" valign="top">u<sub>9</sub></td><td align="center" valign="top">u<sub>8</sub></td><td align="center" valign="top">u<sub>7</sub></td><td align="center" valign="top">u<sub>6</sub></td><td align="center" valign="top">u<sub>5</sub></td><td align="center" valign="top">u<sub>4</sub></td><td align="center" valign="top">u<sub>3</sub></td><td align="center" valign="top">u<sub>2</sub></td><td align="center" valign="top">u<sub>1</sub></td><td align="center" valign="top">u<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>11</sub></td><td align="center" valign="top">y<sub>10</sub></td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">v<sub>11</sub></td><td align="center" valign="top">v<sub>10</sub></td><td align="center" valign="top">v<sub>9</sub></td><td align="center" valign="top">v<sub>8</sub></td><td align="center" valign="top">v<sub>7</sub></td><td align="center" valign="top">v<sub>6</sub></td><td align="center" valign="top">v<sub>5</sub></td><td align="center" valign="top">v<sub>4</sub></td><td align="center" valign="top">v<sub>3</sub></td><td align="center" valign="top">v<sub>2</sub></td><td align="center" valign="top">v<sub>1</sub></td><td align="center" valign="top">v<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>11</sub></td><td align="center" valign="top">y<sub>10</sub></td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-VYUY12-2X12"></a>MEDIA_BUS_FMT_VYUY12_2X12</td><td align="center" valign="top">0x201d</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">v<sub>11</sub></td><td align="center" valign="top">v<sub>10</sub></td><td align="center" valign="top">v<sub>9</sub></td><td align="center" valign="top">v<sub>8</sub></td><td align="center" valign="top">v<sub>7</sub></td><td align="center" valign="top">v<sub>6</sub></td><td align="center" valign="top">v<sub>5</sub></td><td align="center" valign="top">v<sub>4</sub></td><td align="center" valign="top">v<sub>3</sub></td><td align="center" valign="top">v<sub>2</sub></td><td align="center" valign="top">v<sub>1</sub></td><td align="center" valign="top">v<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>11</sub></td><td align="center" valign="top">y<sub>10</sub></td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">u<sub>11</sub></td><td align="center" valign="top">u<sub>10</sub></td><td align="center" valign="top">u<sub>9</sub></td><td align="center" valign="top">u<sub>8</sub></td><td align="center" valign="top">u<sub>7</sub></td><td align="center" valign="top">u<sub>6</sub></td><td align="center" valign="top">u<sub>5</sub></td><td align="center" valign="top">u<sub>4</sub></td><td align="center" valign="top">u<sub>3</sub></td><td align="center" valign="top">u<sub>2</sub></td><td align="center" valign="top">u<sub>1</sub></td><td align="center" valign="top">u<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>11</sub></td><td align="center" valign="top">y<sub>10</sub></td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-YUYV12-2X12"></a>MEDIA_BUS_FMT_YUYV12_2X12</td><td align="center" valign="top">0x201e</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>11</sub></td><td align="center" valign="top">y<sub>10</sub></td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">u<sub>11</sub></td><td align="center" valign="top">u<sub>10</sub></td><td align="center" valign="top">u<sub>9</sub></td><td align="center" valign="top">u<sub>8</sub></td><td align="center" valign="top">u<sub>7</sub></td><td align="center" valign="top">u<sub>6</sub></td><td align="center" valign="top">u<sub>5</sub></td><td align="center" valign="top">u<sub>4</sub></td><td align="center" valign="top">u<sub>3</sub></td><td align="center" valign="top">u<sub>2</sub></td><td align="center" valign="top">u<sub>1</sub></td><td align="center" valign="top">u<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>11</sub></td><td align="center" valign="top">y<sub>10</sub></td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">v<sub>11</sub></td><td align="center" valign="top">v<sub>10</sub></td><td align="center" valign="top">v<sub>9</sub></td><td align="center" valign="top">v<sub>8</sub></td><td align="center" valign="top">v<sub>7</sub></td><td align="center" valign="top">v<sub>6</sub></td><td align="center" valign="top">v<sub>5</sub></td><td align="center" valign="top">v<sub>4</sub></td><td align="center" valign="top">v<sub>3</sub></td><td align="center" valign="top">v<sub>2</sub></td><td align="center" valign="top">v<sub>1</sub></td><td align="center" valign="top">v<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-YVYU12-2X12"></a>MEDIA_BUS_FMT_YVYU12_2X12</td><td align="center" valign="top">0x201f</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>11</sub></td><td align="center" valign="top">y<sub>10</sub></td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">v<sub>11</sub></td><td align="center" valign="top">v<sub>10</sub></td><td align="center" valign="top">v<sub>9</sub></td><td align="center" valign="top">v<sub>8</sub></td><td align="center" valign="top">v<sub>7</sub></td><td align="center" valign="top">v<sub>6</sub></td><td align="center" valign="top">v<sub>5</sub></td><td align="center" valign="top">v<sub>4</sub></td><td align="center" valign="top">v<sub>3</sub></td><td align="center" valign="top">v<sub>2</sub></td><td align="center" valign="top">v<sub>1</sub></td><td align="center" valign="top">v<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>11</sub></td><td align="center" valign="top">y<sub>10</sub></td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">u<sub>11</sub></td><td align="center" valign="top">u<sub>10</sub></td><td align="center" valign="top">u<sub>9</sub></td><td align="center" valign="top">u<sub>8</sub></td><td align="center" valign="top">u<sub>7</sub></td><td align="center" valign="top">u<sub>6</sub></td><td align="center" valign="top">u<sub>5</sub></td><td align="center" valign="top">u<sub>4</sub></td><td align="center" valign="top">u<sub>3</sub></td><td align="center" valign="top">u<sub>2</sub></td><td align="center" valign="top">u<sub>1</sub></td><td align="center" valign="top">u<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-UYVY12-1X24"></a>MEDIA_BUS_FMT_UYVY12_1X24</td><td align="center" valign="top">0x2020</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">u<sub>11</sub></td><td align="center" valign="top">u<sub>10</sub></td><td align="center" valign="top">u<sub>9</sub></td><td align="center" valign="top">u<sub>8</sub></td><td align="center" valign="top">u<sub>7</sub></td><td align="center" valign="top">u<sub>6</sub></td><td align="center" valign="top">u<sub>5</sub></td><td align="center" valign="top">u<sub>4</sub></td><td align="center" valign="top">u<sub>3</sub></td><td align="center" valign="top">u<sub>2</sub></td><td align="center" valign="top">u<sub>1</sub></td><td align="center" valign="top">u<sub>0</sub></td><td align="center" valign="top">y<sub>11</sub></td><td align="center" valign="top">y<sub>10</sub></td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">v<sub>11</sub></td><td align="center" valign="top">v<sub>10</sub></td><td align="center" valign="top">v<sub>9</sub></td><td align="center" valign="top">v<sub>8</sub></td><td align="center" valign="top">v<sub>7</sub></td><td align="center" valign="top">v<sub>6</sub></td><td align="center" valign="top">v<sub>5</sub></td><td align="center" valign="top">v<sub>4</sub></td><td align="center" valign="top">v<sub>3</sub></td><td align="center" valign="top">v<sub>2</sub></td><td align="center" valign="top">v<sub>1</sub></td><td align="center" valign="top">v<sub>0</sub></td><td align="center" valign="top">y<sub>11</sub></td><td align="center" valign="top">y<sub>10</sub></td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-VYUY12-1X24"></a>MEDIA_BUS_FMT_VYUY12_1X24</td><td align="center" valign="top">0x2021</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">v<sub>11</sub></td><td align="center" valign="top">v<sub>10</sub></td><td align="center" valign="top">v<sub>9</sub></td><td align="center" valign="top">v<sub>8</sub></td><td align="center" valign="top">v<sub>7</sub></td><td align="center" valign="top">v<sub>6</sub></td><td align="center" valign="top">v<sub>5</sub></td><td align="center" valign="top">v<sub>4</sub></td><td align="center" valign="top">v<sub>3</sub></td><td align="center" valign="top">v<sub>2</sub></td><td align="center" valign="top">v<sub>1</sub></td><td align="center" valign="top">v<sub>0</sub></td><td align="center" valign="top">y<sub>11</sub></td><td align="center" valign="top">y<sub>10</sub></td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">u<sub>11</sub></td><td align="center" valign="top">u<sub>10</sub></td><td align="center" valign="top">u<sub>9</sub></td><td align="center" valign="top">u<sub>8</sub></td><td align="center" valign="top">u<sub>7</sub></td><td align="center" valign="top">u<sub>6</sub></td><td align="center" valign="top">u<sub>5</sub></td><td align="center" valign="top">u<sub>4</sub></td><td align="center" valign="top">u<sub>3</sub></td><td align="center" valign="top">u<sub>2</sub></td><td align="center" valign="top">u<sub>1</sub></td><td align="center" valign="top">u<sub>0</sub></td><td align="center" valign="top">y<sub>11</sub></td><td align="center" valign="top">y<sub>10</sub></td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-YUYV12-1X24"></a>MEDIA_BUS_FMT_YUYV12_1X24</td><td align="center" valign="top">0x2022</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>11</sub></td><td align="center" valign="top">y<sub>10</sub></td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td><td align="center" valign="top">u<sub>11</sub></td><td align="center" valign="top">u<sub>10</sub></td><td align="center" valign="top">u<sub>9</sub></td><td align="center" valign="top">u<sub>8</sub></td><td align="center" valign="top">u<sub>7</sub></td><td align="center" valign="top">u<sub>6</sub></td><td align="center" valign="top">u<sub>5</sub></td><td align="center" valign="top">u<sub>4</sub></td><td align="center" valign="top">u<sub>3</sub></td><td align="center" valign="top">u<sub>2</sub></td><td align="center" valign="top">u<sub>1</sub></td><td align="center" valign="top">u<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>11</sub></td><td align="center" valign="top">y<sub>10</sub></td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td><td align="center" valign="top">v<sub>11</sub></td><td align="center" valign="top">v<sub>10</sub></td><td align="center" valign="top">v<sub>9</sub></td><td align="center" valign="top">v<sub>8</sub></td><td align="center" valign="top">v<sub>7</sub></td><td align="center" valign="top">v<sub>6</sub></td><td align="center" valign="top">v<sub>5</sub></td><td align="center" valign="top">v<sub>4</sub></td><td align="center" valign="top">v<sub>3</sub></td><td align="center" valign="top">v<sub>2</sub></td><td align="center" valign="top">v<sub>1</sub></td><td align="center" valign="top">v<sub>0</sub></td></tr><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-YVYU12-1X24"></a>MEDIA_BUS_FMT_YVYU12_1X24</td><td align="center" valign="top">0x2023</td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>11</sub></td><td align="center" valign="top">y<sub>10</sub></td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td><td align="center" valign="top">v<sub>11</sub></td><td align="center" valign="top">v<sub>10</sub></td><td align="center" valign="top">v<sub>9</sub></td><td align="center" valign="top">v<sub>8</sub></td><td align="center" valign="top">v<sub>7</sub></td><td align="center" valign="top">v<sub>6</sub></td><td align="center" valign="top">v<sub>5</sub></td><td align="center" valign="top">v<sub>4</sub></td><td align="center" valign="top">v<sub>3</sub></td><td align="center" valign="top">v<sub>2</sub></td><td align="center" valign="top">v<sub>1</sub></td><td align="center" valign="top">v<sub>0</sub></td></tr><tr><td align="left" valign="top"> </td><td align="center" valign="top"> </td><td valign="top"> </td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">-</td><td align="center" valign="top">y<sub>11</sub></td><td align="center" valign="top">y<sub>10</sub></td><td align="center" valign="top">y<sub>9</sub></td><td align="center" valign="top">y<sub>8</sub></td><td align="center" valign="top">y<sub>7</sub></td><td align="center" valign="top">y<sub>6</sub></td><td align="center" valign="top">y<sub>5</sub></td><td align="center" valign="top">y<sub>4</sub></td><td align="center" valign="top">y<sub>3</sub></td><td align="center" valign="top">y<sub>2</sub></td><td align="center" valign="top">y<sub>1</sub></td><td align="center" valign="top">y<sub>0</sub></td><td align="center" valign="top">u<sub>11</sub></td><td align="center" valign="top">u<sub>10</sub></td><td align="center" valign="top">u<sub>9</sub></td><td align="center" valign="top">u<sub>8</sub></td><td align="center" valign="top">u<sub>7</sub></td><td align="center" valign="top">u<sub>6</sub></td><td align="center" valign="top">u<sub>5</sub></td><td align="center" valign="top">u<sub>4</sub></td><td align="center" valign="top">u<sub>3</sub></td><td align="center" valign="top">u<sub>2</sub></td><td align="center" valign="top">u<sub>1</sub></td><td align="center" valign="top">u<sub>0</sub></td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idp67442944"></a>HSV/HSL Formats</h5></div></div></div><p>Those formats transfer pixel data as RGB values in a cylindrical-coordinate
      system using Hue-Saturation-Value or Hue-Saturation-Lightness components. The
      format code is made of the following information.
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The hue, saturation, value or lightness and optional alpha
	components order code, as encoded in a pixel sample. The only currently
	supported value is AHSV.
	</p></li><li class="listitem"><p>The number of bits per component, for each component. The values
	can be different for all components. The only currently supported value is 8888.
	</p></li><li class="listitem"><p>The number of bus samples per pixel. Pixels that are wider than
	the bus width must be transferred in multiple samples. The only currently
	supported value is 1.</p></li><li class="listitem"><p>The bus width.</p></li><li class="listitem"><p>For formats where the total number of bits per pixel is smaller
	than the number of bus samples per pixel times the bus width, a padding
	value stating if the bytes are padded in their most high order bits
	(PADHI) or low order bits (PADLO).</p></li><li class="listitem"><p>For formats where the number of bus samples per pixel is larger
	than 1, an endianness value stating if the pixel is transferred MSB first
	(BE) or LSB first (LE).</p></li></ul></div><p>
      </p><p>The following table lists existing HSV/HSL formats.</p><div class="table"><a name="v4l2-mbus-pixelcode-hsv"></a><p class="title"><b>Table 4.24. HSV/HSL formats</b></p><div class="table-contents"><table summary="HSV/HSL formats" border="0"><colgroup><col align="left" class="id"><col align="center" class="code"><col class="bit"><col align="center" class="b31"><col align="center" class="b20"><col align="center" class="b29"><col align="center" class="b28"><col align="center" class="b27"><col align="center" class="b26"><col align="center" class="b25"><col align="center" class="b24"><col align="center" class="b23"><col align="center" class="b22"><col align="center" class="b21"><col align="center" class="b20"><col align="center" class="b19"><col align="center" class="b18"><col align="center" class="b17"><col align="center" class="b16"><col align="center" class="b15"><col align="center" class="b14"><col align="center" class="b13"><col align="center" class="b12"><col align="center" class="b11"><col align="center" class="b10"><col align="center" class="b09"><col align="center" class="b08"></colgroup><thead><tr><th align="left">Identifier</th><th align="center">Code</th><th> </th><th colspan="32" align="center">Data organization</th></tr><tr><th align="left"> </th><th align="center"> </th><th>Bit</th><th align="center">31</th><th align="center">30</th><th align="center">29</th><th align="center">28</th><th align="center">27</th><th align="center">26</th><th align="center">25</th><th align="center">24</th><th align="center">23</th><th align="center">22</th><th align="center">21</th><th align="center">20</th><th align="center">19</th><th align="center">18</th><th align="center">17</th><th align="center">16</th><th align="center">15</th><th align="center">14</th><th align="center">13</th><th align="center">12</th><th align="center">11</th><th align="center">10</th><th align="center">9</th><th align="center">8</th><th align="center">7</th><th align="center">6</th><th align="center">5</th><th align="center">4</th><th align="center">3</th><th align="center">2</th><th align="center">1</th><th align="center">0</th></tr></thead><tbody valign="top"><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-AHSV8888-1X32"></a>MEDIA_BUS_FMT_AHSV8888_1X32</td><td align="center" valign="top">0x6001</td><td valign="top"> </td><td align="center" valign="top">a<sub>7</sub></td><td align="center" valign="top">a<sub>6</sub></td><td align="center" valign="top">a<sub>5</sub></td><td align="center" valign="top">a<sub>4</sub></td><td align="center" valign="top">a<sub>3</sub></td><td align="center" valign="top">a<sub>2</sub></td><td align="center" valign="top">a<sub>1</sub></td><td align="center" valign="top">a<sub>0</sub></td><td align="center" valign="top">h<sub>7</sub></td><td align="center" valign="top">h<sub>6</sub></td><td align="center" valign="top">h<sub>5</sub></td><td align="center" valign="top">h<sub>4</sub></td><td align="center" valign="top">h<sub>3</sub></td><td align="center" valign="top">h<sub>2</sub></td><td align="center" valign="top">h<sub>1</sub></td><td align="center" valign="top">h<sub>0</sub></td><td align="center" valign="top">s<sub>7</sub></td><td align="center" valign="top">s<sub>6</sub></td><td align="center" valign="top">s<sub>5</sub></td><td align="center" valign="top">s<sub>4</sub></td><td align="center" valign="top">s<sub>3</sub></td><td align="center" valign="top">s<sub>2</sub></td><td align="center" valign="top">s<sub>1</sub></td><td align="center" valign="top">s<sub>0</sub></td><td align="center" valign="top">v<sub>7</sub></td><td align="center" valign="top">v<sub>6</sub></td><td align="center" valign="top">v<sub>5</sub></td><td align="center" valign="top">v<sub>4</sub></td><td align="center" valign="top">v<sub>3</sub></td><td align="center" valign="top">v<sub>2</sub></td><td align="center" valign="top">v<sub>1</sub></td><td align="center" valign="top">v<sub>0</sub></td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idp67526144"></a>JPEG Compressed Formats</h5></div></div></div><p>Those data formats consist of an ordered sequence of 8-bit bytes
	obtained from JPEG compression process. Additionally to the
	<code class="constant">_JPEG</code> postfix the format code is made of
	the following information.
	</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The number of bus samples per entropy encoded byte.</p></li><li class="listitem"><p>The bus width.</p></li></ul></div><p>
      </p><p>For instance, for a JPEG baseline process and an 8-bit bus width
        the format will be named <code class="constant">MEDIA_BUS_FMT_JPEG_1X8</code>.
      </p><p>The following table lists existing JPEG compressed formats.</p><div class="table"><a name="v4l2-mbus-pixelcode-jpeg"></a><p class="title"><b>Table 4.25. JPEG Formats</b></p><div class="table-contents"><table summary="JPEG Formats" border="0"><colgroup><col align="left" class="id"><col align="left" class="code"><col align="left" class="remarks"></colgroup><thead><tr><th align="left">Identifier</th><th align="left">Code</th><th align="left">Remarks</th></tr></thead><tbody valign="top"><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-JPEG-1X8"></a>MEDIA_BUS_FMT_JPEG_1X8</td><td align="left" valign="top">0x4001</td><td align="left" valign="top">Besides of its usage for the parallel bus this format is
		recommended for transmission of JPEG data over MIPI CSI bus
		using the User Defined 8-bit Data types.
	      </td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="v4l2-mbus-vendor-spec-fmts"></a>Vendor and Device Specific Formats</h5></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Experimental</h3><p>This is an <a class="link" href="media.html#experimental" title="Experimental API Elements">experimental</a>
interface and may change in the future.</p></div><p>This section lists complex data formats that are either vendor or
	device specific.
      </p><p>The following table lists the existing vendor and device specific
	formats.</p><div class="table"><a name="v4l2-mbus-pixelcode-vendor-specific"></a><p class="title"><b>Table 4.26. Vendor and device specific formats</b></p><div class="table-contents"><table summary="Vendor and device specific formats" border="0"><colgroup><col align="left" class="id"><col align="left" class="code"><col align="left" class="remarks"></colgroup><thead><tr><th align="left">Identifier</th><th align="left">Code</th><th align="left">Comments</th></tr></thead><tbody valign="top"><tr><td align="left" valign="top"><a name="MEDIA-BUS-FMT-S5C-UYVY-JPEG-1X8"></a>MEDIA_BUS_FMT_S5C_UYVY_JPEG_1X8</td><td align="left" valign="top">0x5001</td><td align="left" valign="top">
		Interleaved raw UYVY and JPEG image format with embedded
		meta-data used by Samsung S3C73MX camera sensors.
	      </td></tr></tbody></table></div></div><br class="table-break"></div></div></div></div><div class="footnotes"><br><hr style="width:100; text-align:left;margin-left: 0"><div id="ftn.idp63225440" class="footnote"><p><a href="media.html#idp63225440" class="para"><sup class="para">[15] </sup></a>A common application of two file descriptors is the
XFree86 <a class="link" href="media.html#xvideo" title="X Video Extension">Xv/V4L</a> interface driver and
a V4L2 application. While the X server controls video overlay, the
application can take advantage of memory mapping and DMA.</p><p>In the opinion of the designers of this API, no driver
writer taking the efforts to support simultaneous capturing and
overlay will restrict this ability by requiring a single file
descriptor, as in V4L and earlier versions of V4L2. Making this
optional means applications depending on two file descriptors need
backup routines to be compatible with all drivers, which is
considerable more work than using two fds in applications which do
not. Also two fd's fit the general concept of one file descriptor for
each logical stream. Hence as a complexity trade-off drivers
<span class="emphasis"><em>must</em></span> support two file descriptors and
<span class="emphasis"><em>may</em></span> support single fd operation.</p></div><div id="ftn.idp63663920" class="footnote"><p><a href="media.html#idp63663920" class="para"><sup class="para">[16] </sup></a>ASK: Amplitude-Shift Keying. A high signal
level represents a '1' bit, a low level a '0' bit.</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="driver"></a>Chapter 5. V4L2 Driver Programming</h2></div></div></div><p>to do</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="libv4l"></a>Chapter 6. Libv4l Userspace Library</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="media.html#libv4l-introduction">Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp73098096">libv4lconvert</a></span></dt><dt><span class="section"><a href="media.html#idp73133024">libv4l1</a></span></dt><dt><span class="section"><a href="media.html#idp73135024">libv4l2</a></span></dt><dt><span class="section"><a href="media.html#idp73163760">v4l1compat.so wrapper library</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="libv4l-introduction"></a>Introduction</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#idp73098096">libv4lconvert</a></span></dt><dt><span class="section"><a href="media.html#idp73133024">libv4l1</a></span></dt><dt><span class="section"><a href="media.html#idp73135024">libv4l2</a></span></dt><dt><span class="section"><a href="media.html#idp73163760">v4l1compat.so wrapper library</a></span></dt></dl></div><p>libv4l is a collection of libraries which adds a thin abstraction
layer on top of video4linux2 devices. The purpose of this (thin) layer
is to make it easy for application writers to support a wide variety of
devices without having to write separate code for different devices in the
same class.</p><p>An example of using libv4l is provided by
<a class="link" href="media.html#v4l2grab-example" title="Appendix E. Video Grabber example using libv4l">v4l2grab</a>.
</p><p>libv4l consists of 3 different libraries:</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73098096"></a>libv4lconvert</h3></div></div></div><p>libv4lconvert is a library that converts several
different pixelformats found in V4L2 drivers into a few common RGB and
YUY formats.</p><p>It currently accepts the following V4L2 driver formats:
<a class="link" href="media.html#V4L2-PIX-FMT-BGR24"><code class="constant">V4L2_PIX_FMT_BGR24</code></a>,
<a class="link" href="media.html#V4L2-PIX-FMT-HM12"><code class="constant">V4L2_PIX_FMT_HM12</code></a>,
<a class="link" href="media.html#V4L2-PIX-FMT-JPEG"><code class="constant">V4L2_PIX_FMT_JPEG</code></a>,
<a class="link" href="media.html#V4L2-PIX-FMT-MJPEG"><code class="constant">V4L2_PIX_FMT_MJPEG</code></a>,
<a class="link" href="media.html#V4L2-PIX-FMT-MR97310A"><code class="constant">V4L2_PIX_FMT_MR97310A</code></a>,
<a class="link" href="media.html#V4L2-PIX-FMT-OV511"><code class="constant">V4L2_PIX_FMT_OV511</code></a>,
<a class="link" href="media.html#V4L2-PIX-FMT-OV518"><code class="constant">V4L2_PIX_FMT_OV518</code></a>,
<a class="link" href="media.html#V4L2-PIX-FMT-PAC207"><code class="constant">V4L2_PIX_FMT_PAC207</code></a>,
<a class="link" href="media.html#V4L2-PIX-FMT-PJPG"><code class="constant">V4L2_PIX_FMT_PJPG</code></a>,
<a class="link" href="media.html#V4L2-PIX-FMT-RGB24"><code class="constant">V4L2_PIX_FMT_RGB24</code></a>,
<a class="link" href="media.html#V4L2-PIX-FMT-SBGGR8" title="V4L2_PIX_FMT_SBGGR8 ('BA81')"><code class="constant">V4L2_PIX_FMT_SBGGR8</code></a>,
<a class="link" href="media.html#V4L2-PIX-FMT-SGBRG8" title="V4L2_PIX_FMT_SGBRG8 ('GBRG')"><code class="constant">V4L2_PIX_FMT_SGBRG8</code></a>,
<a class="link" href="media.html#V4L2-PIX-FMT-SGRBG8" title="V4L2_PIX_FMT_SGRBG8 ('GRBG')"><code class="constant">V4L2_PIX_FMT_SGRBG8</code></a>,
<a class="link" href="media.html#V4L2-PIX-FMT-SN9C10X"><code class="constant">V4L2_PIX_FMT_SN9C10X</code></a>,
<a class="link" href="media.html#V4L2-PIX-FMT-SN9C20X-I420"><code class="constant">V4L2_PIX_FMT_SN9C20X_I420</code></a>,
<a class="link" href="media.html#V4L2-PIX-FMT-SPCA501"><code class="constant">V4L2_PIX_FMT_SPCA501</code></a>,
<a class="link" href="media.html#V4L2-PIX-FMT-SPCA505"><code class="constant">V4L2_PIX_FMT_SPCA505</code></a>,
<a class="link" href="media.html#V4L2-PIX-FMT-SPCA508"><code class="constant">V4L2_PIX_FMT_SPCA508</code></a>,
<a class="link" href="media.html#V4L2-PIX-FMT-SPCA561"><code class="constant">V4L2_PIX_FMT_SPCA561</code></a>,
<a class="link" href="media.html#V4L2-PIX-FMT-SQ905C"><code class="constant">V4L2_PIX_FMT_SQ905C</code></a>,
<code class="constant">V4L2_PIX_FMT_SRGGB8</code>,
<a class="link" href="media.html#V4L2-PIX-FMT-UYVY" title="V4L2_PIX_FMT_UYVY ('UYVY')"><code class="constant">V4L2_PIX_FMT_UYVY</code></a>,
<a class="link" href="media.html#V4L2-PIX-FMT-YUV420"><code class="constant">V4L2_PIX_FMT_YUV420</code></a>,
<a class="link" href="media.html#V4L2-PIX-FMT-YUYV" title="V4L2_PIX_FMT_YUYV ('YUYV')"><code class="constant">V4L2_PIX_FMT_YUYV</code></a>,
<a class="link" href="media.html#V4L2-PIX-FMT-YVU420"><code class="constant">V4L2_PIX_FMT_YVU420</code></a>,
and <a class="link" href="media.html#V4L2-PIX-FMT-YVYU" title="V4L2_PIX_FMT_YVYU ('YVYU')"><code class="constant">V4L2_PIX_FMT_YVYU</code></a>.
</p><p>Later on libv4lconvert was expanded to also be able to do
various	video processing functions to improve webcam video quality.
The video processing is split in to 2 parts: libv4lconvert/control and
libv4lconvert/processing.</p><p>The control part is used to offer video controls which can
be used	to control the video processing functions made available by
	libv4lconvert/processing. These controls are stored application wide
(until reboot) by using a persistent shared memory object.</p><p>libv4lconvert/processing offers the actual video
processing functionality.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73133024"></a>libv4l1</h3></div></div></div><p>This library offers functions that can be used to quickly
make v4l1 applications work with v4l2 devices. These functions work exactly
like the normal open/close/etc, except that libv4l1 does full emulation of
the v4l1 api on top of v4l2 drivers, in case of v4l1 drivers it
will just pass calls through.</p><p>Since those functions are emulations of the old V4L1 API,
it shouldn't be used for new applications.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73135024"></a>libv4l2</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#libv4l-ops">Libv4l device control functions</a></span></dt></dl></div><p>This library should be used for all modern V4L2
applications.</p><p>It provides handles to call V4L2 open/ioctl/close/poll
methods. Instead of just providing the raw output of the device, it enhances
the calls in the sense that it will use libv4lconvert to provide more video
formats and to enhance the image quality.</p><p>In most cases, libv4l2 just passes the calls directly
through to the v4l2 driver, intercepting the calls to
<a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_TRY_FMT</code></a>,
<a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_G_FMT</code></a>
<a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a>
<a class="link" href="media.html#vidioc-enum-framesizes" title="ioctl VIDIOC_ENUM_FRAMESIZES"><code class="constant">VIDIOC_ENUM_FRAMESIZES</code></a>
and <a class="link" href="media.html#vidioc-enum-frameintervals" title="ioctl VIDIOC_ENUM_FRAMEINTERVALS"><code class="constant">VIDIOC_ENUM_FRAMEINTERVALS</code></a>
in order to emulate the formats
<a class="link" href="media.html#V4L2-PIX-FMT-BGR24"><code class="constant">V4L2_PIX_FMT_BGR24</code></a>,
<a class="link" href="media.html#V4L2-PIX-FMT-RGB24"><code class="constant">V4L2_PIX_FMT_RGB24</code></a>,
<a class="link" href="media.html#V4L2-PIX-FMT-YUV420"><code class="constant">V4L2_PIX_FMT_YUV420</code></a>,
and <a class="link" href="media.html#V4L2-PIX-FMT-YVU420"><code class="constant">V4L2_PIX_FMT_YVU420</code></a>,
if they aren't available in the driver.
<a class="link" href="media.html#vidioc-enum-fmt" title="ioctl VIDIOC_ENUM_FMT"><code class="constant">VIDIOC_ENUM_FMT</code></a>
keeps enumerating the hardware supported formats, plus the emulated formats
offered by libv4l at the end.
</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="libv4l-ops"></a>Libv4l device control functions</h4></div></div></div><p>The common file operation methods are provided by
libv4l.</p><p>Those functions operate just like glibc
open/close/dup/ioctl/read/mmap/munmap:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>int v4l2_open(const char *file, int oflag,
...) -
operates like the standard <a class="link" href="media.html#func-open" title="V4L2 open()">open()</a> function.
</p></li><li class="listitem"><p>int v4l2_close(int fd) -
operates like the standard <a class="link" href="media.html#func-close" title="V4L2 close()">close()</a> function.
</p></li><li class="listitem"><p>int v4l2_dup(int fd) -
operates like the standard dup() function, duplicating a file handler.
</p></li><li class="listitem"><p>int v4l2_ioctl (int fd, unsigned long int request, ...) -
operates like the standard <a class="link" href="media.html#func-ioctl" title="V4L2 ioctl()">ioctl()</a> function.
</p></li><li class="listitem"><p>int v4l2_read (int fd, void* buffer, size_t n) -
operates like the standard <a class="link" href="media.html#func-read" title="V4L2 read()">read()</a> function.
</p></li><li class="listitem"><p>void v4l2_mmap(void *start, size_t length, int prot, int flags, int fd, int64_t offset); -
operates like the standard <a class="link" href="media.html#func-mmap" title="V4L2 mmap()">mmap()</a> function.
</p></li><li class="listitem"><p>int v4l2_munmap(void *_start, size_t length); -
operates like the standard <a class="link" href="media.html#func-munmap" title="V4L2 munmap()">munmap()</a> function.
</p></li></ul></div><p>Those functions provide additional control:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>int v4l2_fd_open(int fd, int v4l2_flags) -
opens an already opened fd for further use through v4l2lib and possibly
modify libv4l2's default behavior through the v4l2_flags argument.
Currently, v4l2_flags can be <code class="constant">V4L2_DISABLE_CONVERSION</code>,
to disable format conversion.
</p></li><li class="listitem"><p>int v4l2_set_control(int fd, int cid, int value) -
This function takes a value of 0 - 65535, and then scales that range to
the actual range of the given v4l control id, and then if the cid exists
and is not locked sets the cid to the scaled value.
</p></li><li class="listitem"><p>int v4l2_get_control(int fd, int cid) -
This function returns a value of 0 - 65535, scaled to from the actual range
of the given v4l control id. when the cid does not exist, could not be
accessed for some reason, or some error occurred 0 is returned.
</p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73163760"></a>v4l1compat.so wrapper library</h3></div></div></div><p>This library intercepts calls to
open/close/ioctl/mmap/mmunmap operations and redirects them to the libv4l
counterparts, by using LD_PRELOAD=/usr/lib/v4l1compat.so. It also
emulates V4L1 calls via V4L2 API.</p><p>It allows usage of binary legacy applications that
still don't use libv4l.</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="compat"></a>Chapter 7. Changes</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="media.html#diff-v4l">Differences between V4L and V4L2</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp73187792">Opening and Closing Devices</a></span></dt><dt><span class="section"><a href="media.html#idp73258032">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp73321456">Video Sources</a></span></dt><dt><span class="section"><a href="media.html#idp73346752">Tuning</a></span></dt><dt><span class="section"><a href="media.html#v4l-image-properties">Image Properties</a></span></dt><dt><span class="section"><a href="media.html#idp73438368">Audio</a></span></dt><dt><span class="section"><a href="media.html#idp73474704">Frame Buffer Overlay</a></span></dt><dt><span class="section"><a href="media.html#idp73505072">Cropping</a></span></dt><dt><span class="section"><a href="media.html#idp73520992">Reading Images, Memory Mapping</a></span></dt><dt><span class="section"><a href="media.html#idp73559232">Reading Raw VBI Data</a></span></dt><dt><span class="section"><a href="media.html#idp73583200">Miscellaneous</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#hist-v4l2">Changes of the V4L2 API</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp73589504">Early Versions</a></span></dt><dt><span class="section"><a href="media.html#idp73613424">V4L2 Version 0.16 1999-01-31</a></span></dt><dt><span class="section"><a href="media.html#idp73615264">V4L2 Version 0.18 1999-03-16</a></span></dt><dt><span class="section"><a href="media.html#idp73616672">V4L2 Version 0.19 1999-06-05</a></span></dt><dt><span class="section"><a href="media.html#idp73621104">V4L2 Version 0.20 (1999-09-10)</a></span></dt><dt><span class="section"><a href="media.html#idp73652672">V4L2 Version 0.20 incremental changes</a></span></dt><dt><span class="section"><a href="media.html#idp73680304">V4L2 Version 0.20 2000-11-23</a></span></dt><dt><span class="section"><a href="media.html#idp73695712">V4L2 Version 0.20 2002-07-25</a></span></dt><dt><span class="section"><a href="media.html#idp73696960">V4L2 in Linux 2.5.46, 2002-10</a></span></dt><dt><span class="section"><a href="media.html#idp73873264">V4L2 2003-06-19</a></span></dt><dt><span class="section"><a href="media.html#idp73897616">V4L2 2003-11-05</a></span></dt><dt><span class="section"><a href="media.html#idp73915888">V4L2 in Linux 2.6.6, 2004-05-09</a></span></dt><dt><span class="section"><a href="media.html#idp73919856">V4L2 in Linux 2.6.8</a></span></dt><dt><span class="section"><a href="media.html#idp73925088">V4L2 spec erratum 2004-08-01</a></span></dt><dt><span class="section"><a href="media.html#idp73934624">V4L2 in Linux 2.6.14</a></span></dt><dt><span class="section"><a href="media.html#idp73939664">V4L2 in Linux 2.6.15</a></span></dt><dt><span class="section"><a href="media.html#idp73952688">V4L2 spec erratum 2005-11-27</a></span></dt><dt><span class="section"><a href="media.html#idp73957168">V4L2 spec erratum 2006-01-10</a></span></dt><dt><span class="section"><a href="media.html#idp73962640">V4L2 spec erratum 2006-02-03</a></span></dt><dt><span class="section"><a href="media.html#idp73967104">V4L2 spec erratum 2006-02-04</a></span></dt><dt><span class="section"><a href="media.html#idp73972448">V4L2 in Linux 2.6.17</a></span></dt><dt><span class="section"><a href="media.html#idp73981536">V4L2 spec erratum 2006-09-23 (Draft 0.15)</a></span></dt><dt><span class="section"><a href="media.html#idp74000640">V4L2 in Linux 2.6.18</a></span></dt><dt><span class="section"><a href="media.html#idp74011472">V4L2 in Linux 2.6.19</a></span></dt><dt><span class="section"><a href="media.html#idp74020480">V4L2 spec erratum 2006-10-12 (Draft 0.17)</a></span></dt><dt><span class="section"><a href="media.html#idp74023952">V4L2 in Linux 2.6.21</a></span></dt><dt><span class="section"><a href="media.html#idp74030176">V4L2 in Linux 2.6.22</a></span></dt><dt><span class="section"><a href="media.html#idp74044000">V4L2 in Linux 2.6.24</a></span></dt><dt><span class="section"><a href="media.html#idp74048672">V4L2 in Linux 2.6.25</a></span></dt><dt><span class="section"><a href="media.html#idp74069136">V4L2 in Linux 2.6.26</a></span></dt><dt><span class="section"><a href="media.html#idp74074224">V4L2 in Linux 2.6.27</a></span></dt><dt><span class="section"><a href="media.html#idp74082240">V4L2 in Linux 2.6.28</a></span></dt><dt><span class="section"><a href="media.html#idp74088448">V4L2 in Linux 2.6.29</a></span></dt><dt><span class="section"><a href="media.html#idp74098320">V4L2 in Linux 2.6.30</a></span></dt><dt><span class="section"><a href="media.html#idp74102560">V4L2 in Linux 2.6.32</a></span></dt><dt><span class="section"><a href="media.html#idp74114320">V4L2 in Linux 2.6.33</a></span></dt><dt><span class="section"><a href="media.html#idp74116928">V4L2 in Linux 2.6.34</a></span></dt><dt><span class="section"><a href="media.html#idp74121184">V4L2 in Linux 2.6.37</a></span></dt><dt><span class="section"><a href="media.html#idp74123920">V4L2 in Linux 2.6.39</a></span></dt><dt><span class="section"><a href="media.html#idp74128224">V4L2 in Linux 3.1</a></span></dt><dt><span class="section"><a href="media.html#idp74131696">V4L2 in Linux 3.2</a></span></dt><dt><span class="section"><a href="media.html#idp74136112">V4L2 in Linux 3.3</a></span></dt><dt><span class="section"><a href="media.html#idp74140832">V4L2 in Linux 3.4</a></span></dt><dt><span class="section"><a href="media.html#idp74147504">V4L2 in Linux 3.5</a></span></dt><dt><span class="section"><a href="media.html#idp74165904">V4L2 in Linux 3.6</a></span></dt><dt><span class="section"><a href="media.html#idp74171856">V4L2 in Linux 3.9</a></span></dt><dt><span class="section"><a href="media.html#idp74179504">V4L2 in Linux 3.10</a></span></dt><dt><span class="section"><a href="media.html#idp74183200">V4L2 in Linux 3.11</a></span></dt><dt><span class="section"><a href="media.html#idp74187760">V4L2 in Linux 3.14</a></span></dt><dt><span class="section"><a href="media.html#idp74191600">V4L2 in Linux 3.15</a></span></dt><dt><span class="section"><a href="media.html#idp74194096">V4L2 in Linux 3.16</a></span></dt><dt><span class="section"><a href="media.html#idp74196656">V4L2 in Linux 3.17</a></span></dt><dt><span class="section"><a href="media.html#idp74201536">V4L2 in Linux 3.18</a></span></dt><dt><span class="section"><a href="media.html#idp74204960">V4L2 in Linux 3.19</a></span></dt><dt><span class="section"><a href="media.html#other">Relation of V4L2 to other Linux multimedia APIs</a></span></dt><dt><span class="section"><a href="media.html#experimental">Experimental API Elements</a></span></dt><dt><span class="section"><a href="media.html#obsolete">Obsolete API Elements</a></span></dt></dl></dd></dl></div><p>The following chapters document the evolution of the V4L2 API,
errata or extensions. They are also intended to help application and
driver writers to port or update their code.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="diff-v4l"></a>Differences between V4L and V4L2</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#idp73187792">Opening and Closing Devices</a></span></dt><dt><span class="section"><a href="media.html#idp73258032">Querying Capabilities</a></span></dt><dt><span class="section"><a href="media.html#idp73321456">Video Sources</a></span></dt><dt><span class="section"><a href="media.html#idp73346752">Tuning</a></span></dt><dt><span class="section"><a href="media.html#v4l-image-properties">Image Properties</a></span></dt><dt><span class="section"><a href="media.html#idp73438368">Audio</a></span></dt><dt><span class="section"><a href="media.html#idp73474704">Frame Buffer Overlay</a></span></dt><dt><span class="section"><a href="media.html#idp73505072">Cropping</a></span></dt><dt><span class="section"><a href="media.html#idp73520992">Reading Images, Memory Mapping</a></span></dt><dt><span class="section"><a href="media.html#idp73559232">Reading Raw VBI Data</a></span></dt><dt><span class="section"><a href="media.html#idp73583200">Miscellaneous</a></span></dt></dl></div><p>The Video For Linux API was first introduced in Linux 2.1 to
unify and replace various TV and radio device related interfaces,
developed independently by driver writers in prior years. Starting
with Linux 2.5 the much improved V4L2 API replaces the V4L API.
The support for the old V4L calls were removed from Kernel, but the
library <a class="xref" href="media.html#libv4l" title="Chapter 6. Libv4l Userspace Library">Chapter 6, <i>Libv4l Userspace Library</i></a> supports the conversion of a V4L
API system call into a V4L2 one.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73187792"></a>Opening and Closing Devices</h3></div></div></div><p>For compatibility reasons the character device file names
recommended for V4L2 video capture, overlay, radio and raw
vbi capture devices did not change from those used by V4L. They are
listed in <a class="xref" href="media.html#devices" title="Chapter 4. Interfaces">Chapter 4, <i>Interfaces</i></a> and below in <a class="xref" href="media.html#v4l-dev" title="Table 7.1. V4L Device Types, Names and Numbers">Table 7.1, &#8220;V4L Device Types, Names and Numbers&#8221;</a>.</p><p>The teletext devices (minor range 192-223) have been removed in
V4L2 and no longer exist. There is no hardware available anymore for handling
pure teletext. Instead raw or sliced VBI is used.</p><p>The V4L <code class="filename">videodev</code> module automatically
assigns minor numbers to drivers in load order, depending on the
registered device type. We recommend that V4L2 drivers by default
register devices with the same numbers, but the system administrator
can assign arbitrary minor numbers using driver module options. The
major device number remains 81.</p><div class="table"><a name="v4l-dev"></a><p class="title"><b>Table 7.1. V4L Device Types, Names and Numbers</b></p><div class="table-contents"><table summary="V4L Device Types, Names and Numbers" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Device Type</th><th>File Name</th><th>Minor Numbers</th></tr></thead><tbody valign="top"><tr><td valign="top">Video capture and overlay</td><td valign="top"><p><code class="filename">/dev/video</code> and
<code class="filename">/dev/bttv0</code><a href="media.html#ftn.idp73241728" class="footnote" name="idp73241728"><sup class="footnote">[a]</sup></a>,
<code class="filename">/dev/video0</code> to
<code class="filename">/dev/video63</code></p></td><td valign="top">0-63</td></tr><tr><td valign="top">Radio receiver</td><td valign="top"><p><code class="filename">/dev/radio</code><a href="media.html#ftn.idp73247152" class="footnote" name="idp73247152"><sup class="footnote">[b]</sup></a>, <code class="filename">/dev/radio0</code> to
<code class="filename">/dev/radio63</code></p></td><td valign="top">64-127</td></tr><tr><td valign="top">Raw VBI capture</td><td valign="top"><p><code class="filename">/dev/vbi</code>,
<code class="filename">/dev/vbi0</code> to
<code class="filename">/dev/vbi31</code></p></td><td valign="top">224-255</td></tr></tbody><tbody class="footnotes"><tr><td colspan="3"><div id="ftn.idp73241728" class="footnote"><p><a href="media.html#idp73241728" class="para"><sup class="para">[a] </sup></a>According to
Documentation/devices.txt these should be symbolic links to
<code class="filename">/dev/video0</code>. Note the original bttv interface is
not compatible with V4L or V4L2.</p></div><div id="ftn.idp73247152" class="footnote"><p><a href="media.html#idp73247152" class="para"><sup class="para">[b] </sup></a>According to
<code class="filename">Documentation/devices.txt</code> a symbolic link to
<code class="filename">/dev/radio0</code>.</p></div></td></tr></tbody></table></div></div><br class="table-break"><p>V4L prohibits (or used to prohibit) multiple opens of a
device file. V4L2 drivers <span class="emphasis"><em>may</em></span> support multiple
opens, see <a class="xref" href="media.html#open" title="Opening and Closing Devices">the section called &#8220;Opening and Closing Devices&#8221;</a> for details and consequences.</p><p>V4L drivers respond to V4L2 ioctls with an <span class="errorcode">EINVAL</span> error code.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73258032"></a>Querying Capabilities</h3></div></div></div><p>The V4L <code class="constant">VIDIOCGCAP</code> ioctl is
equivalent to V4L2's <a class="link" href="media.html#vidioc-querycap" title="ioctl VIDIOC_QUERYCAP"><code class="constant">VIDIOC_QUERYCAP</code></a>.</p><p>The <em class="structfield"><code>name</code></em> field in struct
<span class="structname">video_capability</span> became
<em class="structfield"><code>card</code></em> in struct <a class="link" href="media.html#v4l2-capability" title="Table A.92. struct v4l2_capability">v4l2_capability</a>,
<em class="structfield"><code>type</code></em> was replaced by
<em class="structfield"><code>capabilities</code></em>. Note V4L2 does not
distinguish between device types like this, better think of basic
video input, video output and radio devices supporting a set of
related functions like video capturing, video overlay and VBI
capturing. See <a class="xref" href="media.html#open" title="Opening and Closing Devices">the section called &#8220;Opening and Closing Devices&#8221;</a> for an
introduction.</p><div class="informaltable"><table border="1"><colgroup><col><col><col></colgroup><thead><tr><th>struct
<span class="structname">video_capability</span>
<em class="structfield"><code>type</code></em></th><th>struct <a class="link" href="media.html#v4l2-capability" title="Table A.92. struct v4l2_capability">v4l2_capability</a>
<em class="structfield"><code>capabilities</code></em> flags</th><th>Purpose</th></tr></thead><tbody valign="top"><tr><td valign="top"><code class="constant">VID_TYPE_CAPTURE</code></td><td valign="top"><code class="constant">V4L2_CAP_VIDEO_CAPTURE</code></td><td valign="top">The <a class="link" href="media.html#capture" title="Video Capture Interface">video
capture</a> interface is supported.</td></tr><tr><td valign="top"><code class="constant">VID_TYPE_TUNER</code></td><td valign="top"><code class="constant">V4L2_CAP_TUNER</code></td><td valign="top">The device has a <a class="link" href="media.html#tuner" title="Tuners and Modulators">tuner or
modulator</a>.</td></tr><tr><td valign="top"><code class="constant">VID_TYPE_TELETEXT</code></td><td valign="top"><code class="constant">V4L2_CAP_VBI_CAPTURE</code></td><td valign="top">The <a class="link" href="media.html#raw-vbi" title="Raw VBI Data Interface">raw VBI
capture</a> interface is supported.</td></tr><tr><td valign="top"><code class="constant">VID_TYPE_OVERLAY</code></td><td valign="top"><code class="constant">V4L2_CAP_VIDEO_OVERLAY</code></td><td valign="top">The <a class="link" href="media.html#overlay" title="Video Overlay Interface">video
overlay</a> interface is supported.</td></tr><tr><td valign="top"><code class="constant">VID_TYPE_CHROMAKEY</code></td><td valign="top"><code class="constant">V4L2_FBUF_CAP_CHROMAKEY</code> in
field <em class="structfield"><code>capability</code></em> of
struct <a class="link" href="media.html#v4l2-framebuffer" title="Table A.68. struct v4l2_framebuffer">v4l2_framebuffer</a></td><td valign="top">Whether chromakey overlay is supported. For
more information on overlay see
<a class="xref" href="media.html#overlay" title="Video Overlay Interface">the section called &#8220;Video Overlay Interface&#8221;</a>.</td></tr><tr><td valign="top"><code class="constant">VID_TYPE_CLIPPING</code></td><td valign="top"><code class="constant">V4L2_FBUF_CAP_LIST_CLIPPING</code>
and <code class="constant">V4L2_FBUF_CAP_BITMAP_CLIPPING</code> in field
<em class="structfield"><code>capability</code></em> of struct <a class="link" href="media.html#v4l2-framebuffer" title="Table A.68. struct v4l2_framebuffer">v4l2_framebuffer</a></td><td valign="top">Whether clipping the overlaid image is
supported, see <a class="xref" href="media.html#overlay" title="Video Overlay Interface">the section called &#8220;Video Overlay Interface&#8221;</a>.</td></tr><tr><td valign="top"><code class="constant">VID_TYPE_FRAMERAM</code></td><td valign="top"><code class="constant">V4L2_FBUF_CAP_EXTERNOVERLAY</code>
<span class="emphasis"><em>not set</em></span> in field
<em class="structfield"><code>capability</code></em> of struct <a class="link" href="media.html#v4l2-framebuffer" title="Table A.68. struct v4l2_framebuffer">v4l2_framebuffer</a></td><td valign="top">Whether overlay overwrites frame buffer memory,
see <a class="xref" href="media.html#overlay" title="Video Overlay Interface">the section called &#8220;Video Overlay Interface&#8221;</a>.</td></tr><tr><td valign="top"><code class="constant">VID_TYPE_SCALES</code></td><td valign="top"><code class="constant">-</code></td><td valign="top">This flag indicates if the hardware can scale
images. The V4L2 API implies the scale factor by setting the cropping
dimensions and image size with the <a class="link" href="media.html#vidioc-g-crop" title="ioctl VIDIOC_G_CROP, VIDIOC_S_CROP"><code class="constant">VIDIOC_S_CROP</code></a> and <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a>
ioctl, respectively. The driver returns the closest sizes possible.
For more information on cropping and scaling see <a class="xref" href="media.html#crop" title="Image Cropping, Insertion and Scaling">the section called &#8220;Image Cropping, Insertion and Scaling&#8221;</a>.</td></tr><tr><td valign="top"><code class="constant">VID_TYPE_MONOCHROME</code></td><td valign="top"><code class="constant">-</code></td><td valign="top">Applications can enumerate the supported image
formats with the <a class="link" href="media.html#vidioc-enum-fmt" title="ioctl VIDIOC_ENUM_FMT"><code class="constant">VIDIOC_ENUM_FMT</code></a> ioctl to determine if the device
supports grey scale capturing only. For more information on image
formats see <a class="xref" href="media.html#pixfmt" title="Chapter 2. Image Formats">Chapter 2, <i>Image Formats</i></a>.</td></tr><tr><td valign="top"><code class="constant">VID_TYPE_SUBCAPTURE</code></td><td valign="top"><code class="constant">-</code></td><td valign="top">Applications can call the <a class="link" href="media.html#vidioc-g-crop" title="ioctl VIDIOC_G_CROP, VIDIOC_S_CROP"><code class="constant">VIDIOC_G_CROP</code></a> ioctl
to determine if the device supports capturing a subsection of the full
picture ("cropping" in V4L2). If not, the ioctl returns the <span class="errorcode">EINVAL</span> error code.
For more information on cropping and scaling see <a class="xref" href="media.html#crop" title="Image Cropping, Insertion and Scaling">the section called &#8220;Image Cropping, Insertion and Scaling&#8221;</a>.</td></tr><tr><td valign="top"><code class="constant">VID_TYPE_MPEG_DECODER</code></td><td valign="top"><code class="constant">-</code></td><td valign="top">Applications can enumerate the supported image
formats with the <a class="link" href="media.html#vidioc-enum-fmt" title="ioctl VIDIOC_ENUM_FMT"><code class="constant">VIDIOC_ENUM_FMT</code></a> ioctl to determine if the device
supports MPEG streams.</td></tr><tr><td valign="top"><code class="constant">VID_TYPE_MPEG_ENCODER</code></td><td valign="top"><code class="constant">-</code></td><td valign="top">See above.</td></tr><tr><td valign="top"><code class="constant">VID_TYPE_MJPEG_DECODER</code></td><td valign="top"><code class="constant">-</code></td><td valign="top">See above.</td></tr><tr><td valign="top"><code class="constant">VID_TYPE_MJPEG_ENCODER</code></td><td valign="top"><code class="constant">-</code></td><td valign="top">See above.</td></tr></tbody></table></div><p>The <em class="structfield"><code>audios</code></em> field was replaced
by <em class="structfield"><code>capabilities</code></em> flag
<code class="constant">V4L2_CAP_AUDIO</code>, indicating
<span class="emphasis"><em>if</em></span> the device has any audio inputs or outputs. To
determine their number applications can enumerate audio inputs with
the <a class="link" href="media.html#vidioc-g-audio" title="ioctl VIDIOC_G_AUDIO, VIDIOC_S_AUDIO"><code class="constant">VIDIOC_G_AUDIO</code></a> ioctl. The audio ioctls are described in <a class="xref" href="media.html#audio" title="Audio Inputs and Outputs">the section called &#8220;Audio Inputs and Outputs&#8221;</a>.</p><p>The <em class="structfield"><code>maxwidth</code></em>,
<em class="structfield"><code>maxheight</code></em>,
<em class="structfield"><code>minwidth</code></em> and
<em class="structfield"><code>minheight</code></em> fields were removed. Calling the
<a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> or <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_TRY_FMT</code></a> ioctl with the desired dimensions
returns the closest size possible, taking into account the current
video standard, cropping and scaling limitations.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73321456"></a>Video Sources</h3></div></div></div><p>V4L provides the <code class="constant">VIDIOCGCHAN</code> and
<code class="constant">VIDIOCSCHAN</code> ioctl using struct
<span class="structname">video_channel</span> to enumerate
the video inputs of a V4L device. The equivalent V4L2 ioctls
are <a class="link" href="media.html#vidioc-enuminput" title="ioctl VIDIOC_ENUMINPUT"><code class="constant">VIDIOC_ENUMINPUT</code></a>, <a class="link" href="media.html#vidioc-g-input" title="ioctl VIDIOC_G_INPUT, VIDIOC_S_INPUT"><code class="constant">VIDIOC_G_INPUT</code></a> and <a class="link" href="media.html#vidioc-g-input" title="ioctl VIDIOC_G_INPUT, VIDIOC_S_INPUT"><code class="constant">VIDIOC_S_INPUT</code></a>
using struct <a class="link" href="media.html#v4l2-input" title="Table A.38. struct v4l2_input">v4l2_input</a> as discussed in <a class="xref" href="media.html#video" title="Video Inputs and Outputs">the section called &#8220;Video Inputs and Outputs&#8221;</a>.</p><p>The <em class="structfield"><code>channel</code></em> field counting
inputs was renamed to <em class="structfield"><code>index</code></em>, the video
input types were renamed as follows: </p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>struct <span class="structname">video_channel</span>
<em class="structfield"><code>type</code></em></th><th>struct <a class="link" href="media.html#v4l2-input" title="Table A.38. struct v4l2_input">v4l2_input</a>
<em class="structfield"><code>type</code></em></th></tr></thead><tbody valign="top"><tr><td valign="top"><code class="constant">VIDEO_TYPE_TV</code></td><td valign="top"><code class="constant">V4L2_INPUT_TYPE_TUNER</code></td></tr><tr><td valign="top"><code class="constant">VIDEO_TYPE_CAMERA</code></td><td valign="top"><code class="constant">V4L2_INPUT_TYPE_CAMERA</code></td></tr></tbody></table></div><p>Unlike the <em class="structfield"><code>tuners</code></em> field
expressing the number of tuners of this input, V4L2 assumes each video
input is connected to at most one tuner. However a tuner can have more
than one input, i. e. RF connectors, and a device can have multiple
tuners. The index number of the tuner associated with the input, if
any, is stored in field <em class="structfield"><code>tuner</code></em> of
struct <a class="link" href="media.html#v4l2-input" title="Table A.38. struct v4l2_input">v4l2_input</a>. Enumeration of tuners is discussed in <a class="xref" href="media.html#tuner" title="Tuners and Modulators">the section called &#8220;Tuners and Modulators&#8221;</a>.</p><p>The redundant <code class="constant">VIDEO_VC_TUNER</code> flag was
dropped. Video inputs associated with a tuner are of type
<code class="constant">V4L2_INPUT_TYPE_TUNER</code>. The
<code class="constant">VIDEO_VC_AUDIO</code> flag was replaced by the
<em class="structfield"><code>audioset</code></em> field. V4L2 considers devices with
up to 32 audio inputs. Each set bit in the
<em class="structfield"><code>audioset</code></em> field represents one audio input
this video input combines with. For information about audio inputs and
how to switch between them see <a class="xref" href="media.html#audio" title="Audio Inputs and Outputs">the section called &#8220;Audio Inputs and Outputs&#8221;</a>.</p><p>The <em class="structfield"><code>norm</code></em> field describing the
supported video standards was replaced by
<em class="structfield"><code>std</code></em>. The V4L specification mentions a flag
<code class="constant">VIDEO_VC_NORM</code> indicating whether the standard can
be changed. This flag was a later addition together with the
<em class="structfield"><code>norm</code></em> field and has been removed in the
meantime. V4L2 has a similar, albeit more comprehensive approach
to video standards, see <a class="xref" href="media.html#standard" title="Video Standards">the section called &#8220;Video Standards&#8221;</a> for more
information.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73346752"></a>Tuning</h3></div></div></div><p>The V4L <code class="constant">VIDIOCGTUNER</code> and
<code class="constant">VIDIOCSTUNER</code> ioctl and struct
<span class="structname">video_tuner</span> can be used to enumerate the
tuners of a V4L TV or radio device. The equivalent V4L2 ioctls are
<a class="link" href="media.html#vidioc-g-tuner" title="ioctl VIDIOC_G_TUNER, VIDIOC_S_TUNER"><code class="constant">VIDIOC_G_TUNER</code></a> and <a class="link" href="media.html#vidioc-g-tuner" title="ioctl VIDIOC_G_TUNER, VIDIOC_S_TUNER"><code class="constant">VIDIOC_S_TUNER</code></a> using struct <a class="link" href="media.html#v4l2-tuner" title="Table A.86. struct v4l2_tuner">v4l2_tuner</a>. Tuners are
covered in <a class="xref" href="media.html#tuner" title="Tuners and Modulators">the section called &#8220;Tuners and Modulators&#8221;</a>.</p><p>The <em class="structfield"><code>tuner</code></em> field counting tuners
was renamed to <em class="structfield"><code>index</code></em>. The fields
<em class="structfield"><code>name</code></em>, <em class="structfield"><code>rangelow</code></em>
and <em class="structfield"><code>rangehigh</code></em> remained unchanged.</p><p>The <code class="constant">VIDEO_TUNER_PAL</code>,
<code class="constant">VIDEO_TUNER_NTSC</code> and
<code class="constant">VIDEO_TUNER_SECAM</code> flags indicating the supported
video standards were dropped. This information is now contained in the
associated struct <a class="link" href="media.html#v4l2-input" title="Table A.38. struct v4l2_input">v4l2_input</a>. No replacement exists for the
<code class="constant">VIDEO_TUNER_NORM</code> flag indicating whether the
video standard can be switched. The <em class="structfield"><code>mode</code></em>
field to select a different video standard was replaced by a whole new
set of ioctls and structures described in <a class="xref" href="media.html#standard" title="Video Standards">the section called &#8220;Video Standards&#8221;</a>.
Due to its ubiquity it should be mentioned the BTTV driver supports
several standards in addition to the regular
<code class="constant">VIDEO_MODE_PAL</code> (0),
<code class="constant">VIDEO_MODE_NTSC</code>,
<code class="constant">VIDEO_MODE_SECAM</code> and
<code class="constant">VIDEO_MODE_AUTO</code> (3). Namely N/PAL Argentina,
M/PAL, N/PAL, and NTSC Japan with numbers 3-6 (sic).</p><p>The <code class="constant">VIDEO_TUNER_STEREO_ON</code> flag
indicating stereo reception became
<code class="constant">V4L2_TUNER_SUB_STEREO</code> in field
<em class="structfield"><code>rxsubchans</code></em>. This field also permits the
detection of monaural and bilingual audio, see the definition of
struct <a class="link" href="media.html#v4l2-tuner" title="Table A.86. struct v4l2_tuner">v4l2_tuner</a> for details. Presently no replacement exists for the
<code class="constant">VIDEO_TUNER_RDS_ON</code> and
<code class="constant">VIDEO_TUNER_MBS_ON</code> flags.</p><p> The <code class="constant">VIDEO_TUNER_LOW</code> flag was renamed
to <code class="constant">V4L2_TUNER_CAP_LOW</code> in the struct <a class="link" href="media.html#v4l2-tuner" title="Table A.86. struct v4l2_tuner">v4l2_tuner</a>
<em class="structfield"><code>capability</code></em> field.</p><p>The <code class="constant">VIDIOCGFREQ</code> and
<code class="constant">VIDIOCSFREQ</code> ioctl to change the tuner frequency
where renamed to <a class="link" href="media.html#vidioc-g-frequency" title="ioctl VIDIOC_G_FREQUENCY, VIDIOC_S_FREQUENCY"><code class="constant">VIDIOC_G_FREQUENCY</code></a> and  <a class="link" href="media.html#vidioc-g-frequency" title="ioctl VIDIOC_G_FREQUENCY, VIDIOC_S_FREQUENCY"><code class="constant">VIDIOC_S_FREQUENCY</code></a>. They
take a pointer to a struct <a class="link" href="media.html#v4l2-frequency" title="Table A.72. struct v4l2_frequency">v4l2_frequency</a> instead of an unsigned long
integer.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="v4l-image-properties"></a>Image Properties</h3></div></div></div><p>V4L2 has no equivalent of the
<code class="constant">VIDIOCGPICT</code> and <code class="constant">VIDIOCSPICT</code>
ioctl and struct <span class="structname">video_picture</span>. The following
fields where replaced by V4L2 controls accessible with the
<a class="link" href="media.html#vidioc-queryctrl" title="ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU"><code class="constant">VIDIOC_QUERYCTRL</code></a>, <a class="link" href="media.html#vidioc-g-ctrl" title="ioctl VIDIOC_G_CTRL, VIDIOC_S_CTRL"><code class="constant">VIDIOC_G_CTRL</code></a> and <a class="link" href="media.html#vidioc-g-ctrl" title="ioctl VIDIOC_G_CTRL, VIDIOC_S_CTRL"><code class="constant">VIDIOC_S_CTRL</code></a> ioctls:</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>struct <span class="structname">video_picture</span></th><th>V4L2 Control ID</th></tr></thead><tbody valign="top"><tr><td valign="top"><em class="structfield"><code>brightness</code></em></td><td valign="top"><code class="constant">V4L2_CID_BRIGHTNESS</code></td></tr><tr><td valign="top"><em class="structfield"><code>hue</code></em></td><td valign="top"><code class="constant">V4L2_CID_HUE</code></td></tr><tr><td valign="top"><em class="structfield"><code>colour</code></em></td><td valign="top"><code class="constant">V4L2_CID_SATURATION</code></td></tr><tr><td valign="top"><em class="structfield"><code>contrast</code></em></td><td valign="top"><code class="constant">V4L2_CID_CONTRAST</code></td></tr><tr><td valign="top"><em class="structfield"><code>whiteness</code></em></td><td valign="top"><code class="constant">V4L2_CID_WHITENESS</code></td></tr></tbody></table></div><p>The V4L picture controls are assumed to range from 0 to
65535 with no particular reset value. The V4L2 API permits arbitrary
limits and defaults which can be queried with the <a class="link" href="media.html#vidioc-queryctrl" title="ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU"><code class="constant">VIDIOC_QUERYCTRL</code></a>
ioctl. For general information about controls see <a class="xref" href="media.html#control" title="User Controls">the section called &#8220;User Controls&#8221;</a>.</p><p>The <em class="structfield"><code>depth</code></em> (average number of
bits per pixel) of a video image is implied by the selected image
format. V4L2 does not explicitly provide such information assuming
applications recognizing the format are aware of the image depth and
others need not know. The <em class="structfield"><code>palette</code></em> field
moved into the struct <a class="link" href="media.html#v4l2-pix-format" title="Table 2.1. struct v4l2_pix_format">v4l2_pix_format</a>:</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>struct <span class="structname">video_picture</span>
<em class="structfield"><code>palette</code></em></th><th>struct <a class="link" href="media.html#v4l2-pix-format" title="Table 2.1. struct v4l2_pix_format">v4l2_pix_format</a>
<em class="structfield"><code>pixfmt</code></em></th></tr></thead><tbody valign="top"><tr><td valign="top"><code class="constant">VIDEO_PALETTE_GREY</code></td><td valign="top"><p><a class="link" href="media.html#V4L2-PIX-FMT-GREY" title="V4L2_PIX_FMT_GREY ('GREY')"><code class="constant">V4L2_PIX_FMT_GREY</code></a></p></td></tr><tr><td valign="top"><code class="constant">VIDEO_PALETTE_HI240</code></td><td valign="top"><p><a class="link" href="media.html#pixfmt-reserved" title="Reserved Format Identifiers"><code class="constant">V4L2_PIX_FMT_HI240</code></a><a href="media.html#ftn.idp73400288" class="footnote" name="idp73400288"><sup class="footnote">[a]</sup></a></p></td></tr><tr><td valign="top"><code class="constant">VIDEO_PALETTE_RGB565</code></td><td valign="top"><p><a class="link" href="media.html#pixfmt-rgb" title="RGB Formats"><code class="constant">V4L2_PIX_FMT_RGB565</code></a></p></td></tr><tr><td valign="top"><code class="constant">VIDEO_PALETTE_RGB555</code></td><td valign="top"><p><a class="link" href="media.html#pixfmt-rgb" title="RGB Formats"><code class="constant">V4L2_PIX_FMT_RGB555</code></a></p></td></tr><tr><td valign="top"><code class="constant">VIDEO_PALETTE_RGB24</code></td><td valign="top"><p><a class="link" href="media.html#pixfmt-rgb" title="RGB Formats"><code class="constant">V4L2_PIX_FMT_BGR24</code></a></p></td></tr><tr><td valign="top"><code class="constant">VIDEO_PALETTE_RGB32</code></td><td valign="top"><p><a class="link" href="media.html#pixfmt-rgb" title="RGB Formats"><code class="constant">V4L2_PIX_FMT_BGR32</code></a><a href="media.html#ftn.idp73409536" class="footnote" name="idp73409536"><sup class="footnote">[b]</sup></a></p></td></tr><tr><td valign="top"><code class="constant">VIDEO_PALETTE_YUV422</code></td><td valign="top"><p><a class="link" href="media.html#V4L2-PIX-FMT-YUYV" title="V4L2_PIX_FMT_YUYV ('YUYV')"><code class="constant">V4L2_PIX_FMT_YUYV</code></a></p></td></tr><tr><td valign="top"><p><code class="constant">VIDEO_PALETTE_YUYV</code><a href="media.html#ftn.idp73414208" class="footnote" name="idp73414208"><sup class="footnote">[c]</sup></a></p></td><td valign="top"><p><a class="link" href="media.html#V4L2-PIX-FMT-YUYV" title="V4L2_PIX_FMT_YUYV ('YUYV')"><code class="constant">V4L2_PIX_FMT_YUYV</code></a></p></td></tr><tr><td valign="top"><code class="constant">VIDEO_PALETTE_UYVY</code></td><td valign="top"><p><a class="link" href="media.html#V4L2-PIX-FMT-UYVY" title="V4L2_PIX_FMT_UYVY ('UYVY')"><code class="constant">V4L2_PIX_FMT_UYVY</code></a></p></td></tr><tr><td valign="top"><code class="constant">VIDEO_PALETTE_YUV420</code></td><td valign="top">None</td></tr><tr><td valign="top"><code class="constant">VIDEO_PALETTE_YUV411</code></td><td valign="top"><p><a class="link" href="media.html#V4L2-PIX-FMT-Y41P" title="V4L2_PIX_FMT_Y41P ('Y41P')"><code class="constant">V4L2_PIX_FMT_Y41P</code></a><a href="media.html#ftn.idp73422496" class="footnote" name="idp73422496"><sup class="footnote">[d]</sup></a></p></td></tr><tr><td valign="top"><code class="constant">VIDEO_PALETTE_RAW</code></td><td valign="top"><p>None<a href="media.html#ftn.idp73425120" class="footnote" name="idp73425120"><sup class="footnote">[e]</sup></a></p></td></tr><tr><td valign="top"><code class="constant">VIDEO_PALETTE_YUV422P</code></td><td valign="top"><p><a class="link" href="media.html#V4L2-PIX-FMT-YUV422P" title="V4L2_PIX_FMT_YUV422P ('422P')"><code class="constant">V4L2_PIX_FMT_YUV422P</code></a></p></td></tr><tr><td valign="top"><code class="constant">VIDEO_PALETTE_YUV411P</code></td><td valign="top"><p><a class="link" href="media.html#V4L2-PIX-FMT-YUV411P" title="V4L2_PIX_FMT_YUV411P ('411P')"><code class="constant">V4L2_PIX_FMT_YUV411P</code></a><a href="media.html#ftn.idp73430112" class="footnote" name="idp73430112"><sup class="footnote">[f]</sup></a></p></td></tr><tr><td valign="top"><code class="constant">VIDEO_PALETTE_YUV420P</code></td><td valign="top"><p><a class="link" href="media.html#V4L2-PIX-FMT-YVU420"><code class="constant">V4L2_PIX_FMT_YVU420</code></a></p></td></tr><tr><td valign="top"><code class="constant">VIDEO_PALETTE_YUV410P</code></td><td valign="top"><p><a class="link" href="media.html#V4L2-PIX-FMT-YVU410"><code class="constant">V4L2_PIX_FMT_YVU410</code></a></p></td></tr></tbody><tbody class="footnotes"><tr><td colspan="2"><div id="ftn.idp73400288" class="footnote"><p><a href="media.html#idp73400288" class="para"><sup class="para">[a] </sup></a>This is a custom format used by the BTTV
driver, not one of the V4L2 standard formats.</p></div><div id="ftn.idp73409536" class="footnote"><p><a href="media.html#idp73409536" class="para"><sup class="para">[b] </sup></a>Presumably all V4L RGB formats are
little-endian, although some drivers might interpret them according to machine endianness. V4L2 defines little-endian, big-endian and red/blue
swapped variants. For details see <a class="xref" href="media.html#pixfmt-rgb" title="RGB Formats">the section called &#8220;RGB Formats&#8221;</a>.</p></div><div id="ftn.idp73414208" class="footnote"><p><a href="media.html#idp73414208" class="para"><sup class="para">[c] </sup></a><code class="constant">VIDEO_PALETTE_YUV422</code>
and <code class="constant">VIDEO_PALETTE_YUYV</code> are the same formats. Some
V4L drivers respond to one, some to the other.</p></div><div id="ftn.idp73422496" class="footnote"><p><a href="media.html#idp73422496" class="para"><sup class="para">[d] </sup></a>Not to be confused with
<code class="constant">V4L2_PIX_FMT_YUV411P</code>, which is a planar
format.</p></div><div id="ftn.idp73425120" class="footnote"><p><a href="media.html#idp73425120" class="para"><sup class="para">[e] </sup></a>V4L explains this
as: "RAW capture (BT848)"</p></div><div id="ftn.idp73430112" class="footnote"><p><a href="media.html#idp73430112" class="para"><sup class="para">[f] </sup></a>Not to be confused with
<code class="constant">V4L2_PIX_FMT_Y41P</code>, which is a packed
format.</p></div></td></tr></tbody></table></div><p>V4L2 image formats are defined in <a class="xref" href="media.html#pixfmt" title="Chapter 2. Image Formats">Chapter 2, <i>Image Formats</i></a>. The image format can be selected with the
<a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> ioctl.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73438368"></a>Audio</h3></div></div></div><p>The <code class="constant">VIDIOCGAUDIO</code> and
<code class="constant">VIDIOCSAUDIO</code> ioctl and struct
<span class="structname">video_audio</span> are used to enumerate the
audio inputs of a V4L device. The equivalent V4L2 ioctls are
<a class="link" href="media.html#vidioc-g-audio" title="ioctl VIDIOC_G_AUDIO, VIDIOC_S_AUDIO"><code class="constant">VIDIOC_G_AUDIO</code></a> and <a class="link" href="media.html#vidioc-g-audio" title="ioctl VIDIOC_G_AUDIO, VIDIOC_S_AUDIO"><code class="constant">VIDIOC_S_AUDIO</code></a> using struct <a class="link" href="media.html#v4l2-audio" title="Table A.50. struct v4l2_audio">v4l2_audio</a> as
discussed in <a class="xref" href="media.html#audio" title="Audio Inputs and Outputs">the section called &#8220;Audio Inputs and Outputs&#8221;</a>.</p><p>The <em class="structfield"><code>audio</code></em> "channel number"
field counting audio inputs was renamed to
<em class="structfield"><code>index</code></em>.</p><p>On <code class="constant">VIDIOCSAUDIO</code> the
<em class="structfield"><code>mode</code></em> field selects <span class="emphasis"><em>one</em></span>
of the <code class="constant">VIDEO_SOUND_MONO</code>,
<code class="constant">VIDEO_SOUND_STEREO</code>,
<code class="constant">VIDEO_SOUND_LANG1</code> or
<code class="constant">VIDEO_SOUND_LANG2</code> audio demodulation modes. When
the current audio standard is BTSC
<code class="constant">VIDEO_SOUND_LANG2</code> refers to SAP and
<code class="constant">VIDEO_SOUND_LANG1</code> is meaningless. Also
undocumented in the V4L specification, there is no way to query the
selected mode. On <code class="constant">VIDIOCGAUDIO</code> the driver returns
the <span class="emphasis"><em>actually received</em></span> audio programmes in this
field. In the V4L2 API this information is stored in the struct <a class="link" href="media.html#v4l2-tuner" title="Table A.86. struct v4l2_tuner">v4l2_tuner</a>
<em class="structfield"><code>rxsubchans</code></em> and
<em class="structfield"><code>audmode</code></em> fields, respectively. See <a class="xref" href="media.html#tuner" title="Tuners and Modulators">the section called &#8220;Tuners and Modulators&#8221;</a> for more information on tuners. Related to audio
modes struct <a class="link" href="media.html#v4l2-audio" title="Table A.50. struct v4l2_audio">v4l2_audio</a> also reports if this is a mono or stereo
input, regardless if the source is a tuner.</p><p>The following fields where replaced by V4L2 controls
accessible with the <a class="link" href="media.html#vidioc-queryctrl" title="ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU"><code class="constant">VIDIOC_QUERYCTRL</code></a>, <a class="link" href="media.html#vidioc-g-ctrl" title="ioctl VIDIOC_G_CTRL, VIDIOC_S_CTRL"><code class="constant">VIDIOC_G_CTRL</code></a> and
<a class="link" href="media.html#vidioc-g-ctrl" title="ioctl VIDIOC_G_CTRL, VIDIOC_S_CTRL"><code class="constant">VIDIOC_S_CTRL</code></a> ioctls:</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>struct
<span class="structname">video_audio</span></th><th>V4L2 Control ID</th></tr></thead><tbody valign="top"><tr><td valign="top"><em class="structfield"><code>volume</code></em></td><td valign="top"><code class="constant">V4L2_CID_AUDIO_VOLUME</code></td></tr><tr><td valign="top"><em class="structfield"><code>bass</code></em></td><td valign="top"><code class="constant">V4L2_CID_AUDIO_BASS</code></td></tr><tr><td valign="top"><em class="structfield"><code>treble</code></em></td><td valign="top"><code class="constant">V4L2_CID_AUDIO_TREBLE</code></td></tr><tr><td valign="top"><em class="structfield"><code>balance</code></em></td><td valign="top"><code class="constant">V4L2_CID_AUDIO_BALANCE</code></td></tr></tbody></table></div><p>To determine which of these controls are supported by a
driver V4L provides the <em class="structfield"><code>flags</code></em>
<code class="constant">VIDEO_AUDIO_VOLUME</code>,
<code class="constant">VIDEO_AUDIO_BASS</code>,
<code class="constant">VIDEO_AUDIO_TREBLE</code> and
<code class="constant">VIDEO_AUDIO_BALANCE</code>. In the V4L2 API the
<a class="link" href="media.html#vidioc-queryctrl" title="ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU"><code class="constant">VIDIOC_QUERYCTRL</code></a> ioctl reports if the respective control is
supported. Accordingly the <code class="constant">VIDEO_AUDIO_MUTABLE</code>
and <code class="constant">VIDEO_AUDIO_MUTE</code> flags where replaced by the
boolean <code class="constant">V4L2_CID_AUDIO_MUTE</code> control.</p><p>All V4L2 controls have a <em class="structfield"><code>step</code></em>
attribute replacing the struct <span class="structname">video_audio</span>
<em class="structfield"><code>step</code></em> field. The V4L audio controls are
assumed to range from 0 to 65535 with no particular reset value. The
V4L2 API permits arbitrary limits and defaults which can be queried
with the <a class="link" href="media.html#vidioc-queryctrl" title="ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU"><code class="constant">VIDIOC_QUERYCTRL</code></a> ioctl. For general information about
controls see <a class="xref" href="media.html#control" title="User Controls">the section called &#8220;User Controls&#8221;</a>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73474704"></a>Frame Buffer Overlay</h3></div></div></div><p>The V4L2 ioctls equivalent to
<code class="constant">VIDIOCGFBUF</code> and <code class="constant">VIDIOCSFBUF</code>
are <a class="link" href="media.html#vidioc-g-fbuf" title="ioctl VIDIOC_G_FBUF, VIDIOC_S_FBUF"><code class="constant">VIDIOC_G_FBUF</code></a> and <a class="link" href="media.html#vidioc-g-fbuf" title="ioctl VIDIOC_G_FBUF, VIDIOC_S_FBUF"><code class="constant">VIDIOC_S_FBUF</code></a>. The
<em class="structfield"><code>base</code></em> field of struct
<span class="structname">video_buffer</span> remained unchanged, except V4L2
defines a flag to indicate non-destructive overlays instead of a
<code class="constant">NULL</code> pointer. All other fields moved into the
struct <a class="link" href="media.html#v4l2-pix-format" title="Table 2.1. struct v4l2_pix_format">v4l2_pix_format</a> <em class="structfield"><code>fmt</code></em> substructure of
struct <a class="link" href="media.html#v4l2-framebuffer" title="Table A.68. struct v4l2_framebuffer">v4l2_framebuffer</a>. The <em class="structfield"><code>depth</code></em> field was
replaced by <em class="structfield"><code>pixelformat</code></em>. See <a class="xref" href="media.html#pixfmt-rgb" title="RGB Formats">the section called &#8220;RGB Formats&#8221;</a> for a list of RGB formats and their
respective color depths.</p><p>Instead of the special ioctls
<code class="constant">VIDIOCGWIN</code> and <code class="constant">VIDIOCSWIN</code>
V4L2 uses the general-purpose data format negotiation ioctls
<a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_G_FMT</code></a> and <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a>. They take a pointer to a
struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a> as argument. Here the <em class="structfield"><code>win</code></em>
member of the <em class="structfield"><code>fmt</code></em> union is used, a
struct <a class="link" href="media.html#v4l2-window" title="Table 4.1. struct v4l2_window">v4l2_window</a>.</p><p>The <em class="structfield"><code>x</code></em>,
<em class="structfield"><code>y</code></em>, <em class="structfield"><code>width</code></em> and
<em class="structfield"><code>height</code></em> fields of struct
<span class="structname">video_window</span> moved into struct <a class="link" href="media.html#v4l2-rect" title="Table 4.3. struct v4l2_rect">v4l2_rect</a>
substructure <em class="structfield"><code>w</code></em> of struct
<span class="structname">v4l2_window</span>. The
<em class="structfield"><code>chromakey</code></em>,
<em class="structfield"><code>clips</code></em>, and
<em class="structfield"><code>clipcount</code></em> fields remained unchanged. Struct
<span class="structname">video_clip</span> was renamed to struct <a class="link" href="media.html#v4l2-clip" title="Table 4.2. struct v4l2_clip">v4l2_clip</a>, also
containing a struct <span class="structname">v4l2_rect</span>, but the
semantics are still the same.</p><p>The <code class="constant">VIDEO_WINDOW_INTERLACE</code> flag was
dropped. Instead applications must set the
<em class="structfield"><code>field</code></em> field to
<code class="constant">V4L2_FIELD_ANY</code> or
<code class="constant">V4L2_FIELD_INTERLACED</code>. The
<code class="constant">VIDEO_WINDOW_CHROMAKEY</code> flag moved into
struct <a class="link" href="media.html#v4l2-framebuffer" title="Table A.68. struct v4l2_framebuffer">v4l2_framebuffer</a>, under the new name
<code class="constant">V4L2_FBUF_FLAG_CHROMAKEY</code>.</p><p>In V4L, storing a bitmap pointer in
<em class="structfield"><code>clips</code></em> and setting
<em class="structfield"><code>clipcount</code></em> to
<code class="constant">VIDEO_CLIP_BITMAP</code> (-1) requests bitmap
clipping, using a fixed size bitmap of 1024 × 625 bits. Struct
<span class="structname">v4l2_window</span> has a separate
<em class="structfield"><code>bitmap</code></em> pointer field for this purpose and
the bitmap size is determined by <em class="structfield"><code>w.width</code></em> and
<em class="structfield"><code>w.height</code></em>.</p><p>The <code class="constant">VIDIOCCAPTURE</code> ioctl to enable or
disable overlay was renamed to <a class="link" href="media.html#vidioc-overlay" title="ioctl VIDIOC_OVERLAY"><code class="constant">VIDIOC_OVERLAY</code></a>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73505072"></a>Cropping</h3></div></div></div><p>To capture only a subsection of the full picture V4L
defines the <code class="constant">VIDIOCGCAPTURE</code> and
<code class="constant">VIDIOCSCAPTURE</code> ioctls using struct
<span class="structname">video_capture</span>. The equivalent V4L2 ioctls are
<a class="link" href="media.html#vidioc-g-crop" title="ioctl VIDIOC_G_CROP, VIDIOC_S_CROP"><code class="constant">VIDIOC_G_CROP</code></a> and <a class="link" href="media.html#vidioc-g-crop" title="ioctl VIDIOC_G_CROP, VIDIOC_S_CROP"><code class="constant">VIDIOC_S_CROP</code></a> using struct <a class="link" href="media.html#v4l2-crop" title="Table A.54. struct v4l2_crop">v4l2_crop</a>, and the related
<a class="link" href="media.html#vidioc-cropcap" title="ioctl VIDIOC_CROPCAP"><code class="constant">VIDIOC_CROPCAP</code></a> ioctl. This is a rather complex matter, see
<a class="xref" href="media.html#crop" title="Image Cropping, Insertion and Scaling">the section called &#8220;Image Cropping, Insertion and Scaling&#8221;</a> for details.</p><p>The <em class="structfield"><code>x</code></em>,
<em class="structfield"><code>y</code></em>, <em class="structfield"><code>width</code></em> and
<em class="structfield"><code>height</code></em> fields moved into struct <a class="link" href="media.html#v4l2-rect" title="Table 4.3. struct v4l2_rect">v4l2_rect</a>
substructure <em class="structfield"><code>c</code></em> of struct
<span class="structname">v4l2_crop</span>. The
<em class="structfield"><code>decimation</code></em> field was dropped. In the V4L2
API the scaling factor is implied by the size of the cropping
rectangle and the size of the captured or overlaid image.</p><p>The <code class="constant">VIDEO_CAPTURE_ODD</code>
and <code class="constant">VIDEO_CAPTURE_EVEN</code> flags to capture only the
odd or even field, respectively, were replaced by
<code class="constant">V4L2_FIELD_TOP</code> and
<code class="constant">V4L2_FIELD_BOTTOM</code> in the field named
<em class="structfield"><code>field</code></em> of struct <a class="link" href="media.html#v4l2-pix-format" title="Table 2.1. struct v4l2_pix_format">v4l2_pix_format</a> and
struct <a class="link" href="media.html#v4l2-window" title="Table 4.1. struct v4l2_window">v4l2_window</a>. These structures are used to select a capture or
overlay format with the <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> ioctl.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73520992"></a>Reading Images, Memory Mapping</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#idp73521680">Capturing using the read method</a></span></dt><dt><span class="section"><a href="media.html#idp73533872">Capturing using memory mapping</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp73521680"></a>Capturing using the read method</h4></div></div></div><p>There is no essential difference between reading images
from a V4L or V4L2 device using the <a class="link" href="media.html#func-read" title="V4L2 read()"><code class="function">read()</code></a> function, however V4L2
drivers are not required to support this I/O method. Applications can
determine if the function is available with the <a class="link" href="media.html#vidioc-querycap" title="ioctl VIDIOC_QUERYCAP"><code class="constant">VIDIOC_QUERYCAP</code></a>
ioctl. All V4L2 devices exchanging data with applications must support
the <a class="link" href="media.html#func-select" title="V4L2 select()"><code class="function">select()</code></a> and <a class="link" href="media.html#func-poll" title="V4L2 poll()"><code class="function">poll()</code></a> functions.</p><p>To select an image format and size, V4L provides the
<code class="constant">VIDIOCSPICT</code> and <code class="constant">VIDIOCSWIN</code>
ioctls. V4L2 uses the general-purpose data format negotiation ioctls
<a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_G_FMT</code></a> and <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a>. They take a pointer to a
struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a> as argument, here the struct <a class="link" href="media.html#v4l2-pix-format" title="Table 2.1. struct v4l2_pix_format">v4l2_pix_format</a> named
<em class="structfield"><code>pix</code></em> of its <em class="structfield"><code>fmt</code></em>
union is used.</p><p>For more information about the V4L2 read interface see
<a class="xref" href="media.html#rw" title="Read/Write">the section called &#8220;Read/Write&#8221;</a>.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp73533872"></a>Capturing using memory mapping</h4></div></div></div><p>Applications can read from V4L devices by mapping
buffers in device memory, or more often just buffers allocated in
DMA-able system memory, into their address space. This avoids the data
copying overhead of the read method. V4L2 supports memory mapping as
well, with a few differences.</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>V4L</th><th>V4L2</th></tr></thead><tbody valign="top"><tr><td valign="top"> </td><td valign="top">The image format must be selected before
buffers are allocated, with the <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> ioctl. When no format
is selected the driver may use the last, possibly by another
application requested format.</td></tr><tr><td valign="top"><p>Applications cannot change the number of
buffers. The it is built into the driver, unless it has a module
option to change the number when the driver module is
loaded.</p></td><td valign="top"><p>The <a class="link" href="media.html#vidioc-reqbufs" title="ioctl VIDIOC_REQBUFS"><code class="constant">VIDIOC_REQBUFS</code></a> ioctl allocates the
desired number of buffers, this is a required step in the initialization
sequence.</p></td></tr><tr><td valign="top"><p>Drivers map all buffers as one contiguous
range of memory. The <code class="constant">VIDIOCGMBUF</code> ioctl is
available to query the number of buffers, the offset of each buffer
from the start of the virtual file, and the overall amount of memory
used, which can be used as arguments for the <a class="link" href="media.html#func-mmap" title="V4L2 mmap()"><code class="function">mmap()</code></a>
function.</p></td><td valign="top"><p>Buffers are individually mapped. The
offset and size of each buffer can be determined with the
<a class="link" href="media.html#vidioc-querybuf" title="ioctl VIDIOC_QUERYBUF"><code class="constant">VIDIOC_QUERYBUF</code></a> ioctl.</p></td></tr><tr><td valign="top"><p>The <code class="constant">VIDIOCMCAPTURE</code>
ioctl prepares a buffer for capturing. It also determines the image
format for this buffer. The ioctl returns immediately, eventually with
an <span class="errorcode">EAGAIN</span> error code if no video signal had been detected. When the driver
supports more than one buffer applications can call the ioctl multiple
times and thus have multiple outstanding capture
requests.</p><p>The <code class="constant">VIDIOCSYNC</code> ioctl
suspends execution until a particular buffer has been
filled.</p></td><td valign="top"><p>Drivers maintain an incoming and outgoing
queue. <a class="link" href="media.html#vidioc-qbuf" title="ioctl VIDIOC_QBUF, VIDIOC_DQBUF"><code class="constant">VIDIOC_QBUF</code></a> enqueues any empty buffer into the incoming
queue. Filled buffers are dequeued from the outgoing queue with the
<a class="link" href="media.html#vidioc-qbuf" title="ioctl VIDIOC_QBUF, VIDIOC_DQBUF"><code class="constant">VIDIOC_DQBUF</code></a> ioctl. To wait until filled buffers become available this
function, <a class="link" href="media.html#func-select" title="V4L2 select()"><code class="function">select()</code></a> or <a class="link" href="media.html#func-poll" title="V4L2 poll()"><code class="function">poll()</code></a> can be used. The
<a class="link" href="media.html#vidioc-streamon" title="ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF"><code class="constant">VIDIOC_STREAMON</code></a> ioctl must be called once after enqueuing one or
more buffers to start capturing. Its counterpart
<a class="link" href="media.html#vidioc-streamon" title="ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF"><code class="constant">VIDIOC_STREAMOFF</code></a> stops capturing and dequeues all buffers from both
queues. Applications can query the signal status, if known, with the
<a class="link" href="media.html#vidioc-enuminput" title="ioctl VIDIOC_ENUMINPUT"><code class="constant">VIDIOC_ENUMINPUT</code></a> ioctl.</p></td></tr></tbody></table></div><p>For a more in-depth discussion of memory mapping and
examples, see <a class="xref" href="media.html#mmap" title="Streaming I/O (Memory Mapping)">the section called &#8220;Streaming I/O (Memory Mapping)&#8221;</a>.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73559232"></a>Reading Raw VBI Data</h3></div></div></div><p>Originally the V4L API did not specify a raw VBI capture
interface, only the device file <code class="filename">/dev/vbi</code> was
reserved for this purpose. The only driver supporting this interface
was the BTTV driver, de-facto defining the V4L VBI interface. Reading
from the device yields a raw VBI image with the following
parameters:</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>struct <a class="link" href="media.html#v4l2-vbi-format" title="Table 4.4. struct v4l2_vbi_format">v4l2_vbi_format</a></th><th>V4L, BTTV driver</th></tr></thead><tbody valign="top"><tr><td valign="top">sampling_rate</td><td valign="top">28636363 Hz NTSC (or any other 525-line
standard); 35468950 Hz PAL and SECAM (625-line standards)</td></tr><tr><td valign="top">offset</td><td valign="top">?</td></tr><tr><td valign="top">samples_per_line</td><td valign="top">2048</td></tr><tr><td valign="top">sample_format</td><td valign="top">V4L2_PIX_FMT_GREY. The last four bytes (a
machine endianness integer) contain a frame counter.</td></tr><tr><td valign="top">start[]</td><td valign="top">10, 273 NTSC; 22, 335 PAL and SECAM</td></tr><tr><td valign="top">count[]</td><td valign="top"><p>16, 16<a href="media.html#ftn.idp73571872" class="footnote" name="idp73571872"><sup class="footnote">[a]</sup></a></p></td></tr><tr><td valign="top">flags</td><td valign="top">0</td></tr></tbody><tbody class="footnotes"><tr><td colspan="2"><div id="ftn.idp73571872" class="footnote"><p><a href="media.html#idp73571872" class="para"><sup class="para">[a] </sup></a>Old driver
versions used different values, eventually the custom
<code class="constant">BTTV_VBISIZE</code> ioctl was added to query the
correct values.</p></div></td></tr></tbody></table></div><p>Undocumented in the V4L specification, in Linux 2.3 the
<code class="constant">VIDIOCGVBIFMT</code> and
<code class="constant">VIDIOCSVBIFMT</code> ioctls using struct
<span class="structname">vbi_format</span> were added to determine the VBI
image parameters. These ioctls are only partially compatible with the
V4L2 VBI interface specified in <a class="xref" href="media.html#raw-vbi" title="Raw VBI Data Interface">the section called &#8220;Raw VBI Data Interface&#8221;</a>.</p><p>An <em class="structfield"><code>offset</code></em> field does not
exist, <em class="structfield"><code>sample_format</code></em> is supposed to be
<code class="constant">VIDEO_PALETTE_RAW</code>, equivalent to
<code class="constant">V4L2_PIX_FMT_GREY</code>. The remaining fields are
probably equivalent to struct <a class="link" href="media.html#v4l2-vbi-format" title="Table 4.4. struct v4l2_vbi_format">v4l2_vbi_format</a>.</p><p>Apparently only the Zoran (ZR 36120) driver implements
these ioctls. The semantics differ from those specified for V4L2 in two
ways. The parameters are reset on <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a> and
<code class="constant">VIDIOCSVBIFMT</code> always returns an <span class="errorcode">EINVAL</span> error code if the
parameters are invalid.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73583200"></a>Miscellaneous</h3></div></div></div><p>V4L2 has no equivalent of the
<code class="constant">VIDIOCGUNIT</code> ioctl. Applications can find the VBI
device associated with a video capture device (or vice versa) by
reopening the device and requesting VBI data. For details see
<a class="xref" href="media.html#open" title="Opening and Closing Devices">the section called &#8220;Opening and Closing Devices&#8221;</a>.</p><p>No replacement exists for <code class="constant">VIDIOCKEY</code>,
and the V4L functions for microcode programming. A new interface for
MPEG compression and playback devices is documented in <a class="xref" href="media.html#extended-controls" title="Extended Controls">the section called &#8220;Extended Controls&#8221;</a>.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="hist-v4l2"></a>Changes of the V4L2 API</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#idp73589504">Early Versions</a></span></dt><dt><span class="section"><a href="media.html#idp73613424">V4L2 Version 0.16 1999-01-31</a></span></dt><dt><span class="section"><a href="media.html#idp73615264">V4L2 Version 0.18 1999-03-16</a></span></dt><dt><span class="section"><a href="media.html#idp73616672">V4L2 Version 0.19 1999-06-05</a></span></dt><dt><span class="section"><a href="media.html#idp73621104">V4L2 Version 0.20 (1999-09-10)</a></span></dt><dt><span class="section"><a href="media.html#idp73652672">V4L2 Version 0.20 incremental changes</a></span></dt><dt><span class="section"><a href="media.html#idp73680304">V4L2 Version 0.20 2000-11-23</a></span></dt><dt><span class="section"><a href="media.html#idp73695712">V4L2 Version 0.20 2002-07-25</a></span></dt><dt><span class="section"><a href="media.html#idp73696960">V4L2 in Linux 2.5.46, 2002-10</a></span></dt><dt><span class="section"><a href="media.html#idp73873264">V4L2 2003-06-19</a></span></dt><dt><span class="section"><a href="media.html#idp73897616">V4L2 2003-11-05</a></span></dt><dt><span class="section"><a href="media.html#idp73915888">V4L2 in Linux 2.6.6, 2004-05-09</a></span></dt><dt><span class="section"><a href="media.html#idp73919856">V4L2 in Linux 2.6.8</a></span></dt><dt><span class="section"><a href="media.html#idp73925088">V4L2 spec erratum 2004-08-01</a></span></dt><dt><span class="section"><a href="media.html#idp73934624">V4L2 in Linux 2.6.14</a></span></dt><dt><span class="section"><a href="media.html#idp73939664">V4L2 in Linux 2.6.15</a></span></dt><dt><span class="section"><a href="media.html#idp73952688">V4L2 spec erratum 2005-11-27</a></span></dt><dt><span class="section"><a href="media.html#idp73957168">V4L2 spec erratum 2006-01-10</a></span></dt><dt><span class="section"><a href="media.html#idp73962640">V4L2 spec erratum 2006-02-03</a></span></dt><dt><span class="section"><a href="media.html#idp73967104">V4L2 spec erratum 2006-02-04</a></span></dt><dt><span class="section"><a href="media.html#idp73972448">V4L2 in Linux 2.6.17</a></span></dt><dt><span class="section"><a href="media.html#idp73981536">V4L2 spec erratum 2006-09-23 (Draft 0.15)</a></span></dt><dt><span class="section"><a href="media.html#idp74000640">V4L2 in Linux 2.6.18</a></span></dt><dt><span class="section"><a href="media.html#idp74011472">V4L2 in Linux 2.6.19</a></span></dt><dt><span class="section"><a href="media.html#idp74020480">V4L2 spec erratum 2006-10-12 (Draft 0.17)</a></span></dt><dt><span class="section"><a href="media.html#idp74023952">V4L2 in Linux 2.6.21</a></span></dt><dt><span class="section"><a href="media.html#idp74030176">V4L2 in Linux 2.6.22</a></span></dt><dt><span class="section"><a href="media.html#idp74044000">V4L2 in Linux 2.6.24</a></span></dt><dt><span class="section"><a href="media.html#idp74048672">V4L2 in Linux 2.6.25</a></span></dt><dt><span class="section"><a href="media.html#idp74069136">V4L2 in Linux 2.6.26</a></span></dt><dt><span class="section"><a href="media.html#idp74074224">V4L2 in Linux 2.6.27</a></span></dt><dt><span class="section"><a href="media.html#idp74082240">V4L2 in Linux 2.6.28</a></span></dt><dt><span class="section"><a href="media.html#idp74088448">V4L2 in Linux 2.6.29</a></span></dt><dt><span class="section"><a href="media.html#idp74098320">V4L2 in Linux 2.6.30</a></span></dt><dt><span class="section"><a href="media.html#idp74102560">V4L2 in Linux 2.6.32</a></span></dt><dt><span class="section"><a href="media.html#idp74114320">V4L2 in Linux 2.6.33</a></span></dt><dt><span class="section"><a href="media.html#idp74116928">V4L2 in Linux 2.6.34</a></span></dt><dt><span class="section"><a href="media.html#idp74121184">V4L2 in Linux 2.6.37</a></span></dt><dt><span class="section"><a href="media.html#idp74123920">V4L2 in Linux 2.6.39</a></span></dt><dt><span class="section"><a href="media.html#idp74128224">V4L2 in Linux 3.1</a></span></dt><dt><span class="section"><a href="media.html#idp74131696">V4L2 in Linux 3.2</a></span></dt><dt><span class="section"><a href="media.html#idp74136112">V4L2 in Linux 3.3</a></span></dt><dt><span class="section"><a href="media.html#idp74140832">V4L2 in Linux 3.4</a></span></dt><dt><span class="section"><a href="media.html#idp74147504">V4L2 in Linux 3.5</a></span></dt><dt><span class="section"><a href="media.html#idp74165904">V4L2 in Linux 3.6</a></span></dt><dt><span class="section"><a href="media.html#idp74171856">V4L2 in Linux 3.9</a></span></dt><dt><span class="section"><a href="media.html#idp74179504">V4L2 in Linux 3.10</a></span></dt><dt><span class="section"><a href="media.html#idp74183200">V4L2 in Linux 3.11</a></span></dt><dt><span class="section"><a href="media.html#idp74187760">V4L2 in Linux 3.14</a></span></dt><dt><span class="section"><a href="media.html#idp74191600">V4L2 in Linux 3.15</a></span></dt><dt><span class="section"><a href="media.html#idp74194096">V4L2 in Linux 3.16</a></span></dt><dt><span class="section"><a href="media.html#idp74196656">V4L2 in Linux 3.17</a></span></dt><dt><span class="section"><a href="media.html#idp74201536">V4L2 in Linux 3.18</a></span></dt><dt><span class="section"><a href="media.html#idp74204960">V4L2 in Linux 3.19</a></span></dt><dt><span class="section"><a href="media.html#other">Relation of V4L2 to other Linux multimedia APIs</a></span></dt><dt><span class="section"><a href="media.html#experimental">Experimental API Elements</a></span></dt><dt><span class="section"><a href="media.html#obsolete">Obsolete API Elements</a></span></dt></dl></div><p>Soon after the V4L API was added to the kernel it was
criticised as too inflexible. In August 1998 Bill Dirks proposed a
number of improvements and began to work on documentation, example
drivers and applications. With the help of other volunteers this
eventually became the V4L2 API, not just an extension but a
replacement for the V4L API. However it took another four years and
two stable kernel releases until the new API was finally accepted for
inclusion into the kernel in its present form.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73589504"></a>Early Versions</h3></div></div></div><p>1998-08-20: First version.</p><p>1998-08-27: The <a class="link" href="media.html#func-select" title="V4L2 select()"><code class="function">select()</code></a> function was introduced.</p><p>1998-09-10: New video standard interface.</p><p>1998-09-18: The <code class="constant">VIDIOC_NONCAP</code> ioctl
was replaced by the otherwise meaningless <code class="constant">O_TRUNC</code>
<a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a> flag, and the aliases <code class="constant">O_NONCAP</code> and
<code class="constant">O_NOIO</code> were defined. Applications can set this
flag if they intend to access controls only, as opposed to capture
applications which need exclusive access. The
<code class="constant">VIDEO_STD_XXX</code> identifiers are now ordinals
instead of flags, and the <code class="function">video_std_construct()</code>
helper function takes id and transmission arguments.</p><p>1998-09-28: Revamped video standard. Made video controls
individually enumerable.</p><p>1998-10-02: The <em class="structfield"><code>id</code></em> field was
removed from struct <span class="structname">video_standard</span> and the
color subcarrier fields were renamed. The <a class="link" href="media.html#vidioc-querystd" title="ioctl VIDIOC_QUERYSTD"><code class="constant">VIDIOC_QUERYSTD</code></a> ioctl was
renamed to <a class="link" href="media.html#vidioc-enumstd" title="ioctl VIDIOC_ENUMSTD"><code class="constant">VIDIOC_ENUMSTD</code></a>, <a class="link" href="media.html#vidioc-g-input" title="ioctl VIDIOC_G_INPUT, VIDIOC_S_INPUT"><code class="constant">VIDIOC_G_INPUT</code></a> to <a class="link" href="media.html#vidioc-enuminput" title="ioctl VIDIOC_ENUMINPUT"><code class="constant">VIDIOC_ENUMINPUT</code></a>. A
first draft of the Codec API was released.</p><p>1998-11-08: Many minor changes. Most symbols have been
renamed. Some material changes to struct <a class="link" href="media.html#v4l2-capability" title="Table A.92. struct v4l2_capability">v4l2_capability</a>.</p><p>1998-11-12: The read/write directon of some ioctls was misdefined.</p><p>1998-11-14: <code class="constant">V4L2_PIX_FMT_RGB24</code>
changed to <code class="constant">V4L2_PIX_FMT_BGR24</code>, and
<code class="constant">V4L2_PIX_FMT_RGB32</code> changed to
<code class="constant">V4L2_PIX_FMT_BGR32</code>. Audio controls are now
accessible with the <a class="link" href="media.html#vidioc-g-ctrl" title="ioctl VIDIOC_G_CTRL, VIDIOC_S_CTRL"><code class="constant">VIDIOC_G_CTRL</code></a> and <a class="link" href="media.html#vidioc-g-ctrl" title="ioctl VIDIOC_G_CTRL, VIDIOC_S_CTRL"><code class="constant">VIDIOC_S_CTRL</code></a> ioctls under
names starting with <code class="constant">V4L2_CID_AUDIO</code>. The
<code class="constant">V4L2_MAJOR</code> define was removed from
<code class="filename">videodev.h</code> since it was only used once in the
<code class="filename">videodev</code> kernel module. The
<code class="constant">YUV422</code> and <code class="constant">YUV411</code> planar
image formats were added.</p><p>1998-11-28: A few ioctl symbols changed. Interfaces for codecs and
video output devices were added.</p><p>1999-01-14: A raw VBI capture interface was added.</p><p>1999-01-19: The <code class="constant">VIDIOC_NEXTBUF</code> ioctl
      was removed.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73613424"></a>V4L2 Version 0.16 1999-01-31</h3></div></div></div><p>1999-01-27: There is now one QBUF ioctl, VIDIOC_QWBUF and VIDIOC_QRBUF
are gone. VIDIOC_QBUF takes a v4l2_buffer as a parameter. Added
digital zoom (cropping) controls.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73615264"></a>V4L2 Version 0.18 1999-03-16</h3></div></div></div><p>Added a v4l to V4L2 ioctl compatibility layer to
videodev.c. Driver writers, this changes how you implement your ioctl
handler. See the Driver Writer's Guide. Added some more control id
codes.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73616672"></a>V4L2 Version 0.19 1999-06-05</h3></div></div></div><p>1999-03-18: Fill in the category and catname fields of
v4l2_queryctrl objects before passing them to the driver. Required a
minor change to the VIDIOC_QUERYCTRL handlers in the sample
drivers.</p><p>1999-03-31: Better compatibility for v4l memory capture
ioctls. Requires changes to drivers to fully support new compatibility
features, see Driver Writer's Guide and v4l2cap.c. Added new control
IDs: V4L2_CID_HFLIP, _VFLIP. Changed V4L2_PIX_FMT_YUV422P to _YUV422P,
and _YUV411P to _YUV411P.</p><p>1999-04-04: Added a few more control IDs.</p><p>1999-04-07: Added the button control type.</p><p>1999-05-02: Fixed a typo in videodev.h, and added the
V4L2_CTRL_FLAG_GRAYED (later V4L2_CTRL_FLAG_GRABBED) flag.</p><p>1999-05-20: Definition of VIDIOC_G_CTRL was wrong causing
a malfunction of this ioctl.</p><p>1999-06-05: Changed the value of
V4L2_CID_WHITENESS.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73621104"></a>V4L2 Version 0.20 (1999-09-10)</h3></div></div></div><p>Version 0.20 introduced a number of changes which were
<span class="emphasis"><em>not backward compatible</em></span> with 0.19 and earlier
versions. Purpose of these changes was to simplify the API, while
making it more extensible and following common Linux driver API
conventions.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Some typos in <code class="constant">V4L2_FMT_FLAG</code>
symbols were fixed. struct <a class="link" href="media.html#v4l2-clip" title="Table 4.2. struct v4l2_clip">v4l2_clip</a> was changed for compatibility with
v4l. (1999-08-30)</p></li><li class="listitem"><p><code class="constant">V4L2_TUNER_SUB_LANG1</code> was added.
(1999-09-05)</p></li><li class="listitem"><p>All ioctl() commands that used an integer argument now
take a pointer to an integer. Where it makes sense, ioctls will return
the actual new value in the integer pointed to by the argument, a
common convention in the V4L2 API. The affected ioctls are:
VIDIOC_PREVIEW, VIDIOC_STREAMON, VIDIOC_STREAMOFF, VIDIOC_S_FREQ,
VIDIOC_S_INPUT, VIDIOC_S_OUTPUT, VIDIOC_S_EFFECT. For example
</p><pre class="programlisting">
err = ioctl (fd, VIDIOC_XXX, V4L2_XXX);
</pre><p> becomes </p><pre class="programlisting">
int a = V4L2_XXX; err = ioctl(fd, VIDIOC_XXX, &amp;a);
</pre><p>
	  </p></li><li class="listitem"><p>All the different get- and set-format commands were
swept into one <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_G_FMT</code></a> and <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> ioctl taking a union
and a type field selecting the union member as parameter. Purpose is to
simplify the API by eliminating several ioctls and to allow new and
driver private data streams without adding new ioctls.</p><p>This change obsoletes the following ioctls:
<code class="constant">VIDIOC_S_INFMT</code>,
<code class="constant">VIDIOC_G_INFMT</code>,
<code class="constant">VIDIOC_S_OUTFMT</code>,
<code class="constant">VIDIOC_G_OUTFMT</code>,
<code class="constant">VIDIOC_S_VBIFMT</code> and
<code class="constant">VIDIOC_G_VBIFMT</code>. The image format structure
<span class="structname">v4l2_format</span> was renamed to struct <a class="link" href="media.html#v4l2-pix-format" title="Table 2.1. struct v4l2_pix_format">v4l2_pix_format</a>,
while struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a> is now the envelopping structure for all format
negotiations.</p></li><li class="listitem"><p>Similar to the changes above, the
<code class="constant">VIDIOC_G_PARM</code> and
<code class="constant">VIDIOC_S_PARM</code> ioctls were merged with
<code class="constant">VIDIOC_G_OUTPARM</code> and
<code class="constant">VIDIOC_S_OUTPARM</code>. A
<em class="structfield"><code>type</code></em> field in the new struct <a class="link" href="media.html#v4l2-streamparm" title="Table A.77. struct v4l2_streamparm">v4l2_streamparm</a>
selects the respective union member.</p><p>This change obsoletes the
<code class="constant">VIDIOC_G_OUTPARM</code> and
<code class="constant">VIDIOC_S_OUTPARM</code> ioctls.</p></li><li class="listitem"><p>Control enumeration was simplified, and two new
control flags were introduced and one dropped. The
<em class="structfield"><code>catname</code></em> field was replaced by a
<em class="structfield"><code>group</code></em> field.</p><p>Drivers can now flag unsupported and temporarily
unavailable controls with <code class="constant">V4L2_CTRL_FLAG_DISABLED</code>
and <code class="constant">V4L2_CTRL_FLAG_GRABBED</code> respectively. The
<em class="structfield"><code>group</code></em> name indicates a possibly narrower
classification than the <em class="structfield"><code>category</code></em>. In other
words, there may be multiple groups within a category. Controls within
a group would typically be drawn within a group box. Controls in
different categories might have a greater separation, or may even
appear in separate windows.</p></li><li class="listitem"><p>The struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a> <em class="structfield"><code>timestamp</code></em>
was changed to a 64 bit integer, containing the sampling or output
time of the frame in nanoseconds. Additionally timestamps will be in
absolute system time, not starting from zero at the beginning of a
stream. The data type name for timestamps is stamp_t, defined as a
signed 64-bit integer. Output devices should not send a buffer out
until the time in the timestamp field has arrived. I would like to
follow SGI's lead, and adopt a multimedia timestamping system like
their UST (Unadjusted System Time). See
http://web.archive.org/web/*/http://reality.sgi.com
/cpirazzi_engr/lg/time/intro.html.
UST uses timestamps that are 64-bit signed integers
(not struct timeval's) and given in nanosecond units. The UST clock
starts at zero when the system is booted and runs continuously and
uniformly. It takes a little over 292 years for UST to overflow. There
is no way to set the UST clock. The regular Linux time-of-day clock
can be changed periodically, which would cause errors if it were being
used for timestamping a multimedia stream. A real UST style clock will
require some support in the kernel that is not there yet. But in
anticipation, I will change the timestamp field to a 64-bit integer,
and I will change the v4l2_masterclock_gettime() function (used only
by drivers) to return a 64-bit integer.</p></li><li class="listitem"><p>A <em class="structfield"><code>sequence</code></em> field was added
to struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a>. The <em class="structfield"><code>sequence</code></em> field counts
captured frames, it is ignored by output devices. When a capture
driver drops a frame, the sequence number of that frame is
skipped.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73652672"></a>V4L2 Version 0.20 incremental changes</h3></div></div></div><p>1999-12-23: In struct <a class="link" href="media.html#v4l2-vbi-format" title="Table 4.4. struct v4l2_vbi_format">v4l2_vbi_format</a> the
<em class="structfield"><code>reserved1</code></em> field became
<em class="structfield"><code>offset</code></em>. Previously drivers were required to
clear the <em class="structfield"><code>reserved1</code></em> field.</p><p>2000-01-13: The
      <code class="constant">V4L2_FMT_FLAG_NOT_INTERLACED</code> flag was added.</p><p>2000-07-31: The <code class="filename">linux/poll.h</code> header
is now included by <code class="filename">videodev.h</code> for compatibility
with the original <code class="filename">videodev.h</code> file.</p><p>2000-11-20: <code class="constant">V4L2_TYPE_VBI_OUTPUT</code> and
<code class="constant">V4L2_PIX_FMT_Y41P</code> were added.</p><p>2000-11-25: <code class="constant">V4L2_TYPE_VBI_INPUT</code> was
added.</p><p>2000-12-04: A couple typos in symbol names were fixed.</p><p>2001-01-18: To avoid namespace conflicts the
<code class="constant">fourcc</code> macro defined in the
<code class="filename">videodev.h</code> header file was renamed to
<code class="constant">v4l2_fourcc</code>.</p><p>2001-01-25: A possible driver-level compatibility problem
between the <code class="filename">videodev.h</code> file in Linux 2.4.0 and
the <code class="filename">videodev.h</code> file included in the
<code class="filename">videodevX</code> patch was fixed. Users of an earlier
version of <code class="filename">videodevX</code> on Linux 2.4.0 should
recompile their V4L and V4L2 drivers.</p><p>2001-01-26: A possible kernel-level incompatibility
between the <code class="filename">videodev.h</code> file in the
<code class="filename">videodevX</code> patch and the
<code class="filename">videodev.h</code> file in Linux 2.2.x with devfs patches
applied was fixed.</p><p>2001-03-02: Certain V4L ioctls which pass data in both
direction although they are defined with read-only parameter, did not
work correctly through the backward compatibility layer.
[Solution?]</p><p>2001-04-13: Big endian 16-bit RGB formats were added.</p><p>2001-09-17: New YUV formats and the <a class="link" href="media.html#vidioc-g-frequency" title="ioctl VIDIOC_G_FREQUENCY, VIDIOC_S_FREQUENCY"><code class="constant">VIDIOC_G_FREQUENCY</code></a> and
<a class="link" href="media.html#vidioc-g-frequency" title="ioctl VIDIOC_G_FREQUENCY, VIDIOC_S_FREQUENCY"><code class="constant">VIDIOC_S_FREQUENCY</code></a> ioctls were added. (The old
<code class="constant">VIDIOC_G_FREQ</code> and
<code class="constant">VIDIOC_S_FREQ</code> ioctls did not take multiple tuners
into account.)</p><p>2000-09-18: <code class="constant">V4L2_BUF_TYPE_VBI</code> was
added. This may <span class="emphasis"><em>break compatibility</em></span> as the
<a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_G_FMT</code></a> and <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> ioctls may fail now if the struct
<span class="structname">v4l2_fmt</span> <em class="structfield"><code>type</code></em>
field does not contain <code class="constant">V4L2_BUF_TYPE_VBI</code>. In the
documentation of the struct <a class="link" href="media.html#v4l2-vbi-format" title="Table 4.4. struct v4l2_vbi_format">v4l2_vbi_format</a>
<em class="structfield"><code>offset</code></em> field the ambiguous phrase "rising
edge" was changed to "leading edge".</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73680304"></a>V4L2 Version 0.20 2000-11-23</h3></div></div></div><p>A number of changes were made to the raw VBI
interface.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Figures clarifying the line numbering scheme were
added to the V4L2 API specification. The
<em class="structfield"><code>start</code></em>[0] and
<em class="structfield"><code>start</code></em>[1] fields no longer count line
numbers beginning at zero. Rationale: a) The previous definition was
unclear. b) The <em class="structfield"><code>start</code></em>[] values are ordinal
numbers. c) There is no point in inventing a new line numbering
scheme. We now use line number as defined by ITU-R, period.
Compatibility: Add one to the start values. Applications depending on
the previous semantics may not function correctly.</p></li><li class="listitem"><p>The restriction "count[0] &gt; 0 and count[1] &gt; 0"
has been relaxed  to "(count[0] + count[1]) &gt; 0". Rationale:
Drivers may allocate resources at scan line granularity and some data
services are transmitted only on the first field. The comment that
both <em class="structfield"><code>count</code></em> values will usually be equal is
misleading and pointless and has been removed. This change
<span class="emphasis"><em>breaks compatibility</em></span> with earlier versions:
Drivers may return EINVAL, applications may not function
correctly.</p></li><li class="listitem"><p>Drivers are again permitted to return negative
(unknown) start values as proposed earlier. Why this feature was
dropped is unclear. This change may <span class="emphasis"><em>break
compatibility</em></span> with applications depending on the start
values being positive. The use of <code class="constant">EBUSY</code> and
<code class="constant">EINVAL</code> error codes with the <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> ioctl
was clarified. The <span class="errorcode">EBUSY</span> error code was finally documented, and the
<em class="structfield"><code>reserved2</code></em> field which was previously
mentioned only in the <code class="filename">videodev.h</code> header
file.</p></li><li class="listitem"><p>New buffer types
<code class="constant">V4L2_TYPE_VBI_INPUT</code> and
<code class="constant">V4L2_TYPE_VBI_OUTPUT</code> were added. The former is an
alias for the old <code class="constant">V4L2_TYPE_VBI</code>, the latter was
missing in the <code class="filename">videodev.h</code> file.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73695712"></a>V4L2 Version 0.20 2002-07-25</h3></div></div></div><p>Added sliced VBI interface proposal.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73696960"></a>V4L2 in Linux 2.5.46, 2002-10</h3></div></div></div><p>Around October-November 2002, prior to an announced
feature freeze of Linux 2.5, the API was revised, drawing from
experience with V4L2 0.20. This unnamed version was finally merged
into Linux 2.5.46.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>As specified in <a class="xref" href="media.html#related" title="Related Devices">the section called &#8220;Related Devices&#8221;</a>, drivers
must make related device functions available under all minor device
numbers.</p></li><li class="listitem"><p>The <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a> function requires access mode
<code class="constant">O_RDWR</code> regardless of the device type. All V4L2
drivers exchanging data with applications must support the
<code class="constant">O_NONBLOCK</code> flag. The <code class="constant">O_NOIO</code>
flag, a V4L2 symbol which aliased the meaningless
<code class="constant">O_TRUNC</code> to indicate accesses without data
exchange (panel applications) was dropped. Drivers must stay in "panel
mode" until the application attempts to initiate a data exchange, see
<a class="xref" href="media.html#open" title="Opening and Closing Devices">the section called &#8220;Opening and Closing Devices&#8221;</a>.</p></li><li class="listitem"><p>The struct <a class="link" href="media.html#v4l2-capability" title="Table A.92. struct v4l2_capability">v4l2_capability</a> changed dramatically. Note that
also the size of the structure changed, which is encoded in the ioctl
request code, thus older V4L2 devices will respond with an <span class="errorcode">EINVAL</span> error code to
the new <a class="link" href="media.html#vidioc-querycap" title="ioctl VIDIOC_QUERYCAP"><code class="constant">VIDIOC_QUERYCAP</code></a> ioctl.</p><p>There are new fields to identify the driver, a new RDS
device function <code class="constant">V4L2_CAP_RDS_CAPTURE</code>, the
<code class="constant">V4L2_CAP_AUDIO</code> flag indicates if the device has
any audio connectors, another I/O capability
<code class="constant">V4L2_CAP_ASYNCIO</code> can be flagged. In response to
these changes the <em class="structfield"><code>type</code></em> field became a bit
set and was merged into the <em class="structfield"><code>flags</code></em> field.
<code class="constant">V4L2_FLAG_TUNER</code> was renamed to
<code class="constant">V4L2_CAP_TUNER</code>,
<code class="constant">V4L2_CAP_VIDEO_OVERLAY</code> replaced
<code class="constant">V4L2_FLAG_PREVIEW</code> and
<code class="constant">V4L2_CAP_VBI_CAPTURE</code> and
<code class="constant">V4L2_CAP_VBI_OUTPUT</code> replaced
<code class="constant">V4L2_FLAG_DATA_SERVICE</code>.
<code class="constant">V4L2_FLAG_READ</code> and
<code class="constant">V4L2_FLAG_WRITE</code> were merged into
<code class="constant">V4L2_CAP_READWRITE</code>.</p><p>The redundant fields
<em class="structfield"><code>inputs</code></em>, <em class="structfield"><code>outputs</code></em>
and <em class="structfield"><code>audios</code></em> were removed. These properties
can be determined as described in <a class="xref" href="media.html#video" title="Video Inputs and Outputs">the section called &#8220;Video Inputs and Outputs&#8221;</a> and <a class="xref" href="media.html#audio" title="Audio Inputs and Outputs">the section called &#8220;Audio Inputs and Outputs&#8221;</a>.</p><p>The somewhat volatile and therefore barely useful
fields <em class="structfield"><code>maxwidth</code></em>,
<em class="structfield"><code>maxheight</code></em>,
<em class="structfield"><code>minwidth</code></em>,
<em class="structfield"><code>minheight</code></em>,
<em class="structfield"><code>maxframerate</code></em> were removed. This information
is available as described in <a class="xref" href="media.html#format" title="Data Formats">the section called &#8220;Data Formats&#8221;</a> and
<a class="xref" href="media.html#standard" title="Video Standards">the section called &#8220;Video Standards&#8221;</a>.</p><p><code class="constant">V4L2_FLAG_SELECT</code> was removed. We
believe the select() function is important enough to require support
of it in all V4L2 drivers exchanging data with applications. The
redundant <code class="constant">V4L2_FLAG_MONOCHROME</code> flag was removed,
this information is available as described in <a class="xref" href="media.html#format" title="Data Formats">the section called &#8220;Data Formats&#8221;</a>.</p></li><li class="listitem"><p>In struct <a class="link" href="media.html#v4l2-input" title="Table A.38. struct v4l2_input">v4l2_input</a> the
<em class="structfield"><code>assoc_audio</code></em> field and the
<em class="structfield"><code>capability</code></em> field and its only flag
<code class="constant">V4L2_INPUT_CAP_AUDIO</code> was replaced by the new
<em class="structfield"><code>audioset</code></em> field. Instead of linking one
video input to one audio input this field reports all audio inputs
this video input combines with.</p><p>New fields are <em class="structfield"><code>tuner</code></em>
(reversing the former link from tuners to video inputs),
<em class="structfield"><code>std</code></em> and
<em class="structfield"><code>status</code></em>.</p><p>Accordingly struct <a class="link" href="media.html#v4l2-output" title="Table A.42. struct v4l2_output">v4l2_output</a> lost its
<em class="structfield"><code>capability</code></em> and
<em class="structfield"><code>assoc_audio</code></em> fields.
<em class="structfield"><code>audioset</code></em>,
<em class="structfield"><code>modulator</code></em> and
<em class="structfield"><code>std</code></em> where added instead.</p></li><li class="listitem"><p>The struct <a class="link" href="media.html#v4l2-audio" title="Table A.50. struct v4l2_audio">v4l2_audio</a> field
<em class="structfield"><code>audio</code></em> was renamed to
<em class="structfield"><code>index</code></em>, for consistency with other
structures. A new capability flag
<code class="constant">V4L2_AUDCAP_STEREO</code> was added to indicated if the
audio input in question supports stereo sound.
<code class="constant">V4L2_AUDCAP_EFFECTS</code> and the corresponding
<code class="constant">V4L2_AUDMODE</code> flags where removed. This can be
easily implemented using controls. (However the same applies to AVL
which is still there.)</p><p>Again for consistency the struct <a class="link" href="media.html#v4l2-audioout" title="Table A.53. struct v4l2_audioout">v4l2_audioout</a> field
<em class="structfield"><code>audio</code></em> was renamed to
<em class="structfield"><code>index</code></em>.</p></li><li class="listitem"><p>The struct <a class="link" href="media.html#v4l2-tuner" title="Table A.86. struct v4l2_tuner">v4l2_tuner</a>
<em class="structfield"><code>input</code></em> field was replaced by an
<em class="structfield"><code>index</code></em> field, permitting devices with
multiple tuners. The link between video inputs and tuners is now
reversed, inputs point to their tuner. The
<em class="structfield"><code>std</code></em> substructure became a
simple set (more about this below) and moved into struct <a class="link" href="media.html#v4l2-input" title="Table A.38. struct v4l2_input">v4l2_input</a>. A
<em class="structfield"><code>type</code></em> field was added.</p><p>Accordingly in struct <a class="link" href="media.html#v4l2-modulator" title="Table A.75. struct v4l2_modulator">v4l2_modulator</a> the
<em class="structfield"><code>output</code></em> was replaced by an
<em class="structfield"><code>index</code></em> field.</p><p>In struct <a class="link" href="media.html#v4l2-frequency" title="Table A.72. struct v4l2_frequency">v4l2_frequency</a> the
<em class="structfield"><code>port</code></em> field was replaced by a
<em class="structfield"><code>tuner</code></em> field containing the respective tuner
or modulator index number. A tuner <em class="structfield"><code>type</code></em>
field was added and the <em class="structfield"><code>reserved</code></em> field
became larger for future extensions (satellite tuners in
particular).</p></li><li class="listitem"><p>The idea of completely transparent video standards was
dropped. Experience showed that applications must be able to work with
video standards beyond presenting the user a menu. Instead of
enumerating supported standards with an ioctl applications can now
refer to standards by <a class="link" href="media.html#v4l2-std-id" title="Table A.47. typedef v4l2_std_id">v4l2_std_id</a> and symbols defined in the
<code class="filename">videodev2.h</code> header file. For details see <a class="xref" href="media.html#standard" title="Video Standards">the section called &#8220;Video Standards&#8221;</a>. The <a class="link" href="media.html#vidioc-g-std" title="ioctl VIDIOC_G_STD, VIDIOC_S_STD"><code class="constant">VIDIOC_G_STD</code></a> and
<a class="link" href="media.html#vidioc-g-std" title="ioctl VIDIOC_G_STD, VIDIOC_S_STD"><code class="constant">VIDIOC_S_STD</code></a> now take a pointer to this type as argument.
<a class="link" href="media.html#vidioc-querystd" title="ioctl VIDIOC_QUERYSTD"><code class="constant">VIDIOC_QUERYSTD</code></a> was added to autodetect the received standard, if
the hardware has this capability. In struct <a class="link" href="media.html#v4l2-standard" title="Table A.45. struct v4l2_standard">v4l2_standard</a> an
<em class="structfield"><code>index</code></em> field was added for <a class="link" href="media.html#vidioc-enumstd" title="ioctl VIDIOC_ENUMSTD"><code class="constant">VIDIOC_ENUMSTD</code></a>.
A <a class="link" href="media.html#v4l2-std-id" title="Table A.47. typedef v4l2_std_id">v4l2_std_id</a> field named <em class="structfield"><code>id</code></em> was added as
machine readable identifier, also replacing the
<em class="structfield"><code>transmission</code></em> field. The misleading
<em class="structfield"><code>framerate</code></em> field was renamed
to <em class="structfield"><code>frameperiod</code></em>. The now obsolete
<em class="structfield"><code>colorstandard</code></em> information, originally
needed to distguish between variations of standards, were
removed.</p><p>Struct <span class="structname">v4l2_enumstd</span> ceased to
be. <a class="link" href="media.html#vidioc-enumstd" title="ioctl VIDIOC_ENUMSTD"><code class="constant">VIDIOC_ENUMSTD</code></a> now takes a pointer to a struct <a class="link" href="media.html#v4l2-standard" title="Table A.45. struct v4l2_standard">v4l2_standard</a>
directly. The information which standards are supported by a
particular video input or output moved into struct <a class="link" href="media.html#v4l2-input" title="Table A.38. struct v4l2_input">v4l2_input</a> and
struct <a class="link" href="media.html#v4l2-output" title="Table A.42. struct v4l2_output">v4l2_output</a> fields named <em class="structfield"><code>std</code></em>,
respectively.</p></li><li class="listitem"><p>The struct <a class="link" href="media.html#v4l2-queryctrl" title="Table A.94. struct v4l2_queryctrl">v4l2_queryctrl</a> fields
<em class="structfield"><code>category</code></em> and
<em class="structfield"><code>group</code></em> did not catch on and/or were not
implemented as expected and therefore removed.</p></li><li class="listitem"><p>The <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_TRY_FMT</code></a> ioctl was added to negotiate data
formats as with <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a>, but without the overhead of
programming the hardware and regardless of I/O in progress.</p><p>In struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a> the <em class="structfield"><code>fmt</code></em>
union was extended to contain struct <a class="link" href="media.html#v4l2-window" title="Table 4.1. struct v4l2_window">v4l2_window</a>. All image format
negotiations are now possible with <code class="constant">VIDIOC_G_FMT</code>,
<code class="constant">VIDIOC_S_FMT</code> and
<code class="constant">VIDIOC_TRY_FMT</code>; ioctl. The
<code class="constant">VIDIOC_G_WIN</code> and
<code class="constant">VIDIOC_S_WIN</code> ioctls to prepare for a video
overlay were removed. The <em class="structfield"><code>type</code></em> field
changed to type enum <a class="link" href="media.html#v4l2-buf-type" title="Table 3.3. enum v4l2_buf_type">v4l2_buf_type</a> and the buffer type names changed as
follows.</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>Old defines</th><th>enum <a class="link" href="media.html#v4l2-buf-type" title="Table 3.3. enum v4l2_buf_type">v4l2_buf_type</a></th></tr></thead><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_BUF_TYPE_CAPTURE</code></td><td valign="top"><code class="constant">V4L2_BUF_TYPE_VIDEO_CAPTURE</code></td></tr><tr><td valign="top"><code class="constant">V4L2_BUF_TYPE_CODECIN</code></td><td valign="top">Omitted for now</td></tr><tr><td valign="top"><code class="constant">V4L2_BUF_TYPE_CODECOUT</code></td><td valign="top">Omitted for now</td></tr><tr><td valign="top"><code class="constant">V4L2_BUF_TYPE_EFFECTSIN</code></td><td valign="top">Omitted for now</td></tr><tr><td valign="top"><code class="constant">V4L2_BUF_TYPE_EFFECTSIN2</code></td><td valign="top">Omitted for now</td></tr><tr><td valign="top"><code class="constant">V4L2_BUF_TYPE_EFFECTSOUT</code></td><td valign="top">Omitted for now</td></tr><tr><td valign="top"><code class="constant">V4L2_BUF_TYPE_VIDEOOUT</code></td><td valign="top"><code class="constant">V4L2_BUF_TYPE_VIDEO_OUTPUT</code></td></tr><tr><td valign="top"><code class="constant">-</code></td><td valign="top"><code class="constant">V4L2_BUF_TYPE_VIDEO_OVERLAY</code></td></tr><tr><td valign="top"><code class="constant">-</code></td><td valign="top"><code class="constant">V4L2_BUF_TYPE_VBI_CAPTURE</code></td></tr><tr><td valign="top"><code class="constant">-</code></td><td valign="top"><code class="constant">V4L2_BUF_TYPE_VBI_OUTPUT</code></td></tr><tr><td valign="top"><code class="constant">-</code></td><td valign="top"><code class="constant">V4L2_BUF_TYPE_SLICED_VBI_CAPTURE</code></td></tr><tr><td valign="top"><code class="constant">-</code></td><td valign="top"><code class="constant">V4L2_BUF_TYPE_SLICED_VBI_OUTPUT</code></td></tr><tr><td valign="top"><code class="constant">V4L2_BUF_TYPE_PRIVATE_BASE</code></td><td valign="top"><code class="constant">V4L2_BUF_TYPE_PRIVATE</code> (but this is deprecated)</td></tr></tbody></table></div></li><li class="listitem"><p>In struct <a class="link" href="media.html#v4l2-fmtdesc" title="Table A.27. struct v4l2_fmtdesc">v4l2_fmtdesc</a> a enum <a class="link" href="media.html#v4l2-buf-type" title="Table 3.3. enum v4l2_buf_type">v4l2_buf_type</a> field named
<em class="structfield"><code>type</code></em> was added as in struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a>. The
<code class="constant">VIDIOC_ENUM_FBUFFMT</code> ioctl is no longer needed and
was removed. These calls can be replaced by <a class="link" href="media.html#vidioc-enum-fmt" title="ioctl VIDIOC_ENUM_FMT"><code class="constant">VIDIOC_ENUM_FMT</code></a> with
type <code class="constant">V4L2_BUF_TYPE_VIDEO_OVERLAY</code>.</p></li><li class="listitem"><p>In struct <a class="link" href="media.html#v4l2-pix-format" title="Table 2.1. struct v4l2_pix_format">v4l2_pix_format</a> the
<em class="structfield"><code>depth</code></em> field was removed, assuming
applications which recognize the format by its four-character-code
already know the color depth, and others do not care about it. The
same rationale lead to the removal of the
<code class="constant">V4L2_FMT_FLAG_COMPRESSED</code> flag. The
<code class="constant">V4L2_FMT_FLAG_SWCONVECOMPRESSED</code> flag was removed
because drivers are not supposed to convert images in kernel space. A
user library of conversion functions should be provided instead. The
<code class="constant">V4L2_FMT_FLAG_BYTESPERLINE</code> flag was redundant.
Applications can set the <em class="structfield"><code>bytesperline</code></em> field
to zero to get a reasonable default. Since the remaining flags were
replaced as well, the <em class="structfield"><code>flags</code></em> field itself
was removed.</p><p>The interlace flags were replaced by a enum <a class="link" href="media.html#v4l2-field" title="Table 3.9. enum v4l2_field">v4l2_field</a>
value in a newly added <em class="structfield"><code>field</code></em>
field.</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>Old flag</th><th>enum <a class="link" href="media.html#v4l2-field" title="Table 3.9. enum v4l2_field">v4l2_field</a></th></tr></thead><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_FMT_FLAG_NOT_INTERLACED</code></td><td valign="top">?</td></tr><tr><td valign="top"><code class="constant">V4L2_FMT_FLAG_INTERLACED</code>
= <code class="constant">V4L2_FMT_FLAG_COMBINED</code></td><td valign="top"><code class="constant">V4L2_FIELD_INTERLACED</code></td></tr><tr><td valign="top"><code class="constant">V4L2_FMT_FLAG_TOPFIELD</code>
= <code class="constant">V4L2_FMT_FLAG_ODDFIELD</code></td><td valign="top"><code class="constant">V4L2_FIELD_TOP</code></td></tr><tr><td valign="top"><code class="constant">V4L2_FMT_FLAG_BOTFIELD</code>
= <code class="constant">V4L2_FMT_FLAG_EVENFIELD</code></td><td valign="top"><code class="constant">V4L2_FIELD_BOTTOM</code></td></tr><tr><td valign="top"><code class="constant">-</code></td><td valign="top"><code class="constant">V4L2_FIELD_SEQ_TB</code></td></tr><tr><td valign="top"><code class="constant">-</code></td><td valign="top"><code class="constant">V4L2_FIELD_SEQ_BT</code></td></tr><tr><td valign="top"><code class="constant">-</code></td><td valign="top"><code class="constant">V4L2_FIELD_ALTERNATE</code></td></tr></tbody></table></div><p>The color space flags were replaced by a
enum <a class="link" href="media.html#v4l2-colorspace" title="Table 2.4. V4L2 Colorspaces">v4l2_colorspace</a> value in a newly added
<em class="structfield"><code>colorspace</code></em> field, where one of
<code class="constant">V4L2_COLORSPACE_SMPTE170M</code>,
<code class="constant">V4L2_COLORSPACE_BT878</code>,
<code class="constant">V4L2_COLORSPACE_470_SYSTEM_M</code> or
<code class="constant">V4L2_COLORSPACE_470_SYSTEM_BG</code> replaces
<code class="constant">V4L2_FMT_CS_601YUV</code>.</p></li><li class="listitem"><p>In struct <a class="link" href="media.html#v4l2-requestbuffers" title="Table A.99. struct v4l2_requestbuffers">v4l2_requestbuffers</a> the
<em class="structfield"><code>type</code></em> field was properly defined as
enum <a class="link" href="media.html#v4l2-buf-type" title="Table 3.3. enum v4l2_buf_type">v4l2_buf_type</a>. Buffer types changed as mentioned above. A new
<em class="structfield"><code>memory</code></em> field of type enum <a class="link" href="media.html#v4l2-memory" title="Table 3.5. enum v4l2_memory">v4l2_memory</a> was
added to distinguish between I/O methods using buffers allocated
by the driver or the application. See <a class="xref" href="media.html#io" title="Chapter 3. Input/Output">Chapter 3, <i>Input/Output</i></a> for
details.</p></li><li class="listitem"><p>In struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a> the <em class="structfield"><code>type</code></em>
field was properly defined as enum <a class="link" href="media.html#v4l2-buf-type" title="Table 3.3. enum v4l2_buf_type">v4l2_buf_type</a>. Buffer types changed as
mentioned above. A <em class="structfield"><code>field</code></em> field of type
enum <a class="link" href="media.html#v4l2-field" title="Table 3.9. enum v4l2_field">v4l2_field</a> was added to indicate if a buffer contains a top or
bottom field. The old field flags were removed. Since no unadjusted
system time clock was added to the kernel as planned, the
<em class="structfield"><code>timestamp</code></em> field changed back from type
stamp_t, an unsigned 64 bit integer expressing the sample time in
nanoseconds, to struct <span class="structname">timeval</span>. With the
addition of a second memory mapping method the
<em class="structfield"><code>offset</code></em> field moved into union
<em class="structfield"><code>m</code></em>, and a new
<em class="structfield"><code>memory</code></em> field of type enum <a class="link" href="media.html#v4l2-memory" title="Table 3.5. enum v4l2_memory">v4l2_memory</a> was
added to distinguish between I/O methods. See <a class="xref" href="media.html#io" title="Chapter 3. Input/Output">Chapter 3, <i>Input/Output</i></a>
for details.</p><p>The <code class="constant">V4L2_BUF_REQ_CONTIG</code>
flag was used by the V4L compatibility layer, after changes to this
code it was no longer needed. The
<code class="constant">V4L2_BUF_ATTR_DEVICEMEM</code> flag would indicate if
the buffer was indeed allocated in device memory rather than DMA-able
system memory. It was barely useful and so was removed.</p></li><li class="listitem"><p>In struct <a class="link" href="media.html#v4l2-framebuffer" title="Table A.68. struct v4l2_framebuffer">v4l2_framebuffer</a> the
<em class="structfield"><code>base[3]</code></em> array anticipating double- and
triple-buffering in off-screen video memory, however without defining
a synchronization mechanism, was replaced by a single pointer. The
<code class="constant">V4L2_FBUF_CAP_SCALEUP</code> and
<code class="constant">V4L2_FBUF_CAP_SCALEDOWN</code> flags were removed.
Applications can determine this capability more accurately using the
new cropping and scaling interface. The
<code class="constant">V4L2_FBUF_CAP_CLIPPING</code> flag was replaced by
<code class="constant">V4L2_FBUF_CAP_LIST_CLIPPING</code> and
<code class="constant">V4L2_FBUF_CAP_BITMAP_CLIPPING</code>.</p></li><li class="listitem"><p>In struct <a class="link" href="media.html#v4l2-clip" title="Table 4.2. struct v4l2_clip">v4l2_clip</a> the <em class="structfield"><code>x</code></em>,
<em class="structfield"><code>y</code></em>, <em class="structfield"><code>width</code></em> and
<em class="structfield"><code>height</code></em> field moved into a
<em class="structfield"><code>c</code></em> substructure of type struct <a class="link" href="media.html#v4l2-rect" title="Table 4.3. struct v4l2_rect">v4l2_rect</a>. The
<em class="structfield"><code>x</code></em> and <em class="structfield"><code>y</code></em> fields
were renamed to <em class="structfield"><code>left</code></em> and
<em class="structfield"><code>top</code></em>, i. e. offsets to a context dependent
origin.</p></li><li class="listitem"><p>In struct <a class="link" href="media.html#v4l2-window" title="Table 4.1. struct v4l2_window">v4l2_window</a> the <em class="structfield"><code>x</code></em>,
<em class="structfield"><code>y</code></em>, <em class="structfield"><code>width</code></em> and
<em class="structfield"><code>height</code></em> field moved into a
<em class="structfield"><code>w</code></em> substructure as above. A
<em class="structfield"><code>field</code></em> field of type %v4l2-field; was added
to distinguish between field and frame (interlaced) overlay.</p></li><li class="listitem"><p>The digital zoom interface, including struct
<span class="structname">v4l2_zoomcap</span>, struct
<span class="structname">v4l2_zoom</span>,
<code class="constant">V4L2_ZOOM_NONCAP</code> and
<code class="constant">V4L2_ZOOM_WHILESTREAMING</code> was replaced by a new
cropping and scaling interface. The previously unused struct
<span class="structname">v4l2_cropcap</span> and
<span class="structname">v4l2_crop</span> where redefined for this purpose.
See <a class="xref" href="media.html#crop" title="Image Cropping, Insertion and Scaling">the section called &#8220;Image Cropping, Insertion and Scaling&#8221;</a> for details.</p></li><li class="listitem"><p>In struct <a class="link" href="media.html#v4l2-vbi-format" title="Table 4.4. struct v4l2_vbi_format">v4l2_vbi_format</a> the
<em class="structfield"><code>SAMPLE_FORMAT</code></em> field now contains a
four-character-code as used to identify video image formats and
<code class="constant">V4L2_PIX_FMT_GREY</code> replaces the
<code class="constant">V4L2_VBI_SF_UBYTE</code> define. The
<em class="structfield"><code>reserved</code></em> field was extended.</p></li><li class="listitem"><p>In struct <a class="link" href="media.html#v4l2-captureparm" title="Table A.78. struct v4l2_captureparm">v4l2_captureparm</a> the type of the
<em class="structfield"><code>timeperframe</code></em> field changed from unsigned
long to struct <a class="link" href="media.html#v4l2-fract" title="Table A.46. struct v4l2_fract">v4l2_fract</a>. This allows the accurate expression of multiples
of the NTSC-M frame rate 30000 / 1001. A new field
<em class="structfield"><code>readbuffers</code></em> was added to control the driver
behaviour in read I/O mode.</p><p>Similar changes were made to struct <a class="link" href="media.html#v4l2-outputparm" title="Table A.79. struct v4l2_outputparm">v4l2_outputparm</a>.</p></li><li class="listitem"><p>The struct <span class="structname">v4l2_performance</span>
and <code class="constant">VIDIOC_G_PERF</code> ioctl were dropped. Except when
using the <a class="link" href="media.html#rw" title="Read/Write">read/write I/O method</a>, which is
limited anyway, this information is already available to
applications.</p></li><li class="listitem"><p>The example transformation from RGB to YCbCr color
space in the old V4L2 documentation was inaccurate, this has been
corrected in <a class="xref" href="media.html#pixfmt" title="Chapter 2. Image Formats">Chapter 2, <i>Image Formats</i></a>.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73873264"></a>V4L2 2003-06-19</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A new capability flag
<code class="constant">V4L2_CAP_RADIO</code> was added for radio devices. Prior
to this change radio devices would identify solely by having exactly one
tuner whose type field reads <code class="constant">V4L2_TUNER_RADIO</code>.</p></li><li class="listitem"><p>An optional driver access priority mechanism was
added, see <a class="xref" href="media.html#app-pri" title="Application Priority">the section called &#8220;Application Priority&#8221;</a> for details.</p></li><li class="listitem"><p>The audio input and output interface was found to be
incomplete.</p><p>Previously the <a class="link" href="media.html#vidioc-g-audio" title="ioctl VIDIOC_G_AUDIO, VIDIOC_S_AUDIO"><code class="constant">VIDIOC_G_AUDIO</code></a>
ioctl would enumerate the available audio inputs. An ioctl to
determine the current audio input, if more than one combines with the
current video input, did not exist. So
<code class="constant">VIDIOC_G_AUDIO</code> was renamed to
<code class="constant">VIDIOC_G_AUDIO_OLD</code>, this ioctl was removed on
Kernel 2.6.39. The <a class="link" href="media.html#vidioc-enumaudio" title="ioctl VIDIOC_ENUMAUDIO"><code class="constant">VIDIOC_ENUMAUDIO</code></a> ioctl was added to enumerate
audio inputs, while <a class="link" href="media.html#vidioc-g-audio" title="ioctl VIDIOC_G_AUDIO, VIDIOC_S_AUDIO"><code class="constant">VIDIOC_G_AUDIO</code></a> now reports the current audio
input.</p><p>The same changes were made to <a class="link" href="media.html#vidioc-g-audioout" title="ioctl VIDIOC_G_AUDOUT, VIDIOC_S_AUDOUT"><code class="constant">VIDIOC_G_AUDOUT</code></a> and
<a class="link" href="media.html#vidioc-enumaudioout" title="ioctl VIDIOC_ENUMAUDOUT"><code class="constant">VIDIOC_ENUMAUDOUT</code></a>.</p><p>Until further the "videodev" module will automatically
translate between the old and new ioctls, but drivers and applications
must be updated to successfully compile again.</p></li><li class="listitem"><p>The <a class="link" href="media.html#vidioc-overlay" title="ioctl VIDIOC_OVERLAY"><code class="constant">VIDIOC_OVERLAY</code></a> ioctl was incorrectly defined with
write-read parameter. It was changed to write-only, while the write-read
version was renamed to <code class="constant">VIDIOC_OVERLAY_OLD</code>. The old
ioctl was removed on Kernel 2.6.39. Until further the "videodev"
kernel module will automatically translate to the new version, so drivers
must be recompiled, but not applications.</p></li><li class="listitem"><p><a class="xref" href="media.html#overlay" title="Video Overlay Interface">the section called &#8220;Video Overlay Interface&#8221;</a> incorrectly stated that
clipping rectangles define regions where the video can be seen.
Correct is that clipping rectangles define regions where
<span class="emphasis"><em>no</em></span> video shall be displayed and so the graphics
surface can be seen.</p></li><li class="listitem"><p>The <a class="link" href="media.html#vidioc-g-parm" title="ioctl VIDIOC_G_PARM, VIDIOC_S_PARM"><code class="constant">VIDIOC_S_PARM</code></a> and <a class="link" href="media.html#vidioc-g-ctrl" title="ioctl VIDIOC_G_CTRL, VIDIOC_S_CTRL"><code class="constant">VIDIOC_S_CTRL</code></a> ioctls were
defined with write-only parameter, inconsistent with other ioctls
modifying their argument. They were changed to write-read, while a
<code class="constant">_OLD</code> suffix was added to the write-only versions.
The old ioctls were removed on Kernel 2.6.39. Drivers and
applications assuming a constant parameter need an update.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73897616"></a>V4L2 2003-11-05</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>In <a class="xref" href="media.html#pixfmt-rgb" title="RGB Formats">the section called &#8220;RGB Formats&#8221;</a> the following pixel
formats were incorrectly transferred from Bill Dirks' V4L2
specification. Descriptions below refer to bytes in memory, in
ascending address order.</p><div class="informaltable"><table border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Symbol</th><th>In this document prior to revision
0.5</th><th>Corrected</th></tr></thead><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_PIX_FMT_RGB24</code></td><td valign="top">B, G, R</td><td valign="top">R, G, B</td></tr><tr><td valign="top"><code class="constant">V4L2_PIX_FMT_BGR24</code></td><td valign="top">R, G, B</td><td valign="top">B, G, R</td></tr><tr><td valign="top"><code class="constant">V4L2_PIX_FMT_RGB32</code></td><td valign="top">B, G, R, X</td><td valign="top">R, G, B, X</td></tr><tr><td valign="top"><code class="constant">V4L2_PIX_FMT_BGR32</code></td><td valign="top">R, G, B, X</td><td valign="top">B, G, R, X</td></tr></tbody></table></div><p> The
<code class="constant">V4L2_PIX_FMT_BGR24</code> example was always
correct.</p><p>In <a class="xref" href="media.html#v4l-image-properties" title="Image Properties">the section called &#8220;Image Properties&#8221;</a> the mapping
of the V4L <code class="constant">VIDEO_PALETTE_RGB24</code> and
<code class="constant">VIDEO_PALETTE_RGB32</code> formats to V4L2 pixel formats
was accordingly corrected.</p></li><li class="listitem"><p>Unrelated to the fixes above, drivers may still
interpret some V4L2 RGB pixel formats differently. These issues have
yet to be addressed, for details see <a class="xref" href="media.html#pixfmt-rgb" title="RGB Formats">the section called &#8220;RGB Formats&#8221;</a>.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73915888"></a>V4L2 in Linux 2.6.6, 2004-05-09</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The <a class="link" href="media.html#vidioc-cropcap" title="ioctl VIDIOC_CROPCAP"><code class="constant">VIDIOC_CROPCAP</code></a> ioctl was incorrectly defined
with read-only parameter. It is now defined as write-read ioctl, while
the read-only version was renamed to
<code class="constant">VIDIOC_CROPCAP_OLD</code>. The old ioctl was removed
on Kernel 2.6.39.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73919856"></a>V4L2 in Linux 2.6.8</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A new field <em class="structfield"><code>input</code></em> (former
<em class="structfield"><code>reserved[0]</code></em>) was added to the struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a>
structure. Purpose of this field is to alternate between video inputs
(e. g. cameras) in step with the video capturing process. This function
must be enabled with the new <code class="constant">V4L2_BUF_FLAG_INPUT</code>
flag. The <em class="structfield"><code>flags</code></em> field is no longer
read-only.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73925088"></a>V4L2 spec erratum 2004-08-01</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The return value of the
<a class="xref" href="media.html#func-open" title="V4L2 open()"><span class="refentrytitle">V4L2 open()</span>(2)</a> function was incorrectly documented.</p></li><li class="listitem"><p>Audio output ioctls end in -AUDOUT, not -AUDIOOUT.</p></li><li class="listitem"><p>In the Current Audio Input example the
<code class="constant">VIDIOC_G_AUDIO</code> ioctl took the wrong
argument.</p></li><li class="listitem"><p>The documentation of the <a class="link" href="media.html#vidioc-qbuf" title="ioctl VIDIOC_QBUF, VIDIOC_DQBUF"><code class="constant">VIDIOC_QBUF</code></a> and
<a class="link" href="media.html#vidioc-qbuf" title="ioctl VIDIOC_QBUF, VIDIOC_DQBUF"><code class="constant">VIDIOC_DQBUF</code></a> ioctls did not mention the struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a>
<em class="structfield"><code>memory</code></em> field. It was also missing from
examples. Also on the <code class="constant">VIDIOC_DQBUF</code> page the <span class="errorcode">EIO</span> error code
was not documented.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73934624"></a>V4L2 in Linux 2.6.14</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A new sliced VBI interface was added. It is documented
in <a class="xref" href="media.html#sliced" title="Sliced VBI Data Interface">the section called &#8220;Sliced VBI Data Interface&#8221;</a> and replaces the interface first
proposed in V4L2 specification 0.8.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73939664"></a>V4L2 in Linux 2.6.15</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The <a class="link" href="media.html#vidioc-log-status" title="ioctl VIDIOC_LOG_STATUS"><code class="constant">VIDIOC_LOG_STATUS</code></a> ioctl was added.</p></li><li class="listitem"><p>New video standards
<code class="constant">V4L2_STD_NTSC_443</code>,
<code class="constant">V4L2_STD_SECAM_LC</code>,
<code class="constant">V4L2_STD_SECAM_DK</code> (a set of SECAM D, K and K1),
and <code class="constant">V4L2_STD_ATSC</code> (a set of
<code class="constant">V4L2_STD_ATSC_8_VSB</code> and
<code class="constant">V4L2_STD_ATSC_16_VSB</code>) were defined. Note the
<code class="constant">V4L2_STD_525_60</code> set now includes
<code class="constant">V4L2_STD_NTSC_443</code>. See also <a class="xref" href="media.html#v4l2-std-id" title="Table A.47. typedef v4l2_std_id">Table A.47, &#8220;typedef <span class="structname">v4l2_std_id</span>&#8221;</a>.</p></li><li class="listitem"><p>The <code class="constant">VIDIOC_G_COMP</code> and
<code class="constant">VIDIOC_S_COMP</code> ioctl were renamed to
<code class="constant">VIDIOC_G_MPEGCOMP</code> and
<code class="constant">VIDIOC_S_MPEGCOMP</code> respectively. Their argument
was replaced by a struct
<span class="structname">v4l2_mpeg_compression</span> pointer. (The
<code class="constant">VIDIOC_G_MPEGCOMP</code> and
<code class="constant">VIDIOC_S_MPEGCOMP</code> ioctls where removed in Linux
2.6.25.)</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73952688"></a>V4L2 spec erratum 2005-11-27</h3></div></div></div><p>The capture example in <a class="xref" href="media.html#capture-example" title="Appendix D. Video Capture Example">Appendix D, <i>Video Capture Example</i></a>
called the <a class="link" href="media.html#vidioc-g-crop" title="ioctl VIDIOC_G_CROP, VIDIOC_S_CROP"><code class="constant">VIDIOC_S_CROP</code></a> ioctl without checking if cropping is
supported. In the video standard selection example in
<a class="xref" href="media.html#standard" title="Video Standards">the section called &#8220;Video Standards&#8221;</a> the <a class="link" href="media.html#vidioc-g-std" title="ioctl VIDIOC_G_STD, VIDIOC_S_STD"><code class="constant">VIDIOC_S_STD</code></a> call used the wrong
argument type.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73957168"></a>V4L2 spec erratum 2006-01-10</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The <code class="constant">V4L2_IN_ST_COLOR_KILL</code> flag in
struct <a class="link" href="media.html#v4l2-input" title="Table A.38. struct v4l2_input">v4l2_input</a> not only indicates if the color killer is enabled, but
also if it is active. (The color killer disables color decoding when
it detects no color in the video signal to improve the image
quality.)</p></li><li class="listitem"><p><a class="link" href="media.html#vidioc-g-parm" title="ioctl VIDIOC_G_PARM, VIDIOC_S_PARM"><code class="constant">VIDIOC_S_PARM</code></a> is a write-read ioctl, not write-only as
stated on its reference page. The ioctl changed in 2003 as noted above.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73962640"></a>V4L2 spec erratum 2006-02-03</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>In struct <a class="link" href="media.html#v4l2-captureparm" title="Table A.78. struct v4l2_captureparm">v4l2_captureparm</a> and struct <a class="link" href="media.html#v4l2-outputparm" title="Table A.79. struct v4l2_outputparm">v4l2_outputparm</a> the
<em class="structfield"><code>timeperframe</code></em> field gives the time in
seconds, not microseconds.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73967104"></a>V4L2 spec erratum 2006-02-04</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The <em class="structfield"><code>clips</code></em> field in
struct <a class="link" href="media.html#v4l2-window" title="Table 4.1. struct v4l2_window">v4l2_window</a> must point to an array of struct <a class="link" href="media.html#v4l2-clip" title="Table 4.2. struct v4l2_clip">v4l2_clip</a>, not a linked
list, because drivers ignore the struct
<span class="structname">v4l2_clip</span>.<em class="structfield"><code>next</code></em>
pointer.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73972448"></a>V4L2 in Linux 2.6.17</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>New video standard macros were added:
<code class="constant">V4L2_STD_NTSC_M_KR</code> (NTSC M South Korea), and the
sets <code class="constant">V4L2_STD_MN</code>,
<code class="constant">V4L2_STD_B</code>, <code class="constant">V4L2_STD_GH</code> and
<code class="constant">V4L2_STD_DK</code>. The
<code class="constant">V4L2_STD_NTSC</code> and
<code class="constant">V4L2_STD_SECAM</code> sets now include
<code class="constant">V4L2_STD_NTSC_M_KR</code> and
<code class="constant">V4L2_STD_SECAM_LC</code> respectively.</p></li><li class="listitem"><p>A new <code class="constant">V4L2_TUNER_MODE_LANG1_LANG2</code>
was defined to record both languages of a bilingual program. The
use of <code class="constant">V4L2_TUNER_MODE_STEREO</code> for this purpose
is deprecated now. See the <a class="link" href="media.html#vidioc-g-tuner" title="ioctl VIDIOC_G_TUNER, VIDIOC_S_TUNER"><code class="constant">VIDIOC_G_TUNER</code></a> section for
details.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp73981536"></a>V4L2 spec erratum 2006-09-23 (Draft 0.15)</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>In various places
<code class="constant">V4L2_BUF_TYPE_SLICED_VBI_CAPTURE</code> and
<code class="constant">V4L2_BUF_TYPE_SLICED_VBI_OUTPUT</code> of the sliced VBI
interface were not mentioned along with other buffer types.</p></li><li class="listitem"><p>In <a class="xref" href="media.html#vidioc-g-audio" title="ioctl VIDIOC_G_AUDIO, VIDIOC_S_AUDIO"><span class="refentrytitle">ioctl VIDIOC_G_AUDIO, VIDIOC_S_AUDIO</span>(2)</a> it was clarified
that the struct <a class="link" href="media.html#v4l2-audio" title="Table A.50. struct v4l2_audio">v4l2_audio</a> <em class="structfield"><code>mode</code></em> field is a flags
field.</p></li><li class="listitem"><p><a class="xref" href="media.html#vidioc-querycap" title="ioctl VIDIOC_QUERYCAP"><span class="refentrytitle">ioctl VIDIOC_QUERYCAP</span>(2)</a> did not mention the
sliced VBI and radio capability flags.</p></li><li class="listitem"><p>In <a class="xref" href="media.html#vidioc-g-frequency" title="ioctl VIDIOC_G_FREQUENCY, VIDIOC_S_FREQUENCY"><span class="refentrytitle">ioctl VIDIOC_G_FREQUENCY, VIDIOC_S_FREQUENCY</span>(2)</a> it was
clarified that applications must initialize the tuner
<em class="structfield"><code>type</code></em> field of struct <a class="link" href="media.html#v4l2-frequency" title="Table A.72. struct v4l2_frequency">v4l2_frequency</a> before
calling <a class="link" href="media.html#vidioc-g-frequency" title="ioctl VIDIOC_G_FREQUENCY, VIDIOC_S_FREQUENCY"><code class="constant">VIDIOC_S_FREQUENCY</code></a>.</p></li><li class="listitem"><p>The <em class="structfield"><code>reserved</code></em> array
in struct <a class="link" href="media.html#v4l2-requestbuffers" title="Table A.99. struct v4l2_requestbuffers">v4l2_requestbuffers</a> has 2 elements, not 32.</p></li><li class="listitem"><p>In <a class="xref" href="media.html#output" title="Video Output Interface">the section called &#8220;Video Output Interface&#8221;</a> and <a class="xref" href="media.html#raw-vbi" title="Raw VBI Data Interface">the section called &#8220;Raw VBI Data Interface&#8221;</a> the device file names
<code class="filename">/dev/vout</code> which never caught on were replaced
by <code class="filename">/dev/video</code>.</p></li><li class="listitem"><p>With Linux 2.6.15 the possible range for VBI device minor
numbers was extended from 224-239 to 224-255. Accordingly device file names
<code class="filename">/dev/vbi0</code> to <code class="filename">/dev/vbi31</code> are
possible now.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp74000640"></a>V4L2 in Linux 2.6.18</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>New ioctls <a class="link" href="media.html#vidioc-g-ext-ctrls" title="ioctl VIDIOC_G_EXT_CTRLS, VIDIOC_S_EXT_CTRLS, VIDIOC_TRY_EXT_CTRLS"><code class="constant">VIDIOC_G_EXT_CTRLS</code></a>, <a class="link" href="media.html#vidioc-g-ext-ctrls" title="ioctl VIDIOC_G_EXT_CTRLS, VIDIOC_S_EXT_CTRLS, VIDIOC_TRY_EXT_CTRLS"><code class="constant">VIDIOC_S_EXT_CTRLS</code></a>
and <a class="link" href="media.html#vidioc-g-ext-ctrls" title="ioctl VIDIOC_G_EXT_CTRLS, VIDIOC_S_EXT_CTRLS, VIDIOC_TRY_EXT_CTRLS"><code class="constant">VIDIOC_TRY_EXT_CTRLS</code></a> were added, a flag to skip unsupported
controls with <a class="link" href="media.html#vidioc-queryctrl" title="ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU"><code class="constant">VIDIOC_QUERYCTRL</code></a>, new control types
<code class="constant">V4L2_CTRL_TYPE_INTEGER64</code> and
<code class="constant">V4L2_CTRL_TYPE_CTRL_CLASS</code> (<a class="xref" href="media.html#v4l2-ctrl-type" title="Table A.97. enum v4l2_ctrl_type">Table A.97, &#8220;enum v4l2_ctrl_type&#8221;</a>), and new control flags
<code class="constant">V4L2_CTRL_FLAG_READ_ONLY</code>,
<code class="constant">V4L2_CTRL_FLAG_UPDATE</code>,
<code class="constant">V4L2_CTRL_FLAG_INACTIVE</code> and
<code class="constant">V4L2_CTRL_FLAG_SLIDER</code> (<a class="xref" href="media.html#control-flags" title="Table A.98. Control Flags">Table A.98, &#8220;Control Flags&#8221;</a>). See <a class="xref" href="media.html#extended-controls" title="Extended Controls">the section called &#8220;Extended Controls&#8221;</a> for details.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp74011472"></a>V4L2 in Linux 2.6.19</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>In struct <a class="link" href="media.html#v4l2-sliced-vbi-cap" title="Table A.84. struct v4l2_sliced_vbi_cap">v4l2_sliced_vbi_cap</a> a buffer type field was added
replacing a reserved field. Note on architectures where the size of
enum types differs from int types the size of the structure changed.
The <a class="link" href="media.html#vidioc-g-sliced-vbi-cap" title="ioctl VIDIOC_G_SLICED_VBI_CAP"><code class="constant">VIDIOC_G_SLICED_VBI_CAP</code></a> ioctl was redefined from being read-only
to write-read. Applications must initialize the type field and clear
the reserved fields now. These changes may <span class="emphasis"><em>break the
compatibility</em></span> with older drivers and applications.</p></li><li class="listitem"><p>The ioctls <a class="link" href="media.html#vidioc-enum-framesizes" title="ioctl VIDIOC_ENUM_FRAMESIZES"><code class="constant">VIDIOC_ENUM_FRAMESIZES</code></a> and
<a class="link" href="media.html#vidioc-enum-frameintervals" title="ioctl VIDIOC_ENUM_FRAMEINTERVALS"><code class="constant">VIDIOC_ENUM_FRAMEINTERVALS</code></a> were added.</p></li><li class="listitem"><p>A new pixel format <code class="constant">V4L2_PIX_FMT_RGB444</code> (<a class="xref" href="media.html#rgb-formats" title="Table 2.16. Packed RGB Image Formats">Table 2.16, &#8220;Packed RGB Image Formats&#8221;</a>) was added.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp74020480"></a>V4L2 spec erratum 2006-10-12 (Draft 0.17)</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><code class="constant">V4L2_PIX_FMT_HM12</code> (<a class="xref" href="media.html#reserved-formats" title="Table 2.20. Reserved Image Formats">Table 2.20, &#8220;Reserved Image Formats&#8221;</a>) is a YUV 4:2:0, not 4:2:2 format.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp74023952"></a>V4L2 in Linux 2.6.21</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The <code class="filename">videodev2.h</code> header file is
now dual licensed under GNU General Public License version two or
later, and under a 3-clause BSD-style license.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp74030176"></a>V4L2 in Linux 2.6.22</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Two new field orders
	  <code class="constant">V4L2_FIELD_INTERLACED_TB</code> and
	  <code class="constant">V4L2_FIELD_INTERLACED_BT</code> were
	  added. See <a class="xref" href="media.html#v4l2-field" title="Table 3.9. enum v4l2_field">Table 3.9, &#8220;enum v4l2_field&#8221;</a> for details.</p></li><li class="listitem"><p>Three new clipping/blending methods with a global or
straight or inverted local alpha value were added to the video overlay
interface. See the description of the <a class="link" href="media.html#vidioc-g-fbuf" title="ioctl VIDIOC_G_FBUF, VIDIOC_S_FBUF"><code class="constant">VIDIOC_G_FBUF</code></a> and
<a class="link" href="media.html#vidioc-g-fbuf" title="ioctl VIDIOC_G_FBUF, VIDIOC_S_FBUF"><code class="constant">VIDIOC_S_FBUF</code></a> ioctls for details.</p><p>A new <em class="structfield"><code>global_alpha</code></em> field
was added to <a class="link" href="media.html#v4l2-window" title="Table 4.1. struct v4l2_window"><span class="structname">v4l2_window</span></a>,
extending the structure. This may <span class="emphasis"><em>break
compatibility</em></span> with applications using a struct
<span class="structname">v4l2_window</span> directly. However the <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT">VIDIOC_G/S/TRY_FMT</a> ioctls, which take a
pointer to a <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a> parent
structure with padding bytes at the end, are not affected.</p></li><li class="listitem"><p>The format of the <em class="structfield"><code>chromakey</code></em>
field in struct <a class="link" href="media.html#v4l2-window" title="Table 4.1. struct v4l2_window">v4l2_window</a> changed from "host order RGB32" to a pixel
value in the same format as the framebuffer. This may <span class="emphasis"><em>break
compatibility</em></span> with existing applications. Drivers
supporting the "host order RGB32" format are not known.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp74044000"></a>V4L2 in Linux 2.6.24</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The pixel formats
<code class="constant">V4L2_PIX_FMT_PAL8</code>,
<code class="constant">V4L2_PIX_FMT_YUV444</code>,
<code class="constant">V4L2_PIX_FMT_YUV555</code>,
<code class="constant">V4L2_PIX_FMT_YUV565</code> and
<code class="constant">V4L2_PIX_FMT_YUV32</code> were added.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp74048672"></a>V4L2 in Linux 2.6.25</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The pixel formats <a class="link" href="media.html#V4L2-PIX-FMT-Y16" title="V4L2_PIX_FMT_Y16 ('Y16 ')">
<code class="constant">V4L2_PIX_FMT_Y16</code></a> and <a class="link" href="media.html#V4L2-PIX-FMT-SBGGR16" title="V4L2_PIX_FMT_SBGGR16 ('BYR2')">
<code class="constant">V4L2_PIX_FMT_SBGGR16</code></a> were added.</p></li><li class="listitem"><p>New <a class="link" href="media.html#control" title="User Controls">controls</a>
<code class="constant">V4L2_CID_POWER_LINE_FREQUENCY</code>,
<code class="constant">V4L2_CID_HUE_AUTO</code>,
<code class="constant">V4L2_CID_WHITE_BALANCE_TEMPERATURE</code>,
<code class="constant">V4L2_CID_SHARPNESS</code> and
<code class="constant">V4L2_CID_BACKLIGHT_COMPENSATION</code> were added. The
controls <code class="constant">V4L2_CID_BLACK_LEVEL</code>,
<code class="constant">V4L2_CID_WHITENESS</code>,
<code class="constant">V4L2_CID_HCENTER</code> and
<code class="constant">V4L2_CID_VCENTER</code> were deprecated.
</p></li><li class="listitem"><p>A <a class="link" href="media.html#camera-controls" title="Camera Control Reference">Camera controls
class</a> was added, with the new controls
<code class="constant">V4L2_CID_EXPOSURE_AUTO</code>,
<code class="constant">V4L2_CID_EXPOSURE_ABSOLUTE</code>,
<code class="constant">V4L2_CID_EXPOSURE_AUTO_PRIORITY</code>,
<code class="constant">V4L2_CID_PAN_RELATIVE</code>,
<code class="constant">V4L2_CID_TILT_RELATIVE</code>,
<code class="constant">V4L2_CID_PAN_RESET</code>,
<code class="constant">V4L2_CID_TILT_RESET</code>,
<code class="constant">V4L2_CID_PAN_ABSOLUTE</code>,
<code class="constant">V4L2_CID_TILT_ABSOLUTE</code>,
<code class="constant">V4L2_CID_FOCUS_ABSOLUTE</code>,
<code class="constant">V4L2_CID_FOCUS_RELATIVE</code> and
<code class="constant">V4L2_CID_FOCUS_AUTO</code>.</p></li><li class="listitem"><p>The <code class="constant">VIDIOC_G_MPEGCOMP</code> and
<code class="constant">VIDIOC_S_MPEGCOMP</code> ioctls, which were superseded
by the <a class="link" href="media.html#extended-controls" title="Extended Controls">extended controls</a>
interface in Linux 2.6.18, where finally removed from the
<code class="filename">videodev2.h</code> header file.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp74069136"></a>V4L2 in Linux 2.6.26</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The pixel formats
<code class="constant">V4L2_PIX_FMT_Y16</code> and
<code class="constant">V4L2_PIX_FMT_SBGGR16</code> were added.</p></li><li class="listitem"><p>Added user controls
<code class="constant">V4L2_CID_CHROMA_AGC</code> and
<code class="constant">V4L2_CID_COLOR_KILLER</code>.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp74074224"></a>V4L2 in Linux 2.6.27</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The <a class="link" href="media.html#vidioc-s-hw-freq-seek" title="ioctl VIDIOC_S_HW_FREQ_SEEK"><code class="constant">VIDIOC_S_HW_FREQ_SEEK</code></a> ioctl and the
<code class="constant">V4L2_CAP_HW_FREQ_SEEK</code> capability were added.</p></li><li class="listitem"><p>The pixel formats
<code class="constant">V4L2_PIX_FMT_YVYU</code>,
<code class="constant">V4L2_PIX_FMT_PCA501</code>,
<code class="constant">V4L2_PIX_FMT_PCA505</code>,
<code class="constant">V4L2_PIX_FMT_PCA508</code>,
<code class="constant">V4L2_PIX_FMT_PCA561</code>,
<code class="constant">V4L2_PIX_FMT_SGBRG8</code>,
<code class="constant">V4L2_PIX_FMT_PAC207</code> and
<code class="constant">V4L2_PIX_FMT_PJPG</code> were added.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp74082240"></a>V4L2 in Linux 2.6.28</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Added <code class="constant">V4L2_MPEG_AUDIO_ENCODING_AAC</code> and
<code class="constant">V4L2_MPEG_AUDIO_ENCODING_AC3</code> MPEG audio encodings.</p></li><li class="listitem"><p>Added <code class="constant">V4L2_MPEG_VIDEO_ENCODING_MPEG_4_AVC</code> MPEG
video encoding.</p></li><li class="listitem"><p>The pixel formats
<code class="constant">V4L2_PIX_FMT_SGRBG10</code> and
<code class="constant">V4L2_PIX_FMT_SGRBG10DPCM8</code> were added.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp74088448"></a>V4L2 in Linux 2.6.29</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The <code class="constant">VIDIOC_G_CHIP_IDENT</code> ioctl was renamed
to <code class="constant">VIDIOC_G_CHIP_IDENT_OLD</code> and <code class="constant">VIDIOC_DBG_G_CHIP_IDENT</code>
was introduced in its place. The old struct <span class="structname">v4l2_chip_ident</span>
was renamed to <span class="structname"><a name="v4l2-chip-ident-old"></a>v4l2_chip_ident_old</span>.</p></li><li class="listitem"><p>The pixel formats
<code class="constant">V4L2_PIX_FMT_VYUY</code>,
<code class="constant">V4L2_PIX_FMT_NV16</code> and
<code class="constant">V4L2_PIX_FMT_NV61</code> were added.</p></li><li class="listitem"><p>Added camera controls
<code class="constant">V4L2_CID_ZOOM_ABSOLUTE</code>,
<code class="constant">V4L2_CID_ZOOM_RELATIVE</code>,
<code class="constant">V4L2_CID_ZOOM_CONTINUOUS</code> and
<code class="constant">V4L2_CID_PRIVACY</code>.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp74098320"></a>V4L2 in Linux 2.6.30</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>New control flag <code class="constant">V4L2_CTRL_FLAG_WRITE_ONLY</code> was added.</p></li><li class="listitem"><p>New control <code class="constant">V4L2_CID_COLORFX</code> was added.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp74102560"></a>V4L2 in Linux 2.6.32</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>In order to be easier to compare a V4L2 API and a kernel
version, now V4L2 API is numbered using the Linux Kernel version numeration.</p></li><li class="listitem"><p>Finalized the RDS capture API. See <a class="xref" href="media.html#rds" title="RDS Interface">the section called &#8220;RDS Interface&#8221;</a> for
more information.</p></li><li class="listitem"><p>Added new capabilities for modulators and RDS encoders.</p></li><li class="listitem"><p>Add description for libv4l API.</p></li><li class="listitem"><p>Added support for string controls via new type <code class="constant">V4L2_CTRL_TYPE_STRING</code>.</p></li><li class="listitem"><p>Added <code class="constant">V4L2_CID_BAND_STOP_FILTER</code> documentation.</p></li><li class="listitem"><p>Added FM Modulator (FM TX) Extended Control Class: <code class="constant">V4L2_CTRL_CLASS_FM_TX</code> and their Control IDs.</p></li><li class="listitem"><p>Added FM Receiver (FM RX) Extended Control Class: <code class="constant">V4L2_CTRL_CLASS_FM_RX</code> and their Control IDs.</p></li><li class="listitem"><p>Added Remote Controller chapter, describing the default Remote Controller mapping for media devices.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp74114320"></a>V4L2 in Linux 2.6.33</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Added support for Digital Video timings in order to support HDTV receivers and transmitters.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp74116928"></a>V4L2 in Linux 2.6.34</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Added
<code class="constant">V4L2_CID_IRIS_ABSOLUTE</code> and
<code class="constant">V4L2_CID_IRIS_RELATIVE</code> controls to the
	    <a class="link" href="media.html#camera-controls" title="Camera Control Reference">Camera controls class</a>.
	  </p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp74121184"></a>V4L2 in Linux 2.6.37</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Remove the vtx (videotext/teletext) API. This API was no longer
used and no hardware exists to verify the API. Nor were any userspace applications found
that used it. It was originally scheduled for removal in 2.6.35.
	  </p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp74123920"></a>V4L2 in Linux 2.6.39</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The old VIDIOC_*_OLD symbols and V4L1 support were removed.</p></li><li class="listitem"><p>Multi-planar API added. Does not affect the compatibility of
          current drivers and applications. See
          <a class="link" href="media.html#planar-apis" title="Single- and multi-planar APIs">multi-planar API</a>
          for details.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp74128224"></a>V4L2 in Linux 3.1</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>VIDIOC_QUERYCAP now returns a per-subsystem version instead of a per-driver one.</p><p>Standardize an error code for invalid ioctl.</p><p>Added V4L2_CTRL_TYPE_BITMASK.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp74131696"></a>V4L2 in Linux 3.2</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>V4L2_CTRL_FLAG_VOLATILE was added to signal volatile controls to userspace.</p></li><li class="listitem"><p>Add selection API for extended control over cropping
	  and composing. Does not affect the compatibility of current
	  drivers and applications. See <a class="link" href="media.html#selection-api" title="Experimental API for cropping, composing and scaling"> selection API </a> for
	  details.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp74136112"></a>V4L2 in Linux 3.3</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Added <code class="constant">V4L2_CID_ALPHA_COMPONENT</code> control
	    to the <a class="link" href="media.html#control" title="User Controls">User controls class</a>.
	  </p></li><li class="listitem"><p>Added the device_caps field to struct v4l2_capabilities and added the new
	  V4L2_CAP_DEVICE_CAPS capability.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp74140832"></a>V4L2 in Linux 3.4</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Added <a class="link" href="media.html#jpeg-controls" title="JPEG Control Reference">JPEG compression control
	  class</a>.</p></li><li class="listitem"><p>Extended the DV Timings API:
	  <a class="link" href="media.html#vidioc-enum-dv-timings" title="ioctl VIDIOC_ENUM_DV_TIMINGS, VIDIOC_SUBDEV_ENUM_DV_TIMINGS"><code class="constant">VIDIOC_ENUM_DV_TIMINGS</code></a>, <a class="link" href="media.html#vidioc-query-dv-timings" title="ioctl VIDIOC_QUERY_DV_TIMINGS"><code class="constant">VIDIOC_QUERY_DV_TIMINGS</code></a> and
	  <a class="link" href="media.html#vidioc-dv-timings-cap" title="ioctl VIDIOC_DV_TIMINGS_CAP, VIDIOC_SUBDEV_DV_TIMINGS_CAP"><code class="constant">VIDIOC_DV_TIMINGS_CAP</code></a>.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp74147504"></a>V4L2 in Linux 3.5</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Added integer menus, the new type will be
	  V4L2_CTRL_TYPE_INTEGER_MENU.</p></li><li class="listitem"><p>Added selection API for V4L2 subdev interface:
	  <a class="link" href="media.html#vidioc-subdev-g-selection" title="ioctl VIDIOC_SUBDEV_G_SELECTION, VIDIOC_SUBDEV_S_SELECTION"><code class="constant">VIDIOC_SUBDEV_G_SELECTION</code></a> and
	  <a class="link" href="media.html#vidioc-subdev-g-selection" title="ioctl VIDIOC_SUBDEV_G_SELECTION, VIDIOC_SUBDEV_S_SELECTION"><code class="constant">VIDIOC_SUBDEV_S_SELECTION</code></a>.</p></li><li class="listitem"><p> Added <code class="constant">V4L2_COLORFX_ANTIQUE</code>,
	  <code class="constant">V4L2_COLORFX_ART_FREEZE</code>,
	  <code class="constant">V4L2_COLORFX_AQUA</code>,
	  <code class="constant">V4L2_COLORFX_SILHOUETTE</code>,
	  <code class="constant">V4L2_COLORFX_SOLARIZATION</code>,
	  <code class="constant">V4L2_COLORFX_VIVID</code> and
	  <code class="constant">V4L2_COLORFX_ARBITRARY_CBCR</code> menu items
	  to the <code class="constant">V4L2_CID_COLORFX</code> control.</p></li><li class="listitem"><p> Added <code class="constant">V4L2_CID_COLORFX_CBCR</code> control.</p></li><li class="listitem"><p> Added camera controls <code class="constant">V4L2_CID_AUTO_EXPOSURE_BIAS</code>,
	  <code class="constant">V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE</code>,
	  <code class="constant">V4L2_CID_IMAGE_STABILIZATION</code>,
	  <code class="constant">V4L2_CID_ISO_SENSITIVITY</code>,
	  <code class="constant">V4L2_CID_ISO_SENSITIVITY_AUTO</code>,
	  <code class="constant">V4L2_CID_EXPOSURE_METERING</code>,
	  <code class="constant">V4L2_CID_SCENE_MODE</code>,
	  <code class="constant">V4L2_CID_3A_LOCK</code>,
	  <code class="constant">V4L2_CID_AUTO_FOCUS_START</code>,
	  <code class="constant">V4L2_CID_AUTO_FOCUS_STOP</code>,
	  <code class="constant">V4L2_CID_AUTO_FOCUS_STATUS</code> and
	  <code class="constant">V4L2_CID_AUTO_FOCUS_RANGE</code>.
	  </p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp74165904"></a>V4L2 in Linux 3.6</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Replaced <em class="structfield"><code>input</code></em> in
	  <span class="structname">v4l2_buffer</span> by
	  <em class="structfield"><code>reserved2</code></em> and removed
	  <code class="constant">V4L2_BUF_FLAG_INPUT</code>.</p></li><li class="listitem"><p>Added V4L2_CAP_VIDEO_M2M and V4L2_CAP_VIDEO_M2M_MPLANE capabilities.</p></li><li class="listitem"><p>Added support for frequency band enumerations: <a class="link" href="media.html#vidioc-enum-freq-bands" title="ioctl VIDIOC_ENUM_FREQ_BANDS"><code class="constant">VIDIOC_ENUM_FREQ_BANDS</code></a>.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp74171856"></a>V4L2 in Linux 3.9</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Added timestamp types to
	  <em class="structfield"><code>flags</code></em> field in
	  <span class="structname">v4l2_buffer</span>. See <a class="xref" href="media.html#buffer-flags" title="Table 3.4. Buffer Flags">Table 3.4, &#8220;Buffer Flags&#8221;</a>.</p></li><li class="listitem"><p>Added <code class="constant">V4L2_EVENT_CTRL_CH_RANGE</code> control event
	  changes flag. See <a class="xref" href="media.html#changes-flags" title="Table A.18. Changes">Table A.18, &#8220;Changes&#8221;</a>.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp74179504"></a>V4L2 in Linux 3.10</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Removed obsolete and unused DV_PRESET ioctls
	  VIDIOC_G_DV_PRESET, VIDIOC_S_DV_PRESET, VIDIOC_QUERY_DV_PRESET and
	  VIDIOC_ENUM_DV_PRESET. Remove the related v4l2_input/output capability
	  flags V4L2_IN_CAP_PRESETS and V4L2_OUT_CAP_PRESETS.
	  </p></li><li class="listitem"><p>Added new debugging ioctl <a class="link" href="media.html#vidioc-dbg-g-chip-info" title="ioctl VIDIOC_DBG_G_CHIP_INFO"><code class="constant">VIDIOC_DBG_G_CHIP_INFO</code></a>.
	  </p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp74183200"></a>V4L2 in Linux 3.11</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Remove obsolete <code class="constant">VIDIOC_DBG_G_CHIP_IDENT</code> ioctl.
	  </p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp74187760"></a>V4L2 in Linux 3.14</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p> In struct <span class="structname">v4l2_rect</span>, the type
of <em class="structfield"><code>width</code></em> and <em class="structfield"><code>height</code></em>
fields changed from _s32 to _u32.
	  </p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp74191600"></a>V4L2 in Linux 3.15</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Added Software Defined Radio (SDR) Interface.
	  </p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp74194096"></a>V4L2 in Linux 3.16</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Added event V4L2_EVENT_SOURCE_CHANGE.
	  </p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp74196656"></a>V4L2 in Linux 3.17</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Extended struct <a class="link" href="media.html#v4l2-pix-format" title="Table 2.1. struct v4l2_pix_format">v4l2_pix_format</a>. Added format flags.
	  </p></li><li class="listitem"><p>Added compound control types and <a class="link" href="media.html#vidioc-queryctrl" title="ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU"><code class="constant">VIDIOC_QUERY_EXT_CTRL</code></a>.
	  </p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp74201536"></a>V4L2 in Linux 3.18</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Added <code class="constant">V4L2_CID_PAN_SPEED</code> and
 <code class="constant">V4L2_CID_TILT_SPEED</code> camera controls.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp74204960"></a>V4L2 in Linux 3.19</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Rewrote Colorspace chapter, added new enum <a class="link" href="media.html#v4l2-ycbcr-encoding" title="Table 2.5. V4L2 Y'CbCr Encodings">v4l2_ycbcr_encoding</a>
and enum <a class="link" href="media.html#v4l2-quantization" title="Table 2.6. V4L2 Quantization Methods">v4l2_quantization</a> fields to struct <a class="link" href="media.html#v4l2-pix-format" title="Table 2.1. struct v4l2_pix_format">v4l2_pix_format</a>, struct <a class="link" href="media.html#v4l2-pix-format-mplane" title="Table 2.3. struct v4l2_pix_format_mplane">v4l2_pix_format_mplane</a>
and struct <a class="link" href="media.html#v4l2-mbus-framefmt" title="Table 4.20. struct v4l2_mbus_framefmt">v4l2_mbus_framefmt</a>.
	  </p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="other"></a>Relation of V4L2 to other Linux multimedia APIs</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#xvideo">X Video Extension</a></span></dt><dt><span class="section"><a href="media.html#idp74220832">Digital Video</a></span></dt><dt><span class="section"><a href="media.html#idp74222976">Audio Interfaces</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="xvideo"></a>X Video Extension</h4></div></div></div><p>The X Video Extension (abbreviated XVideo or just Xv) is
an extension of the X Window system, implemented for example by the
XFree86 project. Its scope is similar to V4L2, an API to video capture
and output devices for X clients. Xv allows applications to display
live video in a window, send window contents to a TV output, and
capture or output still images in XPixmaps<a href="media.html#ftn.idp74214048" class="footnote" name="idp74214048"><sup class="footnote">[17]</sup></a>. With their implementation XFree86 makes the
extension available across many operating systems and
architectures.</p><p>Because the driver is embedded into the X server Xv has a
number of advantages over the V4L2 <a class="link" href="media.html#overlay" title="Video Overlay Interface">video
overlay interface</a>. The driver can easily determine the overlay
target, i. e. visible graphics memory or off-screen buffers for a
destructive overlay. It can program the RAMDAC for a non-destructive
overlay, scaling or color-keying, or the clipping functions of the
video capture hardware, always in sync with drawing operations or
windows moving or changing their stacking order.</p><p>To combine the advantages of Xv and V4L a special Xv
driver exists in XFree86 and XOrg, just programming any overlay capable
Video4Linux device it finds. To enable it
<code class="filename">/etc/X11/XF86Config</code> must contain these lines:</p><pre class="screen">
Section "Module"
    Load "v4l"
EndSection</pre><p>As of XFree86 4.2 this driver still supports only V4L
ioctls, however it should work just fine with all V4L2 devices through
the V4L2 backward-compatibility layer. Since V4L2 permits multiple
opens it is possible (if supported by the V4L2 driver) to capture
video while an X client requested video overlay. Restrictions of
simultaneous capturing and overlay are discussed in <a class="xref" href="media.html#overlay" title="Video Overlay Interface">the section called &#8220;Video Overlay Interface&#8221;</a> apply.</p><p>Only marginally related to V4L2, XFree86 extended Xv to
support hardware YUV to RGB conversion and scaling for faster video
playback, and added an interface to MPEG-2 decoding hardware. This API
is useful to display images captured with V4L2 devices.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp74220832"></a>Digital Video</h4></div></div></div><p>V4L2 does not support digital terrestrial, cable or
satellite broadcast. A separate project aiming at digital receivers
exists. You can find its homepage at <a class="ulink" href="http://linuxtv.org" target="_top">http://linuxtv.org</a>. The Linux DVB API
has no connection to the V4L2 API except that drivers for hybrid
hardware may support both.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp74222976"></a>Audio Interfaces</h4></div></div></div><p>[to do - OSS/ALSA]</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="experimental"></a>Experimental API Elements</h3></div></div></div><p>The following V4L2 API elements are currently experimental
and may change in the future.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Video Output Overlay (OSD) Interface, <a class="xref" href="media.html#osd" title="Video Output Overlay Interface">the section called &#8220;Video Output Overlay Interface&#8221;</a>.</p></li><li class="listitem"><p><a class="link" href="media.html#vidioc-dbg-g-register" title="ioctl VIDIOC_DBG_G_REGISTER, VIDIOC_DBG_S_REGISTER"><code class="constant">VIDIOC_DBG_G_REGISTER</code></a> and <a class="link" href="media.html#vidioc-dbg-g-register" title="ioctl VIDIOC_DBG_G_REGISTER, VIDIOC_DBG_S_REGISTER"><code class="constant">VIDIOC_DBG_S_REGISTER</code></a>
ioctls.</p></li><li class="listitem"><p><a class="link" href="media.html#vidioc-dbg-g-chip-info" title="ioctl VIDIOC_DBG_G_CHIP_INFO"><code class="constant">VIDIOC_DBG_G_CHIP_INFO</code></a> ioctl.</p></li><li class="listitem"><p><a class="link" href="media.html#vidioc-enum-dv-timings" title="ioctl VIDIOC_ENUM_DV_TIMINGS, VIDIOC_SUBDEV_ENUM_DV_TIMINGS"><code class="constant">VIDIOC_ENUM_DV_TIMINGS</code></a>, <a class="link" href="media.html#vidioc-query-dv-timings" title="ioctl VIDIOC_QUERY_DV_TIMINGS"><code class="constant">VIDIOC_QUERY_DV_TIMINGS</code></a> and
	  <a class="link" href="media.html#vidioc-dv-timings-cap" title="ioctl VIDIOC_DV_TIMINGS_CAP, VIDIOC_SUBDEV_DV_TIMINGS_CAP"><code class="constant">VIDIOC_DV_TIMINGS_CAP</code></a> ioctls.</p></li><li class="listitem"><p>Flash API. <a class="xref" href="media.html#flash-controls" title="Flash Control Reference">the section called &#8220;Flash Control Reference&#8221;</a></p></li><li class="listitem"><p><a class="link" href="media.html#vidioc-create-bufs" title="ioctl VIDIOC_CREATE_BUFS"><code class="constant">VIDIOC_CREATE_BUFS</code></a> and <a class="link" href="media.html#vidioc-prepare-buf" title="ioctl VIDIOC_PREPARE_BUF"><code class="constant">VIDIOC_PREPARE_BUF</code></a> ioctls.</p></li><li class="listitem"><p>Selection API. <a class="xref" href="media.html#selection-api" title="Experimental API for cropping, composing and scaling">the section called &#8220;Experimental API for cropping, composing and scaling&#8221;</a></p></li><li class="listitem"><p>Sub-device selection API: <a class="link" href="media.html#vidioc-subdev-g-selection" title="ioctl VIDIOC_SUBDEV_G_SELECTION, VIDIOC_SUBDEV_S_SELECTION"><code class="constant">VIDIOC_SUBDEV_G_SELECTION</code></a>
	  and <a class="link" href="media.html#vidioc-subdev-g-selection" title="ioctl VIDIOC_SUBDEV_G_SELECTION, VIDIOC_SUBDEV_S_SELECTION"><code class="constant">VIDIOC_SUBDEV_S_SELECTION</code></a> ioctls.</p></li><li class="listitem"><p>Support for frequency band enumeration: <a class="link" href="media.html#vidioc-enum-freq-bands" title="ioctl VIDIOC_ENUM_FREQ_BANDS"><code class="constant">VIDIOC_ENUM_FREQ_BANDS</code></a> ioctl.</p></li><li class="listitem"><p>Vendor and device specific media bus pixel formats.
	    <a class="xref" href="media.html#v4l2-mbus-vendor-spec-fmts" title="Vendor and Device Specific Formats">the section called &#8220;Vendor and Device Specific Formats&#8221;</a>.</p></li><li class="listitem"><p>Importing DMABUF file descriptors as a new IO method described
	  in <a class="xref" href="media.html#dmabuf" title="Streaming I/O (DMA buffer importing)">the section called &#8220;Streaming I/O (DMA buffer importing)&#8221;</a>.</p></li><li class="listitem"><p>Exporting DMABUF files using <a class="link" href="media.html#vidioc-expbuf" title="ioctl VIDIOC_EXPBUF"><code class="constant">VIDIOC_EXPBUF</code></a> ioctl.</p></li><li class="listitem"><p>Software Defined Radio (SDR) Interface, <a class="xref" href="media.html#sdr" title="Software Defined Radio Interface (SDR)">the section called &#8220;Software Defined Radio Interface (SDR)&#8221;</a>.</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="obsolete"></a>Obsolete API Elements</h3></div></div></div><p>The following V4L2 API elements were superseded by new
interfaces and should not be implemented in new drivers.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="constant">VIDIOC_G_MPEGCOMP</code> and
<code class="constant">VIDIOC_S_MPEGCOMP</code> ioctls. Use Extended Controls,
<a class="xref" href="media.html#extended-controls" title="Extended Controls">the section called &#8220;Extended Controls&#8221;</a>.</p></li><li class="listitem"><p>VIDIOC_G_DV_PRESET, VIDIOC_S_DV_PRESET, VIDIOC_ENUM_DV_PRESETS and
	  VIDIOC_QUERY_DV_PRESET ioctls. Use the DV Timings API (<a class="xref" href="media.html#dv-timings" title="Digital Video (DV) Timings">the section called &#8220;Digital Video (DV) Timings&#8221;</a>).</p></li><li class="listitem"><p><code class="constant">VIDIOC_SUBDEV_G_CROP</code> and
	  <code class="constant">VIDIOC_SUBDEV_S_CROP</code> ioctls. Use
	  <code class="constant">VIDIOC_SUBDEV_G_SELECTION</code> and
	  <code class="constant">VIDIOC_SUBDEV_S_SELECTION</code>, <a class="xref" href="media.html#vidioc-subdev-g-selection" title="ioctl VIDIOC_SUBDEV_G_SELECTION, VIDIOC_SUBDEV_S_SELECTION"><span class="refentrytitle">ioctl VIDIOC_SUBDEV_G_SELECTION, VIDIOC_SUBDEV_S_SELECTION</span>(2)</a>.</p></li></ul></div></div></div><div class="footnotes"><br><hr style="width:100; text-align:left;margin-left: 0"><div id="ftn.idp74214048" class="footnote"><p><a href="media.html#idp74214048" class="para"><sup class="para">[17] </sup></a>This is not implemented in XFree86.</p></div></div></div><div class="appendix"><div class="titlepage"><div><div><h2 class="title"><a name="user-func"></a>Appendix A. Function Reference</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="refentrytitle"><a href="media.html#func-close">V4L2 close()</a></span><span class="refpurpose"> &#8212; Close a V4L2 device</span></dt><dt><span class="refentrytitle"><a href="media.html#func-ioctl">V4L2 ioctl()</a></span><span class="refpurpose"> &#8212; Program a V4L2 device</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-create-bufs">ioctl VIDIOC_CREATE_BUFS</a></span><span class="refpurpose"> &#8212; Create buffers for Memory Mapped or User Pointer or DMA Buffer
    I/O</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-cropcap">ioctl VIDIOC_CROPCAP</a></span><span class="refpurpose"> &#8212; Information about the video cropping and scaling abilities</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-dbg-g-chip-info">ioctl VIDIOC_DBG_G_CHIP_INFO</a></span><span class="refpurpose"> &#8212; Identify the chips on a TV card</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-dbg-g-register">ioctl VIDIOC_DBG_G_REGISTER, VIDIOC_DBG_S_REGISTER</a></span><span class="refpurpose"> &#8212; Read or write hardware registers</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-decoder-cmd">ioctl VIDIOC_DECODER_CMD, VIDIOC_TRY_DECODER_CMD</a></span><span class="refpurpose"> &#8212; Execute an decoder command</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-dqevent">ioctl VIDIOC_DQEVENT</a></span><span class="refpurpose"> &#8212; Dequeue event</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-dv-timings-cap">ioctl VIDIOC_DV_TIMINGS_CAP, VIDIOC_SUBDEV_DV_TIMINGS_CAP</a></span><span class="refpurpose"> &#8212; The capabilities of the Digital Video receiver/transmitter</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-encoder-cmd">ioctl VIDIOC_ENCODER_CMD, VIDIOC_TRY_ENCODER_CMD</a></span><span class="refpurpose"> &#8212; Execute an encoder command</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-enumaudio">ioctl VIDIOC_ENUMAUDIO</a></span><span class="refpurpose"> &#8212; Enumerate audio inputs</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-enumaudioout">ioctl VIDIOC_ENUMAUDOUT</a></span><span class="refpurpose"> &#8212; Enumerate audio outputs</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-enum-dv-timings">ioctl VIDIOC_ENUM_DV_TIMINGS, VIDIOC_SUBDEV_ENUM_DV_TIMINGS</a></span><span class="refpurpose"> &#8212; Enumerate supported Digital Video timings</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-enum-fmt">ioctl VIDIOC_ENUM_FMT</a></span><span class="refpurpose"> &#8212; Enumerate image formats</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-enum-framesizes">ioctl VIDIOC_ENUM_FRAMESIZES</a></span><span class="refpurpose"> &#8212; Enumerate frame sizes</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-enum-frameintervals">ioctl VIDIOC_ENUM_FRAMEINTERVALS</a></span><span class="refpurpose"> &#8212; Enumerate frame intervals</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-enum-freq-bands">ioctl VIDIOC_ENUM_FREQ_BANDS</a></span><span class="refpurpose"> &#8212; Enumerate supported frequency bands</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-enuminput">ioctl VIDIOC_ENUMINPUT</a></span><span class="refpurpose"> &#8212; Enumerate video inputs</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-enumoutput">ioctl VIDIOC_ENUMOUTPUT</a></span><span class="refpurpose"> &#8212; Enumerate video outputs</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-enumstd">ioctl VIDIOC_ENUMSTD</a></span><span class="refpurpose"> &#8212; Enumerate supported video standards</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-expbuf">ioctl VIDIOC_EXPBUF</a></span><span class="refpurpose"> &#8212; Export a buffer as a DMABUF file descriptor.</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-audio">ioctl VIDIOC_G_AUDIO, VIDIOC_S_AUDIO</a></span><span class="refpurpose"> &#8212; Query or select the current audio input and its
attributes</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-audioout">ioctl VIDIOC_G_AUDOUT, VIDIOC_S_AUDOUT</a></span><span class="refpurpose"> &#8212; Query or select the current audio output</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-crop">ioctl VIDIOC_G_CROP, VIDIOC_S_CROP</a></span><span class="refpurpose"> &#8212; Get or set the current cropping rectangle</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-ctrl">ioctl VIDIOC_G_CTRL, VIDIOC_S_CTRL</a></span><span class="refpurpose"> &#8212; Get or set the value of a control</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-dv-timings">ioctl VIDIOC_G_DV_TIMINGS, VIDIOC_S_DV_TIMINGS</a></span><span class="refpurpose"> &#8212; Get or set DV timings for input or output</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-edid">ioctl VIDIOC_G_EDID, VIDIOC_S_EDID</a></span><span class="refpurpose"> &#8212; Get or set the EDID of a video receiver/transmitter</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-enc-index">ioctl VIDIOC_G_ENC_INDEX</a></span><span class="refpurpose"> &#8212; Get meta data about a compressed video stream</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-ext-ctrls">ioctl VIDIOC_G_EXT_CTRLS, VIDIOC_S_EXT_CTRLS,
VIDIOC_TRY_EXT_CTRLS</a></span><span class="refpurpose"> &#8212; Get or set the value of several controls, try control
values</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-fbuf">ioctl VIDIOC_G_FBUF, VIDIOC_S_FBUF</a></span><span class="refpurpose"> &#8212; Get or set frame buffer overlay parameters</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-fmt">ioctl VIDIOC_G_FMT, VIDIOC_S_FMT,
VIDIOC_TRY_FMT</a></span><span class="refpurpose"> &#8212; Get or set the data format, try a format</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-frequency">ioctl VIDIOC_G_FREQUENCY, VIDIOC_S_FREQUENCY</a></span><span class="refpurpose"> &#8212; Get or set tuner or modulator radio
frequency</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-input">ioctl VIDIOC_G_INPUT, VIDIOC_S_INPUT</a></span><span class="refpurpose"> &#8212; Query or select the current video input</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-jpegcomp">ioctl VIDIOC_G_JPEGCOMP, VIDIOC_S_JPEGCOMP</a></span><span class="refpurpose"></span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-modulator">ioctl VIDIOC_G_MODULATOR, VIDIOC_S_MODULATOR</a></span><span class="refpurpose"> &#8212; Get or set modulator attributes</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-output">ioctl VIDIOC_G_OUTPUT, VIDIOC_S_OUTPUT</a></span><span class="refpurpose"> &#8212; Query or select the current video output</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-parm">ioctl VIDIOC_G_PARM, VIDIOC_S_PARM</a></span><span class="refpurpose"> &#8212; Get or set streaming parameters</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-priority">ioctl VIDIOC_G_PRIORITY, VIDIOC_S_PRIORITY</a></span><span class="refpurpose"> &#8212; Query or request the access priority associated with a
file descriptor</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-selection">ioctl VIDIOC_G_SELECTION, VIDIOC_S_SELECTION</a></span><span class="refpurpose"> &#8212; Get or set one of the selection rectangles</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-sliced-vbi-cap">ioctl VIDIOC_G_SLICED_VBI_CAP</a></span><span class="refpurpose"> &#8212; Query sliced VBI capabilities</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-std">ioctl VIDIOC_G_STD, VIDIOC_S_STD</a></span><span class="refpurpose"> &#8212; Query or select the video standard of the current input</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-g-tuner">ioctl VIDIOC_G_TUNER, VIDIOC_S_TUNER</a></span><span class="refpurpose"> &#8212; Get or set tuner attributes</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-log-status">ioctl VIDIOC_LOG_STATUS</a></span><span class="refpurpose"> &#8212; Log driver status information</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-overlay">ioctl VIDIOC_OVERLAY</a></span><span class="refpurpose"> &#8212; Start or stop video overlay</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-prepare-buf">ioctl VIDIOC_PREPARE_BUF</a></span><span class="refpurpose"> &#8212; Prepare a buffer for I/O</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-qbuf">ioctl VIDIOC_QBUF, VIDIOC_DQBUF</a></span><span class="refpurpose"> &#8212; Exchange a buffer with the driver</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-querybuf">ioctl VIDIOC_QUERYBUF</a></span><span class="refpurpose"> &#8212; Query the status of a buffer</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-querycap">ioctl VIDIOC_QUERYCAP</a></span><span class="refpurpose"> &#8212; Query device capabilities</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-queryctrl">ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU</a></span><span class="refpurpose"> &#8212; Enumerate controls and menu control items</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-query-dv-timings">ioctl VIDIOC_QUERY_DV_TIMINGS</a></span><span class="refpurpose"> &#8212; Sense the DV preset received by the current
input</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-querystd">ioctl VIDIOC_QUERYSTD</a></span><span class="refpurpose"> &#8212; Sense the video standard received by the current
input</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-reqbufs">ioctl VIDIOC_REQBUFS</a></span><span class="refpurpose"> &#8212; Initiate Memory Mapping or User Pointer I/O</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-s-hw-freq-seek">ioctl VIDIOC_S_HW_FREQ_SEEK</a></span><span class="refpurpose"> &#8212; Perform a hardware frequency seek</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-streamon">ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF</a></span><span class="refpurpose"> &#8212; Start or stop streaming I/O</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-subdev-enum-frame-interval">ioctl VIDIOC_SUBDEV_ENUM_FRAME_INTERVAL</a></span><span class="refpurpose"> &#8212; Enumerate frame intervals</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-subdev-enum-frame-size">ioctl VIDIOC_SUBDEV_ENUM_FRAME_SIZE</a></span><span class="refpurpose"> &#8212; Enumerate media bus frame sizes</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-subdev-enum-mbus-code">ioctl VIDIOC_SUBDEV_ENUM_MBUS_CODE</a></span><span class="refpurpose"> &#8212; Enumerate media bus formats</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-subdev-g-crop">ioctl VIDIOC_SUBDEV_G_CROP, VIDIOC_SUBDEV_S_CROP</a></span><span class="refpurpose"> &#8212; Get or set the crop rectangle on a subdev pad</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-subdev-g-fmt">ioctl VIDIOC_SUBDEV_G_FMT, VIDIOC_SUBDEV_S_FMT</a></span><span class="refpurpose"> &#8212; Get or set the data format on a subdev pad</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-subdev-g-frame-interval">ioctl VIDIOC_SUBDEV_G_FRAME_INTERVAL, VIDIOC_SUBDEV_S_FRAME_INTERVAL</a></span><span class="refpurpose"> &#8212; Get or set the frame interval on a subdev pad</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-subdev-g-selection">ioctl VIDIOC_SUBDEV_G_SELECTION, VIDIOC_SUBDEV_S_SELECTION</a></span><span class="refpurpose"> &#8212; Get or set selection rectangles on a subdev pad</span></dt><dt><span class="refentrytitle"><a href="media.html#vidioc-subscribe-event">ioctl VIDIOC_SUBSCRIBE_EVENT, VIDIOC_UNSUBSCRIBE_EVENT</a></span><span class="refpurpose"> &#8212; Subscribe or unsubscribe event</span></dt><dt><span class="refentrytitle"><a href="media.html#func-mmap">V4L2 mmap()</a></span><span class="refpurpose"> &#8212; Map device memory into application address space</span></dt><dt><span class="refentrytitle"><a href="media.html#func-munmap">V4L2 munmap()</a></span><span class="refpurpose"> &#8212; Unmap device memory</span></dt><dt><span class="refentrytitle"><a href="media.html#func-open">V4L2 open()</a></span><span class="refpurpose"> &#8212; Open a V4L2 device</span></dt><dt><span class="refentrytitle"><a href="media.html#func-poll">V4L2 poll()</a></span><span class="refpurpose"> &#8212; Wait for some event on a file descriptor</span></dt><dt><span class="refentrytitle"><a href="media.html#func-read">V4L2 read()</a></span><span class="refpurpose"> &#8212; Read from a V4L2 device</span></dt><dt><span class="refentrytitle"><a href="media.html#func-select">V4L2 select()</a></span><span class="refpurpose"> &#8212; Synchronous I/O multiplexing</span></dt><dt><span class="refentrytitle"><a href="media.html#func-write">V4L2 write()</a></span><span class="refpurpose"> &#8212; Write to a V4L2 device</span></dt></dl></div><div class="refentry"><a name="func-close"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>v4l2-close &#8212; Close a V4L2 device</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">#include &lt;unistd.h&gt;</pre><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">close</b>(</code></td><td>int <var class="pdparam">fd</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp75327952"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd></dl></div></div><div class="refsect1"><a name="idp75333520"></a><h2>Description</h2><p>Closes the device. Any I/O in progress is terminated and
resources associated with the file descriptor are freed. However data
format parameters, current input or output, control values or other
properties remain unchanged.</p></div><div class="refsect1"><a name="idp75334944"></a><h2>Return Value</h2><p>The function returns <span class="returnvalue">0</span> on
success, <span class="returnvalue">-1</span> on failure and the
<code class="varname">errno</code> is set appropriately. Possible error
codes:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EBADF</span></span></dt><dd><p><em class="parameter"><code>fd</code></em> is not a valid open file
descriptor.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="func-ioctl"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>v4l2-ioctl &#8212; Program a V4L2 device</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">#include &lt;sys/ioctl.h&gt;</pre><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>void *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp75369136"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>V4L2 ioctl request code as defined in the <code class="filename">videodev2.h</code> header file, for example
VIDIOC_QUERYCAP.</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p>Pointer to a function parameter, usually a structure.</p></dd></dl></div></div><div class="refsect1"><a name="idp75378192"></a><h2>Description</h2><p>The <code class="function">ioctl()</code> function is used to program
V4L2 devices. The argument <em class="parameter"><code>fd</code></em> must be an open
file descriptor. An ioctl <em class="parameter"><code>request</code></em> has encoded
in it whether the argument is an input, output or read/write
parameter, and the size of the argument <em class="parameter"><code>argp</code></em> in
bytes. Macros and defines specifying V4L2 ioctl requests are located
in the <code class="filename">videodev2.h</code> header file.
Applications should use their own copy, not include the version in the
kernel sources on the system they compile on. All V4L2 ioctl requests,
their respective function and parameters are specified in <a class="xref" href="media.html#user-func" title="Appendix A. Function Reference">Appendix A, <i>Function Reference</i></a>.</p></div><div class="refsect1"><a name="idp75384064"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><p>When an ioctl that takes an output or read/write parameter fails,
    the parameter remains unmodified.</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-create-bufs"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_CREATE_BUFS &#8212; Create buffers for Memory Mapped or User Pointer or DMA Buffer
    I/O</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_create_buffers *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp75366000"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_CREATE_BUFS</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp75436480"></a><h2>Description</h2><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Experimental</h3><p>This is an <a class="link" href="media.html#experimental" title="Experimental API Elements"> experimental </a>
      interface and may change in the future.</p></div><p>This ioctl is used to create buffers for <a class="link" href="media.html#mmap" title="Streaming I/O (Memory Mapping)">memory
mapped</a> or <a class="link" href="media.html#userp" title="Streaming I/O (User Pointers)">user pointer</a> or <a class="link" href="media.html#dmabuf" title="Streaming I/O (DMA buffer importing)">DMA buffer</a> I/O. It can be used as an alternative or in
addition to the <code class="constant">VIDIOC_REQBUFS</code> ioctl, when a tighter
control over buffers is required. This ioctl can be called multiple times to
create buffers of different sizes.</p><p>To allocate the device buffers applications must initialize the
relevant fields of the <span class="structname">v4l2_create_buffers</span> structure.
The <em class="structfield"><code>count</code></em> field must be set to the number of
requested buffers, the <em class="structfield"><code>memory</code></em> field specifies the
requested I/O method and the <em class="structfield"><code>reserved</code></em> array must be
zeroed.</p><p>The <em class="structfield"><code>format</code></em> field specifies the image format
that the buffers must be able to handle. The application has to fill in this
struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a>. Usually this will be done using the
<code class="constant">VIDIOC_TRY_FMT</code> or <code class="constant">VIDIOC_G_FMT</code> ioctl()
to ensure that the requested format is supported by the driver. Unsupported
formats will result in an error.</p><p>The buffers created by this ioctl will have as minimum size the size
defined by the <em class="structfield"><code>format.pix.sizeimage</code></em> field. If the
<em class="structfield"><code>format.pix.sizeimage</code></em> field is less than the minimum
required for the given format, then <em class="structfield"><code>sizeimage</code></em> will be
increased by the driver to that minimum to allocate the buffers. If it is
larger, then the value will be used as-is. The same applies to the
<em class="structfield"><code>sizeimage</code></em> field of the
<span class="structname">v4l2_plane_pix_format</span> structure in the case of
multiplanar formats.</p><p>When the ioctl is called with a pointer to this structure the driver
will attempt to allocate up to the requested number of buffers and store the
actual number allocated and the starting index in the
<em class="structfield"><code>count</code></em> and the <em class="structfield"><code>index</code></em> fields
respectively. On return <em class="structfield"><code>count</code></em> can be smaller than
the number requested. The driver may also increase buffer sizes if required,
however, it will not update <em class="structfield"><code>sizeimage</code></em> field values.
The user has to use <code class="constant">VIDIOC_QUERYBUF</code> to retrieve that
information.</p><div class="table"><a name="v4l2-create-buffers"></a><p class="title"><b>Table A.1. struct <span class="structname">v4l2_create_buffers</span></b></p><div class="table-contents"><table summary="struct v4l2_create_buffers" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>index</code></em></td><td valign="top">The starting buffer index, returned by the driver.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>count</code></em></td><td valign="top">The number of buffers requested or granted. If count == 0, then
	    <code class="constant">VIDIOC_CREATE_BUFS</code> will set <em class="structfield"><code>index</code></em>
	    to the current number of created buffers, and it will check the validity of
	    <em class="structfield"><code>memory</code></em> and <em class="structfield"><code>format.type</code></em>.
	    If those are invalid -1 is returned and errno is set to <span class="errorcode">EINVAL</span> error code,
	    otherwise <code class="constant">VIDIOC_CREATE_BUFS</code> returns 0. It will
	    never set errno to <span class="errorcode">EBUSY</span> error code in this particular case.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>memory</code></em></td><td valign="top">Applications set this field to
<code class="constant">V4L2_MEMORY_MMAP</code>,
<code class="constant">V4L2_MEMORY_DMABUF</code> or
<code class="constant">V4L2_MEMORY_USERPTR</code>. See <a class="xref" href="media.html#v4l2-memory" title="Table 3.5. enum v4l2_memory">Table 3.5, &#8220;enum v4l2_memory&#8221;</a></td></tr><tr><td valign="top">struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a></td><td valign="top"><em class="structfield"><code>format</code></em></td><td valign="top">Filled in by the application, preserved by the driver.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[8]</td><td valign="top">A place holder for future extensions.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp75475648"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">ENOMEM</span></span></dt><dd><p>No memory to allocate buffers for <a class="link" href="media.html#mmap" title="Streaming I/O (Memory Mapping)">memory
mapped</a> I/O.</p></dd><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The buffer type (<em class="structfield"><code>format.type</code></em> field),
requested I/O method (<em class="structfield"><code>memory</code></em>) or format
(<em class="structfield"><code>format</code></em> field) is not valid.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-cropcap"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_CROPCAP &#8212; Information about the video cropping and scaling abilities</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_cropcap
*<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp75561904"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_CROPCAP</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp75570032"></a><h2>Description</h2><p>Applications use this function to query the cropping
limits, the pixel aspect of images and to calculate scale factors.
They set the <em class="structfield"><code>type</code></em> field of a v4l2_cropcap
structure to the respective buffer (stream) type and call the
<code class="constant">VIDIOC_CROPCAP</code> ioctl with a pointer to this
structure. Drivers fill the rest of the structure. The results are
constant except when switching the video standard. Remember this
switch can occur implicit when switching the video input or
output.</p><p>This ioctl must be implemented for video capture or output devices that
support cropping and/or scaling and/or have non-square pixels, and for overlay devices.</p><div class="table"><a name="v4l2-cropcap"></a><p class="title"><b>Table A.2. struct <span class="structname">v4l2_cropcap</span></b></p><div class="table-contents"><table summary="struct v4l2_cropcap" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>type</code></em></td><td valign="top">Type of the data stream, set by the application.
Only these types are valid here:
<code class="constant">V4L2_BUF_TYPE_VIDEO_CAPTURE</code>,
<code class="constant">V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE</code>,
<code class="constant">V4L2_BUF_TYPE_VIDEO_OUTPUT</code>,
<code class="constant">V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE</code> and
<code class="constant">V4L2_BUF_TYPE_VIDEO_OVERLAY</code>. See <a class="xref" href="media.html#v4l2-buf-type" title="Table 3.3. enum v4l2_buf_type">Table 3.3, &#8220;enum v4l2_buf_type&#8221;</a>.</td></tr><tr><td valign="top">struct <a class="link" href="media.html#v4l2-rect-crop" title="Table A.3. struct v4l2_rect">v4l2_rect</a></td><td valign="top"><em class="structfield"><code>bounds</code></em></td><td valign="top">Defines the window within capturing or output is
possible, this may exclude for example the horizontal and vertical
blanking areas. The cropping rectangle cannot exceed these limits.
Width and height are defined in pixels, the driver writer is free to
choose origin and units of the coordinate system in the analog
domain.</td></tr><tr><td valign="top">struct <a class="link" href="media.html#v4l2-rect-crop" title="Table A.3. struct v4l2_rect">v4l2_rect</a></td><td valign="top"><em class="structfield"><code>defrect</code></em></td><td valign="top">Default cropping rectangle, it shall cover the
"whole picture". Assuming pixel aspect 1/1 this could be for example a
640 × 480 rectangle for NTSC, a
768 × 576 rectangle for PAL and SECAM centered over
the active picture area. The same co-ordinate system as for
	    <em class="structfield"><code>bounds</code></em> is used.</td></tr><tr><td valign="top">struct <a class="link" href="media.html#v4l2-fract" title="Table A.46. struct v4l2_fract">v4l2_fract</a></td><td valign="top"><em class="structfield"><code>pixelaspect</code></em></td><td valign="top"><p>This is the pixel aspect (y / x) when no
scaling is applied, the ratio of the actual sampling
frequency and the frequency required to get square
pixels.</p><p>When cropping coordinates refer to square pixels,
the driver sets <em class="structfield"><code>pixelaspect</code></em> to 1/1. Other
common values are 54/59 for PAL and SECAM, 11/10 for NTSC sampled
according to [<a class="xref" href="media.html#itu601" title='ITU-R Recommendation BT.601-5 "Studio Encoding Parameters of Digital Television for Standard 4:3 and Wide-Screen 16:9 Aspect Ratios"'>[<abbr class="abbrev">ITU BT.601</abbr>]</a>].</p></td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-rect-crop"></a><p class="title"><b>Table A.3. struct <span class="structname">v4l2_rect</span></b></p><div class="table-contents"><table summary="struct v4l2_rect" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__s32</td><td valign="top"><em class="structfield"><code>left</code></em></td><td valign="top">Horizontal offset of the top, left corner of the
rectangle, in pixels.</td></tr><tr><td valign="top">__s32</td><td valign="top"><em class="structfield"><code>top</code></em></td><td valign="top">Vertical offset of the top, left corner of the
rectangle, in pixels.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>width</code></em></td><td valign="top">Width of the rectangle, in pixels.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>height</code></em></td><td valign="top">Height of the rectangle, in pixels.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp75608160"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The struct <a class="link" href="media.html#v4l2-cropcap" title="Table A.2. struct v4l2_cropcap">v4l2_cropcap</a> <em class="structfield"><code>type</code></em> is
invalid.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-dbg-g-chip-info"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_DBG_G_CHIP_INFO &#8212; Identify the chips on a TV card</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_dbg_chip_info
*<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp75687856"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_DBG_G_CHIP_INFO</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp75695984"></a><h2>Description</h2><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Experimental</h3><p>This is an <a class="link" href="media.html#experimental" title="Experimental API Elements">experimental</a> interface and may change in
the future.</p></div><p>For driver debugging purposes this ioctl allows test
applications to query the driver about the chips present on the TV
card. Regular applications must not use it. When you found a chip
specific bug, please contact the linux-media mailing list (<a class="ulink" href="http://www.linuxtv.org/lists.php" target="_top">http://www.linuxtv.org/lists.php</a>)
so it can be fixed.</p><p>Additionally the Linux kernel must be compiled with the
<code class="constant">CONFIG_VIDEO_ADV_DEBUG</code> option to enable this ioctl.</p><p>To query the driver applications must initialize the
<em class="structfield"><code>match.type</code></em> and
<em class="structfield"><code>match.addr</code></em> or <em class="structfield"><code>match.name</code></em>
fields of a struct <a class="link" href="media.html#v4l2-dbg-chip-info" title="Table A.5. struct v4l2_dbg_chip_info">v4l2_dbg_chip_info</a>
and call <code class="constant">VIDIOC_DBG_G_CHIP_INFO</code> with a pointer to
this structure. On success the driver stores information about the
selected chip in the <em class="structfield"><code>name</code></em> and
<em class="structfield"><code>flags</code></em> fields.</p><p>When <em class="structfield"><code>match.type</code></em> is
<code class="constant">V4L2_CHIP_MATCH_BRIDGE</code>,
<em class="structfield"><code>match.addr</code></em> selects the nth bridge 'chip'
on the TV card. You can enumerate all chips by starting at zero and
incrementing <em class="structfield"><code>match.addr</code></em> by one until
<code class="constant">VIDIOC_DBG_G_CHIP_INFO</code> fails with an <span class="errorcode">EINVAL</span> error code.
The number zero always selects the bridge chip itself, e. g. the chip
connected to the PCI or USB bus. Non-zero numbers identify specific
parts of the bridge chip such as an AC97 register block.</p><p>When <em class="structfield"><code>match.type</code></em> is
<code class="constant">V4L2_CHIP_MATCH_SUBDEV</code>,
<em class="structfield"><code>match.addr</code></em> selects the nth sub-device. This
allows you to enumerate over all sub-devices.</p><p>On success, the <em class="structfield"><code>name</code></em> field will
contain a chip name and the <em class="structfield"><code>flags</code></em> field will
contain <code class="constant">V4L2_CHIP_FL_READABLE</code> if the driver supports
reading registers from the device or <code class="constant">V4L2_CHIP_FL_WRITABLE</code>
if the driver supports writing registers to the device.</p><p>We recommended the <span class="application">v4l2-dbg</span>
utility over calling this ioctl directly. It is available from the
LinuxTV v4l-dvb repository; see <a class="ulink" href="http://linuxtv.org/repo/" target="_top">http://linuxtv.org/repo/</a> for
access instructions.</p><div class="table"><a name="name-v4l2-dbg-match"></a><p class="title"><b>Table A.4. struct <span class="structname">v4l2_dbg_match</span></b></p><div class="table-contents"><table summary="struct v4l2_dbg_match" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>type</code></em></td><td valign="top">See <a class="xref" href="media.html#name-chip-match-types" title="Table A.6. Chip Match Types">Table A.6, &#8220;Chip Match Types&#8221;</a> for a list of
possible types.</td><td class="auto-generated"> </td></tr><tr><td valign="top">union</td><td valign="top">(anonymous)</td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td valign="top"> </td><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>addr</code></em></td><td valign="top">Match a chip by this number, interpreted according
to the <em class="structfield"><code>type</code></em> field.</td></tr><tr><td valign="top"> </td><td valign="top">char</td><td valign="top"><em class="structfield"><code>name[32]</code></em></td><td valign="top">Match a chip by this name, interpreted according
to the <em class="structfield"><code>type</code></em> field. Currently unused.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-dbg-chip-info"></a><p class="title"><b>Table A.5. struct <span class="structname">v4l2_dbg_chip_info</span></b></p><div class="table-contents"><table summary="struct v4l2_dbg_chip_info" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">struct v4l2_dbg_match</td><td valign="top"><em class="structfield"><code>match</code></em></td><td valign="top">How to match the chip, see <a class="xref" href="media.html#name-v4l2-dbg-match" title="Table A.4. struct v4l2_dbg_match">Table A.4, &#8220;struct <span class="structname">v4l2_dbg_match</span>&#8221;</a>.</td></tr><tr><td valign="top">char</td><td valign="top"><em class="structfield"><code>name[32]</code></em></td><td valign="top">The name of the chip.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>flags</code></em></td><td valign="top">Set by the driver. If <code class="constant">V4L2_CHIP_FL_READABLE</code>
is set, then the driver supports reading registers from the device. If
<code class="constant">V4L2_CHIP_FL_WRITABLE</code> is set, then it supports writing registers.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved[8]</code></em></td><td valign="top">Reserved fields, both application and driver must set these to 0.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="name-chip-match-types"></a><p class="title"><b>Table A.6. Chip Match Types</b></p><div class="table-contents"><table summary="Chip Match Types" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_CHIP_MATCH_BRIDGE</code></td><td valign="top">0</td><td valign="top">Match the nth chip on the card, zero for the
	    bridge chip. Does not match sub-devices.</td></tr><tr><td valign="top"><code class="constant">V4L2_CHIP_MATCH_SUBDEV</code></td><td valign="top">4</td><td valign="top">Match the nth sub-device.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp75757200"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The <em class="structfield"><code>match_type</code></em> is invalid or
no device could be matched.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-dbg-g-register"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_DBG_G_REGISTER, VIDIOC_DBG_S_REGISTER &#8212; Read or write hardware registers</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_dbg_register *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>const struct v4l2_dbg_register
*<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp75863744"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_DBG_G_REGISTER, VIDIOC_DBG_S_REGISTER</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp75871904"></a><h2>Description</h2><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Experimental</h3><p>This is an <a class="link" href="media.html#experimental" title="Experimental API Elements">experimental</a>
interface and may change in the future.</p></div><p>For driver debugging purposes these ioctls allow test
applications to access hardware registers directly. Regular
applications must not use them.</p><p>Since writing or even reading registers can jeopardize the
system security, its stability and damage the hardware, both ioctls
require superuser privileges. Additionally the Linux kernel must be
compiled with the <code class="constant">CONFIG_VIDEO_ADV_DEBUG</code> option
to enable these ioctls.</p><p>To write a register applications must initialize all fields
of a struct <a class="link" href="media.html#v4l2-dbg-register" title="Table A.8. struct v4l2_dbg_register">v4l2_dbg_register</a> except for <em class="structfield"><code>size</code></em> and call
<code class="constant">VIDIOC_DBG_S_REGISTER</code> with a pointer to this
structure. The <em class="structfield"><code>match.type</code></em> and
<em class="structfield"><code>match.addr</code></em> or <em class="structfield"><code>match.name</code></em>
fields select a chip on the TV
card, the <em class="structfield"><code>reg</code></em> field specifies a register
number and the <em class="structfield"><code>val</code></em> field the value to be
written into the register.</p><p>To read a register applications must initialize the
<em class="structfield"><code>match.type</code></em>,
<em class="structfield"><code>match.addr</code></em> or <em class="structfield"><code>match.name</code></em> and
<em class="structfield"><code>reg</code></em> fields, and call
<code class="constant">VIDIOC_DBG_G_REGISTER</code> with a pointer to this
structure. On success the driver stores the register value in the
<em class="structfield"><code>val</code></em> field and the size (in bytes) of the
value in <em class="structfield"><code>size</code></em>.</p><p>When <em class="structfield"><code>match.type</code></em> is
<code class="constant">V4L2_CHIP_MATCH_BRIDGE</code>,
<em class="structfield"><code>match.addr</code></em> selects the nth non-sub-device chip
on the TV card.  The number zero always selects the host chip, e. g. the
chip connected to the PCI or USB bus. You can find out which chips are
present with the <a class="link" href="media.html#vidioc-dbg-g-chip-info" title="ioctl VIDIOC_DBG_G_CHIP_INFO"><code class="constant">VIDIOC_DBG_G_CHIP_INFO</code></a> ioctl.</p><p>When <em class="structfield"><code>match.type</code></em> is
<code class="constant">V4L2_CHIP_MATCH_SUBDEV</code>,
<em class="structfield"><code>match.addr</code></em> selects the nth sub-device.</p><p>These ioctls are optional, not all drivers may support them.
However when a driver supports these ioctls it must also support
<a class="link" href="media.html#vidioc-dbg-g-chip-info" title="ioctl VIDIOC_DBG_G_CHIP_INFO"><code class="constant">VIDIOC_DBG_G_CHIP_INFO</code></a>. Conversely it may support
<code class="constant">VIDIOC_DBG_G_CHIP_INFO</code> but not these ioctls.</p><p><code class="constant">VIDIOC_DBG_G_REGISTER</code> and
<code class="constant">VIDIOC_DBG_S_REGISTER</code> were introduced in Linux
2.6.21, but their API was changed to the one described here in kernel 2.6.29.</p><p>We recommended the <span class="application">v4l2-dbg</span>
utility over calling these ioctls directly. It is available from the
LinuxTV v4l-dvb repository; see <a class="ulink" href="http://linuxtv.org/repo/" target="_top">http://linuxtv.org/repo/</a> for
access instructions.</p><div class="table"><a name="v4l2-dbg-match"></a><p class="title"><b>Table A.7. struct <span class="structname">v4l2_dbg_match</span></b></p><div class="table-contents"><table summary="struct v4l2_dbg_match" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>type</code></em></td><td valign="top">See <a class="xref" href="media.html#chip-match-types" title="Table A.9. Chip Match Types">Table A.9, &#8220;Chip Match Types&#8221;</a> for a list of
possible types.</td><td class="auto-generated"> </td></tr><tr><td valign="top">union</td><td valign="top">(anonymous)</td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td valign="top"> </td><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>addr</code></em></td><td valign="top">Match a chip by this number, interpreted according
to the <em class="structfield"><code>type</code></em> field.</td></tr><tr><td valign="top"> </td><td valign="top">char</td><td valign="top"><em class="structfield"><code>name[32]</code></em></td><td valign="top">Match a chip by this name, interpreted according
to the <em class="structfield"><code>type</code></em> field. Currently unused.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-dbg-register"></a><p class="title"><b>Table A.8. struct <span class="structname">v4l2_dbg_register</span></b></p><div class="table-contents"><table summary="struct v4l2_dbg_register" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c4"><col></colgroup><tbody valign="top"><tr><td valign="top">struct v4l2_dbg_match</td><td valign="top"><em class="structfield"><code>match</code></em></td><td valign="top">How to match the chip, see <a class="xref" href="media.html#v4l2-dbg-match" title="Table A.7. struct v4l2_dbg_match">Table A.7, &#8220;struct <span class="structname">v4l2_dbg_match</span>&#8221;</a>.</td><td class="auto-generated"> </td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>size</code></em></td><td valign="top">The register size in bytes.</td><td class="auto-generated"> </td></tr><tr><td valign="top">__u64</td><td valign="top"><em class="structfield"><code>reg</code></em></td><td valign="top">A register number.</td><td class="auto-generated"> </td></tr><tr><td valign="top">__u64</td><td valign="top"><em class="structfield"><code>val</code></em></td><td valign="top">The value read from, or to be written into the
register.</td><td class="auto-generated"> </td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="chip-match-types"></a><p class="title"><b>Table A.9. Chip Match Types</b></p><div class="table-contents"><table summary="Chip Match Types" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_CHIP_MATCH_BRIDGE</code></td><td valign="top">0</td><td valign="top">Match the nth chip on the card, zero for the
	    bridge chip. Does not match sub-devices.</td></tr><tr><td valign="top"><code class="constant">V4L2_CHIP_MATCH_SUBDEV</code></td><td valign="top">4</td><td valign="top">Match the nth sub-device.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp75933760"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EPERM</span></span></dt><dd><p>Insufficient permissions. Root privileges are required
to execute these ioctls.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-decoder-cmd"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_DECODER_CMD, VIDIOC_TRY_DECODER_CMD &#8212; Execute an decoder command</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_decoder_cmd *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp76041168"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_DECODER_CMD, VIDIOC_TRY_DECODER_CMD</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp76049328"></a><h2>Description</h2><p>These ioctls control an audio/video (usually MPEG-) decoder.
<code class="constant">VIDIOC_DECODER_CMD</code> sends a command to the
decoder, <code class="constant">VIDIOC_TRY_DECODER_CMD</code> can be used to
try a command without actually executing it. To send a command applications
must initialize all fields of a struct <a class="link" href="media.html#v4l2-decoder-cmd" title="Table A.10. struct v4l2_decoder_cmd">v4l2_decoder_cmd</a> and call
<code class="constant">VIDIOC_DECODER_CMD</code> or <code class="constant">VIDIOC_TRY_DECODER_CMD</code>
with a pointer to this structure.</p><p>The <em class="structfield"><code>cmd</code></em> field must contain the
command code. Some commands use the <em class="structfield"><code>flags</code></em> field for
additional information.
</p><p>A <code class="function">write</code>() or <a class="link" href="media.html#vidioc-streamon" title="ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF"><code class="constant">VIDIOC_STREAMON</code></a> call sends an implicit
START command to the decoder if it has not been started yet.
</p><p>A <code class="function">close</code>() or <a class="link" href="media.html#vidioc-streamon" title="ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF"><code class="constant">VIDIOC_STREAMOFF</code></a> call of a streaming
file descriptor sends an implicit immediate STOP command to the decoder, and all
buffered data is discarded.</p><p>These ioctls are optional, not all drivers may support
them. They were introduced in Linux 3.3.</p><div class="table"><a name="v4l2-decoder-cmd"></a><p class="title"><b>Table A.10. struct <span class="structname">v4l2_decoder_cmd</span></b></p><div class="table-contents"><table summary="struct v4l2_decoder_cmd" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col><col></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>cmd</code></em></td><td valign="top"> </td><td valign="top"> </td><td valign="top">The decoder command, see <a class="xref" href="media.html#decoder-cmds" title="Table A.11. Decoder Commands">Table A.11, &#8220;Decoder Commands&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>flags</code></em></td><td valign="top"> </td><td valign="top"> </td><td valign="top">Flags to go with the command. If no flags are defined for
this command, drivers and applications must set this field to zero.</td></tr><tr><td valign="top">union</td><td valign="top">(anonymous)</td><td valign="top"> </td><td valign="top"> </td><td valign="top"> </td></tr><tr><td valign="top"> </td><td valign="top">struct</td><td valign="top"><em class="structfield"><code>start</code></em></td><td valign="top"> </td><td valign="top">Structure containing additional data for the
<code class="constant">V4L2_DEC_CMD_START</code> command.</td></tr><tr><td valign="top"> </td><td valign="top"> </td><td valign="top">__s32</td><td valign="top"><em class="structfield"><code>speed</code></em></td><td valign="top">Playback speed and direction. The playback speed is defined as
<em class="structfield"><code>speed</code></em>/1000 of the normal speed. So 1000 is normal playback.
Negative numbers denote reverse playback, so -1000 does reverse playback at normal
speed. Speeds -1, 0 and 1 have special meanings: speed 0 is shorthand for 1000
(normal playback). A speed of 1 steps just one frame forward, a speed of -1 steps
just one frame back.
	    </td></tr><tr><td valign="top"> </td><td valign="top"> </td><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>format</code></em></td><td valign="top">Format restrictions. This field is set by the driver, not the
application. Possible values are <code class="constant">V4L2_DEC_START_FMT_NONE</code> if
there are no format restrictions or <code class="constant">V4L2_DEC_START_FMT_GOP</code>
if the decoder operates on full GOPs (<em class="wordasword">Group Of Pictures</em>).
This is usually the case for reverse playback: the decoder needs full GOPs, which
it can then play in reverse order. So to implement reverse playback the application
must feed the decoder the last GOP in the video file, then the GOP before that, etc. etc.
	    </td></tr><tr><td valign="top"> </td><td valign="top">struct</td><td valign="top"><em class="structfield"><code>stop</code></em></td><td valign="top"> </td><td valign="top">Structure containing additional data for the
<code class="constant">V4L2_DEC_CMD_STOP</code> command.</td></tr><tr><td valign="top"> </td><td valign="top"> </td><td valign="top">__u64</td><td valign="top"><em class="structfield"><code>pts</code></em></td><td valign="top">Stop playback at this <em class="structfield"><code>pts</code></em> or immediately
if the playback is already past that timestamp. Leave to 0 if you want to stop after the
last frame was decoded.
	    </td></tr><tr><td valign="top"> </td><td valign="top">struct</td><td valign="top"><em class="structfield"><code>raw</code></em></td><td valign="top"> </td><td valign="top"> </td></tr><tr><td valign="top"> </td><td valign="top"> </td><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>data</code></em>[16]</td><td valign="top">Reserved for future extensions. Drivers and
applications must set the array to zero.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="decoder-cmds"></a><p class="title"><b>Table A.11. Decoder Commands</b></p><div class="table-contents"><table summary="Decoder Commands" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_DEC_CMD_START</code></td><td valign="top">0</td><td valign="top">Start the decoder. When the decoder is already
running or paused, this command will just change the playback speed.
That means that calling <code class="constant">V4L2_DEC_CMD_START</code> when
the decoder was paused will <span class="emphasis"><em>not</em></span> resume the decoder.
You have to explicitly call <code class="constant">V4L2_DEC_CMD_RESUME</code> for that.
This command has one flag:
<code class="constant">V4L2_DEC_CMD_START_MUTE_AUDIO</code>. If set, then audio will
be muted when playing back at a non-standard speed.
            </td></tr><tr><td valign="top"><code class="constant">V4L2_DEC_CMD_STOP</code></td><td valign="top">1</td><td valign="top">Stop the decoder. When the decoder is already stopped,
this command does nothing. This command has two flags:
if <code class="constant">V4L2_DEC_CMD_STOP_TO_BLACK</code> is set, then the decoder will
set the picture to black after it stopped decoding. Otherwise the last image will
repeat. If <code class="constant">V4L2_DEC_CMD_STOP_IMMEDIATELY</code> is set, then the decoder
stops immediately (ignoring the <em class="structfield"><code>pts</code></em> value), otherwise it
will keep decoding until timestamp &gt;= pts or until the last of the pending data from
its internal buffers was decoded.
</td></tr><tr><td valign="top"><code class="constant">V4L2_DEC_CMD_PAUSE</code></td><td valign="top">2</td><td valign="top">Pause the decoder. When the decoder has not been
started yet, the driver will return an <span class="errorcode">EPERM</span> error code. When the decoder is
already paused, this command does nothing. This command has one flag:
if <code class="constant">V4L2_DEC_CMD_PAUSE_TO_BLACK</code> is set, then set the
decoder output to black when paused.
</td></tr><tr><td valign="top"><code class="constant">V4L2_DEC_CMD_RESUME</code></td><td valign="top">3</td><td valign="top">Resume decoding after a PAUSE command. When the
decoder has not been started yet, the driver will return an <span class="errorcode">EPERM</span> error code.
When the decoder is already running, this command does nothing. No
flags are defined for this command.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp76113824"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The <em class="structfield"><code>cmd</code></em> field is invalid.</p></dd><dt><span class="term"><span class="errorcode">EPERM</span></span></dt><dd><p>The application sent a PAUSE or RESUME command when
the decoder was not running.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-dqevent"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_DQEVENT &#8212; Dequeue event</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_event
*<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp76223200"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_DQEVENT</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp76231328"></a><h2>Description</h2><p>Dequeue an event from a video device. No input is required
    for this ioctl. All the fields of the struct <a class="link" href="media.html#v4l2-event" title="Table A.12. struct v4l2_event">v4l2_event</a> structure are
    filled by the driver. The file handle will also receive exceptions
    which the application may get by e.g. using the select system
    call.</p><div class="table"><a name="v4l2-event"></a><p class="title"><b>Table A.12. struct <span class="structname">v4l2_event</span></b></p><div class="table-contents"><table summary="struct v4l2_event" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>type</code></em></td><td valign="top"> </td><td valign="top">Type of the event.</td></tr><tr><td valign="top">union</td><td valign="top"><em class="structfield"><code>u</code></em></td><td valign="top"> </td><td valign="top"> </td></tr><tr><td valign="top"> </td><td valign="top">struct <a class="link" href="media.html#v4l2-event-vsync" title="Table A.13. struct v4l2_event_vsync">v4l2_event_vsync</a></td><td valign="top"><em class="structfield"><code>vsync</code></em></td><td valign="top">Event data for event <code class="constant">V4L2_EVENT_VSYNC</code>.
            </td></tr><tr><td valign="top"> </td><td valign="top">struct <a class="link" href="media.html#v4l2-event-ctrl" title="Table A.14. struct v4l2_event_ctrl">v4l2_event_ctrl</a></td><td valign="top"><em class="structfield"><code>ctrl</code></em></td><td valign="top">Event data for event <code class="constant">V4L2_EVENT_CTRL</code>.
            </td></tr><tr><td valign="top"> </td><td valign="top">struct <a class="link" href="media.html#v4l2-event-frame-sync" title="Table A.15. struct v4l2_event_frame_sync">v4l2_event_frame_sync</a></td><td valign="top"><em class="structfield"><code>frame_sync</code></em></td><td valign="top">Event data for event
	    <code class="constant">V4L2_EVENT_FRAME_SYNC</code>.</td></tr><tr><td valign="top"> </td><td valign="top">struct <a class="link" href="media.html#v4l2-event-motion-det" title="Table A.17. struct v4l2_event_motion_det">v4l2_event_motion_det</a></td><td valign="top"><em class="structfield"><code>motion_det</code></em></td><td valign="top">Event data for event V4L2_EVENT_MOTION_DET.</td></tr><tr><td valign="top"> </td><td valign="top">struct <a class="link" href="media.html#v4l2-event-src-change" title="Table A.16. struct v4l2_event_src_change">v4l2_event_src_change</a></td><td valign="top"><em class="structfield"><code>src_change</code></em></td><td valign="top">Event data for event V4L2_EVENT_SOURCE_CHANGE.</td></tr><tr><td valign="top"> </td><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>data</code></em>[64]</td><td valign="top">Event data. Defined by the event type. The union
            should be used to define easily accessible type for
            events.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>pending</code></em></td><td valign="top"> </td><td valign="top">Number of pending events excluding this one.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>sequence</code></em></td><td valign="top"> </td><td valign="top">Event sequence number. The sequence number is
	    incremented for every subscribed event that takes place.
	    If sequence numbers are not contiguous it means that
	    events have been lost.
	    </td></tr><tr><td valign="top">struct timespec</td><td valign="top"><em class="structfield"><code>timestamp</code></em></td><td valign="top"> </td><td valign="top">Event timestamp.</td></tr><tr><td valign="top">u32</td><td valign="top"><em class="structfield"><code>id</code></em></td><td valign="top"> </td><td valign="top">The ID associated with the event source. If the event does not
		have an associated ID (this depends on the event type), then this
		is 0.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[8]</td><td valign="top"> </td><td valign="top">Reserved for future extensions. Drivers must set
	    the array to zero.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-event-vsync"></a><p class="title"><b>Table A.13. struct <span class="structname">v4l2_event_vsync</span></b></p><div class="table-contents"><table summary="struct v4l2_event_vsync" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>field</code></em></td><td valign="top">The upcoming field. See enum <a class="link" href="media.html#v4l2-field" title="Table 3.9. enum v4l2_field">v4l2_field</a>.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-event-ctrl"></a><p class="title"><b>Table A.14. struct <span class="structname">v4l2_event_ctrl</span></b></p><div class="table-contents"><table summary="struct v4l2_event_ctrl" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>changes</code></em></td><td valign="top"> </td><td valign="top">A bitmask that tells what has changed. See <a class="xref" href="media.html#changes-flags" title="Table A.18. Changes">Table A.18, &#8220;Changes&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>type</code></em></td><td valign="top"> </td><td valign="top">The type of the control. See enum <a class="link" href="media.html#v4l2-ctrl-type" title="Table A.97. enum v4l2_ctrl_type">v4l2_ctrl_type</a>.</td></tr><tr><td valign="top">union (anonymous)</td><td valign="top"> </td><td valign="top"> </td><td valign="top"> </td></tr><tr><td valign="top"> </td><td valign="top">__s32</td><td valign="top"><em class="structfield"><code>value</code></em></td><td valign="top">The 32-bit value of the control for 32-bit control types.
		This is 0 for string controls since the value of a string
		cannot be passed using <a class="link" href="media.html#vidioc-dqevent" title="ioctl VIDIOC_DQEVENT"><code class="constant">VIDIOC_DQEVENT</code></a>.</td></tr><tr><td valign="top"> </td><td valign="top">__s64</td><td valign="top"><em class="structfield"><code>value64</code></em></td><td valign="top">The 64-bit value of the control for 64-bit control types.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>flags</code></em></td><td valign="top"> </td><td valign="top">The control flags. See <a class="xref" href="media.html#control-flags" title="Table A.98. Control Flags">Table A.98, &#8220;Control Flags&#8221;</a>.</td></tr><tr><td valign="top">__s32</td><td valign="top"><em class="structfield"><code>minimum</code></em></td><td valign="top"> </td><td valign="top">The minimum value of the control. See struct <a class="link" href="media.html#v4l2-queryctrl" title="Table A.94. struct v4l2_queryctrl">v4l2_queryctrl</a>.</td></tr><tr><td valign="top">__s32</td><td valign="top"><em class="structfield"><code>maximum</code></em></td><td valign="top"> </td><td valign="top">The maximum value of the control. See struct <a class="link" href="media.html#v4l2-queryctrl" title="Table A.94. struct v4l2_queryctrl">v4l2_queryctrl</a>.</td></tr><tr><td valign="top">__s32</td><td valign="top"><em class="structfield"><code>step</code></em></td><td valign="top"> </td><td valign="top">The step value of the control. See struct <a class="link" href="media.html#v4l2-queryctrl" title="Table A.94. struct v4l2_queryctrl">v4l2_queryctrl</a>.</td></tr><tr><td valign="top">__s32</td><td valign="top"><em class="structfield"><code>default_value</code></em></td><td valign="top"> </td><td valign="top">The default value value of the control. See struct <a class="link" href="media.html#v4l2-queryctrl" title="Table A.94. struct v4l2_queryctrl">v4l2_queryctrl</a>.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-event-frame-sync"></a><p class="title"><b>Table A.15. struct <span class="structname">v4l2_event_frame_sync</span></b></p><div class="table-contents"><table summary="struct v4l2_event_frame_sync" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>frame_sequence</code></em></td><td valign="top">
	      The sequence number of the frame being received.
	    </td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-event-src-change"></a><p class="title"><b>Table A.16. struct <span class="structname">v4l2_event_src_change</span></b></p><div class="table-contents"><table summary="struct v4l2_event_src_change" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>changes</code></em></td><td valign="top">
	      A bitmask that tells what has changed. See <a class="xref" href="media.html#src-changes-flags" title="Table A.19. Source Changes">Table A.19, &#8220;Source Changes&#8221;</a>.
	    </td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-event-motion-det"></a><p class="title"><b>Table A.17. struct <span class="structname">v4l2_event_motion_det</span></b></p><div class="table-contents"><table summary="struct v4l2_event_motion_det" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>flags</code></em></td><td valign="top">
	      Currently only one flag is available: if <code class="constant">V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ</code>
	      is set, then the <em class="structfield"><code>frame_sequence</code></em> field is valid,
	      otherwise that field should be ignored.
	    </td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>frame_sequence</code></em></td><td valign="top">
	      The sequence number of the frame being received. Only valid if the
	      <code class="constant">V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ</code> flag was set.
	    </td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>region_mask</code></em></td><td valign="top">
	      The bitmask of the regions that reported motion. There is at least one
	      region. If this field is 0, then no motion was detected at all.
	      If there is no <code class="constant">V4L2_CID_DETECT_MD_REGION_GRID</code> control
	      (see <a class="xref" href="media.html#detect-controls" title="Detect Control Reference">the section called &#8220;Detect Control Reference&#8221;</a>) to assign a different region
	      to each cell in the motion detection grid, then that all cells
	      are automatically assigned to the default region 0.
	    </td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="changes-flags"></a><p class="title"><b>Table A.18. Changes</b></p><div class="table-contents"><table summary="Changes" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_EVENT_CTRL_CH_VALUE</code></td><td valign="top">0x0001</td><td valign="top">This control event was triggered because the value of the control
		changed. Special case: if a button control is pressed, then this
		event is sent as well, even though there is not explicit value
		associated with a button control.</td></tr><tr><td valign="top"><code class="constant">V4L2_EVENT_CTRL_CH_FLAGS</code></td><td valign="top">0x0002</td><td valign="top">This control event was triggered because the control flags
		changed.</td></tr><tr><td valign="top"><code class="constant">V4L2_EVENT_CTRL_CH_RANGE</code></td><td valign="top">0x0004</td><td valign="top">This control event was triggered because the minimum,
	    maximum, step or the default value of the control changed.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="src-changes-flags"></a><p class="title"><b>Table A.19. Source Changes</b></p><div class="table-contents"><table summary="Source Changes" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_EVENT_SRC_CH_RESOLUTION</code></td><td valign="top">0x0001</td><td valign="top">This event gets triggered when a resolution change is
	    detected at an input. This can come from an input connector or
	    from a video decoder.
	    </td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp76368560"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-dv-timings-cap"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_DV_TIMINGS_CAP, VIDIOC_SUBDEV_DV_TIMINGS_CAP &#8212; The capabilities of the Digital Video receiver/transmitter</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_dv_timings_cap *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp76541200"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_DV_TIMINGS_CAP, VIDIOC_SUBDEV_DV_TIMINGS_CAP</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp76549360"></a><h2>Description</h2><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Experimental</h3><p>This is an <a class="link" href="media.html#experimental" title="Experimental API Elements"> experimental </a>
      interface and may change in the future.</p></div><p>To query the capabilities of the DV receiver/transmitter applications
can call the <code class="constant">VIDIOC_DV_TIMINGS_CAP</code> ioctl on a video node
and the driver will fill in the structure. Note that drivers may return
different values after switching the video input or output.</p><p>When implemented by the driver DV capabilities of subdevices can be
queried by calling the <code class="constant">VIDIOC_SUBDEV_DV_TIMINGS_CAP</code> ioctl
directly on a subdevice node. The capabilities are specific to inputs (for DV
receivers) or outputs (for DV transmitters), applications must specify the
desired pad number in the struct <a class="link" href="media.html#v4l2-dv-timings-cap" title="Table A.21. struct v4l2_dv_timings_cap">v4l2_dv_timings_cap</a> <em class="structfield"><code>pad</code></em>
field. Attempts to query capabilities on a pad that doesn't support them will
return an <span class="errorcode">EINVAL</span> error code.</p><div class="table"><a name="v4l2-bt-timings-cap"></a><p class="title"><b>Table A.20. struct <span class="structname">v4l2_bt_timings_cap</span></b></p><div class="table-contents"><table summary="struct v4l2_bt_timings_cap" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>min_width</code></em></td><td valign="top">Minimum width of the active video in pixels.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>max_width</code></em></td><td valign="top">Maximum width of the active video in pixels.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>min_height</code></em></td><td valign="top">Minimum height of the active video in lines.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>max_height</code></em></td><td valign="top">Maximum height of the active video in lines.</td></tr><tr><td valign="top">__u64</td><td valign="top"><em class="structfield"><code>min_pixelclock</code></em></td><td valign="top">Minimum pixelclock frequency in Hz.</td></tr><tr><td valign="top">__u64</td><td valign="top"><em class="structfield"><code>max_pixelclock</code></em></td><td valign="top">Maximum pixelclock frequency in Hz.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>standards</code></em></td><td valign="top">The video standard(s) supported by the hardware.
	    See <a class="xref" href="media.html#dv-bt-standards" title="Table A.59. DV BT Timing standards">Table A.59, &#8220;DV BT Timing standards&#8221;</a> for a list of standards.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>capabilities</code></em></td><td valign="top">Several flags giving more information about the capabilities.
	    See <a class="xref" href="media.html#dv-bt-cap-capabilities" title="Table A.22. DV BT Timing capabilities">Table A.22, &#8220;DV BT Timing capabilities&#8221;</a> for a description of the flags.
	    </td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[16]</td><td valign="top">Reserved for future extensions. Drivers must set the array to zero.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-dv-timings-cap"></a><p class="title"><b>Table A.21. struct <span class="structname">v4l2_dv_timings_cap</span></b></p><div class="table-contents"><table summary="struct v4l2_dv_timings_cap" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>type</code></em></td><td valign="top">Type of DV timings as listed in <a class="xref" href="media.html#dv-timing-types" title="Table A.58. DV Timing types">Table A.58, &#8220;DV Timing types&#8221;</a>.</td><td class="auto-generated"> </td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>pad</code></em></td><td valign="top">Pad number as reported by the media controller API. This field
	    is only used when operating on a subdevice node. When operating on a
	    video node applications must set this field to zero.</td><td class="auto-generated"> </td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[2]</td><td valign="top">Reserved for future extensions. Drivers must set the array to zero.</td><td class="auto-generated"> </td></tr><tr><td valign="top">union</td><td valign="top"><em class="structfield"><code></code></em></td><td valign="top"> </td><td class="auto-generated"> </td></tr><tr><td valign="top"> </td><td valign="top">struct <a class="link" href="media.html#v4l2-bt-timings-cap" title="Table A.20. struct v4l2_bt_timings_cap">v4l2_bt_timings_cap</a></td><td valign="top"><em class="structfield"><code>bt</code></em></td><td valign="top">BT.656/1120 timings capabilities of the hardware.</td></tr><tr><td valign="top"> </td><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>raw_data</code></em>[32]</td><td valign="top"> </td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="dv-bt-cap-capabilities"></a><p class="title"><b>Table A.22. DV BT Timing capabilities</b></p><div class="table-contents"><table summary="DV BT Timing capabilities" width="100%" border="0"><colgroup><col class="c1"><col class="c2"></colgroup><tbody valign="top"><tr><td valign="top">Flag</td><td valign="top">Description</td></tr><tr><td valign="top"> </td><td valign="top"> </td></tr><tr><td valign="top">V4L2_DV_BT_CAP_INTERLACED</td><td valign="top">Interlaced formats are supported.
	    </td></tr><tr><td valign="top">V4L2_DV_BT_CAP_PROGRESSIVE</td><td valign="top">Progressive formats are supported.
	    </td></tr><tr><td valign="top">V4L2_DV_BT_CAP_REDUCED_BLANKING</td><td valign="top">CVT/GTF specific: the timings can make use of reduced blanking (CVT)
or the 'Secondary GTF' curve (GTF).
	    </td></tr><tr><td valign="top">V4L2_DV_BT_CAP_CUSTOM</td><td valign="top">Can support non-standard timings, i.e. timings not belonging to the
standards set in the <em class="structfield"><code>standards</code></em> field.
	    </td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp76615312"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-encoder-cmd"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_ENCODER_CMD, VIDIOC_TRY_ENCODER_CMD &#8212; Execute an encoder command</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_encoder_cmd *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp76716880"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_ENCODER_CMD, VIDIOC_TRY_ENCODER_CMD</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp76725040"></a><h2>Description</h2><p>These ioctls control an audio/video (usually MPEG-) encoder.
<code class="constant">VIDIOC_ENCODER_CMD</code> sends a command to the
encoder, <code class="constant">VIDIOC_TRY_ENCODER_CMD</code> can be used to
try a command without actually executing it.</p><p>To send a command applications must initialize all fields of a
    struct <a class="link" href="media.html#v4l2-encoder-cmd" title="Table A.23. struct v4l2_encoder_cmd">v4l2_encoder_cmd</a> and call
    <code class="constant">VIDIOC_ENCODER_CMD</code> or
    <code class="constant">VIDIOC_TRY_ENCODER_CMD</code> with a pointer to this
    structure.</p><p>The <em class="structfield"><code>cmd</code></em> field must contain the
command code. The <em class="structfield"><code>flags</code></em> field is currently
only used by the STOP command and contains one bit: If the
<code class="constant">V4L2_ENC_CMD_STOP_AT_GOP_END</code> flag is set,
encoding will continue until the end of the current <em class="wordasword">Group
Of Pictures</em>, otherwise it will stop immediately.</p><p>A <code class="function">read</code>() or <a class="link" href="media.html#vidioc-streamon" title="ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF"><code class="constant">VIDIOC_STREAMON</code></a> call sends an implicit
START command to the encoder if it has not been started yet. After a STOP command,
<code class="function">read</code>() calls will read the remaining data
buffered by the driver. When the buffer is empty,
<code class="function">read</code>() will return zero and the next
<code class="function">read</code>() call will restart the encoder.</p><p>A <code class="function">close</code>() or <a class="link" href="media.html#vidioc-streamon" title="ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF"><code class="constant">VIDIOC_STREAMOFF</code></a> call of a streaming
file descriptor sends an implicit immediate STOP to the encoder, and all buffered
data is discarded.</p><p>These ioctls are optional, not all drivers may support
them. They were introduced in Linux 2.6.21.</p><div class="table"><a name="v4l2-encoder-cmd"></a><p class="title"><b>Table A.23. struct <span class="structname">v4l2_encoder_cmd</span></b></p><div class="table-contents"><table summary="struct v4l2_encoder_cmd" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>cmd</code></em></td><td valign="top">The encoder command, see <a class="xref" href="media.html#encoder-cmds" title="Table A.24. Encoder Commands">Table A.24, &#8220;Encoder Commands&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>flags</code></em></td><td valign="top">Flags to go with the command, see <a class="xref" href="media.html#encoder-flags" title="Table A.25. Encoder Command Flags">Table A.25, &#8220;Encoder Command Flags&#8221;</a>. If no flags are defined for
this command, drivers and applications must set this field to
zero.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>data</code></em>[8]</td><td valign="top">Reserved for future extensions. Drivers and
applications must set the array to zero.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="encoder-cmds"></a><p class="title"><b>Table A.24. Encoder Commands</b></p><div class="table-contents"><table summary="Encoder Commands" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_ENC_CMD_START</code></td><td valign="top">0</td><td valign="top">Start the encoder. When the encoder is already
running or paused, this command does nothing. No flags are defined for
this command.</td></tr><tr><td valign="top"><code class="constant">V4L2_ENC_CMD_STOP</code></td><td valign="top">1</td><td valign="top">Stop the encoder. When the
<code class="constant">V4L2_ENC_CMD_STOP_AT_GOP_END</code> flag is set,
encoding will continue until the end of the current <em class="wordasword">Group
Of Pictures</em>, otherwise encoding will stop immediately.
When the encoder is already stopped, this command does
nothing.</td></tr><tr><td valign="top"><code class="constant">V4L2_ENC_CMD_PAUSE</code></td><td valign="top">2</td><td valign="top">Pause the encoder. When the encoder has not been
started yet, the driver will return an <span class="errorcode">EPERM</span> error code. When the encoder is
already paused, this command does nothing. No flags are defined for
this command.</td></tr><tr><td valign="top"><code class="constant">V4L2_ENC_CMD_RESUME</code></td><td valign="top">3</td><td valign="top">Resume encoding after a PAUSE command. When the
encoder has not been started yet, the driver will return an <span class="errorcode">EPERM</span> error code.
When the encoder is already running, this command does nothing. No
flags are defined for this command.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="encoder-flags"></a><p class="title"><b>Table A.25. Encoder Command Flags</b></p><div class="table-contents"><table summary="Encoder Command Flags" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_ENC_CMD_STOP_AT_GOP_END</code></td><td valign="top">0x0001</td><td valign="top">Stop encoding at the end of the current <em class="wordasword">Group Of
Pictures</em>, rather than immediately.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp76777392"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The <em class="structfield"><code>cmd</code></em> field is invalid.</p></dd><dt><span class="term"><span class="errorcode">EPERM</span></span></dt><dd><p>The application sent a PAUSE or RESUME command when
the encoder was not running.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-enumaudio"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_ENUMAUDIO &#8212; Enumerate audio inputs</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_audio *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp76874240"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_ENUMAUDIO</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp76882320"></a><h2>Description</h2><p>To query the attributes of an audio input applications
initialize the <em class="structfield"><code>index</code></em> field and zero out the
<em class="structfield"><code>reserved</code></em> array of a struct <a class="link" href="media.html#v4l2-audio" title="Table A.50. struct v4l2_audio">v4l2_audio</a>
and call the <code class="constant">VIDIOC_ENUMAUDIO</code> ioctl with a pointer
to this structure. Drivers fill the rest of the structure or return an
<span class="errorcode">EINVAL</span> error code when the index is out of bounds. To enumerate all audio
inputs applications shall begin at index zero, incrementing by one
until the driver returns <span class="errorcode">EINVAL</span>.</p><p>See <a class="xref" href="media.html#vidioc-g-audio" title="ioctl VIDIOC_G_AUDIO, VIDIOC_S_AUDIO"><span class="refentrytitle">ioctl VIDIOC_G_AUDIO, VIDIOC_S_AUDIO</span>(2)</a> for a description of
struct <a class="link" href="media.html#v4l2-audio" title="Table A.50. struct v4l2_audio">v4l2_audio</a>.</p></div><div class="refsect1"><a name="idp76889008"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The number of the audio input is out of bounds.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-enumaudioout"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_ENUMAUDOUT &#8212; Enumerate audio outputs</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_audioout *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp76867968"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_ENUMAUDOUT</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp76941840"></a><h2>Description</h2><p>To query the attributes of an audio output applications
initialize the <em class="structfield"><code>index</code></em> field and zero out the
<em class="structfield"><code>reserved</code></em> array of a struct <a class="link" href="media.html#v4l2-audioout" title="Table A.53. struct v4l2_audioout">v4l2_audioout</a> and
call the <code class="constant">VIDIOC_G_AUDOUT</code> ioctl with a pointer
to this structure. Drivers fill the rest of the structure or return an
<span class="errorcode">EINVAL</span> error code when the index is out of bounds. To enumerate all audio
outputs applications shall begin at index zero, incrementing by one
until the driver returns <span class="errorcode">EINVAL</span>.</p><p>Note connectors on a TV card to loop back the received audio
signal to a sound card are not audio outputs in this sense.</p><p>See <a class="xref" href="media.html#vidioc-g-audioout" title="ioctl VIDIOC_G_AUDOUT, VIDIOC_S_AUDOUT"><span class="refentrytitle">ioctl VIDIOC_G_AUDOUT, VIDIOC_S_AUDOUT</span>(2)</a> for a description of
struct <a class="link" href="media.html#v4l2-audioout" title="Table A.53. struct v4l2_audioout">v4l2_audioout</a>.</p></div><div class="refsect1"><a name="idp76949168"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The number of the audio output is out of bounds.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-enum-dv-timings"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_ENUM_DV_TIMINGS, VIDIOC_SUBDEV_ENUM_DV_TIMINGS &#8212; Enumerate supported Digital Video timings</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_enum_dv_timings *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp76994976"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_ENUM_DV_TIMINGS, VIDIOC_SUBDEV_ENUM_DV_TIMINGS</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp77003040"></a><h2>Description</h2><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Experimental</h3><p>This is an <a class="link" href="media.html#experimental" title="Experimental API Elements"> experimental </a>
      interface and may change in the future.</p></div><p>While some DV receivers or transmitters support a wide range of timings, others
support only a limited number of timings. With this ioctl applications can enumerate a list
of known supported timings. Call <a class="link" href="media.html#vidioc-dv-timings-cap" title="ioctl VIDIOC_DV_TIMINGS_CAP, VIDIOC_SUBDEV_DV_TIMINGS_CAP"><code class="constant">VIDIOC_DV_TIMINGS_CAP</code></a> to check if it also supports other
standards or even custom timings that are not in this list.</p><p>To query the available timings, applications initialize the
<em class="structfield"><code>index</code></em> field and zero the reserved array of struct <a class="link" href="media.html#v4l2-enum-dv-timings" title="Table A.26. struct v4l2_enum_dv_timings">v4l2_enum_dv_timings</a>
and call the <code class="constant">VIDIOC_ENUM_DV_TIMINGS</code> ioctl on a video node with a
pointer to this structure. Drivers fill the rest of the structure or return an
<span class="errorcode">EINVAL</span> error code when the index is out of bounds. To enumerate all supported DV timings,
applications shall begin at index zero, incrementing by one until the
driver returns <span class="errorcode">EINVAL</span>. Note that drivers may enumerate a
different set of DV timings after switching the video input or
output.</p><p>When implemented by the driver DV timings of subdevices can be queried
by calling the <code class="constant">VIDIOC_SUBDEV_ENUM_DV_TIMINGS</code> ioctl directly
on a subdevice node. The DV timings are specific to inputs (for DV receivers) or
outputs (for DV transmitters), applications must specify the desired pad number
in the struct <a class="link" href="media.html#v4l2-enum-dv-timings" title="Table A.26. struct v4l2_enum_dv_timings">v4l2_enum_dv_timings</a> <em class="structfield"><code>pad</code></em> field. Attempts to
enumerate timings on a pad that doesn't support them will return an <span class="errorcode">EINVAL</span> error code.</p><div class="table"><a name="v4l2-enum-dv-timings"></a><p class="title"><b>Table A.26. struct <span class="structname">v4l2_enum_dv_timings</span></b></p><div class="table-contents"><table summary="struct v4l2_enum_dv_timings" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>index</code></em></td><td valign="top">Number of the DV timings, set by the
application.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>pad</code></em></td><td valign="top">Pad number as reported by the media controller API. This field
	    is only used when operating on a subdevice node. When operating on a
	    video node applications must set this field to zero.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[2]</td><td valign="top">Reserved for future extensions. Drivers and applications must
	    set the array to zero.</td></tr><tr><td valign="top">struct <a class="link" href="media.html#v4l2-dv-timings" title="Table A.57. struct v4l2_dv_timings">v4l2_dv_timings</a></td><td valign="top"><em class="structfield"><code>timings</code></em></td><td valign="top">The timings.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp77030624"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The struct <a class="link" href="media.html#v4l2-enum-dv-timings" title="Table A.26. struct v4l2_enum_dv_timings">v4l2_enum_dv_timings</a> <em class="structfield"><code>index</code></em>
is out of bounds or the <em class="structfield"><code>pad</code></em> number is invalid.</p></dd><dt><span class="term"><span class="errorcode">ENODATA</span></span></dt><dd><p>Digital video presets are not supported for this input or output.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-enum-fmt"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_ENUM_FMT &#8212; Enumerate image formats</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_fmtdesc
*<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp77103824"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_ENUM_FMT</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp77111904"></a><h2>Description</h2><p>To enumerate image formats applications initialize the
<em class="structfield"><code>type</code></em> and <em class="structfield"><code>index</code></em>
field of struct <a class="link" href="media.html#v4l2-fmtdesc" title="Table A.27. struct v4l2_fmtdesc">v4l2_fmtdesc</a> and call the
<code class="constant">VIDIOC_ENUM_FMT</code> ioctl with a pointer to this
structure. Drivers fill the rest of the structure or return an
<span class="errorcode">EINVAL</span> error code. All formats are enumerable by beginning at index zero and
incrementing by one until <span class="errorcode">EINVAL</span> is
returned.</p><p>Note that after switching input or output the list of enumerated image
formats may be different.</p><div class="table"><a name="v4l2-fmtdesc"></a><p class="title"><b>Table A.27. struct <span class="structname">v4l2_fmtdesc</span></b></p><div class="table-contents"><table summary="struct v4l2_fmtdesc" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>index</code></em></td><td valign="top">Number of the format in the enumeration, set by
the application. This is in no way related to the <em class="structfield"><code>
pixelformat</code></em> field.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>type</code></em></td><td valign="top">Type of the data stream, set by the application.
Only these types are valid here:
<code class="constant">V4L2_BUF_TYPE_VIDEO_CAPTURE</code>,
<code class="constant">V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE</code>,
<code class="constant">V4L2_BUF_TYPE_VIDEO_OUTPUT</code>,
<code class="constant">V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE</code> and
<code class="constant">V4L2_BUF_TYPE_VIDEO_OVERLAY</code>. See <a class="xref" href="media.html#v4l2-buf-type" title="Table 3.3. enum v4l2_buf_type">Table 3.3, &#8220;enum v4l2_buf_type&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>flags</code></em></td><td valign="top">See <a class="xref" href="media.html#fmtdesc-flags" title="Table A.28. Image Format Description Flags">Table A.28, &#8220;Image Format Description Flags&#8221;</a></td></tr><tr><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>description</code></em>[32]</td><td valign="top">Description of the format, a NUL-terminated ASCII
string. This information is intended for the user, for example: "YUV
4:2:2".</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>pixelformat</code></em></td><td valign="top">The image format identifier. This is a
four character code as computed by the v4l2_fourcc()
macro:</td></tr><tr><td colspan="3" valign="top"><p><a name="v4l2-fourcc"></a></p><pre class="programlisting">
#define v4l2_fourcc(a,b,c,d) (((__u32)(a)&lt;&lt;0)|((__u32)(b)&lt;&lt;8)|((__u32)(c)&lt;&lt;16)|((__u32)(d)&lt;&lt;24))
</pre><p>Several image formats are already
defined by this specification in <a class="xref" href="media.html#pixfmt" title="Chapter 2. Image Formats">Chapter 2, <i>Image Formats</i></a>. Note these
codes are not the same as those used in the Windows world.</p></td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[4]</td><td valign="top">Reserved for future extensions. Drivers must set
the array to zero.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="fmtdesc-flags"></a><p class="title"><b>Table A.28. Image Format Description Flags</b></p><div class="table-contents"><table summary="Image Format Description Flags" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_FMT_FLAG_COMPRESSED</code></td><td valign="top">0x0001</td><td valign="top">This is a compressed format.</td></tr><tr><td valign="top"><code class="constant">V4L2_FMT_FLAG_EMULATED</code></td><td valign="top">0x0002</td><td valign="top">This format is not native to the device but emulated
through software (usually libv4l2), where possible try to use a native format
instead for better performance.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp77151904"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The struct <a class="link" href="media.html#v4l2-fmtdesc" title="Table A.27. struct v4l2_fmtdesc">v4l2_fmtdesc</a> <em class="structfield"><code>type</code></em>
is not supported or the <em class="structfield"><code>index</code></em> is out of
bounds.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-enum-framesizes"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_ENUM_FRAMESIZES &#8212; Enumerate frame sizes</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_frmsizeenum *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp77234336"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_ENUM_FRAMESIZES</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p>Pointer to a struct <a class="link" href="media.html#v4l2-frmsizeenum" title="Table A.31. struct v4l2_frmsizeenum">v4l2_frmsizeenum</a> that contains an index
and pixel format and receives a frame width and height.</p></dd></dl></div></div><div class="refsect1"><a name="idp77242624"></a><h2>Description</h2><p>This ioctl allows applications to enumerate all frame sizes
(i. e. width and height in pixels) that the device supports for the
given pixel format.</p><p>The supported pixel formats can be obtained by using the
<a class="link" href="media.html#vidioc-enum-fmt" title="ioctl VIDIOC_ENUM_FMT"><code class="constant">VIDIOC_ENUM_FMT</code></a> function.</p><p>The return value and the content of the
<em class="structfield"><code>v4l2_frmsizeenum.type</code></em> field depend on the
type of frame sizes the device supports. Here are the semantics of the
function for the different cases:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="bold"><strong>Discrete:</strong></span> The function
returns success if the given index value (zero-based) is valid. The
application should increase the index by one for each call until
<code class="constant">EINVAL</code> is returned. The
<em class="structfield"><code>v4l2_frmsizeenum.type</code></em> field is set to
<code class="constant">V4L2_FRMSIZE_TYPE_DISCRETE</code> by the driver. Of the
union only the <em class="structfield"><code>discrete</code></em> member is
valid.</p></li><li class="listitem"><p><span class="bold"><strong>Step-wise:</strong></span> The function
returns success if the given index value is zero and
<code class="constant">EINVAL</code> for any other index value. The
<em class="structfield"><code>v4l2_frmsizeenum.type</code></em> field is set to
<code class="constant">V4L2_FRMSIZE_TYPE_STEPWISE</code> by the driver. Of the
union only the <em class="structfield"><code>stepwise</code></em> member is
valid.</p></li><li class="listitem"><p><span class="bold"><strong>Continuous:</strong></span> This is a
special case of the step-wise type above. The function returns success
if the given index value is zero and <code class="constant">EINVAL</code> for
any other index value. The
<em class="structfield"><code>v4l2_frmsizeenum.type</code></em> field is set to
<code class="constant">V4L2_FRMSIZE_TYPE_CONTINUOUS</code> by the driver. Of
the union only the <em class="structfield"><code>stepwise</code></em> member is valid
and the <em class="structfield"><code>step_width</code></em> and
<em class="structfield"><code>step_height</code></em> values are set to 1.</p></li></ul></div><p>When the application calls the function with index zero, it
must check the <em class="structfield"><code>type</code></em> field to determine the
type of frame size enumeration the device supports. Only for the
<code class="constant">V4L2_FRMSIZE_TYPE_DISCRETE</code> type does it make
sense to increase the index value to receive more frame sizes.</p><p>Note that the order in which the frame sizes are returned
has no special meaning. In particular does it not say anything about
potential default format sizes.</p><p>Applications can assume that the enumeration data does not
change without any interaction from the application itself. This means
that the enumeration data is consistent if the application does not
perform any other ioctl calls while it runs the frame size
enumeration.</p></div><div class="refsect1"><a name="idp77261712"></a><h2>Structs</h2><p>In the structs below, <span class="emphasis"><em>IN</em></span> denotes a
value that has to be filled in by the application,
<span class="emphasis"><em>OUT</em></span> denotes values that the driver fills in. The
application should zero out all members except for the
<span class="emphasis"><em>IN</em></span> fields.</p><div class="table"><a name="v4l2-frmsize-discrete"></a><p class="title"><b>Table A.29. struct <span class="structname">v4l2_frmsize_discrete</span></b></p><div class="table-contents"><table summary="struct v4l2_frmsize_discrete" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>width</code></em></td><td valign="top">Width of the frame [pixel].</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>height</code></em></td><td valign="top">Height of the frame [pixel].</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-frmsize-stepwise"></a><p class="title"><b>Table A.30. struct <span class="structname">v4l2_frmsize_stepwise</span></b></p><div class="table-contents"><table summary="struct v4l2_frmsize_stepwise" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>min_width</code></em></td><td valign="top">Minimum frame width [pixel].</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>max_width</code></em></td><td valign="top">Maximum frame width [pixel].</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>step_width</code></em></td><td valign="top">Frame width step size [pixel].</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>min_height</code></em></td><td valign="top">Minimum frame height [pixel].</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>max_height</code></em></td><td valign="top">Maximum frame height [pixel].</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>step_height</code></em></td><td valign="top">Frame height step size [pixel].</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-frmsizeenum"></a><p class="title"><b>Table A.31. struct <span class="structname">v4l2_frmsizeenum</span></b></p><div class="table-contents"><table summary="struct v4l2_frmsizeenum" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>index</code></em></td><td valign="top"> </td><td valign="top">IN: Index of the given frame size in the enumeration.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>pixel_format</code></em></td><td valign="top"> </td><td valign="top">IN: Pixel format for which the frame sizes are enumerated.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>type</code></em></td><td valign="top"> </td><td valign="top">OUT: Frame size type the device supports.</td></tr><tr><td valign="top">union</td><td valign="top"> </td><td valign="top"> </td><td valign="top">OUT: Frame size with the given index.</td></tr><tr><td valign="top"> </td><td valign="top">struct <a class="link" href="media.html#v4l2-frmsize-discrete" title="Table A.29. struct v4l2_frmsize_discrete">v4l2_frmsize_discrete</a></td><td valign="top"><em class="structfield"><code>discrete</code></em></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td valign="top">struct <a class="link" href="media.html#v4l2-frmsize-stepwise" title="Table A.30. struct v4l2_frmsize_stepwise">v4l2_frmsize_stepwise</a></td><td valign="top"><em class="structfield"><code>stepwise</code></em></td><td valign="top"> </td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved[2]</code></em></td><td valign="top"> </td><td valign="top">Reserved space for future use.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp77313184"></a><h2>Enums</h2><div class="table"><a name="v4l2-frmsizetypes"></a><p class="title"><b>Table A.32. enum <span class="structname">v4l2_frmsizetypes</span></b></p><div class="table-contents"><table summary="enum v4l2_frmsizetypes" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_FRMSIZE_TYPE_DISCRETE</code></td><td valign="top">1</td><td valign="top">Discrete frame size.</td></tr><tr><td valign="top"><code class="constant">V4L2_FRMSIZE_TYPE_CONTINUOUS</code></td><td valign="top">2</td><td valign="top">Continuous frame size.</td></tr><tr><td valign="top"><code class="constant">V4L2_FRMSIZE_TYPE_STEPWISE</code></td><td valign="top">3</td><td valign="top">Step-wise defined frame size.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp77325584"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-enum-frameintervals"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_ENUM_FRAMEINTERVALS &#8212; Enumerate frame intervals</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_frmivalenum *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp77443728"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_ENUM_FRAMEINTERVALS</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p>Pointer to a struct <a class="link" href="media.html#v4l2-frmivalenum" title="Table A.34. struct v4l2_frmivalenum">v4l2_frmivalenum</a> structure that
contains a pixel format and size and receives a frame interval.</p></dd></dl></div></div><div class="refsect1"><a name="idp77452032"></a><h2>Description</h2><p>This ioctl allows applications to enumerate all frame
intervals that the device supports for the given pixel format and
frame size.</p><p>The supported pixel formats and frame sizes can be obtained
by using the <a class="link" href="media.html#vidioc-enum-fmt" title="ioctl VIDIOC_ENUM_FMT"><code class="constant">VIDIOC_ENUM_FMT</code></a> and <a class="link" href="media.html#vidioc-enum-framesizes" title="ioctl VIDIOC_ENUM_FRAMESIZES"><code class="constant">VIDIOC_ENUM_FRAMESIZES</code></a>
functions.</p><p>The return value and the content of the
<em class="structfield"><code>v4l2_frmivalenum.type</code></em> field depend on the
type of frame intervals the device supports. Here are the semantics of
the function for the different cases:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="bold"><strong>Discrete:</strong></span> The function
returns success if the given index value (zero-based) is valid. The
application should increase the index by one for each call until
<code class="constant">EINVAL</code> is returned. The `v4l2_frmivalenum.type`
field is set to `V4L2_FRMIVAL_TYPE_DISCRETE` by the driver. Of the
union only the `discrete` member is valid.</p></li><li class="listitem"><p><span class="bold"><strong>Step-wise:</strong></span> The function
returns success if the given index value is zero and
<code class="constant">EINVAL</code> for any other index value. The
<em class="structfield"><code>v4l2_frmivalenum.type</code></em> field is set to
<code class="constant">V4L2_FRMIVAL_TYPE_STEPWISE</code> by the driver. Of the
union only the <em class="structfield"><code>stepwise</code></em> member is
valid.</p></li><li class="listitem"><p><span class="bold"><strong>Continuous:</strong></span> This is a
special case of the step-wise type above. The function returns success
if the given index value is zero and <code class="constant">EINVAL</code> for
any other index value. The
<em class="structfield"><code>v4l2_frmivalenum.type</code></em> field is set to
<code class="constant">V4L2_FRMIVAL_TYPE_CONTINUOUS</code> by the driver. Of
the union only the <em class="structfield"><code>stepwise</code></em> member is valid
and the <em class="structfield"><code>step</code></em> value is set to 1.</p></li></ul></div><p>When the application calls the function with index zero, it
must check the <em class="structfield"><code>type</code></em> field to determine the
type of frame interval enumeration the device supports. Only for the
<code class="constant">V4L2_FRMIVAL_TYPE_DISCRETE</code> type does it make
sense to increase the index value to receive more frame
intervals.</p><p>Note that the order in which the frame intervals are
returned has no special meaning. In particular does it not say
anything about potential default frame intervals.</p><p>Applications can assume that the enumeration data does not
change without any interaction from the application itself. This means
that the enumeration data is consistent if the application does not
perform any other ioctl calls while it runs the frame interval
enumeration.</p></div><div class="refsect1"><a name="idp77470368"></a><h2>Notes</h2><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="bold"><strong>Frame intervals and frame
rates:</strong></span> The V4L2 API uses frame intervals instead of frame
rates. Given the frame interval the frame rate can be computed as
follows:</p><pre class="screen">frame_rate = 1 / frame_interval</pre></li></ul></div></div><div class="refsect1"><a name="idp77473616"></a><h2>Structs</h2><p>In the structs below, <span class="emphasis"><em>IN</em></span> denotes a
value that has to be filled in by the application,
<span class="emphasis"><em>OUT</em></span> denotes values that the driver fills in. The
application should zero out all members except for the
<span class="emphasis"><em>IN</em></span> fields.</p><div class="table"><a name="v4l2-frmival-stepwise"></a><p class="title"><b>Table A.33. struct <span class="structname">v4l2_frmival_stepwise</span></b></p><div class="table-contents"><table summary="struct v4l2_frmival_stepwise" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">struct <a class="link" href="media.html#v4l2-fract" title="Table A.46. struct v4l2_fract">v4l2_fract</a></td><td valign="top"><em class="structfield"><code>min</code></em></td><td valign="top">Minimum frame interval [s].</td></tr><tr><td valign="top">struct <a class="link" href="media.html#v4l2-fract" title="Table A.46. struct v4l2_fract">v4l2_fract</a></td><td valign="top"><em class="structfield"><code>max</code></em></td><td valign="top">Maximum frame interval [s].</td></tr><tr><td valign="top">struct <a class="link" href="media.html#v4l2-fract" title="Table A.46. struct v4l2_fract">v4l2_fract</a></td><td valign="top"><em class="structfield"><code>step</code></em></td><td valign="top">Frame interval step size [s].</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-frmivalenum"></a><p class="title"><b>Table A.34. struct <span class="structname">v4l2_frmivalenum</span></b></p><div class="table-contents"><table summary="struct v4l2_frmivalenum" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>index</code></em></td><td valign="top"> </td><td valign="top">IN: Index of the given frame interval in the
enumeration.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>pixel_format</code></em></td><td valign="top"> </td><td valign="top">IN: Pixel format for which the frame intervals are
enumerated.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>width</code></em></td><td valign="top"> </td><td valign="top">IN: Frame width for which the frame intervals are
enumerated.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>height</code></em></td><td valign="top"> </td><td valign="top">IN: Frame height for which the frame intervals are
enumerated.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>type</code></em></td><td valign="top"> </td><td valign="top">OUT: Frame interval type the device supports.</td></tr><tr><td valign="top">union</td><td valign="top"> </td><td valign="top"> </td><td valign="top">OUT: Frame interval with the given index.</td></tr><tr><td valign="top"> </td><td valign="top">struct <a class="link" href="media.html#v4l2-fract" title="Table A.46. struct v4l2_fract">v4l2_fract</a></td><td valign="top"><em class="structfield"><code>discrete</code></em></td><td valign="top">Frame interval [s].</td></tr><tr><td valign="top"> </td><td valign="top">struct <a class="link" href="media.html#v4l2-frmival-stepwise" title="Table A.33. struct v4l2_frmival_stepwise">v4l2_frmival_stepwise</a></td><td valign="top"><em class="structfield"><code>stepwise</code></em></td><td valign="top"> </td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved[2]</code></em></td><td valign="top"> </td><td valign="top">Reserved space for future use.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp77514576"></a><h2>Enums</h2><div class="table"><a name="v4l2-frmivaltypes"></a><p class="title"><b>Table A.35. enum <span class="structname">v4l2_frmivaltypes</span></b></p><div class="table-contents"><table summary="enum v4l2_frmivaltypes" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_FRMIVAL_TYPE_DISCRETE</code></td><td valign="top">1</td><td valign="top">Discrete frame interval.</td></tr><tr><td valign="top"><code class="constant">V4L2_FRMIVAL_TYPE_CONTINUOUS</code></td><td valign="top">2</td><td valign="top">Continuous frame interval.</td></tr><tr><td valign="top"><code class="constant">V4L2_FRMIVAL_TYPE_STEPWISE</code></td><td valign="top">3</td><td valign="top">Step-wise defined frame interval.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp77527472"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-enum-freq-bands"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_ENUM_FREQ_BANDS &#8212; Enumerate supported frequency bands</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_frequency_band
*<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp77638480"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_ENUM_FREQ_BANDS</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp77646608"></a><h2>Description</h2><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Experimental</h3><p>This is an <a class="link" href="media.html#experimental" title="Experimental API Elements"> experimental </a>
      interface and may change in the future.</p></div><p>Enumerates the frequency bands that a tuner or modulator supports.
To do this applications initialize the <em class="structfield"><code>tuner</code></em>,
<em class="structfield"><code>type</code></em> and <em class="structfield"><code>index</code></em> fields,
and zero out the <em class="structfield"><code>reserved</code></em> array of a struct <a class="link" href="media.html#v4l2-frequency-band" title="Table A.36. struct v4l2_frequency_band">v4l2_frequency_band</a> and
call the <code class="constant">VIDIOC_ENUM_FREQ_BANDS</code> ioctl with a pointer
to this structure.</p><p>This ioctl is supported if the <code class="constant">V4L2_TUNER_CAP_FREQ_BANDS</code> capability
    of the corresponding tuner/modulator is set.</p><div class="table"><a name="v4l2-frequency-band"></a><p class="title"><b>Table A.36. struct <span class="structname">v4l2_frequency_band</span></b></p><div class="table-contents"><table summary="struct v4l2_frequency_band" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>tuner</code></em></td><td valign="top">The tuner or modulator index number. This is the
same value as in the struct <a class="link" href="media.html#v4l2-input" title="Table A.38. struct v4l2_input">v4l2_input</a> <em class="structfield"><code>tuner</code></em>
field and the struct <a class="link" href="media.html#v4l2-tuner" title="Table A.86. struct v4l2_tuner">v4l2_tuner</a> <em class="structfield"><code>index</code></em> field, or
the struct <a class="link" href="media.html#v4l2-output" title="Table A.42. struct v4l2_output">v4l2_output</a> <em class="structfield"><code>modulator</code></em> field and the
struct <a class="link" href="media.html#v4l2-modulator" title="Table A.75. struct v4l2_modulator">v4l2_modulator</a> <em class="structfield"><code>index</code></em> field.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>type</code></em></td><td valign="top">The tuner type. This is the same value as in the
struct <a class="link" href="media.html#v4l2-tuner" title="Table A.86. struct v4l2_tuner">v4l2_tuner</a> <em class="structfield"><code>type</code></em> field. The type must be set
to <code class="constant">V4L2_TUNER_RADIO</code> for <code class="filename">/dev/radioX</code>
device nodes, and to <code class="constant">V4L2_TUNER_ANALOG_TV</code>
for all others. Set this field to <code class="constant">V4L2_TUNER_RADIO</code> for
modulators (currently only radio modulators are supported).
See <a class="xref" href="media.html#v4l2-tuner-type" title="Table A.87. enum v4l2_tuner_type">Table A.87, &#8220;enum v4l2_tuner_type&#8221;</a></td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>index</code></em></td><td valign="top">Identifies the frequency band, set by the application.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>capability</code></em></td><td colspan="3" valign="top">The tuner/modulator capability flags for
this frequency band, see <a class="xref" href="media.html#tuner-capability" title="Table A.88. Tuner and Modulator Capability Flags">Table A.88, &#8220;Tuner and Modulator Capability Flags&#8221;</a>. The <code class="constant">V4L2_TUNER_CAP_LOW</code>
or <code class="constant">V4L2_TUNER_CAP_1HZ</code> capability must be the same for all frequency bands of the selected tuner/modulator.
So either all bands have that capability set, or none of them have that capability.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>rangelow</code></em></td><td colspan="3" valign="top">The lowest tunable frequency in
units of 62.5 kHz, or if the <em class="structfield"><code>capability</code></em>
flag <code class="constant">V4L2_TUNER_CAP_LOW</code> is set, in units of 62.5
Hz, for this frequency band. A 1 Hz unit is used when the <em class="structfield"><code>capability</code></em> flag
<code class="constant">V4L2_TUNER_CAP_1HZ</code> is set.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>rangehigh</code></em></td><td colspan="3" valign="top">The highest tunable frequency in
units of 62.5 kHz, or if the <em class="structfield"><code>capability</code></em>
flag <code class="constant">V4L2_TUNER_CAP_LOW</code> is set, in units of 62.5
Hz, for this frequency band. A 1 Hz unit is used when the <em class="structfield"><code>capability</code></em> flag
<code class="constant">V4L2_TUNER_CAP_1HZ</code> is set.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>modulation</code></em></td><td colspan="3" valign="top">The supported modulation systems of this frequency band.
	    See <a class="xref" href="media.html#band-modulation" title="Table A.37. Band Modulation Systems">Table A.37, &#8220;Band Modulation Systems&#8221;</a>. Note that currently only one
	    modulation system per frequency band is supported. More work will need to
	    be done if multiple modulation systems are possible. Contact the
	    linux-media mailing list (<a class="ulink" href="http://www.linuxtv.org/lists.php" target="_top">http://www.linuxtv.org/lists.php</a>) if you need that functionality.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[9]</td><td valign="top">Reserved for future extensions. Applications and drivers
	    must set the array to zero.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="band-modulation"></a><p class="title"><b>Table A.37. Band Modulation Systems</b></p><div class="table-contents"><table summary="Band Modulation Systems" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_BAND_MODULATION_VSB</code></td><td valign="top">0x02</td><td valign="top">Vestigial Sideband modulation, used for analog TV.</td></tr><tr><td valign="top"><code class="constant">V4L2_BAND_MODULATION_FM</code></td><td valign="top">0x04</td><td valign="top">Frequency Modulation, commonly used for analog radio.</td></tr><tr><td valign="top"><code class="constant">V4L2_BAND_MODULATION_AM</code></td><td valign="top">0x08</td><td valign="top">Amplitude Modulation, commonly used for analog radio.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp77703888"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The <em class="structfield"><code>tuner</code></em> or <em class="structfield"><code>index</code></em>
is out of bounds or the <em class="structfield"><code>type</code></em> field is wrong.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-enuminput"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_ENUMINPUT &#8212; Enumerate video inputs</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_input
*<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp77802880"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_ENUMINPUT</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp77811008"></a><h2>Description</h2><p>To query the attributes of a video input applications
initialize the <em class="structfield"><code>index</code></em> field of struct <a class="link" href="media.html#v4l2-input" title="Table A.38. struct v4l2_input">v4l2_input</a>
and call the <code class="constant">VIDIOC_ENUMINPUT</code> ioctl with a
pointer to this structure. Drivers fill the rest of the structure or
return an <span class="errorcode">EINVAL</span> error code when the index is out of bounds. To enumerate all
inputs applications shall begin at index zero, incrementing by one
until the driver returns <span class="errorcode">EINVAL</span>.</p><div class="table"><a name="v4l2-input"></a><p class="title"><b>Table A.38. struct <span class="structname">v4l2_input</span></b></p><div class="table-contents"><table summary="struct v4l2_input" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>index</code></em></td><td valign="top">Identifies the input, set by the
application.</td></tr><tr><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>name</code></em>[32]</td><td valign="top">Name of the video input, a NUL-terminated ASCII
string, for example: "Vin (Composite 2)". This information is intended
for the user, preferably the connector label on the device itself.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>type</code></em></td><td valign="top">Type of the input, see <a class="xref" href="media.html#input-type" title="Table A.39. Input Types">Table A.39, &#8220;Input Types&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>audioset</code></em></td><td valign="top"><p>Drivers can enumerate up to 32 video and
audio inputs. This field shows which audio inputs were selectable as
audio source if this was the currently selected video input. It is a
bit mask. The LSB corresponds to audio input 0, the MSB to input 31.
Any number of bits can be set, or none.</p><p>When the driver
does not enumerate audio inputs no bits must be set. Applications
shall not interpret this as lack of audio support. Some drivers
automatically select audio sources and do not enumerate them since
there is no choice anyway.</p><p>For details on audio inputs and
how to select the current input see <a class="xref" href="media.html#audio" title="Audio Inputs and Outputs">the section called &#8220;Audio Inputs and Outputs&#8221;</a>.</p></td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>tuner</code></em></td><td valign="top">Capture devices can have zero or more tuners (RF
demodulators). When the <em class="structfield"><code>type</code></em> is set to
<code class="constant">V4L2_INPUT_TYPE_TUNER</code> this is an RF connector and
this field identifies the tuner. It corresponds to
struct <a class="link" href="media.html#v4l2-tuner" title="Table A.86. struct v4l2_tuner">v4l2_tuner</a> field <em class="structfield"><code>index</code></em>. For details on
tuners see <a class="xref" href="media.html#tuner" title="Tuners and Modulators">the section called &#8220;Tuners and Modulators&#8221;</a>.</td></tr><tr><td valign="top"><a class="link" href="media.html#v4l2-std-id" title="Table A.47. typedef v4l2_std_id">v4l2_std_id</a></td><td valign="top"><em class="structfield"><code>std</code></em></td><td valign="top">Every video input supports one or more different
video standards. This field is a set of all supported standards. For
details on video standards and how to switch see <a class="xref" href="media.html#standard" title="Video Standards">the section called &#8220;Video Standards&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>status</code></em></td><td valign="top">This field provides status information about the
input. See <a class="xref" href="media.html#input-status" title="Table A.40. Input Status Flags">Table A.40, &#8220;Input Status Flags&#8221;</a> for flags.
With the exception of the sensor orientation bits <em class="structfield"><code>status</code></em> is only valid when this is the
current input.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>capabilities</code></em></td><td valign="top">This field provides capabilities for the
input. See <a class="xref" href="media.html#input-capabilities" title="Table A.41. Input capabilities">Table A.41, &#8220;Input capabilities&#8221;</a> for flags.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[3]</td><td valign="top">Reserved for future extensions. Drivers must set
the array to zero.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="input-type"></a><p class="title"><b>Table A.39. Input Types</b></p><div class="table-contents"><table summary="Input Types" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_INPUT_TYPE_TUNER</code></td><td valign="top">1</td><td valign="top">This input uses a tuner (RF demodulator).</td></tr><tr><td valign="top"><code class="constant">V4L2_INPUT_TYPE_CAMERA</code></td><td valign="top">2</td><td valign="top">Analog baseband input, for example CVBS /
Composite Video, S-Video, RGB.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="input-status"></a><p class="title"><b>Table A.40. Input Status Flags</b></p><div class="table-contents"><table summary="Input Status Flags" width="100%" border="0"><colgroup><col class="c1"><col align="center" class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td colspan="3" align="left" valign="top">General</td></tr><tr><td valign="top"><code class="constant">V4L2_IN_ST_NO_POWER</code></td><td align="center" valign="top">0x00000001</td><td valign="top">Attached device is off.</td></tr><tr><td valign="top"><code class="constant">V4L2_IN_ST_NO_SIGNAL</code></td><td align="center" valign="top">0x00000002</td><td valign="top"> </td></tr><tr><td valign="top"><code class="constant">V4L2_IN_ST_NO_COLOR</code></td><td align="center" valign="top">0x00000004</td><td valign="top">The hardware supports color decoding, but does not
detect color modulation in the signal.</td></tr><tr><td colspan="3" align="left" valign="top">Sensor Orientation</td></tr><tr><td valign="top"><code class="constant">V4L2_IN_ST_HFLIP</code></td><td align="center" valign="top">0x00000010</td><td valign="top">The input is connected to a device that produces a signal
that is flipped horizontally and does not correct this before passing the
signal to userspace.</td></tr><tr><td valign="top"><code class="constant">V4L2_IN_ST_VFLIP</code></td><td align="center" valign="top">0x00000020</td><td valign="top">The input is connected to a device that produces a signal
that is flipped vertically and does not correct this before passing the
signal to userspace. Note that a 180 degree rotation is the same as HFLIP | VFLIP</td></tr><tr><td colspan="3" align="left" valign="top">Analog Video</td></tr><tr><td valign="top"><code class="constant">V4L2_IN_ST_NO_H_LOCK</code></td><td align="center" valign="top">0x00000100</td><td valign="top">No horizontal sync lock.</td></tr><tr><td valign="top"><code class="constant">V4L2_IN_ST_COLOR_KILL</code></td><td align="center" valign="top">0x00000200</td><td valign="top">A color killer circuit automatically disables color
decoding when it detects no color modulation. When this flag is set
the color killer is enabled <span class="emphasis"><em>and</em></span> has shut off
color decoding.</td></tr><tr><td colspan="3" align="left" valign="top">Digital Video</td></tr><tr><td valign="top"><code class="constant">V4L2_IN_ST_NO_SYNC</code></td><td align="center" valign="top">0x00010000</td><td valign="top">No synchronization lock.</td></tr><tr><td valign="top"><code class="constant">V4L2_IN_ST_NO_EQU</code></td><td align="center" valign="top">0x00020000</td><td valign="top">No equalizer lock.</td></tr><tr><td valign="top"><code class="constant">V4L2_IN_ST_NO_CARRIER</code></td><td align="center" valign="top">0x00040000</td><td valign="top">Carrier recovery failed.</td></tr><tr><td colspan="3" align="left" valign="top">VCR and Set-Top Box</td></tr><tr><td valign="top"><code class="constant">V4L2_IN_ST_MACROVISION</code></td><td align="center" valign="top">0x01000000</td><td valign="top">Macrovision is an analog copy prevention system
mangling the video signal to confuse video recorders. When this
flag is set Macrovision has been detected.</td></tr><tr><td valign="top"><code class="constant">V4L2_IN_ST_NO_ACCESS</code></td><td align="center" valign="top">0x02000000</td><td valign="top">Conditional access denied.</td></tr><tr><td valign="top"><code class="constant">V4L2_IN_ST_VTR</code></td><td align="center" valign="top">0x04000000</td><td valign="top">VTR time constant. [?]</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="input-capabilities"></a><p class="title"><b>Table A.41. Input capabilities</b></p><div class="table-contents"><table summary="Input capabilities" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_IN_CAP_DV_TIMINGS</code></td><td valign="top">0x00000002</td><td valign="top">This input supports setting video timings by using VIDIOC_S_DV_TIMINGS.</td></tr><tr><td valign="top"><code class="constant">V4L2_IN_CAP_STD</code></td><td valign="top">0x00000004</td><td valign="top">This input supports setting the TV standard by using VIDIOC_S_STD.</td></tr><tr><td valign="top"><code class="constant">V4L2_IN_CAP_NATIVE_SIZE</code></td><td valign="top">0x00000008</td><td valign="top">This input supports setting the native size using
	    the <code class="constant">V4L2_SEL_TGT_NATIVE_SIZE</code>
	    selection target, see <a class="xref" href="media.html#v4l2-selections-common" title="Common selection definitions">the section called &#8220;Common selection definitions&#8221;</a>.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp77905712"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The struct <a class="link" href="media.html#v4l2-input" title="Table A.38. struct v4l2_input">v4l2_input</a> <em class="structfield"><code>index</code></em> is
out of bounds.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-enumoutput"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_ENUMOUTPUT &#8212; Enumerate video outputs</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_output *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp78045792"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_ENUMOUTPUT</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp78053872"></a><h2>Description</h2><p>To query the attributes of a video outputs applications
initialize the <em class="structfield"><code>index</code></em> field of struct <a class="link" href="media.html#v4l2-output" title="Table A.42. struct v4l2_output">v4l2_output</a>
and call the <code class="constant">VIDIOC_ENUMOUTPUT</code> ioctl with a
pointer to this structure. Drivers fill the rest of the structure or
return an <span class="errorcode">EINVAL</span> error code when the index is out of bounds. To enumerate all
outputs applications shall begin at index zero, incrementing by one
until the driver returns <span class="errorcode">EINVAL</span>.</p><div class="table"><a name="v4l2-output"></a><p class="title"><b>Table A.42. struct <span class="structname">v4l2_output</span></b></p><div class="table-contents"><table summary="struct v4l2_output" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>index</code></em></td><td valign="top">Identifies the output, set by the
application.</td></tr><tr><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>name</code></em>[32]</td><td valign="top">Name of the video output, a NUL-terminated ASCII
string, for example: "Vout". This information is intended for the
user, preferably the connector label on the device itself.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>type</code></em></td><td valign="top">Type of the output, see <a class="xref" href="media.html#output-type" title="Table A.43. Output Type">Table A.43, &#8220;Output Type&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>audioset</code></em></td><td valign="top"><p>Drivers can enumerate up to 32 video and
audio outputs. This field shows which audio outputs were
selectable as the current output if this was the currently selected
video output. It is a bit mask. The LSB corresponds to audio output 0,
the MSB to output 31. Any number of bits can be set, or
none.</p><p>When the driver does not enumerate audio outputs no
bits must be set. Applications shall not interpret this as lack of
audio support. Drivers may automatically select audio outputs without
enumerating them.</p><p>For details on audio outputs and how to
select the current output see <a class="xref" href="media.html#audio" title="Audio Inputs and Outputs">the section called &#8220;Audio Inputs and Outputs&#8221;</a>.</p></td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>modulator</code></em></td><td valign="top">Output devices can have zero or more RF modulators.
When the <em class="structfield"><code>type</code></em> is
<code class="constant">V4L2_OUTPUT_TYPE_MODULATOR</code> this is an RF
connector and this field identifies the modulator. It corresponds to
struct <a class="link" href="media.html#v4l2-modulator" title="Table A.75. struct v4l2_modulator">v4l2_modulator</a> field <em class="structfield"><code>index</code></em>. For details
on modulators see <a class="xref" href="media.html#tuner" title="Tuners and Modulators">the section called &#8220;Tuners and Modulators&#8221;</a>.</td></tr><tr><td valign="top"><a class="link" href="media.html#v4l2-std-id" title="Table A.47. typedef v4l2_std_id">v4l2_std_id</a></td><td valign="top"><em class="structfield"><code>std</code></em></td><td valign="top">Every video output supports one or more different
video standards. This field is a set of all supported standards. For
details on video standards and how to switch see <a class="xref" href="media.html#standard" title="Video Standards">the section called &#8220;Video Standards&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>capabilities</code></em></td><td valign="top">This field provides capabilities for the
output. See <a class="xref" href="media.html#output-capabilities" title="Table A.44. Output capabilities">Table A.44, &#8220;Output capabilities&#8221;</a> for flags.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[3]</td><td valign="top">Reserved for future extensions. Drivers must set
the array to zero.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="output-type"></a><p class="title"><b>Table A.43. Output Type</b></p><div class="table-contents"><table summary="Output Type" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_OUTPUT_TYPE_MODULATOR</code></td><td valign="top">1</td><td valign="top">This output is an analog TV modulator.</td></tr><tr><td valign="top"><code class="constant">V4L2_OUTPUT_TYPE_ANALOG</code></td><td valign="top">2</td><td valign="top">Analog baseband output, for example Composite /
CVBS, S-Video, RGB.</td></tr><tr><td valign="top"><code class="constant">V4L2_OUTPUT_TYPE_ANALOGVGAOVERLAY</code></td><td valign="top">3</td><td valign="top">[?]</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="output-capabilities"></a><p class="title"><b>Table A.44. Output capabilities</b></p><div class="table-contents"><table summary="Output capabilities" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_OUT_CAP_DV_TIMINGS</code></td><td valign="top">0x00000002</td><td valign="top">This output supports setting video timings by using VIDIOC_S_DV_TIMINGS.</td></tr><tr><td valign="top"><code class="constant">V4L2_OUT_CAP_STD</code></td><td valign="top">0x00000004</td><td valign="top">This output supports setting the TV standard by using VIDIOC_S_STD.</td></tr><tr><td valign="top"><code class="constant">V4L2_OUT_CAP_NATIVE_SIZE</code></td><td valign="top">0x00000008</td><td valign="top">This output supports setting the native size using
	    the <code class="constant">V4L2_SEL_TGT_NATIVE_SIZE</code>
	    selection target, see <a class="xref" href="media.html#v4l2-selections-common" title="Common selection definitions">the section called &#8220;Common selection definitions&#8221;</a>.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp78111360"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The struct <a class="link" href="media.html#v4l2-output" title="Table A.42. struct v4l2_output">v4l2_output</a> <em class="structfield"><code>index</code></em>
is out of bounds.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-enumstd"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_ENUMSTD &#8212; Enumerate supported video standards</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_standard *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp78211392"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_ENUMSTD</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp78219520"></a><h2>Description</h2><p>To query the attributes of a video standard,
especially a custom (driver defined) one, applications initialize the
<em class="structfield"><code>index</code></em> field of struct <a class="link" href="media.html#v4l2-standard" title="Table A.45. struct v4l2_standard">v4l2_standard</a> and call the
<code class="constant">VIDIOC_ENUMSTD</code> ioctl with a pointer to this
structure. Drivers fill the rest of the structure or return an
<span class="errorcode">EINVAL</span> error code when the index is out of bounds. To enumerate all standards
applications shall begin  at index zero, incrementing by one until the
driver returns <span class="errorcode">EINVAL</span>. Drivers may enumerate a
different set of standards after switching the video input or
output.<a href="media.html#ftn.idp78223936" class="footnote" name="idp78223936"><sup class="footnote">[18]</sup></a></p><div class="table"><a name="v4l2-standard"></a><p class="title"><b>Table A.45. struct <span class="structname">v4l2_standard</span></b></p><div class="table-contents"><table summary="struct v4l2_standard" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>index</code></em></td><td valign="top">Number of the video standard, set by the
application.</td></tr><tr><td valign="top"><a class="link" href="media.html#v4l2-std-id" title="Table A.47. typedef v4l2_std_id">v4l2_std_id</a></td><td valign="top"><em class="structfield"><code>id</code></em></td><td valign="top">The bits in this field identify the standard as
one of the common standards listed in <a class="xref" href="media.html#v4l2-std-id" title="Table A.47. typedef v4l2_std_id">Table A.47, &#8220;typedef <span class="structname">v4l2_std_id</span>&#8221;</a>,
or if bits 32 to 63 are set as custom standards. Multiple bits can be
set if the hardware does not distinguish between these standards,
however separate indices do not indicate the opposite. The
<em class="structfield"><code>id</code></em> must be unique. No other enumerated
<span class="structname">v4l2_standard</span> structure, for this input or
output anyway, can contain the same set of bits.</td></tr><tr><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>name</code></em>[24]</td><td valign="top">Name of the standard, a NUL-terminated ASCII
string, for example: "PAL-B/G", "NTSC Japan". This information is
intended for the user.</td></tr><tr><td valign="top">struct <a class="link" href="media.html#v4l2-fract" title="Table A.46. struct v4l2_fract">v4l2_fract</a></td><td valign="top"><em class="structfield"><code>frameperiod</code></em></td><td valign="top">The frame period (not field period) is numerator
/ denominator. For example M/NTSC has a frame period of 1001 /
30000 seconds.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>framelines</code></em></td><td valign="top">Total lines per frame including blanking,
e. g. 625 for B/PAL.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[4]</td><td valign="top">Reserved for future extensions. Drivers must set
the array to zero.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-fract"></a><p class="title"><b>Table A.46. struct <span class="structname">v4l2_fract</span></b></p><div class="table-contents"><table summary="struct v4l2_fract" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>numerator</code></em></td><td valign="top"> </td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>denominator</code></em></td><td valign="top"> </td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-std-id"></a><p class="title"><b>Table A.47. typedef <span class="structname">v4l2_std_id</span></b></p><div class="table-contents"><table summary="typedef v4l2_std_id" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u64</td><td valign="top"><em class="structfield"><code>v4l2_std_id</code></em></td><td valign="top">This type is a set, each bit representing another
video standard as listed below and in <a class="xref" href="media.html#video-standards" title="Table A.48. Video Standards (based on [[ITU BT.470]])">Table A.48, &#8220;Video Standards (based on [[<abbr class="abbrev">ITU BT.470</abbr>]])&#8221;</a>. The 32 most significant bits are reserved
for custom (driver defined) video standards.</td></tr></tbody></table></div></div><br class="table-break"><pre class="programlisting">
#define V4L2_STD_PAL_B          ((v4l2_std_id)0x00000001)
#define V4L2_STD_PAL_B1         ((v4l2_std_id)0x00000002)
#define V4L2_STD_PAL_G          ((v4l2_std_id)0x00000004)
#define V4L2_STD_PAL_H          ((v4l2_std_id)0x00000008)
#define V4L2_STD_PAL_I          ((v4l2_std_id)0x00000010)
#define V4L2_STD_PAL_D          ((v4l2_std_id)0x00000020)
#define V4L2_STD_PAL_D1         ((v4l2_std_id)0x00000040)
#define V4L2_STD_PAL_K          ((v4l2_std_id)0x00000080)

#define V4L2_STD_PAL_M          ((v4l2_std_id)0x00000100)
#define V4L2_STD_PAL_N          ((v4l2_std_id)0x00000200)
#define V4L2_STD_PAL_Nc         ((v4l2_std_id)0x00000400)
#define V4L2_STD_PAL_60         ((v4l2_std_id)0x00000800)
</pre><p><code class="constant">V4L2_STD_PAL_60</code> is
a hybrid standard with 525 lines, 60 Hz refresh rate, and PAL color
modulation with a 4.43 MHz color subcarrier. Some PAL video recorders
can play back NTSC tapes in this mode for display on a 50/60 Hz agnostic
PAL TV.</p><pre class="programlisting">
#define V4L2_STD_NTSC_M         ((v4l2_std_id)0x00001000)
#define V4L2_STD_NTSC_M_JP      ((v4l2_std_id)0x00002000)
#define V4L2_STD_NTSC_443       ((v4l2_std_id)0x00004000)
</pre><p><code class="constant">V4L2_STD_NTSC_443</code>
is a hybrid standard with 525 lines, 60 Hz refresh rate, and NTSC
color modulation with a 4.43 MHz color
subcarrier.</p><pre class="programlisting">
#define V4L2_STD_NTSC_M_KR      ((v4l2_std_id)0x00008000)

#define V4L2_STD_SECAM_B        ((v4l2_std_id)0x00010000)
#define V4L2_STD_SECAM_D        ((v4l2_std_id)0x00020000)
#define V4L2_STD_SECAM_G        ((v4l2_std_id)0x00040000)
#define V4L2_STD_SECAM_H        ((v4l2_std_id)0x00080000)
#define V4L2_STD_SECAM_K        ((v4l2_std_id)0x00100000)
#define V4L2_STD_SECAM_K1       ((v4l2_std_id)0x00200000)
#define V4L2_STD_SECAM_L        ((v4l2_std_id)0x00400000)
#define V4L2_STD_SECAM_LC       ((v4l2_std_id)0x00800000)

/* ATSC/HDTV */
#define V4L2_STD_ATSC_8_VSB     ((v4l2_std_id)0x01000000)
#define V4L2_STD_ATSC_16_VSB    ((v4l2_std_id)0x02000000)
</pre><p><code class="constant">V4L2_STD_ATSC_8_VSB</code> and
<code class="constant">V4L2_STD_ATSC_16_VSB</code> are U.S. terrestrial digital
TV standards. Presently the V4L2 API does not support digital TV. See
also the Linux DVB API at <a class="ulink" href="http://linuxtv.org" target="_top">http://linuxtv.org</a>.</p><pre class="programlisting">
#define V4L2_STD_PAL_BG         (V4L2_STD_PAL_B         |\
				 V4L2_STD_PAL_B1        |\
				 V4L2_STD_PAL_G)
#define V4L2_STD_B              (V4L2_STD_PAL_B         |\
				 V4L2_STD_PAL_B1        |\
				 V4L2_STD_SECAM_B)
#define V4L2_STD_GH             (V4L2_STD_PAL_G         |\
				 V4L2_STD_PAL_H         |\
				 V4L2_STD_SECAM_G       |\
				 V4L2_STD_SECAM_H)
#define V4L2_STD_PAL_DK         (V4L2_STD_PAL_D         |\
				 V4L2_STD_PAL_D1        |\
				 V4L2_STD_PAL_K)
#define V4L2_STD_PAL            (V4L2_STD_PAL_BG        |\
				 V4L2_STD_PAL_DK        |\
				 V4L2_STD_PAL_H         |\
				 V4L2_STD_PAL_I)
#define V4L2_STD_NTSC           (V4L2_STD_NTSC_M        |\
				 V4L2_STD_NTSC_M_JP     |\
				 V4L2_STD_NTSC_M_KR)
#define V4L2_STD_MN             (V4L2_STD_PAL_M         |\
				 V4L2_STD_PAL_N         |\
				 V4L2_STD_PAL_Nc        |\
				 V4L2_STD_NTSC)
#define V4L2_STD_SECAM_DK       (V4L2_STD_SECAM_D       |\
				 V4L2_STD_SECAM_K       |\
				 V4L2_STD_SECAM_K1)
#define V4L2_STD_DK             (V4L2_STD_PAL_DK        |\
				 V4L2_STD_SECAM_DK)

#define V4L2_STD_SECAM          (V4L2_STD_SECAM_B       |\
				 V4L2_STD_SECAM_G       |\
				 V4L2_STD_SECAM_H       |\
				 V4L2_STD_SECAM_DK      |\
				 V4L2_STD_SECAM_L       |\
				 V4L2_STD_SECAM_LC)

#define V4L2_STD_525_60         (V4L2_STD_PAL_M         |\
				 V4L2_STD_PAL_60        |\
				 V4L2_STD_NTSC          |\
				 V4L2_STD_NTSC_443)
#define V4L2_STD_625_50         (V4L2_STD_PAL           |\
				 V4L2_STD_PAL_N         |\
				 V4L2_STD_PAL_Nc        |\
				 V4L2_STD_SECAM)

#define V4L2_STD_UNKNOWN        0
#define V4L2_STD_ALL            (V4L2_STD_525_60        |\
				 V4L2_STD_625_50)
</pre><div class="table"><a name="video-standards"></a><p class="title"><b>Table A.48. Video Standards (based on [<a class="xref" href="media.html#itu470" title='ITU-R Recommendation BT.470-6 "Conventional Television Systems"'>[<abbr class="abbrev">ITU BT.470</abbr>]</a>])</b></p><div class="table-contents"><table summary="Video Standards (based on [])" width="100%" border="1"><colgroup><col align="left" class="c1"><col align="center" class="c2"><col align="center" class="c3"><col align="center" class="c4"><col align="center" class="c5"><col><col align="center" class="c7"><col><col align="center" class="c9"><col><col><col align="center" class="c12"></colgroup><thead><tr><th align="left">Characteristics</th><th align="center"><p>M/NTSC<a href="media.html#ftn.idp78290752" class="footnote" name="idp78290752"><sup class="footnote">[a]</sup></a></p></th><th align="center">M/PAL</th><th align="center"><p>N/PAL<a href="media.html#ftn.idp78292448" class="footnote" name="idp78292448"><sup class="footnote">[b]</sup></a></p></th><th align="center">B, B1, G/PAL</th><th align="center">D, D1, K/PAL</th><th align="center">H/PAL</th><th align="center">I/PAL</th><th align="center">B, G/SECAM</th><th align="center">D, K/SECAM</th><th align="center">K1/SECAM</th><th align="center">L/SECAM</th></tr></thead><tbody valign="top"><tr><td align="left" valign="top">Frame lines</td><td colspan="2" align="center" valign="top">525</td><td colspan="9" align="center" valign="top">625</td></tr><tr><td align="left" valign="top">Frame period (s)</td><td colspan="2" align="center" valign="top">1001/30000</td><td colspan="9" align="center" valign="top">1/25</td></tr><tr><td align="left" valign="top">Chrominance sub-carrier frequency (Hz)</td><td align="center" valign="top">3579545 ± 10</td><td align="center" valign="top">3579611.49 ± 10</td><td align="center" valign="top">4433618.75 ± 5 (3582056.25
± 5)</td><td colspan="3" align="center" valign="top">4433618.75 ± 5</td><td align="center" valign="top">4433618.75 ± 1</td><td colspan="4" align="center" valign="top">f<sub>OR</sub> =
4406250 ± 2000, f<sub>OB</sub> = 4250000
± 2000</td></tr><tr><td align="left" valign="top">Nominal radio-frequency channel bandwidth
(MHz)</td><td align="center" valign="top">6</td><td align="center" valign="top">6</td><td align="center" valign="top">6</td><td align="center" valign="top">B: 7; B1, G: 8</td><td align="center" valign="top">8</td><td align="center" valign="top">8</td><td align="center" valign="top">8</td><td align="center" valign="top">8</td><td align="center" valign="top">8</td><td align="center" valign="top">8</td><td align="center" valign="top">8</td></tr><tr><td align="left" valign="top">Sound carrier relative to vision carrier
(MHz)</td><td align="center" valign="top">+ 4.5</td><td align="center" valign="top">+ 4.5</td><td align="center" valign="top">+ 4.5</td><td align="center" valign="top"><p>+ 5.5 ± 0.001
<a href="media.html#ftn.idp78316544" class="footnote" name="idp78316544"><sup class="footnote">[c]</sup></a> <a href="media.html#ftn.idp78316960" class="footnote" name="idp78316960"><sup class="footnote">[d]</sup></a> <a href="media.html#ftn.idp78318192" class="footnote" name="idp78318192"><sup class="footnote">[e]</sup></a> <a href="media.html#ftn.idp78318576" class="footnote" name="idp78318576"><sup class="footnote">[f]</sup></a></p></td><td align="center" valign="top">+ 6.5 ± 0.001</td><td align="center" valign="top">+ 5.5</td><td align="center" valign="top">+ 5.9996 ± 0.0005</td><td align="center" valign="top">+ 5.5 ± 0.001</td><td align="center" valign="top">+ 6.5 ± 0.001</td><td align="center" valign="top">+ 6.5</td><td align="center" valign="top"><p>+ 6.5 <a href="media.html#ftn.idp78322304" class="footnote" name="idp78322304"><sup class="footnote">[g]</sup></a></p></td></tr></tbody><tbody class="footnotes"><tr><td colspan="12"><div id="ftn.idp78290752" class="footnote"><p><a href="media.html#idp78290752" class="para"><sup class="para">[a] </sup></a>Japan uses a standard
similar to M/NTSC
(V4L2_STD_NTSC_M_JP).</p></div><div id="ftn.idp78292448" class="footnote"><p><a href="media.html#idp78292448" class="para"><sup class="para">[b] </sup></a> The values in
brackets apply to the combination N/PAL a.k.a.
N<sub>C</sub> used in Argentina
(V4L2_STD_PAL_Nc).</p></div><div id="ftn.idp78316544" class="footnote"><p><a href="media.html#idp78316544" class="para"><sup class="para">[c] </sup></a>In the Federal Republic of Germany, Austria, Italy,
the Netherlands, Slovakia and Switzerland a system of two sound
carriers is used, the frequency of the second carrier being
242.1875 kHz above the frequency of the first sound carrier. For
stereophonic sound transmissions a similar system is used in
Australia.</p></div><div id="ftn.idp78316960" class="footnote"><p><a href="media.html#idp78316960" class="para"><sup class="para">[d] </sup></a>New Zealand uses a sound
carrier displaced 5.4996 ± 0.0005 MHz from the vision
carrier.</p></div><div id="ftn.idp78318192" class="footnote"><p><a href="media.html#idp78318192" class="para"><sup class="para">[e] </sup></a>In Denmark, Finland, New
Zealand, Sweden and Spain a system of two sound carriers is used. In
Iceland, Norway and Poland the same system is being introduced. The
second carrier is 5.85 MHz above the vision carrier and is DQPSK
modulated with 728 kbit/s sound and data multiplex. (NICAM
system)</p></div><div id="ftn.idp78318576" class="footnote"><p><a href="media.html#idp78318576" class="para"><sup class="para">[f] </sup></a>In the United Kingdom, a
system of two sound carriers is used. The second sound carrier is
6.552 MHz above the vision carrier and is DQPSK modulated with a
728 kbit/s sound and data multiplex able to carry two sound
channels. (NICAM system)</p></div><div id="ftn.idp78322304" class="footnote"><p><a href="media.html#idp78322304" class="para"><sup class="para">[g] </sup></a>In France, a
digital carrier 5.85 MHz away from the vision carrier may be used in
addition to the main sound carrier. It is modulated in differentially
encoded QPSK with a 728 kbit/s sound and data multiplexer capable of
carrying two sound channels. (NICAM
system)</p></div></td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp78324320"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The struct <a class="link" href="media.html#v4l2-standard" title="Table A.45. struct v4l2_standard">v4l2_standard</a> <em class="structfield"><code>index</code></em>
is out of bounds.</p></dd><dt><span class="term"><span class="errorcode">ENODATA</span></span></dt><dd><p>Standard video timings are not supported for this input or output.</p></dd></dl></div></div><div class="footnotes"><br><hr style="width:100; text-align:left;margin-left: 0"><div id="ftn.idp78223936" class="footnote"><p><a href="media.html#idp78223936" class="para"><sup class="para">[18] </sup></a>The supported standards may overlap and we need an
unambiguous set to find the current standard returned by
<code class="constant">VIDIOC_G_STD</code>.</p></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-expbuf"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_EXPBUF &#8212; Export a buffer as a DMABUF file descriptor.</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_exportbuffer *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp78475600"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_EXPBUF</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp78483728"></a><h2>Description</h2><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Experimental</h3><p>This is an <a class="link" href="media.html#experimental" title="Experimental API Elements"> experimental </a>
      interface and may change in the future.</p></div><p>This ioctl is an extension to the <a class="link" href="media.html#mmap" title="Streaming I/O (Memory Mapping)">memory
mapping</a> I/O method, therefore it is available only for
<code class="constant">V4L2_MEMORY_MMAP</code> buffers.  It can be used to export a
buffer as a DMABUF file at any time after buffers have been allocated with the
<a class="link" href="media.html#vidioc-reqbufs" title="ioctl VIDIOC_REQBUFS"><code class="constant">VIDIOC_REQBUFS</code></a> ioctl.</p><p> To export a buffer, applications fill struct <a class="link" href="media.html#v4l2-exportbuffer" title="Table A.49. struct v4l2_exportbuffer">v4l2_exportbuffer</a>.  The
<em class="structfield"><code> type </code></em> field is set to the same buffer type as was
previously used with  struct <a class="link" href="media.html#v4l2-requestbuffers" title="Table A.99. struct v4l2_requestbuffers">v4l2_requestbuffers</a><em class="structfield"><code> type </code></em>.
Applications must also set the <em class="structfield"><code> index </code></em> field. Valid
index numbers range from zero to the number of buffers allocated with
<a class="link" href="media.html#vidioc-reqbufs" title="ioctl VIDIOC_REQBUFS"><code class="constant">VIDIOC_REQBUFS</code></a> (struct <a class="link" href="media.html#v4l2-requestbuffers" title="Table A.99. struct v4l2_requestbuffers">v4l2_requestbuffers</a><em class="structfield"><code> count </code></em>)
minus one.  For the multi-planar API, applications set the <em class="structfield"><code> plane
</code></em> field to the index of the plane to be exported. Valid planes
range from zero to the maximal number of valid planes for the currently active
format. For the single-planar API, applications must set <em class="structfield"><code> plane
</code></em> to zero.  Additional flags may be posted in the <em class="structfield"><code>
flags </code></em> field.  Refer to a manual for open() for details.
Currently only O_CLOEXEC, O_RDONLY, O_WRONLY, and O_RDWR are supported.  All
other fields must be set to zero.
In the case of multi-planar API, every plane is exported separately using
multiple <code class="constant"> VIDIOC_EXPBUF </code> calls. </p><p> After calling <code class="constant">VIDIOC_EXPBUF</code> the <em class="structfield"><code> fd
</code></em> field will be set by a driver.  This is a DMABUF file
descriptor. The application may pass it to other DMABUF-aware devices. Refer to
<a class="link" href="media.html#dmabuf" title="Streaming I/O (DMA buffer importing)">DMABUF importing</a> for details about importing
DMABUF files into V4L2 nodes. It is recommended to close a DMABUF file when it
is no longer used to allow the associated memory to be reclaimed. </p></div><div class="refsect1"><a name="idp78499744"></a><h2>Examples</h2><div class="example"><a name="idp78500416"></a><p class="title"><b>Example A.1. Exporting a buffer.</b></p><div class="example-contents"><pre class="programlisting">
int buffer_export(int v4lfd, enum <a class="link" href="media.html#v4l2-buf-type" title="Table 3.3. enum v4l2_buf_type">v4l2_buf_type</a> bt, int index, int *dmafd)
{
	struct <a class="link" href="media.html#v4l2-exportbuffer" title="Table A.49. struct v4l2_exportbuffer">v4l2_exportbuffer</a> expbuf;

	memset(&amp;expbuf, 0, sizeof(expbuf));
	expbuf.type = bt;
	expbuf.index = index;
	if (ioctl(v4lfd, <a class="link" href="media.html#vidioc-expbuf" title="ioctl VIDIOC_EXPBUF"><code class="constant">VIDIOC_EXPBUF</code></a>, &amp;expbuf) == -1) {
		perror("VIDIOC_EXPBUF");
		return -1;
	}

	*dmafd = expbuf.fd;

	return 0;
}
      </pre></div></div><br class="example-break"><div class="example"><a name="idp78504848"></a><p class="title"><b>Example A.2. Exporting a buffer using the multi-planar API.</b></p><div class="example-contents"><pre class="programlisting">
int buffer_export_mp(int v4lfd, enum <a class="link" href="media.html#v4l2-buf-type" title="Table 3.3. enum v4l2_buf_type">v4l2_buf_type</a> bt, int index,
	int dmafd[], int n_planes)
{
	int i;

	for (i = 0; i &lt; n_planes; ++i) {
		struct <a class="link" href="media.html#v4l2-exportbuffer" title="Table A.49. struct v4l2_exportbuffer">v4l2_exportbuffer</a> expbuf;

		memset(&amp;expbuf, 0, sizeof(expbuf));
		expbuf.type = bt;
		expbuf.index = index;
		expbuf.plane = i;
		if (ioctl(v4lfd, <a class="link" href="media.html#vidioc-expbuf" title="ioctl VIDIOC_EXPBUF"><code class="constant">VIDIOC_EXPBUF</code></a>, &amp;expbuf) == -1) {
			perror("VIDIOC_EXPBUF");
			while (i)
				close(dmafd[--i]);
			return -1;
		}
		dmafd[i] = expbuf.fd;
	}

	return 0;
}
      </pre></div></div><br class="example-break"><div class="table"><a name="v4l2-exportbuffer"></a><p class="title"><b>Table A.49. struct <span class="structname">v4l2_exportbuffer</span></b></p><div class="table-contents"><table summary="struct v4l2_exportbuffer" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>type</code></em></td><td valign="top">Type of the buffer, same as struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a>
<em class="structfield"><code>type</code></em> or struct <a class="link" href="media.html#v4l2-requestbuffers" title="Table A.99. struct v4l2_requestbuffers">v4l2_requestbuffers</a>
<em class="structfield"><code>type</code></em>, set by the application. See <a class="xref" href="media.html#v4l2-buf-type" title="Table 3.3. enum v4l2_buf_type">Table 3.3, &#8220;enum v4l2_buf_type&#8221;</a></td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>index</code></em></td><td valign="top">Number of the buffer, set by the application. This field is
only used for <a class="link" href="media.html#mmap" title="Streaming I/O (Memory Mapping)">memory mapping</a> I/O and can range from
zero to the number of buffers allocated with the <a class="link" href="media.html#vidioc-reqbufs" title="ioctl VIDIOC_REQBUFS"><code class="constant">VIDIOC_REQBUFS</code></a> and/or
<a class="link" href="media.html#vidioc-create-bufs" title="ioctl VIDIOC_CREATE_BUFS"><code class="constant">VIDIOC_CREATE_BUFS</code></a> ioctls. </td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>plane</code></em></td><td valign="top">Index of the plane to be exported when using the
multi-planar API. Otherwise this value must be set to zero. </td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>flags</code></em></td><td valign="top">Flags for the newly created file, currently only <code class="constant">
O_CLOEXEC </code>, <code class="constant">O_RDONLY</code>, <code class="constant">O_WRONLY
</code>, and <code class="constant">O_RDWR</code> are supported, refer to the manual
of open() for more details.</td></tr><tr><td valign="top">__s32</td><td valign="top"><em class="structfield"><code>fd</code></em></td><td valign="top">The DMABUF file descriptor associated with a buffer. Set by
		the driver.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved[11]</code></em></td><td valign="top">Reserved field for future use. Must be set to zero.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp78533728"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>A queue is not in MMAP mode or DMABUF exporting is not
supported or <em class="structfield"><code> flags </code></em> or <em class="structfield"><code> type
</code></em> or <em class="structfield"><code> index </code></em> or <em class="structfield"><code> plane
</code></em> fields are invalid.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-g-audio"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_G_AUDIO, VIDIOC_S_AUDIO &#8212; Query or select the current audio input and its
attributes</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_audio *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>const struct v4l2_audio *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp78630272"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_G_AUDIO, VIDIOC_S_AUDIO</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp78638416"></a><h2>Description</h2><p>To query the current audio input applications zero out the
<em class="structfield"><code>reserved</code></em> array of a struct <a class="link" href="media.html#v4l2-audio" title="Table A.50. struct v4l2_audio">v4l2_audio</a>
and call the <code class="constant">VIDIOC_G_AUDIO</code> ioctl with a pointer
to this structure. Drivers fill the rest of the structure or return an
<span class="errorcode">EINVAL</span> error code when the device has no audio inputs, or none which combine
with the current video input.</p><p>Audio inputs have one writable property, the audio mode. To
select the current audio input <span class="emphasis"><em>and</em></span> change the
audio mode, applications initialize the
<em class="structfield"><code>index</code></em> and <em class="structfield"><code>mode</code></em>
fields, and the
<em class="structfield"><code>reserved</code></em> array of a
<span class="structname">v4l2_audio</span> structure and call the
<code class="constant">VIDIOC_S_AUDIO</code> ioctl. Drivers may switch to a
different audio mode if the request cannot be satisfied. However, this
is a write-only ioctl, it does not return the actual new audio
mode.</p><div class="table"><a name="v4l2-audio"></a><p class="title"><b>Table A.50. struct <span class="structname">v4l2_audio</span></b></p><div class="table-contents"><table summary="struct v4l2_audio" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>index</code></em></td><td valign="top">Identifies the audio input, set by the
driver or application.</td></tr><tr><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>name</code></em>[32]</td><td valign="top">Name of the audio input, a NUL-terminated ASCII
string, for example: "Line In". This information is intended for the
user, preferably the connector label on the device itself.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>capability</code></em></td><td valign="top">Audio capability flags, see <a class="xref" href="media.html#audio-capability" title="Table A.51. Audio Capability Flags">Table A.51, &#8220;Audio Capability Flags&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>mode</code></em></td><td valign="top">Audio mode flags set by drivers and applications (on
	    <code class="constant">VIDIOC_S_AUDIO</code> ioctl), see <a class="xref" href="media.html#audio-mode" title="Table A.52. Audio Mode Flags">Table A.52, &#8220;Audio Mode Flags&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[2]</td><td valign="top">Reserved for future extensions. Drivers and
applications must set the array to zero.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="audio-capability"></a><p class="title"><b>Table A.51. Audio Capability Flags</b></p><div class="table-contents"><table summary="Audio Capability Flags" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_AUDCAP_STEREO</code></td><td valign="top">0x00001</td><td valign="top">This is a stereo input. The flag is intended to
automatically disable stereo recording etc. when the signal is always
monaural. The API provides no means to detect if stereo is
<span class="emphasis"><em>received</em></span>, unless the audio input belongs to a
tuner.</td></tr><tr><td valign="top"><code class="constant">V4L2_AUDCAP_AVL</code></td><td valign="top">0x00002</td><td valign="top">Automatic Volume Level mode is supported.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="audio-mode"></a><p class="title"><b>Table A.52. Audio Mode Flags</b></p><div class="table-contents"><table summary="Audio Mode Flags" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_AUDMODE_AVL</code></td><td valign="top">0x00001</td><td valign="top">AVL mode is on.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp78681488"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>No audio inputs combine with the current video input,
or the number of the selected audio input is out of bounds or it does
not combine.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-g-audioout"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_G_AUDOUT, VIDIOC_S_AUDOUT &#8212; Query or select the current audio output</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_audioout *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>const struct v4l2_audioout *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp78774768"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_G_AUDOUT, VIDIOC_S_AUDOUT</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp78782912"></a><h2>Description</h2><p>To query the current audio output applications zero out the
<em class="structfield"><code>reserved</code></em> array of a struct <a class="link" href="media.html#v4l2-audioout" title="Table A.53. struct v4l2_audioout">v4l2_audioout</a> and
call the <code class="constant">VIDIOC_G_AUDOUT</code> ioctl with a pointer
to this structure. Drivers fill the rest of the structure or return an
<span class="errorcode">EINVAL</span> error code when the device has no audio inputs, or none which combine
with the current video output.</p><p>Audio outputs have no writable properties. Nevertheless, to
select the current audio output applications can initialize the
<em class="structfield"><code>index</code></em> field and
<em class="structfield"><code>reserved</code></em> array (which in the future may
contain writable properties) of a
<span class="structname">v4l2_audioout</span> structure and call the
<code class="constant">VIDIOC_S_AUDOUT</code> ioctl. Drivers switch to the
requested output or return the <span class="errorcode">EINVAL</span> error code when the index is out of
bounds. This is a write-only ioctl, it does not return the current
audio output attributes as <code class="constant">VIDIOC_G_AUDOUT</code>
does.</p><p>Note connectors on a TV card to loop back the received audio
signal to a sound card are not audio outputs in this sense.</p><div class="table"><a name="v4l2-audioout"></a><p class="title"><b>Table A.53. struct <span class="structname">v4l2_audioout</span></b></p><div class="table-contents"><table summary="struct v4l2_audioout" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>index</code></em></td><td valign="top">Identifies the audio output, set by the
driver or application.</td></tr><tr><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>name</code></em>[32]</td><td valign="top">Name of the audio output, a NUL-terminated ASCII
string, for example: "Line Out". This information is intended for the
user, preferably the connector label on the device itself.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>capability</code></em></td><td valign="top">Audio capability flags, none defined yet. Drivers
must set this field to zero.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>mode</code></em></td><td valign="top">Audio mode, none defined yet. Drivers and
applications (on <code class="constant">VIDIOC_S_AUDOUT</code>) must set this
field to zero.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[2]</td><td valign="top">Reserved for future extensions. Drivers and
applications must set the array to zero.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp78807168"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>No audio outputs combine with the current video
output, or the number of the selected audio output is out of bounds or
it does not combine.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-g-crop"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_G_CROP, VIDIOC_S_CROP &#8212; Get or set the current cropping rectangle</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_crop *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>const struct v4l2_crop *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp78881264"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_G_CROP, VIDIOC_S_CROP</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp78889408"></a><h2>Description</h2><p>To query the cropping rectangle size and position
applications set the <em class="structfield"><code>type</code></em> field of a
<span class="structname">v4l2_crop</span> structure to the respective buffer
(stream) type and call the <code class="constant">VIDIOC_G_CROP</code> ioctl
with a pointer to this structure. The driver fills the rest of the
structure or returns the <span class="errorcode">EINVAL</span> error code if cropping is not supported.</p><p>To change the cropping rectangle applications initialize the
<em class="structfield"><code>type</code></em> and struct <a class="link" href="media.html#v4l2-rect" title="Table 4.3. struct v4l2_rect">v4l2_rect</a> substructure named
<em class="structfield"><code>c</code></em> of a v4l2_crop structure and call the
<code class="constant">VIDIOC_S_CROP</code> ioctl with a pointer to this
structure.</p><p>The driver first adjusts the requested dimensions against
hardware limits, i. e. the bounds given by the capture/output window,
and it rounds to the closest possible values of horizontal and
vertical offset, width and height. In particular the driver must round
the vertical offset of the cropping rectangle to frame lines modulo
two, such that the field order cannot be confused.</p><p>Second the driver adjusts the image size (the opposite
rectangle of the scaling process, source or target depending on the
data direction) to the closest size possible while maintaining the
current horizontal and vertical scaling factor.</p><p>Finally the driver programs the hardware with the actual
cropping and image parameters. <code class="constant">VIDIOC_S_CROP</code> is a
write-only ioctl, it does not return the actual parameters. To query
them applications must call <code class="constant">VIDIOC_G_CROP</code> and
<a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_G_FMT</code></a>. When the parameters are unsuitable the application may
modify the cropping or image parameters and repeat the cycle until
satisfactory parameters have been negotiated.</p><p>When cropping is not supported then no parameters are
changed and <code class="constant">VIDIOC_S_CROP</code> returns the
<span class="errorcode">EINVAL</span> error code.</p><div class="table"><a name="v4l2-crop"></a><p class="title"><b>Table A.54. struct <span class="structname">v4l2_crop</span></b></p><div class="table-contents"><table summary="struct v4l2_crop" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>type</code></em></td><td valign="top">Type of the data stream, set by the application.
Only these types are valid here: <code class="constant">V4L2_BUF_TYPE_VIDEO_CAPTURE</code>,
<code class="constant">V4L2_BUF_TYPE_VIDEO_OUTPUT</code> and
<code class="constant">V4L2_BUF_TYPE_VIDEO_OVERLAY</code>. See <a class="xref" href="media.html#v4l2-buf-type" title="Table 3.3. enum v4l2_buf_type">Table 3.3, &#8220;enum v4l2_buf_type&#8221;</a>.</td></tr><tr><td valign="top">struct <a class="link" href="media.html#v4l2-rect" title="Table 4.3. struct v4l2_rect">v4l2_rect</a></td><td valign="top"><em class="structfield"><code>c</code></em></td><td valign="top">Cropping rectangle. The same co-ordinate system as
for struct <a class="link" href="media.html#v4l2-cropcap" title="Table A.2. struct v4l2_cropcap">v4l2_cropcap</a> <em class="structfield"><code>bounds</code></em> is used.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp78914656"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-g-ctrl"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_G_CTRL, VIDIOC_S_CTRL &#8212; Get or set the value of a control</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_control
*<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp78979344"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_G_CTRL, VIDIOC_S_CTRL</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp78987488"></a><h2>Description</h2><p>To get the current value of a control applications
initialize the <em class="structfield"><code>id</code></em> field of a struct
<span class="structname">v4l2_control</span> and call the
<code class="constant">VIDIOC_G_CTRL</code> ioctl with a pointer to this
structure. To change the value of a control applications initialize
the <em class="structfield"><code>id</code></em> and <em class="structfield"><code>value</code></em>
fields of a struct <span class="structname">v4l2_control</span> and call the
<code class="constant">VIDIOC_S_CTRL</code> ioctl.</p><p>When the <em class="structfield"><code>id</code></em> is invalid drivers
return an <span class="errorcode">EINVAL</span> error code. When the <em class="structfield"><code>value</code></em> is out
of bounds drivers can choose to take the closest valid value or return
an <span class="errorcode">ERANGE</span> error code, whatever seems more appropriate. However,
<code class="constant">VIDIOC_S_CTRL</code> is a write-only ioctl, it does not
return the actual new value. If the <em class="structfield"><code>value</code></em>
is inappropriate for the control (e.g. if it refers to an unsupported
menu index of a menu control), then <span class="errorcode">EINVAL</span> error code is returned as well.</p><p>These ioctls work only with user controls. For other
control classes the <a class="link" href="media.html#vidioc-g-ext-ctrls" title="ioctl VIDIOC_G_EXT_CTRLS, VIDIOC_S_EXT_CTRLS, VIDIOC_TRY_EXT_CTRLS"><code class="constant">VIDIOC_G_EXT_CTRLS</code></a>, <a class="link" href="media.html#vidioc-g-ext-ctrls" title="ioctl VIDIOC_G_EXT_CTRLS, VIDIOC_S_EXT_CTRLS, VIDIOC_TRY_EXT_CTRLS"><code class="constant">VIDIOC_S_EXT_CTRLS</code></a> or
<a class="link" href="media.html#vidioc-g-ext-ctrls" title="ioctl VIDIOC_G_EXT_CTRLS, VIDIOC_S_EXT_CTRLS, VIDIOC_TRY_EXT_CTRLS"><code class="constant">VIDIOC_TRY_EXT_CTRLS</code></a> must be used.</p><div class="table"><a name="v4l2-control"></a><p class="title"><b>Table A.55. struct <span class="structname">v4l2_control</span></b></p><div class="table-contents"><table summary="struct v4l2_control" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>id</code></em></td><td valign="top">Identifies the control, set by the
application.</td></tr><tr><td valign="top">__s32</td><td valign="top"><em class="structfield"><code>value</code></em></td><td valign="top">New value or current value.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp79010368"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The struct <a class="link" href="media.html#v4l2-control" title="Table A.55. struct v4l2_control">v4l2_control</a> <em class="structfield"><code>id</code></em> is
invalid or the <em class="structfield"><code>value</code></em> is inappropriate for
the given control (i.e. if a menu item is selected that is not supported
by the driver according to <a class="link" href="media.html#vidioc-queryctrl" title="ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU"><code class="constant">VIDIOC_QUERYMENU</code></a>).</p></dd><dt><span class="term"><span class="errorcode">ERANGE</span></span></dt><dd><p>The struct <a class="link" href="media.html#v4l2-control" title="Table A.55. struct v4l2_control">v4l2_control</a> <em class="structfield"><code>value</code></em>
is out of bounds.</p></dd><dt><span class="term"><span class="errorcode">EBUSY</span></span></dt><dd><p>The control is temporarily not changeable, possibly
because another applications took over control of the device function
this control belongs to.</p></dd><dt><span class="term"><span class="errorcode">EACCES</span></span></dt><dd><p>Attempt to set a read-only control or to get a
	  write-only control.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-g-dv-timings"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_G_DV_TIMINGS, VIDIOC_S_DV_TIMINGS &#8212; Get or set DV timings for input or output</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_dv_timings *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp79092032"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_G_DV_TIMINGS, VIDIOC_S_DV_TIMINGS</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp79100192"></a><h2>Description</h2><p>To set DV timings for the input or output, applications use the
<code class="constant">VIDIOC_S_DV_TIMINGS</code> ioctl and to get the current timings,
applications use the <code class="constant">VIDIOC_G_DV_TIMINGS</code> ioctl. The detailed timing
information is filled in using the structure struct <a class="link" href="media.html#v4l2-dv-timings" title="Table A.57. struct v4l2_dv_timings">v4l2_dv_timings</a>. These ioctls take
a pointer to the struct <a class="link" href="media.html#v4l2-dv-timings" title="Table A.57. struct v4l2_dv_timings">v4l2_dv_timings</a> structure as argument. If the ioctl is not supported
or the timing values are not correct, the driver returns <span class="errorcode">EINVAL</span> error code.</p><p>The <code class="filename">linux/v4l2-dv-timings.h</code> header can be used to get the
timings of the formats in the <a class="xref" href="media.html#cea861" title="A DTV Profile for Uncompressed High Speed Digital Interfaces">[<abbr class="abbrev">CEA-861-E</abbr>]</a> and <a class="xref" href="media.html#vesadmt" title="VESA and Industry Standards and Guidelines for Computer Display Monitor Timing (DMT)">[<abbr class="abbrev">VESA DMT</abbr>]</a>
standards. If the current input or output does not support DV timings (e.g. if
<a class="link" href="media.html#vidioc-enuminput" title="ioctl VIDIOC_ENUMINPUT"><code class="constant">VIDIOC_ENUMINPUT</code></a> does not set the <code class="constant">V4L2_IN_CAP_DV_TIMINGS</code> flag), then
<span class="errorcode">ENODATA</span> error code is returned.</p></div><div class="refsect1"><a name="idp79108592"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>This ioctl is not supported, or the
<code class="constant">VIDIOC_S_DV_TIMINGS</code> parameter was unsuitable.</p></dd><dt><span class="term"><span class="errorcode">ENODATA</span></span></dt><dd><p>Digital video timings are not supported for this input or output.</p></dd><dt><span class="term"><span class="errorcode">EBUSY</span></span></dt><dd><p>The device is busy and therefore can not change the timings.</p></dd></dl></div><div class="table"><a name="v4l2-bt-timings"></a><p class="title"><b>Table A.56. struct <span class="structname">v4l2_bt_timings</span></b></p><div class="table-contents"><table summary="struct v4l2_bt_timings" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>width</code></em></td><td valign="top">Width of the active video in pixels.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>height</code></em></td><td valign="top">Height of the active video frame in lines. So for interlaced formats the
	    height of the active video in each field is <em class="structfield"><code>height</code></em>/2.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>interlaced</code></em></td><td valign="top">Progressive (0) or interlaced (1)</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>polarities</code></em></td><td valign="top">This is a bit mask that defines polarities of sync signals.
bit 0 (V4L2_DV_VSYNC_POS_POL) is for vertical sync polarity and bit 1 (V4L2_DV_HSYNC_POS_POL) is for horizontal sync polarity. If the bit is set
(1) it is positive polarity and if is cleared (0), it is negative polarity.</td></tr><tr><td valign="top">__u64</td><td valign="top"><em class="structfield"><code>pixelclock</code></em></td><td valign="top">Pixel clock in Hz. Ex. 74.25MHz-&gt;74250000</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>hfrontporch</code></em></td><td valign="top">Horizontal front porch in pixels</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>hsync</code></em></td><td valign="top">Horizontal sync length in pixels</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>hbackporch</code></em></td><td valign="top">Horizontal back porch in pixels</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>vfrontporch</code></em></td><td valign="top">Vertical front porch in lines. For interlaced formats this refers to the
	    odd field (aka field 1).</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>vsync</code></em></td><td valign="top">Vertical sync length in lines. For interlaced formats this refers to the
	    odd field (aka field 1).</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>vbackporch</code></em></td><td valign="top">Vertical back porch in lines. For interlaced formats this refers to the
	    odd field (aka field 1).</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>il_vfrontporch</code></em></td><td valign="top">Vertical front porch in lines for the even field (aka field 2) of
	    interlaced field formats. Must be 0 for progressive formats.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>il_vsync</code></em></td><td valign="top">Vertical sync length in lines for the even field (aka field 2) of
	    interlaced field formats. Must be 0 for progressive formats.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>il_vbackporch</code></em></td><td valign="top">Vertical back porch in lines for the even field (aka field 2) of
	    interlaced field formats. Must be 0 for progressive formats.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>standards</code></em></td><td valign="top">The video standard(s) this format belongs to. This will be filled in by
	    the driver. Applications must set this to 0. See <a class="xref" href="media.html#dv-bt-standards" title="Table A.59. DV BT Timing standards">Table A.59, &#8220;DV BT Timing standards&#8221;</a>
	    for a list of standards.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>flags</code></em></td><td valign="top">Several flags giving more information about the format.
	    See <a class="xref" href="media.html#dv-bt-flags" title="Table A.60. DV BT Timing flags">Table A.60, &#8220;DV BT Timing flags&#8221;</a> for a description of the flags.
	    </td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-dv-timings"></a><p class="title"><b>Table A.57. struct <span class="structname">v4l2_dv_timings</span></b></p><div class="table-contents"><table summary="struct v4l2_dv_timings" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>type</code></em></td><td valign="top"> </td><td valign="top">Type of DV timings as listed in <a class="xref" href="media.html#dv-timing-types" title="Table A.58. DV Timing types">Table A.58, &#8220;DV Timing types&#8221;</a>.</td></tr><tr><td valign="top">union</td><td valign="top"><em class="structfield"><code></code></em></td><td valign="top"> </td><td class="auto-generated"> </td></tr><tr><td valign="top"> </td><td valign="top">struct <a class="link" href="media.html#v4l2-bt-timings" title="Table A.56. struct v4l2_bt_timings">v4l2_bt_timings</a></td><td valign="top"><em class="structfield"><code>bt</code></em></td><td valign="top">Timings defined by BT.656/1120 specifications</td></tr><tr><td valign="top"> </td><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[32]</td><td valign="top"> </td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="dv-timing-types"></a><p class="title"><b>Table A.58. DV Timing types</b></p><div class="table-contents"><table summary="DV Timing types" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">Timing type</td><td valign="top">value</td><td valign="top">Description</td></tr><tr><td valign="top"> </td><td valign="top"> </td><td valign="top"> </td></tr><tr><td valign="top">V4L2_DV_BT_656_1120</td><td valign="top">0</td><td valign="top">BT.656/1120 timings</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="dv-bt-standards"></a><p class="title"><b>Table A.59. DV BT Timing standards</b></p><div class="table-contents"><table summary="DV BT Timing standards" width="100%" border="0"><colgroup><col class="c1"><col class="c2"></colgroup><tbody valign="top"><tr><td valign="top">Timing standard</td><td valign="top">Description</td></tr><tr><td valign="top"> </td><td valign="top"> </td></tr><tr><td valign="top">V4L2_DV_BT_STD_CEA861</td><td valign="top">The timings follow the CEA-861 Digital TV Profile standard</td></tr><tr><td valign="top">V4L2_DV_BT_STD_DMT</td><td valign="top">The timings follow the VESA Discrete Monitor Timings standard</td></tr><tr><td valign="top">V4L2_DV_BT_STD_CVT</td><td valign="top">The timings follow the VESA Coordinated Video Timings standard</td></tr><tr><td valign="top">V4L2_DV_BT_STD_GTF</td><td valign="top">The timings follow the VESA Generalized Timings Formula standard</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="dv-bt-flags"></a><p class="title"><b>Table A.60. DV BT Timing flags</b></p><div class="table-contents"><table summary="DV BT Timing flags" width="100%" border="0"><colgroup><col class="c1"><col class="c2"></colgroup><tbody valign="top"><tr><td valign="top">Flag</td><td valign="top">Description</td></tr><tr><td valign="top"> </td><td valign="top"> </td></tr><tr><td valign="top">V4L2_DV_FL_REDUCED_BLANKING</td><td valign="top">CVT/GTF specific: the timings use reduced blanking (CVT) or the 'Secondary
GTF' curve (GTF). In both cases the horizontal and/or vertical blanking
intervals are reduced, allowing a higher resolution over the same
bandwidth. This is a read-only flag, applications must not set this.
	    </td></tr><tr><td valign="top">V4L2_DV_FL_CAN_REDUCE_FPS</td><td valign="top">CEA-861 specific: set for CEA-861 formats with a framerate that is a multiple
of six. These formats can be optionally played at 1 / 1.001 speed to
be compatible with 60 Hz based standards such as NTSC and PAL-M that use a framerate of
29.97 frames per second. If the transmitter can't generate such frequencies, then the
flag will also be cleared. This is a read-only flag, applications must not set this.
	    </td></tr><tr><td valign="top">V4L2_DV_FL_REDUCED_FPS</td><td valign="top">CEA-861 specific: only valid for video transmitters, the flag is cleared
by receivers. It is also only valid for formats with the V4L2_DV_FL_CAN_REDUCE_FPS flag
set, for other formats the flag will be cleared by the driver.

If the application sets this flag, then the pixelclock used to set up the transmitter is
divided by 1.001 to make it compatible with NTSC framerates. If the transmitter
can't generate such frequencies, then the flag will also be cleared.
	    </td></tr><tr><td valign="top">V4L2_DV_FL_HALF_LINE</td><td valign="top">Specific to interlaced formats: if set, then field 1 (aka the odd field)
is really one half-line longer and field 2 (aka the even field) is really one half-line
shorter, so each field has exactly the same number of half-lines. Whether half-lines can be
detected or used depends on the hardware.
	    </td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-g-edid"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_G_EDID, VIDIOC_S_EDID &#8212; Get or set the EDID of a video receiver/transmitter</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_edid *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_edid *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp79360912"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_G_EDID, VIDIOC_S_EDID</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp79369056"></a><h2>Description</h2><p>These ioctls can be used to get or set an EDID associated with an input
    from a receiver or an output of a transmitter device. They can be
    used with subdevice nodes (/dev/v4l-subdevX) or with video nodes (/dev/videoX).</p><p>When used with video nodes the <em class="structfield"><code>pad</code></em> field represents the
    input (for video capture devices) or output (for video output devices) index as
    is returned by <a class="link" href="media.html#vidioc-enuminput" title="ioctl VIDIOC_ENUMINPUT"><code class="constant">VIDIOC_ENUMINPUT</code></a> and <a class="link" href="media.html#vidioc-enumoutput" title="ioctl VIDIOC_ENUMOUTPUT"><code class="constant">VIDIOC_ENUMOUTPUT</code></a> respectively. When used
    with subdevice nodes the <em class="structfield"><code>pad</code></em> field represents the
    input or output pad of the subdevice. If there is no EDID support for the given
    <em class="structfield"><code>pad</code></em> value, then the <span class="errorcode">EINVAL</span> error code will be returned.</p><p>To get the EDID data the application has to fill in the <em class="structfield"><code>pad</code></em>,
    <em class="structfield"><code>start_block</code></em>, <em class="structfield"><code>blocks</code></em> and <em class="structfield"><code>edid</code></em>
    fields and call <code class="constant">VIDIOC_G_EDID</code>. The current EDID from block
    <em class="structfield"><code>start_block</code></em> and of size <em class="structfield"><code>blocks</code></em>
    will be placed in the memory <em class="structfield"><code>edid</code></em> points to. The <em class="structfield"><code>edid</code></em>
    pointer must point to memory at least <em class="structfield"><code>blocks</code></em> * 128 bytes
    large (the size of one block is 128 bytes).</p><p>If there are fewer blocks than specified, then the driver will set <em class="structfield"><code>blocks</code></em>
    to the actual number of blocks. If there are no EDID blocks available at all, then the error code
    ENODATA is set.</p><p>If blocks have to be retrieved from the sink, then this call will block until they
    have been read.</p><p>To set the EDID blocks of a receiver the application has to fill in the <em class="structfield"><code>pad</code></em>,
    <em class="structfield"><code>blocks</code></em> and <em class="structfield"><code>edid</code></em> fields and set
    <em class="structfield"><code>start_block</code></em> to 0. It is not possible to set part of an EDID,
    it is always all or nothing. Setting the EDID data is only valid for receivers as it makes
    no sense for a transmitter.</p><p>The driver assumes that the full EDID is passed in. If there are more EDID blocks than
    the hardware can handle then the EDID is not written, but instead the error code E2BIG is set
    and <em class="structfield"><code>blocks</code></em> is set to the maximum that the hardware supports.
    If <em class="structfield"><code>start_block</code></em> is any
    value other than 0 then the error code EINVAL is set.</p><p>To disable an EDID you set <em class="structfield"><code>blocks</code></em> to 0. Depending on the
    hardware this will drive the hotplug pin low and/or block the source from reading the EDID
    data in some way. In any case, the end result is the same: the EDID is no longer available.
    </p><div class="table"><a name="v4l2-edid"></a><p class="title"><b>Table A.61. struct <span class="structname">v4l2_edid</span></b></p><div class="table-contents"><table summary="struct v4l2_edid" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>pad</code></em></td><td valign="top">Pad for which to get/set the EDID blocks. When used with a video device
	    node the pad represents the input or output index as returned by
	    <a class="link" href="media.html#vidioc-enuminput" title="ioctl VIDIOC_ENUMINPUT"><code class="constant">VIDIOC_ENUMINPUT</code></a> and <a class="link" href="media.html#vidioc-enumoutput" title="ioctl VIDIOC_ENUMOUTPUT"><code class="constant">VIDIOC_ENUMOUTPUT</code></a> respectively.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>start_block</code></em></td><td valign="top">Read the EDID from starting with this block. Must be 0 when setting
	    the EDID.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>blocks</code></em></td><td valign="top">The number of blocks to get or set. Must be less or equal to 256 (the
	    maximum number of blocks as defined by the standard). When you set the EDID and
	    <em class="structfield"><code>blocks</code></em> is 0, then the EDID is disabled or erased.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[5]</td><td valign="top">Reserved for future extensions. Applications and drivers must
	    set the array to zero.</td></tr><tr><td valign="top">__u8 *</td><td valign="top"><em class="structfield"><code>edid</code></em></td><td valign="top">Pointer to memory that contains the EDID. The minimum size is
	    <em class="structfield"><code>blocks</code></em> * 128.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp79404848"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">ENODATA</span></span></dt><dd><p>The EDID data is not available.</p></dd><dt><span class="term"><span class="errorcode">E2BIG</span></span></dt><dd><p>The EDID data you provided is more than the hardware can handle.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-g-enc-index"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_G_ENC_INDEX &#8212; Get meta data about a compressed video stream</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_enc_idx *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp79489744"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_G_ENC_INDEX</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp79497872"></a><h2>Description</h2><p>The <code class="constant">VIDIOC_G_ENC_INDEX</code> ioctl provides
meta data about a compressed video stream the same or another
application currently reads from the driver, which is useful for
random access into the stream without decoding it.</p><p>To read the data applications must call
<code class="constant">VIDIOC_G_ENC_INDEX</code> with a pointer to a
struct <a class="link" href="media.html#v4l2-enc-idx" title="Table A.62. struct v4l2_enc_idx">v4l2_enc_idx</a>. On success the driver fills the
<em class="structfield"><code>entry</code></em> array, stores the number of elements
written in the <em class="structfield"><code>entries</code></em> field, and
initializes the <em class="structfield"><code>entries_cap</code></em> field.</p><p>Each element of the <em class="structfield"><code>entry</code></em> array
contains meta data about one picture. A
<code class="constant">VIDIOC_G_ENC_INDEX</code> call reads up to
<code class="constant">V4L2_ENC_IDX_ENTRIES</code> entries from a driver
buffer, which can hold up to <em class="structfield"><code>entries_cap</code></em>
entries. This number can be lower or higher than
<code class="constant">V4L2_ENC_IDX_ENTRIES</code>, but not zero. When the
application fails to read the meta data in time the oldest entries
will be lost. When the buffer is empty or no capturing/encoding is in
progress, <em class="structfield"><code>entries</code></em> will be zero.</p><p>Currently this ioctl is only defined for MPEG-2 program
streams and video elementary streams.</p><div class="table"><a name="v4l2-enc-idx"></a><p class="title"><b>Table A.62. struct <span class="structname">v4l2_enc_idx</span></b></p><div class="table-contents"><table summary="struct v4l2_enc_idx" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>entries</code></em></td><td valign="top">The number of entries the driver stored in the
<em class="structfield"><code>entry</code></em> array.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>entries_cap</code></em></td><td valign="top">The number of entries the driver can
buffer. Must be greater than zero.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[4]</td><td colspan="3" valign="top">Reserved for future extensions.
Drivers must set the array to zero.</td></tr><tr><td valign="top">struct <a class="link" href="media.html#v4l2-enc-idx-entry" title="Table A.63. struct v4l2_enc_idx_entry">v4l2_enc_idx_entry</a></td><td valign="top"><em class="structfield"><code>entry</code></em>[<code class="constant">V4L2_ENC_IDX_ENTRIES</code>]</td><td valign="top">Meta data about a compressed video stream. Each
element of the array corresponds to one picture, sorted in ascending
order by their <em class="structfield"><code>offset</code></em>.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-enc-idx-entry"></a><p class="title"><b>Table A.63. struct <span class="structname">v4l2_enc_idx_entry</span></b></p><div class="table-contents"><table summary="struct v4l2_enc_idx_entry" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u64</td><td valign="top"><em class="structfield"><code>offset</code></em></td><td valign="top">The offset in bytes from the beginning of the
compressed video stream to the beginning of this picture, that is a
<em class="wordasword">PES packet header</em> as defined in <a class="xref" href="media.html#mpeg2part1" title='ITU-T Rec. H.222.0 | ISO/IEC 13818-1 "Information technology &#8212; Generic coding of moving pictures and associated audio information: Systems"'>[<abbr class="abbrev">ISO 13818-1</abbr>]</a> or a <em class="wordasword">picture
header</em> as defined in <a class="xref" href="media.html#mpeg2part2" title='ITU-T Rec. H.262 | ISO/IEC 13818-2 "Information technology &#8212; Generic coding of moving pictures and associated audio information: Video"'>[<abbr class="abbrev">ISO 13818-2</abbr>]</a>. When
the encoder is stopped, the driver resets the offset to zero.</td></tr><tr><td valign="top">__u64</td><td valign="top"><em class="structfield"><code>pts</code></em></td><td valign="top">The 33 bit <em class="wordasword">Presentation Time
Stamp</em> of this picture as defined in <a class="xref" href="media.html#mpeg2part1" title='ITU-T Rec. H.222.0 | ISO/IEC 13818-1 "Information technology &#8212; Generic coding of moving pictures and associated audio information: Systems"'>[<abbr class="abbrev">ISO 13818-1</abbr>]</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>length</code></em></td><td valign="top">The length of this picture in bytes.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>flags</code></em></td><td valign="top">Flags containing the coding type of this picture, see <a class="xref" href="media.html#enc-idx-flags" title="Table A.64. Index Entry Flags">Table A.64, &#8220;Index Entry Flags&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[2]</td><td valign="top">Reserved for future extensions.
Drivers must set the array to zero.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="enc-idx-flags"></a><p class="title"><b>Table A.64. Index Entry Flags</b></p><div class="table-contents"><table summary="Index Entry Flags" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_ENC_IDX_FRAME_I</code></td><td valign="top">0x00</td><td valign="top">This is an Intra-coded picture.</td></tr><tr><td valign="top"><code class="constant">V4L2_ENC_IDX_FRAME_P</code></td><td valign="top">0x01</td><td valign="top">This is a Predictive-coded picture.</td></tr><tr><td valign="top"><code class="constant">V4L2_ENC_IDX_FRAME_B</code></td><td valign="top">0x02</td><td valign="top">This is a Bidirectionally predictive-coded
picture.</td></tr><tr><td valign="top"><code class="constant">V4L2_ENC_IDX_FRAME_MASK</code></td><td valign="top">0x0F</td><td valign="top"><em class="wordasword">AND</em> the flags field with
this mask to obtain the picture coding type.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp79557872"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-g-ext-ctrls"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_G_EXT_CTRLS, VIDIOC_S_EXT_CTRLS, VIDIOC_TRY_EXT_CTRLS &#8212; Get or set the value of several controls, try control
values</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_ext_controls
*<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp79651824"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_G_EXT_CTRLS, VIDIOC_S_EXT_CTRLS,
VIDIOC_TRY_EXT_CTRLS</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp79660000"></a><h2>Description</h2><p>These ioctls allow the caller to get or set multiple
controls atomically. Control IDs are grouped into control classes (see
<a class="xref" href="media.html#ctrl-class" title="Table A.67. Control classes">Table A.67, &#8220;Control classes&#8221;</a>) and all controls in the control array
must belong to the same control class.</p><p>Applications must always fill in the
<em class="structfield"><code>count</code></em>,
<em class="structfield"><code>ctrl_class</code></em>,
<em class="structfield"><code>controls</code></em> and
<em class="structfield"><code>reserved</code></em> fields of struct <a class="link" href="media.html#v4l2-ext-controls" title="Table A.66. struct v4l2_ext_controls">v4l2_ext_controls</a>, and
initialize the struct <a class="link" href="media.html#v4l2-ext-control" title="Table A.65. struct v4l2_ext_control">v4l2_ext_control</a> array pointed to by the
<em class="structfield"><code>controls</code></em> fields.</p><p>To get the current value of a set of controls applications
initialize the <em class="structfield"><code>id</code></em>,
<em class="structfield"><code>size</code></em> and <em class="structfield"><code>reserved2</code></em> fields
of each struct <a class="link" href="media.html#v4l2-ext-control" title="Table A.65. struct v4l2_ext_control">v4l2_ext_control</a> and call the
<code class="constant">VIDIOC_G_EXT_CTRLS</code> ioctl. String controls controls
must also set the <em class="structfield"><code>string</code></em> field. Controls
of compound types (<code class="constant">V4L2_CTRL_FLAG_HAS_PAYLOAD</code> is set)
must set the <em class="structfield"><code>ptr</code></em> field.</p><p>If the <em class="structfield"><code>size</code></em> is too small to
receive the control result (only relevant for pointer-type controls
like strings), then the driver will set <em class="structfield"><code>size</code></em>
to a valid value and return an <span class="errorcode">ENOSPC</span> error code. You should re-allocate the
memory to this new size and try again. For the string type it is possible that
the same issue occurs again if the string has grown in the meantime. It is
recommended to call <a class="link" href="media.html#vidioc-queryctrl" title="ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU"><code class="constant">VIDIOC_QUERYCTRL</code></a> first and use
<em class="structfield"><code>maximum</code></em>+1 as the new <em class="structfield"><code>size</code></em>
value. It is guaranteed that that is sufficient memory.
</p><p>N-dimensional arrays are set and retrieved row-by-row. You cannot set a partial
array, all elements have to be set or retrieved. The total size is calculated
as <em class="structfield"><code>elems</code></em> * <em class="structfield"><code>elem_size</code></em>.
These values can be obtained by calling <a class="link" href="media.html#vidioc-queryctrl" title="ioctl VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU"><code class="constant">VIDIOC_QUERY_EXT_CTRL</code></a>.</p><p>To change the value of a set of controls applications
initialize the <em class="structfield"><code>id</code></em>, <em class="structfield"><code>size</code></em>,
<em class="structfield"><code>reserved2</code></em> and
<em class="structfield"><code>value/value64/string/ptr</code></em> fields of each struct <a class="link" href="media.html#v4l2-ext-control" title="Table A.65. struct v4l2_ext_control">v4l2_ext_control</a> and
call the <code class="constant">VIDIOC_S_EXT_CTRLS</code> ioctl. The controls
will only be set if <span class="emphasis"><em>all</em></span> control values are
valid.</p><p>To check if a set of controls have correct values applications
initialize the <em class="structfield"><code>id</code></em>, <em class="structfield"><code>size</code></em>,
<em class="structfield"><code>reserved2</code></em> and
<em class="structfield"><code>value/value64/string/ptr</code></em> fields of each struct <a class="link" href="media.html#v4l2-ext-control" title="Table A.65. struct v4l2_ext_control">v4l2_ext_control</a> and
call the <code class="constant">VIDIOC_TRY_EXT_CTRLS</code> ioctl. It is up to
the driver whether wrong values are automatically adjusted to a valid
value or if an error is returned.</p><p>When the <em class="structfield"><code>id</code></em> or
<em class="structfield"><code>ctrl_class</code></em> is invalid drivers return an
<span class="errorcode">EINVAL</span> error code. When the value is out of bounds drivers can choose to take
the closest valid value or return an <span class="errorcode">ERANGE</span> error code, whatever seems more
appropriate. In the first case the new value is set in
struct <a class="link" href="media.html#v4l2-ext-control" title="Table A.65. struct v4l2_ext_control">v4l2_ext_control</a>. If the new control value is inappropriate (e.g. the
given menu index is not supported by the menu control), then this will
also result in an <span class="errorcode">EINVAL</span> error code error.</p><p>The driver will only set/get these controls if all control
values are correct. This prevents the situation where only some of the
controls were set/get. Only low-level errors (e. g. a failed i2c
command) can still cause this situation.</p><div class="table"><a name="v4l2-ext-control"></a><p class="title"><b>Table A.65. struct <span class="structname">v4l2_ext_control</span></b></p><div class="table-contents"><table summary="struct v4l2_ext_control" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>id</code></em></td><td valign="top"> </td><td valign="top">Identifies the control, set by the
application.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>size</code></em></td><td valign="top"> </td><td valign="top">The total size in bytes of the payload of this
control. This is normally 0, but for pointer controls this should be
set to the size of the memory containing the payload, or that will
receive the payload. If <code class="constant">VIDIOC_G_EXT_CTRLS</code> finds
that this value is less than is required to store
the payload result, then it is set to a value large enough to store the
payload result and ENOSPC is returned. Note that for string controls
this <em class="structfield"><code>size</code></em> field should not be confused with the length of the string.
This field refers to the size of the memory that contains the string.
The actual <span class="emphasis"><em>length</em></span> of the string may well be much smaller.
</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved2</code></em>[1]</td><td valign="top"> </td><td valign="top">Reserved for future extensions. Drivers and
applications must set the array to zero.</td></tr><tr><td valign="top">union</td><td valign="top">(anonymous)</td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td valign="top"> </td><td valign="top">__s32</td><td valign="top"><em class="structfield"><code>value</code></em></td><td valign="top">New value or current value. Valid if this control is not of
type <code class="constant">V4L2_CTRL_TYPE_INTEGER64</code> and
<code class="constant">V4L2_CTRL_FLAG_HAS_PAYLOAD</code> is not set.</td></tr><tr><td valign="top"> </td><td valign="top">__s64</td><td valign="top"><em class="structfield"><code>value64</code></em></td><td valign="top">New value or current value. Valid if this control is of
type <code class="constant">V4L2_CTRL_TYPE_INTEGER64</code> and
<code class="constant">V4L2_CTRL_FLAG_HAS_PAYLOAD</code> is not set.</td></tr><tr><td valign="top"> </td><td valign="top">char *</td><td valign="top"><em class="structfield"><code>string</code></em></td><td valign="top">A pointer to a string. Valid if this control is of
type <code class="constant">V4L2_CTRL_TYPE_STRING</code>.</td></tr><tr><td valign="top"> </td><td valign="top">__u8 *</td><td valign="top"><em class="structfield"><code>p_u8</code></em></td><td valign="top">A pointer to a matrix control of unsigned 8-bit values.
Valid if this control is of type <code class="constant">V4L2_CTRL_TYPE_U8</code>.</td></tr><tr><td valign="top"> </td><td valign="top">__u16 *</td><td valign="top"><em class="structfield"><code>p_u16</code></em></td><td valign="top">A pointer to a matrix control of unsigned 16-bit values.
Valid if this control is of type <code class="constant">V4L2_CTRL_TYPE_U16</code>.</td></tr><tr><td valign="top"> </td><td valign="top">void *</td><td valign="top"><em class="structfield"><code>ptr</code></em></td><td valign="top">A pointer to a compound type which can be an N-dimensional array and/or a
compound type (the control's type is &gt;= <code class="constant">V4L2_CTRL_COMPOUND_TYPES</code>).
Valid if <code class="constant">V4L2_CTRL_FLAG_HAS_PAYLOAD</code> is set for this control.
</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-ext-controls"></a><p class="title"><b>Table A.66. struct <span class="structname">v4l2_ext_controls</span></b></p><div class="table-contents"><table summary="struct v4l2_ext_controls" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>ctrl_class</code></em></td><td valign="top">The control class to which all controls belong, see
<a class="xref" href="media.html#ctrl-class" title="Table A.67. Control classes">Table A.67, &#8220;Control classes&#8221;</a>. Drivers that use a kernel framework for handling
controls will also accept a value of 0 here, meaning that the controls can
belong to any control class. Whether drivers support this can be tested by setting
<em class="structfield"><code>ctrl_class</code></em> to 0 and calling <code class="constant">VIDIOC_TRY_EXT_CTRLS</code>
with a <em class="structfield"><code>count</code></em> of 0. If that succeeds, then the driver
supports this feature.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>count</code></em></td><td valign="top">The number of controls in the controls array. May
also be zero.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>error_idx</code></em></td><td valign="top"><p>Set by the driver in case of an error. If the error is
associated with a particular control, then <em class="structfield"><code>error_idx</code></em>
is set to the index of that control. If the error is not related to a specific
control, or the validation step failed (see below), then
<em class="structfield"><code>error_idx</code></em> is set to <em class="structfield"><code>count</code></em>.
The value is undefined if the ioctl returned 0 (success).</p>

<p>Before controls are read from/written to hardware a validation step
takes place: this checks if all controls in the list are valid controls,
if no attempt is made to write to a read-only control or read from a write-only
control, and any other up-front checks that can be done without accessing the
hardware. The exact validations done during this step are driver dependent
since some checks might require hardware access for some devices, thus making
it impossible to do those checks up-front. However, drivers should make a
best-effort to do as many up-front checks as possible.</p>

<p>This check is done to avoid leaving the hardware in an inconsistent state due
to easy-to-avoid problems. But it leads to another problem: the application needs to
know whether an error came from the validation step (meaning that the hardware
was not touched) or from an error during the actual reading from/writing to hardware.</p>

<p>The, in hindsight quite poor, solution for that is to set <em class="structfield"><code>error_idx</code></em>
to <em class="structfield"><code>count</code></em> if the validation failed. This has the
unfortunate side-effect that it is not possible to see which control failed the
validation. If the validation was successful and the error happened while
accessing the hardware, then <em class="structfield"><code>error_idx</code></em> is less than
<em class="structfield"><code>count</code></em> and only the controls up to
<em class="structfield"><code>error_idx-1</code></em> were read or written correctly, and the
state of the remaining controls is undefined.</p>

<p>Since <code class="constant">VIDIOC_TRY_EXT_CTRLS</code> does not access hardware
there is also no need to handle the validation step in this special way,
so <em class="structfield"><code>error_idx</code></em> will just be set to the control that
failed the validation step instead of to <em class="structfield"><code>count</code></em>.
This means that if <code class="constant">VIDIOC_S_EXT_CTRLS</code> fails with
<em class="structfield"><code>error_idx</code></em> set to <em class="structfield"><code>count</code></em>,
then you can call <code class="constant">VIDIOC_TRY_EXT_CTRLS</code> to try to discover
the actual control that failed the validation step. Unfortunately, there
is no <code class="constant">TRY</code> equivalent for <code class="constant">VIDIOC_G_EXT_CTRLS</code>.
</p></td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[2]</td><td valign="top">Reserved for future extensions. Drivers and
applications must set the array to zero.</td></tr><tr><td valign="top">struct <a class="link" href="media.html#v4l2-ext-control" title="Table A.65. struct v4l2_ext_control">v4l2_ext_control</a> *</td><td valign="top"><em class="structfield"><code>controls</code></em></td><td valign="top">Pointer to an array of
<em class="structfield"><code>count</code></em> v4l2_ext_control structures. Ignored
if <em class="structfield"><code>count</code></em> equals zero.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="ctrl-class"></a><p class="title"><b>Table A.67. Control classes</b></p><div class="table-contents"><table summary="Control classes" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_CTRL_CLASS_USER</code></td><td valign="top">0x980000</td><td valign="top">The class containing user controls. These controls
are described in <a class="xref" href="media.html#control" title="User Controls">the section called &#8220;User Controls&#8221;</a>. All controls that can be set
using the <a class="link" href="media.html#vidioc-g-ctrl" title="ioctl VIDIOC_G_CTRL, VIDIOC_S_CTRL"><code class="constant">VIDIOC_S_CTRL</code></a> and <a class="link" href="media.html#vidioc-g-ctrl" title="ioctl VIDIOC_G_CTRL, VIDIOC_S_CTRL"><code class="constant">VIDIOC_G_CTRL</code></a> ioctl belong to this
class.</td></tr><tr><td valign="top"><code class="constant">V4L2_CTRL_CLASS_MPEG</code></td><td valign="top">0x990000</td><td valign="top">The class containing MPEG compression controls.
These controls are described in <a class="xref" href="media.html#mpeg-controls" title="Codec Control Reference">the section called &#8220;Codec Control Reference&#8221;</a>.</td></tr><tr><td valign="top"><code class="constant">V4L2_CTRL_CLASS_CAMERA</code></td><td valign="top">0x9a0000</td><td valign="top">The class containing camera controls.
These controls are described in <a class="xref" href="media.html#camera-controls" title="Camera Control Reference">the section called &#8220;Camera Control Reference&#8221;</a>.</td></tr><tr><td valign="top"><code class="constant">V4L2_CTRL_CLASS_FM_TX</code></td><td valign="top">0x9b0000</td><td valign="top">The class containing FM Transmitter (FM TX) controls.
These controls are described in <a class="xref" href="media.html#fm-tx-controls" title="FM Transmitter Control Reference">the section called &#8220;FM Transmitter Control Reference&#8221;</a>.</td></tr><tr><td valign="top"><code class="constant">V4L2_CTRL_CLASS_FLASH</code></td><td valign="top">0x9c0000</td><td valign="top">The class containing flash device controls.
These controls are described in <a class="xref" href="media.html#flash-controls" title="Flash Control Reference">the section called &#8220;Flash Control Reference&#8221;</a>.</td></tr><tr><td valign="top"><code class="constant">V4L2_CTRL_CLASS_JPEG</code></td><td valign="top">0x9d0000</td><td valign="top">The class containing JPEG compression controls.
These controls are described in <a class="xref" href="media.html#jpeg-controls" title="JPEG Control Reference">the section called &#8220;JPEG Control Reference&#8221;</a>.</td></tr><tr><td valign="top"><code class="constant">V4L2_CTRL_CLASS_IMAGE_SOURCE</code></td><td valign="top">0x9e0000</td><td valign="top">The class containing image
	    source controls. These controls are described in <a class="xref" href="media.html#image-source-controls" title="Image Source Control Reference">the section called &#8220;Image Source Control Reference&#8221;</a>.</td></tr><tr><td valign="top"><code class="constant">V4L2_CTRL_CLASS_IMAGE_PROC</code></td><td valign="top">0x9f0000</td><td valign="top">The class containing image
	    processing controls. These controls are described in <a class="xref" href="media.html#image-process-controls" title="Image Process Control Reference">the section called &#8220;Image Process Control Reference&#8221;</a>.</td></tr><tr><td valign="top"><code class="constant">V4L2_CTRL_CLASS_FM_RX</code></td><td valign="top">0xa10000</td><td valign="top">The class containing FM Receiver (FM RX) controls.
These controls are described in <a class="xref" href="media.html#fm-rx-controls" title="FM Receiver Control Reference">the section called &#8220;FM Receiver Control Reference&#8221;</a>.</td></tr><tr><td valign="top"><code class="constant">V4L2_CTRL_CLASS_RF_TUNER</code></td><td valign="top">0xa20000</td><td valign="top">The class containing RF tuner controls.
These controls are described in <a class="xref" href="media.html#rf-tuner-controls" title="RF Tuner Control Reference">the section called &#8220;RF Tuner Control Reference&#8221;</a>.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp79786656"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The struct <a class="link" href="media.html#v4l2-ext-control" title="Table A.65. struct v4l2_ext_control">v4l2_ext_control</a> <em class="structfield"><code>id</code></em>
is invalid, the struct <a class="link" href="media.html#v4l2-ext-controls" title="Table A.66. struct v4l2_ext_controls">v4l2_ext_controls</a>
<em class="structfield"><code>ctrl_class</code></em> is invalid, or the struct <a class="link" href="media.html#v4l2-ext-control" title="Table A.65. struct v4l2_ext_control">v4l2_ext_control</a>
<em class="structfield"><code>value</code></em> was inappropriate (e.g. the given menu
index is not supported by the driver). This error code is
also returned by the <code class="constant">VIDIOC_S_EXT_CTRLS</code> and
<code class="constant">VIDIOC_TRY_EXT_CTRLS</code> ioctls if two or more
control values are in conflict.</p></dd><dt><span class="term"><span class="errorcode">ERANGE</span></span></dt><dd><p>The struct <a class="link" href="media.html#v4l2-ext-control" title="Table A.65. struct v4l2_ext_control">v4l2_ext_control</a> <em class="structfield"><code>value</code></em>
is out of bounds.</p></dd><dt><span class="term"><span class="errorcode">EBUSY</span></span></dt><dd><p>The control is temporarily not changeable, possibly
because another applications took over control of the device function
this control belongs to.</p></dd><dt><span class="term"><span class="errorcode">ENOSPC</span></span></dt><dd><p>The space reserved for the control's payload is insufficient.
The field <em class="structfield"><code>size</code></em> is set to a value that is enough
to store the payload and this error code is returned.</p></dd><dt><span class="term"><span class="errorcode">EACCES</span></span></dt><dd><p>Attempt to try or set a read-only control or to get a
	  write-only control.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-g-fbuf"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_G_FBUF, VIDIOC_S_FBUF &#8212; Get or set frame buffer overlay parameters</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_framebuffer *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>const struct v4l2_framebuffer *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp79990304"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_G_FBUF, VIDIOC_S_FBUF</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp79998448"></a><h2>Description</h2><p>Applications can use the <code class="constant">VIDIOC_G_FBUF</code> and
<code class="constant">VIDIOC_S_FBUF</code> ioctl to get and set the
framebuffer parameters for a <a class="link" href="media.html#overlay" title="Video Overlay Interface">Video
Overlay</a> or <a class="link" href="media.html#osd" title="Video Output Overlay Interface">Video Output Overlay</a>
(OSD). The type of overlay is implied by the device type (capture or
output device) and can be determined with the <a class="link" href="media.html#vidioc-querycap" title="ioctl VIDIOC_QUERYCAP"><code class="constant">VIDIOC_QUERYCAP</code></a> ioctl.
One <code class="filename">/dev/videoN</code> device must not support both
kinds of overlay.</p><p>The V4L2 API distinguishes destructive and non-destructive
overlays. A destructive overlay copies captured video images into the
video memory of a graphics card. A non-destructive overlay blends
video images into a VGA signal or graphics into a video signal.
<em class="wordasword">Video Output Overlays</em> are always
non-destructive.</p><p>To get the current parameters applications call the
<code class="constant">VIDIOC_G_FBUF</code> ioctl with a pointer to a
<span class="structname">v4l2_framebuffer</span> structure. The driver fills
all fields of the structure or returns an <span class="errorcode">EINVAL</span> error code when overlays are
not supported.</p><p>To set the parameters for a <em class="wordasword">Video Output
Overlay</em>, applications must initialize the
<em class="structfield"><code>flags</code></em> field of a struct
<span class="structname">v4l2_framebuffer</span>. Since the framebuffer is
implemented on the TV card all other parameters are determined by the
driver. When an application calls <code class="constant">VIDIOC_S_FBUF</code>
with a pointer to this structure, the driver prepares for the overlay
and returns the framebuffer parameters as
<code class="constant">VIDIOC_G_FBUF</code> does, or it returns an error
code.</p><p>To set the parameters for a <em class="wordasword">non-destructive
Video Overlay</em>, applications must initialize the
<em class="structfield"><code>flags</code></em> field, the
<em class="structfield"><code>fmt</code></em> substructure, and call
<code class="constant">VIDIOC_S_FBUF</code>. Again the driver prepares for the
overlay and returns the framebuffer parameters as
<code class="constant">VIDIOC_G_FBUF</code> does, or it returns an error
code.</p><p>For a <em class="wordasword">destructive Video Overlay</em>
applications must additionally provide a
<em class="structfield"><code>base</code></em> address. Setting up a DMA to a
random memory location can jeopardize the system security, its
stability or even damage the hardware, therefore only the superuser
can set the parameters for a destructive video overlay.</p><div class="table"><a name="v4l2-framebuffer"></a><p class="title"><b>Table A.68. struct <span class="structname">v4l2_framebuffer</span></b></p><div class="table-contents"><table summary="struct v4l2_framebuffer" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>capability</code></em></td><td valign="top"> </td><td valign="top">Overlay capability flags set by the driver, see
<a class="xref" href="media.html#framebuffer-cap" title="Table A.69. Frame Buffer Capability Flags">Table A.69, &#8220;Frame Buffer Capability Flags&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>flags</code></em></td><td valign="top"> </td><td valign="top">Overlay control flags set by application and
driver, see <a class="xref" href="media.html#framebuffer-flags" title="Table A.70. Frame Buffer Flags">Table A.70, &#8220;Frame Buffer Flags&#8221;</a></td></tr><tr><td valign="top">void *</td><td valign="top"><em class="structfield"><code>base</code></em></td><td valign="top"> </td><td valign="top">Physical base address of the framebuffer,
that is the address of the pixel in the top left corner of the
framebuffer.<a href="media.html#ftn.idp80028544" class="footnote" name="idp80028544"><sup class="footnote">[a]</sup></a></td></tr><tr><td valign="top"> </td><td valign="top"> </td><td valign="top"> </td><td valign="top">This field is irrelevant to
<em class="wordasword">non-destructive Video Overlays</em>. For
<em class="wordasword">destructive Video Overlays</em> applications must
provide a base address. The driver may accept only base addresses
which are a multiple of two, four or eight bytes. For
<em class="wordasword">Video Output Overlays</em> the driver must return
a valid base address, so applications can find the corresponding Linux
framebuffer device (see <a class="xref" href="media.html#osd" title="Video Output Overlay Interface">the section called &#8220;Video Output Overlay Interface&#8221;</a>).</td></tr><tr><td valign="top">struct</td><td valign="top"><em class="structfield"><code>fmt</code></em></td><td valign="top"> </td><td valign="top">Layout of the frame buffer.</td></tr><tr><td valign="top"> </td><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>width</code></em></td><td valign="top">Width of the frame buffer in pixels.</td></tr><tr><td valign="top"> </td><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>height</code></em></td><td valign="top">Height of the frame buffer in pixels.</td></tr><tr><td valign="top"> </td><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>pixelformat</code></em></td><td valign="top">The pixel format of the
framebuffer.</td></tr><tr><td valign="top"> </td><td valign="top"> </td><td valign="top"> </td><td valign="top">For <em class="wordasword">non-destructive Video
Overlays</em> this field only defines a format for the
struct <a class="link" href="media.html#v4l2-window" title="Table 4.1. struct v4l2_window">v4l2_window</a> <em class="structfield"><code>chromakey</code></em> field.</td></tr><tr><td valign="top"> </td><td valign="top"> </td><td valign="top"> </td><td valign="top">For <em class="wordasword">destructive Video
Overlays</em> applications must initialize this field. For
<em class="wordasword">Video Output Overlays</em> the driver must return
a valid format.</td></tr><tr><td valign="top"> </td><td valign="top"> </td><td valign="top"> </td><td valign="top">Usually this is an RGB format (for example
<a class="link" href="media.html#V4L2-PIX-FMT-RGB565"><code class="constant">V4L2_PIX_FMT_RGB565</code></a>)
but YUV formats (only packed YUV formats when chroma keying is used,
not including <code class="constant">V4L2_PIX_FMT_YUYV</code> and
<code class="constant">V4L2_PIX_FMT_UYVY</code>) and the
<code class="constant">V4L2_PIX_FMT_PAL8</code> format are also permitted. The
behavior of the driver when an application requests a compressed
format is undefined. See <a class="xref" href="media.html#pixfmt" title="Chapter 2. Image Formats">Chapter 2, <i>Image Formats</i></a> for information on
pixel formats.</td></tr><tr><td valign="top"> </td><td valign="top">enum <a class="link" href="media.html#v4l2-field" title="Table 3.9. enum v4l2_field">v4l2_field</a></td><td valign="top"><em class="structfield"><code>field</code></em></td><td valign="top">Drivers and applications shall ignore this field.
If applicable, the field order is selected with the <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a>
ioctl, using the <em class="structfield"><code>field</code></em> field of
struct <a class="link" href="media.html#v4l2-window" title="Table 4.1. struct v4l2_window">v4l2_window</a>.</td></tr><tr><td valign="top"> </td><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>bytesperline</code></em></td><td valign="top">Distance in bytes between the leftmost pixels in
two adjacent lines.</td></tr><tr><td colspan="4" valign="top"><p>This field is irrelevant to
<em class="wordasword">non-destructive Video
Overlays</em>.</p><p>For <em class="wordasword">destructive Video
Overlays</em> both applications and drivers can set this field
to request padding bytes at the end of each line. Drivers however may
ignore the requested value, returning <em class="structfield"><code>width</code></em>
times bytes-per-pixel or a larger value required by the hardware. That
implies applications can just set this field to zero to get a
reasonable default.</p><p>For <em class="wordasword">Video Output
Overlays</em> the driver must return a valid
value.</p><p>Video hardware may access padding bytes, therefore
they must reside in accessible memory. Consider for example the case
where padding bytes after the last line of an image cross a system
page boundary. Capture devices may write padding bytes, the value is
undefined. Output devices ignore the contents of padding
bytes.</p><p>When the image format is planar the
<em class="structfield"><code>bytesperline</code></em> value applies to the largest
plane and is divided by the same factor as the
<em class="structfield"><code>width</code></em> field for any smaller planes. For
example the Cb and Cr planes of a YUV 4:2:0 image have half as many
padding bytes following each line as the Y plane. To avoid ambiguities
drivers must return a <em class="structfield"><code>bytesperline</code></em> value
rounded up to a multiple of the scale factor.</p></td></tr><tr><td valign="top"> </td><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>sizeimage</code></em></td><td valign="top"><p>This field is irrelevant to
<em class="wordasword">non-destructive Video Overlays</em>. For
<em class="wordasword">destructive Video Overlays</em> applications must
initialize this field. For <em class="wordasword">Video Output
Overlays</em> the driver must return a valid
format.</p><p>Together with <em class="structfield"><code>base</code></em> it
defines the framebuffer memory accessible by the
driver.</p></td></tr><tr><td valign="top"> </td><td valign="top">enum <a class="link" href="media.html#v4l2-colorspace" title="Table 2.4. V4L2 Colorspaces">v4l2_colorspace</a></td><td valign="top"><em class="structfield"><code>colorspace</code></em></td><td valign="top">This information supplements the
<em class="structfield"><code>pixelformat</code></em> and must be set by the driver,
see <a class="xref" href="media.html#colorspaces" title="Colorspaces">the section called &#8220;Colorspaces&#8221;</a>.</td></tr><tr><td valign="top"> </td><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>priv</code></em></td><td valign="top">Reserved. Drivers and applications must set this field to
zero.</td></tr></tbody><tbody class="footnotes"><tr><td colspan="4"><div id="ftn.idp80028544" class="footnote"><p><a href="media.html#idp80028544" class="para"><sup class="para">[a] </sup></a>A physical base address may not suit all
platforms. GK notes in theory we should pass something like PCI device
+ memory region + offset instead. If you encounter problems please
discuss on the linux-media mailing list: <a class="ulink" href="http://www.linuxtv.org/lists.php" target="_top">http://www.linuxtv.org/lists.php</a>.</p></div></td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="framebuffer-cap"></a><p class="title"><b>Table A.69. Frame Buffer Capability Flags</b></p><div class="table-contents"><table summary="Frame Buffer Capability Flags" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_FBUF_CAP_EXTERNOVERLAY</code></td><td valign="top">0x0001</td><td valign="top">The device is capable of non-destructive overlays.
When the driver clears this flag, only destructive overlays are
supported. There are no drivers yet which support both destructive and
non-destructive overlays. Video Output Overlays are in practice always
non-destructive.</td></tr><tr><td valign="top"><code class="constant">V4L2_FBUF_CAP_CHROMAKEY</code></td><td valign="top">0x0002</td><td valign="top">The device supports clipping by chroma-keying the
images. That is, image pixels replace pixels in the VGA or video
signal only where the latter assume a certain color. Chroma-keying
makes no sense for destructive overlays.</td></tr><tr><td valign="top"><code class="constant">V4L2_FBUF_CAP_LIST_CLIPPING</code></td><td valign="top">0x0004</td><td valign="top">The device supports clipping using a list of clip
rectangles.</td></tr><tr><td valign="top"><code class="constant">V4L2_FBUF_CAP_BITMAP_CLIPPING</code></td><td valign="top">0x0008</td><td valign="top">The device supports clipping using a bit mask.</td></tr><tr><td valign="top"><code class="constant">V4L2_FBUF_CAP_LOCAL_ALPHA</code></td><td valign="top">0x0010</td><td valign="top">The device supports clipping/blending using the
alpha channel of the framebuffer or VGA signal. Alpha blending makes
no sense for destructive overlays.</td></tr><tr><td valign="top"><code class="constant">V4L2_FBUF_CAP_GLOBAL_ALPHA</code></td><td valign="top">0x0020</td><td valign="top">The device supports alpha blending using a global
alpha value. Alpha blending makes no sense for destructive overlays.</td></tr><tr><td valign="top"><code class="constant">V4L2_FBUF_CAP_LOCAL_INV_ALPHA</code></td><td valign="top">0x0040</td><td valign="top">The device supports clipping/blending using the
inverted alpha channel of the framebuffer or VGA signal. Alpha
blending makes no sense for destructive overlays.</td></tr><tr><td valign="top"><code class="constant">V4L2_FBUF_CAP_SRC_CHROMAKEY</code></td><td valign="top">0x0080</td><td valign="top">The device supports Source Chroma-keying. Video pixels
with the chroma-key colors are replaced by framebuffer pixels, which is exactly opposite of
<code class="constant">V4L2_FBUF_CAP_CHROMAKEY</code></td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="framebuffer-flags"></a><p class="title"><b>Table A.70. Frame Buffer Flags</b></p><div class="table-contents"><table summary="Frame Buffer Flags" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_FBUF_FLAG_PRIMARY</code></td><td valign="top">0x0001</td><td valign="top">The framebuffer is the primary graphics surface.
In other words, the overlay is destructive. This flag is typically set by any
driver that doesn't have the <code class="constant">V4L2_FBUF_CAP_EXTERNOVERLAY</code>
capability and it is cleared otherwise.</td></tr><tr><td valign="top"><code class="constant">V4L2_FBUF_FLAG_OVERLAY</code></td><td valign="top">0x0002</td><td valign="top">If this flag is set for a video capture device, then the
driver will set the initial overlay size to cover the full framebuffer size,
otherwise the existing overlay size (as set by <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a>) will be used.

Only one video capture driver (bttv) supports this flag. The use of this flag
for capture devices is deprecated. There is no way to detect which drivers
support this flag, so the only reliable method of setting the overlay size is
through <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a>.

If this flag is set for a video output device, then the video output overlay
window is relative to the top-left corner of the framebuffer and restricted
to the size of the framebuffer. If it is cleared, then the video output
overlay window is relative to the video output display.
            </td></tr><tr><td valign="top"><code class="constant">V4L2_FBUF_FLAG_CHROMAKEY</code></td><td valign="top">0x0004</td><td valign="top">Use chroma-keying. The chroma-key color is
determined by the <em class="structfield"><code>chromakey</code></em> field of
struct <a class="link" href="media.html#v4l2-window" title="Table 4.1. struct v4l2_window">v4l2_window</a> and negotiated with the <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> ioctl, see <a class="xref" href="media.html#overlay" title="Video Overlay Interface">the section called &#8220;Video Overlay Interface&#8221;</a>
and
	    <a class="xref" href="media.html#osd" title="Video Output Overlay Interface">the section called &#8220;Video Output Overlay Interface&#8221;</a>.</td></tr><tr><td colspan="3" valign="top">There are no flags to enable
clipping using a list of clip rectangles or a bitmap. These methods
are negotiated with the <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> ioctl, see <a class="xref" href="media.html#overlay" title="Video Overlay Interface">the section called &#8220;Video Overlay Interface&#8221;</a> and <a class="xref" href="media.html#osd" title="Video Output Overlay Interface">the section called &#8220;Video Output Overlay Interface&#8221;</a>.</td></tr><tr><td valign="top"><code class="constant">V4L2_FBUF_FLAG_LOCAL_ALPHA</code></td><td valign="top">0x0008</td><td valign="top">Use the alpha channel of the framebuffer to clip or
blend framebuffer pixels with video images. The blend
function is: output = framebuffer pixel * alpha + video pixel * (1 -
alpha). The actual alpha depth depends on the framebuffer pixel
format.</td></tr><tr><td valign="top"><code class="constant">V4L2_FBUF_FLAG_GLOBAL_ALPHA</code></td><td valign="top">0x0010</td><td valign="top">Use a global alpha value to blend the framebuffer
with video images. The blend function is: output = (framebuffer pixel
* alpha + video pixel * (255 - alpha)) / 255. The alpha value is
determined by the <em class="structfield"><code>global_alpha</code></em> field of
struct <a class="link" href="media.html#v4l2-window" title="Table 4.1. struct v4l2_window">v4l2_window</a> and negotiated with the <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> ioctl, see <a class="xref" href="media.html#overlay" title="Video Overlay Interface">the section called &#8220;Video Overlay Interface&#8221;</a>
and <a class="xref" href="media.html#osd" title="Video Output Overlay Interface">the section called &#8220;Video Output Overlay Interface&#8221;</a>.</td></tr><tr><td valign="top"><code class="constant">V4L2_FBUF_FLAG_LOCAL_INV_ALPHA</code></td><td valign="top">0x0020</td><td valign="top">Like
<code class="constant">V4L2_FBUF_FLAG_LOCAL_ALPHA</code>, use the alpha channel
of the framebuffer to clip or blend framebuffer pixels with video
images, but with an inverted alpha value. The blend function is:
output = framebuffer pixel * (1 - alpha) + video pixel * alpha. The
actual alpha depth depends on the framebuffer pixel format.</td></tr><tr><td valign="top"><code class="constant">V4L2_FBUF_FLAG_SRC_CHROMAKEY</code></td><td valign="top">0x0040</td><td valign="top">Use source chroma-keying. The source chroma-key color is
determined by the <em class="structfield"><code>chromakey</code></em> field of
struct <a class="link" href="media.html#v4l2-window" title="Table 4.1. struct v4l2_window">v4l2_window</a> and negotiated with the <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> ioctl, see <a class="xref" href="media.html#overlay" title="Video Overlay Interface">the section called &#8220;Video Overlay Interface&#8221;</a> and <a class="xref" href="media.html#osd" title="Video Output Overlay Interface">the section called &#8220;Video Output Overlay Interface&#8221;</a>.
Both chroma-keying are mutual exclusive to each other, so same
<em class="structfield"><code>chromakey</code></em> field of struct <a class="link" href="media.html#v4l2-window" title="Table 4.1. struct v4l2_window">v4l2_window</a> is being used.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp80135280"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EPERM</span></span></dt><dd><p><code class="constant">VIDIOC_S_FBUF</code> can only be called
by a privileged user to negotiate the parameters for a destructive
overlay.</p></dd><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The <code class="constant">VIDIOC_S_FBUF</code> parameters are unsuitable.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-g-fmt"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT &#8212; Get or set the data format, try a format</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_format
*<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp80327280"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp80335392"></a><h2>Description</h2><p>These ioctls are used to negotiate the format of data
(typically image format) exchanged between driver and
application.</p><p>To query the current parameters applications set the
<em class="structfield"><code>type</code></em> field of a struct
<span class="structname">v4l2_format</span> to the respective buffer (stream)
type. For example video capture devices use
<code class="constant">V4L2_BUF_TYPE_VIDEO_CAPTURE</code> or
<code class="constant">V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE</code>. When the application
calls the <code class="constant">VIDIOC_G_FMT</code> ioctl with a pointer to
this structure the driver fills the respective member of the
<em class="structfield"><code>fmt</code></em> union. In case of video capture devices
that is either the struct <a class="link" href="media.html#v4l2-pix-format" title="Table 2.1. struct v4l2_pix_format">v4l2_pix_format</a> <em class="structfield"><code>pix</code></em> or
the struct <a class="link" href="media.html#v4l2-pix-format-mplane" title="Table 2.3. struct v4l2_pix_format_mplane">v4l2_pix_format_mplane</a> <em class="structfield"><code>pix_mp</code></em> member.
When the requested buffer type is not supported drivers return an
<span class="errorcode">EINVAL</span> error code.</p><p>To change the current format parameters applications
initialize the <em class="structfield"><code>type</code></em> field and all
fields of the respective <em class="structfield"><code>fmt</code></em>
union member. For details see the documentation of the various devices
types in <a class="xref" href="media.html#devices" title="Chapter 4. Interfaces">Chapter 4, <i>Interfaces</i></a>. Good practice is to query the
current parameters first, and to
modify only those parameters not suitable for the application. When
the application calls the <code class="constant">VIDIOC_S_FMT</code> ioctl
with a pointer to a <span class="structname">v4l2_format</span> structure
the driver checks
and adjusts the parameters against hardware abilities. Drivers
should not return an error code unless the <em class="structfield"><code>type</code></em> field is invalid, this is
a mechanism to fathom device capabilities and to approach parameters
acceptable for both the application and driver. On success the driver
may program the hardware, allocate resources and generally prepare for
data exchange.
Finally the <code class="constant">VIDIOC_S_FMT</code> ioctl returns the
current format parameters as <code class="constant">VIDIOC_G_FMT</code> does.
Very simple, inflexible devices may even ignore all input and always
return the default parameters. However all V4L2 devices exchanging
data with the application must implement the
<code class="constant">VIDIOC_G_FMT</code> and
<code class="constant">VIDIOC_S_FMT</code> ioctl. When the requested buffer
type is not supported drivers return an <span class="errorcode">EINVAL</span> error code on a
<code class="constant">VIDIOC_S_FMT</code> attempt. When I/O is already in
progress or the resource is not available for other reasons drivers
return the <span class="errorcode">EBUSY</span> error code.</p><p>The <code class="constant">VIDIOC_TRY_FMT</code> ioctl is equivalent
to <code class="constant">VIDIOC_S_FMT</code> with one exception: it does not
change driver state. It can also be called at any time, never
returning <span class="errorcode">EBUSY</span>. This function is provided to
negotiate parameters, to learn about hardware limitations, without
disabling I/O or possibly time consuming hardware preparations.
Although strongly recommended drivers are not required to implement
this ioctl.</p><p>The format as returned by <code class="constant">VIDIOC_TRY_FMT</code>
must be identical to what <code class="constant">VIDIOC_S_FMT</code> returns for
the same input or output.</p><div class="table"><a name="v4l2-format"></a><p class="title"><b>Table A.71. struct <span class="structname">v4l2_format</span></b></p><div class="table-contents"><table summary="struct v4l2_format" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>type</code></em></td><td valign="top"> </td><td valign="top">Type of the data stream, see <a class="xref" href="media.html#v4l2-buf-type" title="Table 3.3. enum v4l2_buf_type">Table 3.3, &#8220;enum v4l2_buf_type&#8221;</a>.</td></tr><tr><td valign="top">union</td><td valign="top"><em class="structfield"><code>fmt</code></em></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td valign="top"> </td><td valign="top">struct <a class="link" href="media.html#v4l2-pix-format" title="Table 2.1. struct v4l2_pix_format">v4l2_pix_format</a></td><td valign="top"><em class="structfield"><code>pix</code></em></td><td valign="top">Definition of an image format, see <a class="xref" href="media.html#pixfmt" title="Chapter 2. Image Formats">Chapter 2, <i>Image Formats</i></a>, used by video capture and output
devices.</td></tr><tr><td valign="top"> </td><td valign="top">struct <a class="link" href="media.html#v4l2-pix-format-mplane" title="Table 2.3. struct v4l2_pix_format_mplane">v4l2_pix_format_mplane</a></td><td valign="top"><em class="structfield"><code>pix_mp</code></em></td><td valign="top">Definition of an image format, see <a class="xref" href="media.html#pixfmt" title="Chapter 2. Image Formats">Chapter 2, <i>Image Formats</i></a>, used by video capture and output
devices that support the <a class="link" href="media.html#planar-apis" title="Single- and multi-planar APIs">multi-planar
version of the API</a>.</td></tr><tr><td valign="top"> </td><td valign="top">struct <a class="link" href="media.html#v4l2-window" title="Table 4.1. struct v4l2_window">v4l2_window</a></td><td valign="top"><em class="structfield"><code>win</code></em></td><td valign="top">Definition of an overlaid image, see <a class="xref" href="media.html#overlay" title="Video Overlay Interface">the section called &#8220;Video Overlay Interface&#8221;</a>, used by video overlay devices.</td></tr><tr><td valign="top"> </td><td valign="top">struct <a class="link" href="media.html#v4l2-vbi-format" title="Table 4.4. struct v4l2_vbi_format">v4l2_vbi_format</a></td><td valign="top"><em class="structfield"><code>vbi</code></em></td><td valign="top">Raw VBI capture or output parameters. This is
discussed in more detail in <a class="xref" href="media.html#raw-vbi" title="Raw VBI Data Interface">the section called &#8220;Raw VBI Data Interface&#8221;</a>. Used by raw VBI
capture and output devices.</td></tr><tr><td valign="top"> </td><td valign="top">struct <a class="link" href="media.html#v4l2-sliced-vbi-format" title="Table 4.6. struct v4l2_sliced_vbi_format">v4l2_sliced_vbi_format</a></td><td valign="top"><em class="structfield"><code>sliced</code></em></td><td valign="top">Sliced VBI capture or output parameters. See
<a class="xref" href="media.html#sliced" title="Sliced VBI Data Interface">the section called &#8220;Sliced VBI Data Interface&#8221;</a> for details. Used by sliced VBI
capture and output devices.</td></tr><tr><td valign="top"> </td><td valign="top">struct <a class="link" href="media.html#v4l2-sdr-format" title="Table 4.18. struct v4l2_sdr_format">v4l2_sdr_format</a></td><td valign="top"><em class="structfield"><code>sdr</code></em></td><td valign="top">Definition of a data format, see
<a class="xref" href="media.html#pixfmt" title="Chapter 2. Image Formats">Chapter 2, <i>Image Formats</i></a>, used by SDR capture devices.</td></tr><tr><td valign="top"> </td><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>raw_data</code></em>[200]</td><td valign="top">Place holder for future extensions.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp80386704"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a> <em class="structfield"><code>type</code></em>
field is invalid or the requested buffer type not supported.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-g-frequency"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_G_FREQUENCY, VIDIOC_S_FREQUENCY &#8212; Get or set tuner or modulator radio
frequency</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_frequency
*<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>const struct v4l2_frequency
*<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp80486112"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_G_FREQUENCY, VIDIOC_S_FREQUENCY</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp80494256"></a><h2>Description</h2><p>To get the current tuner or modulator radio frequency
applications set the <em class="structfield"><code>tuner</code></em> field of a
struct <a class="link" href="media.html#v4l2-frequency" title="Table A.72. struct v4l2_frequency">v4l2_frequency</a> to the respective tuner or modulator number (only
input devices have tuners, only output devices have modulators), zero
out the <em class="structfield"><code>reserved</code></em> array and
call the <code class="constant">VIDIOC_G_FREQUENCY</code> ioctl with a pointer
to this structure. The driver stores the current frequency in the
<em class="structfield"><code>frequency</code></em> field.</p><p>To change the current tuner or modulator radio frequency
applications initialize the <em class="structfield"><code>tuner</code></em>,
<em class="structfield"><code>type</code></em> and
<em class="structfield"><code>frequency</code></em> fields, and the
<em class="structfield"><code>reserved</code></em> array of a struct <a class="link" href="media.html#v4l2-frequency" title="Table A.72. struct v4l2_frequency">v4l2_frequency</a> and
call the <code class="constant">VIDIOC_S_FREQUENCY</code> ioctl with a pointer
to this structure. When the requested frequency is not possible the
driver assumes the closest possible value. However
<code class="constant">VIDIOC_S_FREQUENCY</code> is a write-only ioctl, it does
not return the actual new frequency.</p><div class="table"><a name="v4l2-frequency"></a><p class="title"><b>Table A.72. struct <span class="structname">v4l2_frequency</span></b></p><div class="table-contents"><table summary="struct v4l2_frequency" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>tuner</code></em></td><td valign="top">The tuner or modulator index number. This is the
same value as in the struct <a class="link" href="media.html#v4l2-input" title="Table A.38. struct v4l2_input">v4l2_input</a> <em class="structfield"><code>tuner</code></em>
field and the struct <a class="link" href="media.html#v4l2-tuner" title="Table A.86. struct v4l2_tuner">v4l2_tuner</a> <em class="structfield"><code>index</code></em> field, or
the struct <a class="link" href="media.html#v4l2-output" title="Table A.42. struct v4l2_output">v4l2_output</a> <em class="structfield"><code>modulator</code></em> field and the
struct <a class="link" href="media.html#v4l2-modulator" title="Table A.75. struct v4l2_modulator">v4l2_modulator</a> <em class="structfield"><code>index</code></em> field.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>type</code></em></td><td valign="top">The tuner type. This is the same value as in the
struct <a class="link" href="media.html#v4l2-tuner" title="Table A.86. struct v4l2_tuner">v4l2_tuner</a> <em class="structfield"><code>type</code></em> field. The type must be set
to <code class="constant">V4L2_TUNER_RADIO</code> for <code class="filename">/dev/radioX</code>
device nodes, and to <code class="constant">V4L2_TUNER_ANALOG_TV</code>
for all others. Set this field to <code class="constant">V4L2_TUNER_RADIO</code> for
modulators (currently only radio modulators are supported).
See <a class="xref" href="media.html#v4l2-tuner-type" title="Table A.87. enum v4l2_tuner_type">Table A.87, &#8220;enum v4l2_tuner_type&#8221;</a></td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>frequency</code></em></td><td valign="top">Tuning frequency in units of 62.5 kHz, or if the
struct <a class="link" href="media.html#v4l2-tuner" title="Table A.86. struct v4l2_tuner">v4l2_tuner</a> or struct <a class="link" href="media.html#v4l2-modulator" title="Table A.75. struct v4l2_modulator">v4l2_modulator</a> <em class="structfield"><code>capability</code></em> flag
<code class="constant">V4L2_TUNER_CAP_LOW</code> is set, in units of 62.5
Hz. A 1 Hz unit is used when the <em class="structfield"><code>capability</code></em> flag
<code class="constant">V4L2_TUNER_CAP_1HZ</code> is set.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[8]</td><td valign="top">Reserved for future extensions. Drivers and
	    applications must set the array to zero.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp80527584"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The <em class="structfield"><code>tuner</code></em> index is out of
bounds or the value in the <em class="structfield"><code>type</code></em> field is
wrong.</p></dd><dt><span class="term"><span class="errorcode">EBUSY</span></span></dt><dd><p>A hardware seek is in progress.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-g-input"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_G_INPUT, VIDIOC_S_INPUT &#8212; Query or select the current video input</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>int *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp80611840"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_G_INPUT, VIDIOC_S_INPUT</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp80619984"></a><h2>Description</h2><p>To query the current video input applications call the
<code class="constant">VIDIOC_G_INPUT</code> ioctl with a pointer to an integer
where the driver stores the number of the input, as in the
struct <a class="link" href="media.html#v4l2-input" title="Table A.38. struct v4l2_input">v4l2_input</a> <em class="structfield"><code>index</code></em> field. This ioctl will
fail only when there are no video inputs, returning
<span class="errorcode">EINVAL</span>.</p><p>To select a video input applications store the number of the
desired input in an integer and call the
<code class="constant">VIDIOC_S_INPUT</code> ioctl with a pointer to this
integer. Side effects are possible. For example inputs may support
different video standards, so the driver may implicitly switch the
current standard. Because of these possible side effects applications
must select an input before querying or negotiating any other parameters.</p><p>Information about video inputs is available using the
<a class="link" href="media.html#vidioc-enuminput" title="ioctl VIDIOC_ENUMINPUT"><code class="constant">VIDIOC_ENUMINPUT</code></a> ioctl.</p></div><div class="refsect1"><a name="idp80626176"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The number of the video input is out of bounds.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-g-jpegcomp"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_G_JPEGCOMP, VIDIOC_S_JPEGCOMP</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>v4l2_jpegcompression *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>const v4l2_jpegcompression *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp80675792"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_G_JPEGCOMP, VIDIOC_S_JPEGCOMP</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp80683936"></a><h2>Description</h2><p>These ioctls are <span class="bold"><strong>deprecated</strong></span>.
    New drivers and applications should use <a class="link" href="media.html#jpeg-controls" title="JPEG Control Reference">
    JPEG class controls</a> for image quality and JPEG markers control.
    </p><p>[to do]</p><p>Ronald Bultje elaborates:</p><p>APP is some application-specific information. The
application can set it itself, and it'll be stored in the JPEG-encoded
fields (eg; interlacing information for in an AVI or so). COM is the
same, but it's comments, like 'encoded by me' or so.</p><p>jpeg_markers describes whether the huffman tables,
quantization tables and the restart interval information (all
JPEG-specific stuff) should be stored in the JPEG-encoded fields.
These define how the JPEG field is encoded. If you omit them,
applications assume you've used standard encoding. You usually do want
to add them.</p><div class="table"><a name="v4l2-jpegcompression"></a><p class="title"><b>Table A.73. struct <span class="structname">v4l2_jpegcompression</span></b></p><div class="table-contents"><table summary="struct v4l2_jpegcompression" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">int</td><td valign="top"><em class="structfield"><code>quality</code></em></td><td valign="top">Deprecated. If <a class="link" href="media.html#jpeg-quality-control"><code class="constant">
	    V4L2_CID_JPEG_COMPRESSION_QUALITY</code></a> control is exposed
	    by a driver applications should use it instead and ignore this field.
	    </td></tr><tr><td valign="top">int</td><td valign="top"><em class="structfield"><code>APPn</code></em></td><td valign="top"> </td></tr><tr><td valign="top">int</td><td valign="top"><em class="structfield"><code>APP_len</code></em></td><td valign="top"> </td></tr><tr><td valign="top">char</td><td valign="top"><em class="structfield"><code>APP_data</code></em>[60]</td><td valign="top"> </td></tr><tr><td valign="top">int</td><td valign="top"><em class="structfield"><code>COM_len</code></em></td><td valign="top"> </td></tr><tr><td valign="top">char</td><td valign="top"><em class="structfield"><code>COM_data</code></em>[60]</td><td valign="top"> </td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>jpeg_markers</code></em></td><td valign="top">See <a class="xref" href="media.html#jpeg-markers" title="Table A.74. JPEG Markers Flags">Table A.74, &#8220;JPEG Markers Flags&#8221;</a>. Deprecated.
	    If <a class="link" href="media.html#jpeg-active-marker-control"><code class="constant">
	    V4L2_CID_JPEG_ACTIVE_MARKER</code></a> control
	    is exposed by a driver applications should use it instead
	    and ignore this field.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="jpeg-markers"></a><p class="title"><b>Table A.74. JPEG Markers Flags</b></p><div class="table-contents"><table summary="JPEG Markers Flags" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_JPEG_MARKER_DHT</code></td><td valign="top">(1&lt;&lt;3)</td><td valign="top">Define Huffman Tables</td></tr><tr><td valign="top"><code class="constant">V4L2_JPEG_MARKER_DQT</code></td><td valign="top">(1&lt;&lt;4)</td><td valign="top">Define Quantization Tables</td></tr><tr><td valign="top"><code class="constant">V4L2_JPEG_MARKER_DRI</code></td><td valign="top">(1&lt;&lt;5)</td><td valign="top">Define Restart Interval</td></tr><tr><td valign="top"><code class="constant">V4L2_JPEG_MARKER_COM</code></td><td valign="top">(1&lt;&lt;6)</td><td valign="top">Comment segment</td></tr><tr><td valign="top"><code class="constant">V4L2_JPEG_MARKER_APP</code></td><td valign="top">(1&lt;&lt;7)</td><td valign="top">App segment, driver will always use APP0</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp80725952"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-g-modulator"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_G_MODULATOR, VIDIOC_S_MODULATOR &#8212; Get or set modulator attributes</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_modulator
*<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>const struct v4l2_modulator
*<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp80812896"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_G_MODULATOR, VIDIOC_S_MODULATOR</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp80821040"></a><h2>Description</h2><p>To query the attributes of a modulator applications initialize
the <em class="structfield"><code>index</code></em> field and zero out the
<em class="structfield"><code>reserved</code></em> array of a struct <a class="link" href="media.html#v4l2-modulator" title="Table A.75. struct v4l2_modulator">v4l2_modulator</a> and
call the <code class="constant">VIDIOC_G_MODULATOR</code> ioctl with a pointer
to this structure. Drivers fill the rest of the structure or return an
<span class="errorcode">EINVAL</span> error code when the index is out of bounds. To enumerate all modulators
applications shall begin at index zero, incrementing by one until the
driver returns <span class="errorcode">EINVAL</span>.</p><p>Modulators have two writable properties, an audio
modulation set and the radio frequency. To change the modulated audio
subprograms, applications initialize the <em class="structfield"><code>index
</code></em> and <em class="structfield"><code>txsubchans</code></em> fields and the
<em class="structfield"><code>reserved</code></em> array and call the
<code class="constant">VIDIOC_S_MODULATOR</code> ioctl. Drivers may choose a
different audio modulation if the request cannot be satisfied. However
this is a write-only ioctl, it does not return the actual audio
modulation selected.</p><p>To change the radio frequency the <a class="link" href="media.html#vidioc-g-frequency" title="ioctl VIDIOC_G_FREQUENCY, VIDIOC_S_FREQUENCY"><code class="constant">VIDIOC_S_FREQUENCY</code></a> ioctl
is available.</p><div class="table"><a name="v4l2-modulator"></a><p class="title"><b>Table A.75. struct <span class="structname">v4l2_modulator</span></b></p><div class="table-contents"><table summary="struct v4l2_modulator" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>index</code></em></td><td valign="top">Identifies the modulator, set by the
application.</td></tr><tr><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>name</code></em>[32]</td><td valign="top">Name of the modulator, a NUL-terminated ASCII
string. This information is intended for the user.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>capability</code></em></td><td valign="top">Modulator capability flags. No flags are defined
for this field, the tuner flags in struct <a class="link" href="media.html#v4l2-tuner" title="Table A.86. struct v4l2_tuner">v4l2_tuner</a>
are used accordingly. The audio flags indicate the ability
to encode audio subprograms. They will <span class="emphasis"><em>not</em></span>
change for example with the current video standard.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>rangelow</code></em></td><td valign="top">The lowest tunable frequency in units of 62.5
KHz, or if the <em class="structfield"><code>capability</code></em> flag
<code class="constant">V4L2_TUNER_CAP_LOW</code> is set, in units of 62.5
Hz, or if the <em class="structfield"><code>capability</code></em> flag
<code class="constant">V4L2_TUNER_CAP_1HZ</code> is set, in units of 1 Hz.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>rangehigh</code></em></td><td valign="top">The highest tunable frequency in units of 62.5
KHz, or if the <em class="structfield"><code>capability</code></em> flag
<code class="constant">V4L2_TUNER_CAP_LOW</code> is set, in units of 62.5
Hz, or if the <em class="structfield"><code>capability</code></em> flag
<code class="constant">V4L2_TUNER_CAP_1HZ</code> is set, in units of 1 Hz.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>txsubchans</code></em></td><td valign="top">With this field applications can determine how
audio sub-carriers shall be modulated. It contains a set of flags as
defined in <a class="xref" href="media.html#modulator-txsubchans" title="Table A.76. Modulator Audio Transmission Flags">Table A.76, &#8220;Modulator Audio Transmission Flags&#8221;</a>. Note the tuner
<em class="structfield"><code>rxsubchans</code></em> flags are reused, but the
semantics are different. Video output devices are assumed to have an
analog or PCM audio input with 1-3 channels. The
<em class="structfield"><code>txsubchans</code></em> flags select one or more
channels for modulation, together with some audio subprogram
indicator, for example a stereo pilot tone.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[4]</td><td valign="top">Reserved for future extensions. Drivers and
applications must set the array to zero.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="modulator-txsubchans"></a><p class="title"><b>Table A.76. Modulator Audio Transmission Flags</b></p><div class="table-contents"><table summary="Modulator Audio Transmission Flags" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_TUNER_SUB_MONO</code></td><td valign="top">0x0001</td><td valign="top">Modulate channel 1 as mono audio, when the input
has more channels, a down-mix of channel 1 and 2. This flag does not
combine with <code class="constant">V4L2_TUNER_SUB_STEREO</code> or
<code class="constant">V4L2_TUNER_SUB_LANG1</code>.</td></tr><tr><td valign="top"><code class="constant">V4L2_TUNER_SUB_STEREO</code></td><td valign="top">0x0002</td><td valign="top">Modulate channel 1 and 2 as left and right
channel of a stereo audio signal. When the input has only one channel
or two channels and <code class="constant">V4L2_TUNER_SUB_SAP</code> is also
set, channel 1 is encoded as left and right channel. This flag does
not combine with <code class="constant">V4L2_TUNER_SUB_MONO</code> or
<code class="constant">V4L2_TUNER_SUB_LANG1</code>. When the driver does not
support stereo audio it shall fall back to mono.</td></tr><tr><td valign="top"><code class="constant">V4L2_TUNER_SUB_LANG1</code></td><td valign="top">0x0008</td><td valign="top">Modulate channel 1 and 2 as primary and secondary
language of a bilingual audio signal. When the input has only one
channel it is used for both languages. It is not possible to encode
the primary or secondary language only. This flag does not combine
with <code class="constant">V4L2_TUNER_SUB_MONO</code>,
<code class="constant">V4L2_TUNER_SUB_STEREO</code> or
<code class="constant">V4L2_TUNER_SUB_SAP</code>. If the hardware does not
support the respective audio matrix, or the current video standard
does not permit bilingual audio the
<code class="constant">VIDIOC_S_MODULATOR</code> ioctl shall return an <span class="errorcode">EINVAL</span> error code
and the driver shall fall back to mono or stereo mode.</td></tr><tr><td valign="top"><code class="constant">V4L2_TUNER_SUB_LANG2</code></td><td valign="top">0x0004</td><td valign="top">Same effect as
<code class="constant">V4L2_TUNER_SUB_SAP</code>.</td></tr><tr><td valign="top"><code class="constant">V4L2_TUNER_SUB_SAP</code></td><td valign="top">0x0004</td><td valign="top">When combined with <code class="constant">V4L2_TUNER_SUB_MONO
</code> the first channel is encoded as mono audio, the last
channel as Second Audio Program. When the input has only one channel
it is used for both audio tracks. When the input has three channels
the mono track is a down-mix of channel 1 and 2. When combined with
<code class="constant">V4L2_TUNER_SUB_STEREO</code> channel 1 and 2 are
encoded as left and right stereo audio, channel 3 as Second Audio
Program. When the input has only two channels, the first is encoded as
left and right channel and the second as SAP. When the input has only
one channel it is used for all audio tracks. It is not possible to
encode a Second Audio Program only. This flag must combine with
<code class="constant">V4L2_TUNER_SUB_MONO</code> or
<code class="constant">V4L2_TUNER_SUB_STEREO</code>. If the hardware does not
support the respective audio matrix, or the current video standard
does not permit SAP the <code class="constant">VIDIOC_S_MODULATOR</code> ioctl
shall return an <span class="errorcode">EINVAL</span> error code and driver shall fall back to mono or stereo
mode.</td></tr><tr><td valign="top"><code class="constant">V4L2_TUNER_SUB_RDS</code></td><td valign="top">0x0010</td><td valign="top">Enable the RDS encoder for a radio FM transmitter.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp80882352"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The struct <a class="link" href="media.html#v4l2-modulator" title="Table A.75. struct v4l2_modulator">v4l2_modulator</a>
<em class="structfield"><code>index</code></em> is out of bounds.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-g-output"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_G_OUTPUT, VIDIOC_S_OUTPUT &#8212; Query or select the current video output</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>int *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp80992272"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_G_OUTPUT, VIDIOC_S_OUTPUT</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp81000416"></a><h2>Description</h2><p>To query the current video output applications call the
<code class="constant">VIDIOC_G_OUTPUT</code> ioctl with a pointer to an integer
where the driver stores the number of the output, as in the
struct <a class="link" href="media.html#v4l2-output" title="Table A.42. struct v4l2_output">v4l2_output</a> <em class="structfield"><code>index</code></em> field. This ioctl
will fail only when there are no video outputs, returning the
<span class="errorcode">EINVAL</span> error code.</p><p>To select a video output applications store the number of the
desired output in an integer and call the
<code class="constant">VIDIOC_S_OUTPUT</code> ioctl with a pointer to this integer.
Side effects are possible. For example outputs may support different
video standards, so the driver may implicitly switch the current
standard.
standard. Because of these possible side effects applications
must select an output before querying or negotiating any other parameters.</p><p>Information about video outputs is available using the
<a class="link" href="media.html#vidioc-enumoutput" title="ioctl VIDIOC_ENUMOUTPUT"><code class="constant">VIDIOC_ENUMOUTPUT</code></a> ioctl.</p></div><div class="refsect1"><a name="idp81006624"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The number of the video output is out of bounds, or
there are no video outputs at all.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-g-parm"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_G_PARM, VIDIOC_S_PARM &#8212; Get or set streaming parameters</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>v4l2_streamparm *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp80986112"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_G_PARM, VIDIOC_S_PARM</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp81060080"></a><h2>Description</h2><p>The current video standard determines a nominal number of
frames per second. If less than this number of frames is to be
captured or output, applications can request frame skipping or
duplicating on the driver side. This is especially useful when using
the <code class="function">read()</code> or <code class="function">write()</code>, which
are not augmented by timestamps or sequence counters, and to avoid
unnecessary data copying.</p><p>Further these ioctls can be used to determine the number of
buffers used internally by a driver in read/write mode. For
implications see the section discussing the <a class="link" href="media.html#func-read" title="V4L2 read()"><code class="function">read()</code></a>
function.</p><p>To get and set the streaming parameters applications call
the <code class="constant">VIDIOC_G_PARM</code> and
<code class="constant">VIDIOC_S_PARM</code> ioctl, respectively. They take a
pointer to a struct <span class="structname">v4l2_streamparm</span> which
contains a union holding separate parameters for input and output
devices.</p><div class="table"><a name="v4l2-streamparm"></a><p class="title"><b>Table A.77. struct <span class="structname">v4l2_streamparm</span></b></p><div class="table-contents"><table summary="struct v4l2_streamparm" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>type</code></em></td><td valign="top"> </td><td valign="top">The buffer (stream) type, same as struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a>
<em class="structfield"><code>type</code></em>, set by the application. See <a class="xref" href="media.html#v4l2-buf-type" title="Table 3.3. enum v4l2_buf_type">Table 3.3, &#8220;enum v4l2_buf_type&#8221;</a></td></tr><tr><td valign="top">union</td><td valign="top"><em class="structfield"><code>parm</code></em></td><td valign="top"> </td><td valign="top"> </td></tr><tr><td valign="top"> </td><td valign="top">struct <a class="link" href="media.html#v4l2-captureparm" title="Table A.78. struct v4l2_captureparm">v4l2_captureparm</a></td><td valign="top"><em class="structfield"><code>capture</code></em></td><td valign="top">Parameters for capture devices, used when
<em class="structfield"><code>type</code></em> is
<code class="constant">V4L2_BUF_TYPE_VIDEO_CAPTURE</code>.</td></tr><tr><td valign="top"> </td><td valign="top">struct <a class="link" href="media.html#v4l2-outputparm" title="Table A.79. struct v4l2_outputparm">v4l2_outputparm</a></td><td valign="top"><em class="structfield"><code>output</code></em></td><td valign="top">Parameters for output devices, used when
<em class="structfield"><code>type</code></em> is
<code class="constant">V4L2_BUF_TYPE_VIDEO_OUTPUT</code>.</td></tr><tr><td valign="top"> </td><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>raw_data</code></em>[200]</td><td valign="top">A place holder for future extensions.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-captureparm"></a><p class="title"><b>Table A.78. struct <span class="structname">v4l2_captureparm</span></b></p><div class="table-contents"><table summary="struct v4l2_captureparm" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>capability</code></em></td><td valign="top">See <a class="xref" href="media.html#parm-caps" title="Table A.80. Streaming Parameters Capabilites">Table A.80, &#8220;Streaming Parameters Capabilites&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>capturemode</code></em></td><td valign="top">Set by drivers and applications, see <a class="xref" href="media.html#parm-flags" title="Table A.81. Capture Parameters Flags">Table A.81, &#8220;Capture Parameters Flags&#8221;</a>.</td></tr><tr><td valign="top">struct <a class="link" href="media.html#v4l2-fract" title="Table A.46. struct v4l2_fract">v4l2_fract</a></td><td valign="top"><em class="structfield"><code>timeperframe</code></em></td><td valign="top"><p>This is the desired period between
successive frames captured by the driver, in seconds. The
field is intended to skip frames on the driver side, saving I/O
bandwidth.</p><p>Applications store here the desired frame
period, drivers return the actual frame period, which must be greater
or equal to the nominal frame period determined by the current video
standard (struct <a class="link" href="media.html#v4l2-standard" title="Table A.45. struct v4l2_standard">v4l2_standard</a> <em class="structfield"><code>frameperiod</code></em>
field). Changing the video standard (also implicitly by switching the
video input) may reset this parameter to the nominal frame period. To
reset manually applications can just set this field to
zero.</p><p>Drivers support this function only when they set the
<code class="constant">V4L2_CAP_TIMEPERFRAME</code> flag in the
<em class="structfield"><code>capability</code></em> field.</p></td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>extendedmode</code></em></td><td valign="top">Custom (driver specific) streaming parameters. When
unused, applications and drivers must set this field to zero.
Applications using this field should check the driver name and
version, see <a class="xref" href="media.html#querycap" title="Querying Capabilities">the section called &#8220;Querying Capabilities&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>readbuffers</code></em></td><td valign="top">Applications set this field to the desired number
of buffers used internally by the driver in <a class="link" href="media.html#func-read" title="V4L2 read()"><code class="function">read()</code></a> mode. Drivers
return the actual number of buffers. When an application requests zero
buffers, drivers should just return the current setting rather than
the minimum or an error code. For details see <a class="xref" href="media.html#rw" title="Read/Write">the section called &#8220;Read/Write&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[4]</td><td valign="top">Reserved for future extensions. Drivers and
applications must set the array to zero.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-outputparm"></a><p class="title"><b>Table A.79. struct <span class="structname">v4l2_outputparm</span></b></p><div class="table-contents"><table summary="struct v4l2_outputparm" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>capability</code></em></td><td valign="top">See <a class="xref" href="media.html#parm-caps" title="Table A.80. Streaming Parameters Capabilites">Table A.80, &#8220;Streaming Parameters Capabilites&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>outputmode</code></em></td><td valign="top">Set by drivers and applications, see <a class="xref" href="media.html#parm-flags" title="Table A.81. Capture Parameters Flags">Table A.81, &#8220;Capture Parameters Flags&#8221;</a>.</td></tr><tr><td valign="top">struct <a class="link" href="media.html#v4l2-fract" title="Table A.46. struct v4l2_fract">v4l2_fract</a></td><td valign="top"><em class="structfield"><code>timeperframe</code></em></td><td valign="top">This is the desired period between
successive frames output by the driver, in seconds.</td></tr><tr><td colspan="3" valign="top"><p>The field is intended to
repeat frames on the driver side in <a class="link" href="media.html#func-write" title="V4L2 write()"><code class="function">write()</code></a> mode (in streaming
mode timestamps can be used to throttle the output), saving I/O
bandwidth.</p><p>Applications store here the desired frame
period, drivers return the actual frame period, which must be greater
or equal to the nominal frame period determined by the current video
standard (struct <a class="link" href="media.html#v4l2-standard" title="Table A.45. struct v4l2_standard">v4l2_standard</a> <em class="structfield"><code>frameperiod</code></em>
field). Changing the video standard (also implicitly by switching the
video output) may reset this parameter to the nominal frame period. To
reset manually applications can just set this field to
zero.</p><p>Drivers support this function only when they set the
<code class="constant">V4L2_CAP_TIMEPERFRAME</code> flag in the
<em class="structfield"><code>capability</code></em> field.</p></td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>extendedmode</code></em></td><td valign="top">Custom (driver specific) streaming parameters. When
unused, applications and drivers must set this field to zero.
Applications using this field should check the driver name and
version, see <a class="xref" href="media.html#querycap" title="Querying Capabilities">the section called &#8220;Querying Capabilities&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>writebuffers</code></em></td><td valign="top">Applications set this field to the desired number
of buffers used internally by the driver in
<code class="function">write()</code> mode. Drivers return the actual number of
buffers. When an application requests zero buffers, drivers should
just return the current setting rather than the minimum or an error
code. For details see <a class="xref" href="media.html#rw" title="Read/Write">the section called &#8220;Read/Write&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[4]</td><td valign="top">Reserved for future extensions. Drivers and
applications must set the array to zero.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="parm-caps"></a><p class="title"><b>Table A.80. Streaming Parameters Capabilites</b></p><div class="table-contents"><table summary="Streaming Parameters Capabilites" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_CAP_TIMEPERFRAME</code></td><td valign="top">0x1000</td><td valign="top">The frame skipping/repeating controlled by the
<em class="structfield"><code>timeperframe</code></em> field is supported.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="parm-flags"></a><p class="title"><b>Table A.81. Capture Parameters Flags</b></p><div class="table-contents"><table summary="Capture Parameters Flags" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_MODE_HIGHQUALITY</code></td><td valign="top">0x0001</td><td valign="top"><p>High quality imaging mode. High quality mode
is intended for still imaging applications. The idea is to get the
best possible image quality that the hardware can deliver. It is not
defined how the driver writer may achieve that; it will depend on the
hardware and the ingenuity of the driver writer. High quality mode is
a different mode from the the regular motion video capture modes. In
high quality mode:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The driver may be able to capture higher
resolutions than for motion capture.</p></li><li class="listitem"><p>The driver may support fewer pixel formats
than motion capture (eg; true color).</p></li><li class="listitem"><p>The driver may capture and arithmetically
combine multiple successive fields or frames to remove color edge
artifacts and reduce the noise in the video data.
</p></li><li class="listitem"><p>The driver may capture images in slices like
a scanner in order to handle larger format images than would otherwise
be possible. </p></li><li class="listitem"><p>An image capture operation may be
significantly slower than motion capture. </p></li><li class="listitem"><p>Moving objects in the image might have
excessive motion blur. </p></li><li class="listitem"><p>Capture might only work through the
<code class="function">read()</code> call.</p></li></ul></div></td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp81164784"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-g-priority"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_G_PRIORITY, VIDIOC_S_PRIORITY &#8212; Query or request the access priority associated with a
file descriptor</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>enum v4l2_priority *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>const enum v4l2_priority *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp81311920"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_G_PRIORITY, VIDIOC_S_PRIORITY</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p>Pointer to an enum v4l2_priority type.</p></dd></dl></div></div><div class="refsect1"><a name="idp81320240"></a><h2>Description</h2><p>To query the current access priority
applications call the <code class="constant">VIDIOC_G_PRIORITY</code> ioctl
with a pointer to an enum v4l2_priority variable where the driver stores
the current priority.</p><p>To request an access priority applications store the
desired priority in an enum v4l2_priority variable and call
<code class="constant">VIDIOC_S_PRIORITY</code> ioctl with a pointer to this
variable.</p><div class="table"><a name="v4l2-priority"></a><p class="title"><b>Table A.82. enum v4l2_priority</b></p><div class="table-contents"><table summary="enum v4l2_priority" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_PRIORITY_UNSET</code></td><td valign="top">0</td><td valign="top"> </td></tr><tr><td valign="top"><code class="constant">V4L2_PRIORITY_BACKGROUND</code></td><td valign="top">1</td><td valign="top">Lowest priority, usually applications running in
background, for example monitoring VBI transmissions. A proxy
application running in user space will be necessary if multiple
applications want to read from a device at this priority.</td></tr><tr><td valign="top"><code class="constant">V4L2_PRIORITY_INTERACTIVE</code></td><td valign="top">2</td><td valign="top"> </td></tr><tr><td valign="top"><code class="constant">V4L2_PRIORITY_DEFAULT</code></td><td valign="top">2</td><td valign="top">Medium priority, usually applications started and
interactively controlled by the user. For example TV viewers, Teletext
browsers, or just "panel" applications to change the channel or video
controls. This is the default priority unless an application requests
another.</td></tr><tr><td valign="top"><code class="constant">V4L2_PRIORITY_RECORD</code></td><td valign="top">3</td><td valign="top">Highest priority. Only one file descriptor can have
this priority, it blocks any other fd from changing device properties.
Usually applications which must not be interrupted, like video
recording.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp81338128"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The requested priority value is invalid.</p></dd><dt><span class="term"><span class="errorcode">EBUSY</span></span></dt><dd><p>Another application already requested higher
priority.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-g-selection"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_G_SELECTION, VIDIOC_S_SELECTION &#8212; Get or set one of the selection rectangles</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_selection *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp81405456"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_G_SELECTION, VIDIOC_S_SELECTION</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp81413552"></a><h2>Description</h2><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Experimental</h3><p>This is an <a class="link" href="media.html#experimental" title="Experimental API Elements"> experimental </a>
      interface and may change in the future.</p></div><p>The ioctls are used to query and configure selection rectangles.</p><p>To query the cropping (composing) rectangle set struct <a class="link" href="media.html#v4l2-selection" title="Table A.83. struct v4l2_selection">v4l2_selection</a>
<em class="structfield"><code> type </code></em> field to the respective buffer type.
Do not use multiplanar buffers.  Use <code class="constant">V4L2_BUF_TYPE_VIDEO_CAPTURE</code>
instead of <code class="constant">V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE</code>.  Use
<code class="constant">V4L2_BUF_TYPE_VIDEO_OUTPUT</code> instead of
<code class="constant">V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE</code>.  The next step is
setting the value of struct <a class="link" href="media.html#v4l2-selection" title="Table A.83. struct v4l2_selection">v4l2_selection</a> <em class="structfield"><code>target</code></em> field
to <code class="constant">V4L2_SEL_TGT_CROP</code> (<code class="constant">V4L2_SEL_TGT_COMPOSE</code>).
Please refer to table <a class="xref" href="media.html#v4l2-selections-common" title="Common selection definitions">the section called &#8220;Common selection definitions&#8221;</a> or <a class="xref" href="media.html#selection-api" title="Experimental API for cropping, composing and scaling">the section called &#8220;Experimental API for cropping, composing and scaling&#8221;</a>
for additional targets.  The <em class="structfield"><code>flags</code></em> and <em class="structfield"><code>reserved
</code></em> fields of struct <a class="link" href="media.html#v4l2-selection" title="Table A.83. struct v4l2_selection">v4l2_selection</a> are ignored and they must be filled
with zeros.  The driver fills the rest of the structure or
returns <span class="errorcode">EINVAL</span> error code if incorrect buffer type or target was used. If cropping
(composing) is not supported then the active rectangle is not mutable and it is
always equal to the bounds rectangle.  Finally, the struct <a class="link" href="media.html#v4l2-rect" title="Table 4.3. struct v4l2_rect">v4l2_rect</a>
<em class="structfield"><code>r</code></em> rectangle is filled with the current cropping
(composing) coordinates. The coordinates are expressed in driver-dependent
units. The only exception are rectangles for images in raw formats, whose
coordinates are always expressed in pixels.</p><p>To change the cropping (composing) rectangle set the struct <a class="link" href="media.html#v4l2-selection" title="Table A.83. struct v4l2_selection">v4l2_selection</a>
<em class="structfield"><code>type</code></em> field to the respective buffer type.  Do not
use multiplanar buffers.  Use <code class="constant">V4L2_BUF_TYPE_VIDEO_CAPTURE</code>
instead of <code class="constant">V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE</code>.  Use
<code class="constant">V4L2_BUF_TYPE_VIDEO_OUTPUT</code> instead of
<code class="constant">V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE</code>.  The next step is
setting the value of struct <a class="link" href="media.html#v4l2-selection" title="Table A.83. struct v4l2_selection">v4l2_selection</a> <em class="structfield"><code>target</code></em> to
<code class="constant">V4L2_SEL_TGT_CROP</code> (<code class="constant">V4L2_SEL_TGT_COMPOSE</code>).
Please refer to table <a class="xref" href="media.html#v4l2-selections-common" title="Common selection definitions">the section called &#8220;Common selection definitions&#8221;</a> or <a class="xref" href="media.html#selection-api" title="Experimental API for cropping, composing and scaling">the section called &#8220;Experimental API for cropping, composing and scaling&#8221;</a>
for additional targets.  The struct <a class="link" href="media.html#v4l2-rect" title="Table 4.3. struct v4l2_rect">v4l2_rect</a> <em class="structfield"><code>r</code></em> rectangle need to be
set to the desired active area. Field struct <a class="link" href="media.html#v4l2-selection" title="Table A.83. struct v4l2_selection">v4l2_selection</a> <em class="structfield"><code> reserved
</code></em> is ignored and must be filled with zeros.  The driver may adjust
coordinates of the requested rectangle. An application may
introduce constraints to control rounding behaviour. The struct <a class="link" href="media.html#v4l2-selection" title="Table A.83. struct v4l2_selection">v4l2_selection</a>
<em class="structfield"><code>flags</code></em> field must be set to one of the following:

</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="constant">0</code> - The driver can adjust the rectangle size freely
and shall choose a crop/compose rectangle as close as possible to the requested
one.</p></li><li class="listitem"><p><code class="constant">V4L2_SEL_FLAG_GE</code> - The driver is not allowed to
shrink the rectangle.  The original rectangle must lay inside the adjusted
one.</p></li><li class="listitem"><p><code class="constant">V4L2_SEL_FLAG_LE</code> - The driver is not allowed to
enlarge the rectangle.  The adjusted rectangle must lay inside the original
one.</p></li><li class="listitem"><p><code class="constant">V4L2_SEL_FLAG_GE | V4L2_SEL_FLAG_LE</code> - The driver
must choose the size exactly the same as in the requested rectangle.</p></li></ul></div><p>

Please refer to <a class="xref" href="media.html#sel-const-adjust" title="Figure A.1. Size adjustments with constraint flags.">Figure A.1, &#8220;Size adjustments with constraint flags.&#8221;</a>.

</p><p> The driver may have to adjusts the requested dimensions against hardware
limits and other parts as the pipeline, i.e. the bounds given by the
capture/output window or TV display. The closest possible values of horizontal
and vertical offset and sizes are chosen according to following priority:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Satisfy constraints from struct <a class="link" href="media.html#v4l2-selection" title="Table A.83. struct v4l2_selection">v4l2_selection</a> <em class="structfield"><code>flags</code></em>.</p></li><li class="listitem"><p>Adjust width, height, left, and top to hardware limits and alignments.</p></li><li class="listitem"><p>Keep center of adjusted rectangle as close as possible to the original one.</p></li><li class="listitem"><p>Keep width and height as close as possible to original ones.</p></li><li class="listitem"><p>Keep horizontal and vertical offset as close as possible to original ones.</p></li></ol></div><p>

On success the struct <a class="link" href="media.html#v4l2-rect" title="Table 4.3. struct v4l2_rect">v4l2_rect</a> <em class="structfield"><code>r</code></em> field contains
the adjusted rectangle. When the parameters are unsuitable the application may
modify the cropping (composing) or image parameters and repeat the cycle until
satisfactory parameters have been negotiated. If constraints flags have to be
violated at then ERANGE is returned. The error indicates that <span class="emphasis"><em>there
exist no rectangle</em></span> that satisfies the constraints.</p><p>Selection targets and flags are documented in <a class="xref" href="media.html#v4l2-selections-common" title="Common selection definitions">the section called &#8220;Common selection definitions&#8221;</a>.</p><p>
      </p><div class="figure"><a name="sel-const-adjust"></a><p class="title"><b>Figure A.1. Size adjustments with constraint flags.</b></p><div class="figure-contents"><div class="mediaobject"><img src="constraints.png" alt="Behaviour of rectangle adjustment for different constraint flags."></div></div></div><p><br class="figure-break">
    </p><p>
    </p><div class="table"><a name="v4l2-selection"></a><p class="title"><b>Table A.83. struct <span class="structname">v4l2_selection</span></b></p><div class="table-contents"><table summary="struct v4l2_selection" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>type</code></em></td><td valign="top">Type of the buffer (from enum <a class="link" href="media.html#v4l2-buf-type" title="Table 3.3. enum v4l2_buf_type">v4l2_buf_type</a>).</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>target</code></em></td><td valign="top">Used to select between <a class="link" href="media.html#v4l2-selections-common" title="Common selection definitions"> cropping
	    and composing rectangles</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>flags</code></em></td><td valign="top">Flags controlling the selection rectangle adjustments, refer to
	    <a class="link" href="media.html#v4l2-selection-flags" title="Selection flags">selection flags</a>.</td></tr><tr><td valign="top">struct <a class="link" href="media.html#v4l2-rect" title="Table 4.3. struct v4l2_rect">v4l2_rect</a></td><td valign="top"><em class="structfield"><code>r</code></em></td><td valign="top">The selection rectangle.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved[9]</code></em></td><td valign="top">Reserved fields for future use.</td></tr></tbody></table></div></div><p><br class="table-break">
  </p></div><div class="refsect1"><a name="idp81476960"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>Given buffer type <em class="structfield"><code>type</code></em> or
the selection target <em class="structfield"><code>target</code></em> is not supported,
or the <em class="structfield"><code>flags</code></em> argument is not valid.</p></dd><dt><span class="term"><span class="errorcode">ERANGE</span></span></dt><dd><p>It is not possible to adjust struct <a class="link" href="media.html#v4l2-rect" title="Table 4.3. struct v4l2_rect">v4l2_rect</a> <em class="structfield"><code>
r</code></em> rectangle to satisfy all contraints given in the
<em class="structfield"><code>flags</code></em> argument.</p></dd><dt><span class="term"><span class="errorcode">EBUSY</span></span></dt><dd><p>It is not possible to apply change of the selection rectangle
at the moment. Usually because streaming is in progress.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-g-sliced-vbi-cap"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_G_SLICED_VBI_CAP &#8212; Query sliced VBI capabilities</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_sliced_vbi_cap *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp81595648"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_G_SLICED_VBI_CAP</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp81603776"></a><h2>Description</h2><p>To find out which data services are supported by a sliced
VBI capture or output device, applications initialize the
<em class="structfield"><code>type</code></em> field of a struct <a class="link" href="media.html#v4l2-sliced-vbi-cap" title="Table A.84. struct v4l2_sliced_vbi_cap">v4l2_sliced_vbi_cap</a>,
clear the <em class="structfield"><code>reserved</code></em> array and
call the <code class="constant">VIDIOC_G_SLICED_VBI_CAP</code> ioctl. The
driver fills in the remaining fields or returns an <span class="errorcode">EINVAL</span> error code if the
sliced VBI API is unsupported or <em class="structfield"><code>type</code></em>
is invalid.</p><p>Note the <em class="structfield"><code>type</code></em> field was added,
and the ioctl changed from read-only to write-read, in Linux 2.6.19.</p><div class="table"><a name="v4l2-sliced-vbi-cap"></a><p class="title"><b>Table A.84. struct <span class="structname">v4l2_sliced_vbi_cap</span></b></p><div class="table-contents"><table summary="struct v4l2_sliced_vbi_cap" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"><col class="c5"></colgroup><tbody valign="top"><tr><td valign="top">__u16</td><td valign="top"><em class="structfield"><code>service_set</code></em></td><td colspan="3" valign="top">A set of all data services
supported by the driver. Equal to the union of all elements of the
<em class="structfield"><code>service_lines </code></em> array.</td></tr><tr><td valign="top">__u16</td><td valign="top"><em class="structfield"><code>service_lines</code></em>[2][24]</td><td colspan="3" valign="top">Each element of this array
contains a set of data services the hardware can look for or insert
into a particular scan line. Data services are defined in <a class="xref" href="media.html#vbi-services" title="Table A.85. Sliced VBI services">Table A.85, &#8220;Sliced VBI services&#8221;</a>. Array indices map to ITU-R
line numbers (see also <a class="xref" href="media.html#vbi-525" title="Figure 4.2. ITU-R 525 line numbering (M/NTSC and M/PAL)">Figure 4.2, &#8220;ITU-R 525 line numbering (M/NTSC and M/PAL)&#8221;</a> and <a class="xref" href="media.html#vbi-625" title="Figure 4.3. ITU-R 625 line numbering">Figure 4.3, &#8220;ITU-R 625 line numbering&#8221;</a>) as follows:</td></tr><tr><td valign="top"> </td><td valign="top"> </td><td valign="top">Element</td><td valign="top">525 line systems</td><td valign="top">625 line systems</td></tr><tr><td valign="top"> </td><td valign="top"> </td><td valign="top"><em class="structfield"><code>service_lines</code></em>[0][1]</td><td align="center" valign="top">1</td><td align="center" valign="top">1</td></tr><tr><td valign="top"> </td><td valign="top"> </td><td valign="top"><em class="structfield"><code>service_lines</code></em>[0][23]</td><td align="center" valign="top">23</td><td align="center" valign="top">23</td></tr><tr><td valign="top"> </td><td valign="top"> </td><td valign="top"><em class="structfield"><code>service_lines</code></em>[1][1]</td><td align="center" valign="top">264</td><td align="center" valign="top">314</td></tr><tr><td valign="top"> </td><td valign="top"> </td><td valign="top"><em class="structfield"><code>service_lines</code></em>[1][23]</td><td align="center" valign="top">286</td><td align="center" valign="top">336</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td valign="top"> </td><td valign="top"> </td><td colspan="3" valign="top">The number of VBI lines the
hardware can capture or output per frame, or the number of services it
can identify on a given line may be limited. For example on PAL line
16 the hardware may be able to look for a VPS or Teletext signal, but
not both at the same time. Applications can learn about these limits
using the <a class="link" href="media.html#vidioc-g-fmt" title="ioctl VIDIOC_G_FMT, VIDIOC_S_FMT, VIDIOC_TRY_FMT"><code class="constant">VIDIOC_S_FMT</code></a> ioctl as described in <a class="xref" href="media.html#sliced" title="Sliced VBI Data Interface">the section called &#8220;Sliced VBI Data Interface&#8221;</a>.</td></tr><tr><td valign="top"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td valign="top"> </td><td valign="top"> </td><td colspan="3" valign="top">Drivers must set
<em class="structfield"><code>service_lines</code></em>[0][0] and
<em class="structfield"><code>service_lines</code></em>[1][0] to zero.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>type</code></em></td><td valign="top">Type of the data stream, see <a class="xref" href="media.html#v4l2-buf-type" title="Table 3.3. enum v4l2_buf_type">Table 3.3, &#8220;enum v4l2_buf_type&#8221;</a>. Should be
<code class="constant">V4L2_BUF_TYPE_SLICED_VBI_CAPTURE</code> or
<code class="constant">V4L2_BUF_TYPE_SLICED_VBI_OUTPUT</code>.</td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[3]</td><td colspan="3" valign="top">This array is reserved for future
extensions. Applications and drivers must set it to zero.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="vbi-services"></a><p class="title"><b>Table A.85. Sliced VBI services</b></p><div class="table-contents"><table summary="Sliced VBI services" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"><col class="c5"></colgroup><thead><tr><th>Symbol</th><th>Value</th><th>Reference</th><th>Lines, usually</th><th>Payload</th></tr></thead><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_SLICED_TELETEXT_B</code> (Teletext
System B)</td><td valign="top">0x0001</td><td valign="top"><a class="xref" href="media.html#ets300706" title='ETS 300 706 "Enhanced Teletext specification"'>[<abbr class="abbrev">ETS 300 706</abbr>]</a>, <a class="xref" href="media.html#itu653" title='ITU-R Recommendation BT.653-3 "Teletext systems"'>[<abbr class="abbrev">ITU BT.653</abbr>]</a></td><td valign="top">PAL/SECAM line 7-22, 320-335 (second field 7-22)</td><td valign="top">Last 42 of the 45 byte Teletext packet, that is
without clock run-in and framing code, lsb first transmitted.</td></tr><tr><td valign="top"><code class="constant">V4L2_SLICED_VPS</code></td><td valign="top">0x0400</td><td valign="top"><a class="xref" href="media.html#ets300231" title='ETS 300 231 "Specification of the domestic video Programme Delivery Control system (PDC)"'>[<abbr class="abbrev">ETS 300 231</abbr>]</a></td><td valign="top">PAL line 16</td><td valign="top">Byte number 3 to 15 according to Figure 9 of
ETS 300 231, lsb first transmitted.</td></tr><tr><td valign="top"><code class="constant">V4L2_SLICED_CAPTION_525</code></td><td valign="top">0x1000</td><td valign="top"><a class="xref" href="media.html#eia608" title='EIA 608-B "Recommended Practice for Line 21 Data Service"'>[<abbr class="abbrev">EIA 608-B</abbr>]</a></td><td valign="top">NTSC line 21, 284 (second field 21)</td><td valign="top">Two bytes in transmission order, including parity
bit, lsb first transmitted.</td></tr><tr><td valign="top"><code class="constant">V4L2_SLICED_WSS_625</code></td><td valign="top">0x4000</td><td valign="top"><a class="xref" href="media.html#en300294" title='EN 300 294 "625-line television Wide Screen Signalling (WSS)"'>[<abbr class="abbrev">EN 300 294</abbr>]</a>, <a class="xref" href="media.html#itu1119" title='ITU-R Recommendation BT.1119 "625-line television Wide Screen Signalling (WSS)"'>[<abbr class="abbrev">ITU BT.1119</abbr>]</a></td><td valign="top">PAL/SECAM line 23</td><td valign="top"><pre class="screen">
Byte        0                 1
     msb         lsb  msb           lsb
Bit  7 6 5 4 3 2 1 0  x x 13 12 11 10 9
</pre></td></tr><tr><td valign="top"><code class="constant">V4L2_SLICED_VBI_525</code></td><td valign="top">0x1000</td><td colspan="3" valign="top">Set of services applicable to 525
line systems.</td></tr><tr><td valign="top"><code class="constant">V4L2_SLICED_VBI_625</code></td><td valign="top">0x4401</td><td colspan="3" valign="top">Set of services applicable to 625
line systems.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp81679552"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The value in the <em class="structfield"><code>type</code></em> field is
wrong.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-g-std"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_G_STD, VIDIOC_S_STD &#8212; Query or select the video standard of the current input</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>v4l2_std_id
*<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>const v4l2_std_id
*<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp81803936"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_G_STD, VIDIOC_S_STD</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp81812080"></a><h2>Description</h2><p>To query and select the current video standard applications
use the <code class="constant">VIDIOC_G_STD</code> and <code class="constant">VIDIOC_S_STD</code> ioctls which take a pointer to a
<a class="link" href="media.html#v4l2-std-id" title="Table A.47. typedef v4l2_std_id">v4l2_std_id</a> type as argument. <code class="constant">VIDIOC_G_STD</code> can
return a single flag or a set of flags as in struct <a class="link" href="media.html#v4l2-standard" title="Table A.45. struct v4l2_standard">v4l2_standard</a> field
<em class="structfield"><code>id</code></em>. The flags must be unambiguous such
that they appear in only one enumerated <span class="structname">v4l2_standard</span> structure.</p><p><code class="constant">VIDIOC_S_STD</code> accepts one or more
flags, being a write-only ioctl it does not return the actual new standard as
<code class="constant">VIDIOC_G_STD</code> does. When no flags are given or
the current input does not support the requested standard the driver
returns an <span class="errorcode">EINVAL</span> error code. When the standard set is ambiguous drivers may
return <span class="errorcode">EINVAL</span> or choose any of the requested
standards. If the current input or output does not support standard video timings (e.g. if
<a class="link" href="media.html#vidioc-enuminput" title="ioctl VIDIOC_ENUMINPUT"><code class="constant">VIDIOC_ENUMINPUT</code></a> does not set the <code class="constant">V4L2_IN_CAP_STD</code> flag), then
<span class="errorcode">ENODATA</span> error code is returned.</p></div><div class="refsect1"><a name="idp81822096"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The <code class="constant">VIDIOC_S_STD</code> parameter was unsuitable.</p></dd><dt><span class="term"><span class="errorcode">ENODATA</span></span></dt><dd><p>Standard video timings are not supported for this input or output.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-g-tuner"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_G_TUNER, VIDIOC_S_TUNER &#8212; Get or set tuner attributes</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_tuner
*<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>const struct v4l2_tuner
*<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp81885680"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_G_TUNER, VIDIOC_S_TUNER</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp81893824"></a><h2>Description</h2><p>To query the attributes of a tuner applications initialize the
<em class="structfield"><code>index</code></em> field and zero out the
<em class="structfield"><code>reserved</code></em> array of a struct <a class="link" href="media.html#v4l2-tuner" title="Table A.86. struct v4l2_tuner">v4l2_tuner</a> and call the
<code class="constant">VIDIOC_G_TUNER</code> ioctl with a pointer to this
structure. Drivers fill the rest of the structure or return an
<span class="errorcode">EINVAL</span> error code when the index is out of bounds. To enumerate all tuners
applications shall begin at index zero, incrementing by one until the
driver returns <span class="errorcode">EINVAL</span>.</p><p>Tuners have two writable properties, the audio mode and
the radio frequency. To change the audio mode, applications initialize
the <em class="structfield"><code>index</code></em>,
<em class="structfield"><code>audmode</code></em> and
<em class="structfield"><code>reserved</code></em> fields and call the
<code class="constant">VIDIOC_S_TUNER</code> ioctl. This will
<span class="emphasis"><em>not</em></span> change the current tuner, which is determined
by the current video input. Drivers may choose a different audio mode
if the requested mode is invalid or unsupported. Since this is a
write-only ioctl, it does not return the actually
selected audio mode.</p><p>To change the radio frequency the <a class="link" href="media.html#vidioc-g-frequency" title="ioctl VIDIOC_G_FREQUENCY, VIDIOC_S_FREQUENCY"><code class="constant">VIDIOC_S_FREQUENCY</code></a> ioctl
is available.</p><div class="table"><a name="v4l2-tuner"></a><p class="title"><b>Table A.86. struct <span class="structname">v4l2_tuner</span></b></p><div class="table-contents"><table summary="struct v4l2_tuner" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>index</code></em></td><td colspan="2" valign="top">Identifies the tuner, set by the
application.</td></tr><tr><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>name</code></em>[32]</td><td colspan="2" valign="top"><p>Name of the tuner, a
NUL-terminated ASCII string. This information is intended for the
user.</p></td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>type</code></em></td><td colspan="2" valign="top">Type of the tuner, see <a class="xref" href="media.html#v4l2-tuner-type" title="Table A.87. enum v4l2_tuner_type">Table A.87, &#8220;enum v4l2_tuner_type&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>capability</code></em></td><td colspan="2" valign="top"><p>Tuner capability flags, see
<a class="xref" href="media.html#tuner-capability" title="Table A.88. Tuner and Modulator Capability Flags">Table A.88, &#8220;Tuner and Modulator Capability Flags&#8221;</a>. Audio flags indicate the ability
to decode audio subprograms. They will <span class="emphasis"><em>not</em></span>
change, for example with the current video standard.</p><p>When
the structure refers to a radio tuner the
<code class="constant">V4L2_TUNER_CAP_LANG1</code>,
<code class="constant">V4L2_TUNER_CAP_LANG2</code> and
<code class="constant">V4L2_TUNER_CAP_NORM</code> flags can't be used.</p>
<p>If multiple frequency bands are supported, then
<em class="structfield"><code>capability</code></em> is the union of all
<em class="structfield"><code>capability</code></em> fields of each struct <a class="link" href="media.html#v4l2-frequency-band" title="Table A.36. struct v4l2_frequency_band">v4l2_frequency_band</a>.
</p></td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>rangelow</code></em></td><td colspan="2" valign="top">The lowest tunable frequency in
units of 62.5 kHz, or if the <em class="structfield"><code>capability</code></em>
flag <code class="constant">V4L2_TUNER_CAP_LOW</code> is set, in units of 62.5
Hz, or if the <em class="structfield"><code>capability</code></em> flag
<code class="constant">V4L2_TUNER_CAP_1HZ</code> is set, in units of 1 Hz.
If multiple frequency bands are supported, then
<em class="structfield"><code>rangelow</code></em> is the lowest frequency
of all the frequency bands.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>rangehigh</code></em></td><td colspan="2" valign="top">The highest tunable frequency in
units of 62.5 kHz, or if the <em class="structfield"><code>capability</code></em>
flag <code class="constant">V4L2_TUNER_CAP_LOW</code> is set, in units of 62.5
Hz, or if the <em class="structfield"><code>capability</code></em> flag
<code class="constant">V4L2_TUNER_CAP_1HZ</code> is set, in units of 1 Hz.
If multiple frequency bands are supported, then
<em class="structfield"><code>rangehigh</code></em> is the highest frequency
of all the frequency bands.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>rxsubchans</code></em></td><td colspan="2" valign="top"><p>Some tuners or audio
decoders can determine the received audio subprograms by analyzing
audio carriers, pilot tones or other indicators. To pass this
information drivers set flags defined in <a class="xref" href="media.html#tuner-rxsubchans" title="Table A.89. Tuner Audio Reception Flags">Table A.89, &#8220;Tuner Audio Reception Flags&#8221;</a> in this field. For
example:</p></td></tr><tr><td valign="top"> </td><td valign="top"> </td><td valign="top"><code class="constant">V4L2_TUNER_SUB_MONO</code></td><td valign="top">receiving mono audio</td></tr><tr><td valign="top"> </td><td valign="top"> </td><td valign="top"><code class="constant">STEREO | SAP</code></td><td valign="top">receiving stereo audio and a secondary audio
program</td></tr><tr><td valign="top"> </td><td valign="top"> </td><td valign="top"><code class="constant">MONO | STEREO</code></td><td valign="top">receiving mono or stereo audio, the hardware cannot
distinguish</td></tr><tr><td valign="top"> </td><td valign="top"> </td><td valign="top"><code class="constant">LANG1 | LANG2</code></td><td valign="top">receiving bilingual audio</td></tr><tr><td valign="top"> </td><td valign="top"> </td><td valign="top"><code class="constant">MONO | STEREO | LANG1 | LANG2</code></td><td valign="top">receiving mono, stereo or bilingual
audio</td></tr><tr><td valign="top"> </td><td valign="top"> </td><td colspan="2" valign="top"><p>When the
<code class="constant">V4L2_TUNER_CAP_STEREO</code>,
<code class="constant">_LANG1</code>, <code class="constant">_LANG2</code> or
<code class="constant">_SAP</code> flag is cleared in the
<em class="structfield"><code>capability</code></em> field, the corresponding
<code class="constant">V4L2_TUNER_SUB_</code> flag must not be set
here.</p><p>This field is valid only if this is the tuner of the
current video input, or when the structure refers to a radio
tuner.</p></td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>audmode</code></em></td><td colspan="2" valign="top"><p>The selected audio mode, see
<a class="xref" href="media.html#tuner-audmode" title="Table A.90. Tuner Audio Modes">Table A.90, &#8220;Tuner Audio Modes&#8221;</a> for valid values. The audio mode does
not affect audio subprogram detection, and like a <a class="link" href="media.html#control" title="User Controls">control</a> it does not automatically change
unless the requested mode is invalid or unsupported. See <a class="xref" href="media.html#tuner-matrix" title="Table A.91. Tuner Audio Matrix">Table A.91, &#8220;Tuner Audio Matrix&#8221;</a> for possible results when
the selected and received audio programs do not
match.</p><p>Currently this is the only field of struct
<span class="structname">v4l2_tuner</span> applications can
change.</p></td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>signal</code></em></td><td colspan="2" valign="top">The signal strength if known, ranging
from 0 to 65535. Higher values indicate a better signal.</td></tr><tr><td valign="top">__s32</td><td valign="top"><em class="structfield"><code>afc</code></em></td><td colspan="2" valign="top">Automatic frequency control: When the
<em class="structfield"><code>afc</code></em> value is negative, the frequency is too
low, when positive too high.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[4]</td><td colspan="2" valign="top">Reserved for future extensions. Drivers and
applications must set the array to zero.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-tuner-type"></a><p class="title"><b>Table A.87. enum v4l2_tuner_type</b></p><div class="table-contents"><table summary="enum v4l2_tuner_type" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_TUNER_RADIO</code></td><td valign="top">1</td><td valign="top"> </td></tr><tr><td valign="top"><code class="constant">V4L2_TUNER_ANALOG_TV</code></td><td valign="top">2</td><td valign="top"> </td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="tuner-capability"></a><p class="title"><b>Table A.88. Tuner and Modulator Capability Flags</b></p><div class="table-contents"><table summary="Tuner and Modulator Capability Flags" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_TUNER_CAP_LOW</code></td><td valign="top">0x0001</td><td valign="top">When set, tuning frequencies are expressed in units of
62.5 Hz instead of 62.5 kHz.</td></tr><tr><td valign="top"><code class="constant">V4L2_TUNER_CAP_NORM</code></td><td valign="top">0x0002</td><td valign="top">This is a multi-standard tuner; the video standard
can or must be switched. (B/G PAL tuners for example are typically not
      considered multi-standard because the video standard is automatically
      determined from the frequency band.) The set of supported video
      standards is available from the struct <a class="link" href="media.html#v4l2-input" title="Table A.38. struct v4l2_input">v4l2_input</a> pointing to this tuner,
      see the description of ioctl <a class="link" href="media.html#vidioc-enuminput" title="ioctl VIDIOC_ENUMINPUT"><code class="constant">VIDIOC_ENUMINPUT</code></a> for details. Only
      <code class="constant">V4L2_TUNER_ANALOG_TV</code> tuners can have this capability.</td></tr><tr><td valign="top"><code class="constant">V4L2_TUNER_CAP_HWSEEK_BOUNDED</code></td><td valign="top">0x0004</td><td valign="top">If set, then this tuner supports the hardware seek functionality
	    where the seek stops when it reaches the end of the frequency range.</td></tr><tr><td valign="top"><code class="constant">V4L2_TUNER_CAP_HWSEEK_WRAP</code></td><td valign="top">0x0008</td><td valign="top">If set, then this tuner supports the hardware seek functionality
	    where the seek wraps around when it reaches the end of the frequency range.</td></tr><tr><td valign="top"><code class="constant">V4L2_TUNER_CAP_STEREO</code></td><td valign="top">0x0010</td><td valign="top">Stereo audio reception is supported.</td></tr><tr><td valign="top"><code class="constant">V4L2_TUNER_CAP_LANG1</code></td><td valign="top">0x0040</td><td valign="top">Reception of the primary language of a bilingual
audio program is supported. Bilingual audio is a feature of
two-channel systems, transmitting the primary language monaural on the
main audio carrier and a secondary language monaural on a second
carrier. Only
      <code class="constant">V4L2_TUNER_ANALOG_TV</code> tuners can have this capability.</td></tr><tr><td valign="top"><code class="constant">V4L2_TUNER_CAP_LANG2</code></td><td valign="top">0x0020</td><td valign="top">Reception of the secondary language of a bilingual
audio program is supported. Only
      <code class="constant">V4L2_TUNER_ANALOG_TV</code> tuners can have this capability.</td></tr><tr><td valign="top"><code class="constant">V4L2_TUNER_CAP_SAP</code></td><td valign="top">0x0020</td><td valign="top"><p>Reception of a secondary audio program is
supported. This is a feature of the BTSC system which accompanies the
NTSC video standard. Two audio carriers are available for mono or
stereo transmissions of a primary language, and an independent third
carrier for a monaural secondary language. Only
      <code class="constant">V4L2_TUNER_ANALOG_TV</code> tuners can have this capability.</p><p>Note the
<code class="constant">V4L2_TUNER_CAP_LANG2</code> and
<code class="constant">V4L2_TUNER_CAP_SAP</code> flags are synonyms.
<code class="constant">V4L2_TUNER_CAP_SAP</code> applies when the tuner
supports the <code class="constant">V4L2_STD_NTSC_M</code> video
standard.</p></td></tr><tr><td valign="top"><code class="constant">V4L2_TUNER_CAP_RDS</code></td><td valign="top">0x0080</td><td valign="top">RDS capture is supported. This capability is only valid for
radio tuners.</td></tr><tr><td valign="top"><code class="constant">V4L2_TUNER_CAP_RDS_BLOCK_IO</code></td><td valign="top">0x0100</td><td valign="top">The RDS data is passed as unparsed RDS blocks.</td></tr><tr><td valign="top"><code class="constant">V4L2_TUNER_CAP_RDS_CONTROLS</code></td><td valign="top">0x0200</td><td valign="top">The RDS data is parsed by the hardware and set via controls.</td></tr><tr><td valign="top"><code class="constant">V4L2_TUNER_CAP_FREQ_BANDS</code></td><td valign="top">0x0400</td><td valign="top">The <a class="link" href="media.html#vidioc-enum-freq-bands" title="ioctl VIDIOC_ENUM_FREQ_BANDS"><code class="constant">VIDIOC_ENUM_FREQ_BANDS</code></a> ioctl can be used to enumerate
	the available frequency bands.</td></tr><tr><td valign="top"><code class="constant">V4L2_TUNER_CAP_HWSEEK_PROG_LIM</code></td><td valign="top">0x0800</td><td valign="top">The range to search when using the hardware seek functionality
	is programmable, see <a class="link" href="media.html#vidioc-s-hw-freq-seek" title="ioctl VIDIOC_S_HW_FREQ_SEEK"><code class="constant">VIDIOC_S_HW_FREQ_SEEK</code></a> for details.</td></tr><tr><td valign="top"><code class="constant">V4L2_TUNER_CAP_1HZ</code></td><td valign="top">0x1000</td><td valign="top">When set, tuning frequencies are expressed in units of 1 Hz instead of 62.5 kHz.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="tuner-rxsubchans"></a><p class="title"><b>Table A.89. Tuner Audio Reception Flags</b></p><div class="table-contents"><table summary="Tuner Audio Reception Flags" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_TUNER_SUB_MONO</code></td><td valign="top">0x0001</td><td valign="top">The tuner receives a mono audio signal.</td></tr><tr><td valign="top"><code class="constant">V4L2_TUNER_SUB_STEREO</code></td><td valign="top">0x0002</td><td valign="top">The tuner receives a stereo audio signal.</td></tr><tr><td valign="top"><code class="constant">V4L2_TUNER_SUB_LANG1</code></td><td valign="top">0x0008</td><td valign="top">The tuner receives the primary language of a
bilingual audio signal. Drivers must clear this flag when the current
video standard is <code class="constant">V4L2_STD_NTSC_M</code>.</td></tr><tr><td valign="top"><code class="constant">V4L2_TUNER_SUB_LANG2</code></td><td valign="top">0x0004</td><td valign="top">The tuner receives the secondary language of a
bilingual audio signal (or a second audio program).</td></tr><tr><td valign="top"><code class="constant">V4L2_TUNER_SUB_SAP</code></td><td valign="top">0x0004</td><td valign="top">The tuner receives a Second Audio Program. Note the
<code class="constant">V4L2_TUNER_SUB_LANG2</code> and
<code class="constant">V4L2_TUNER_SUB_SAP</code> flags are synonyms. The
<code class="constant">V4L2_TUNER_SUB_SAP</code> flag applies when the
current video standard is <code class="constant">V4L2_STD_NTSC_M</code>.</td></tr><tr><td valign="top"><code class="constant">V4L2_TUNER_SUB_RDS</code></td><td valign="top">0x0010</td><td valign="top">The tuner receives an RDS channel.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="tuner-audmode"></a><p class="title"><b>Table A.90. Tuner Audio Modes</b></p><div class="table-contents"><table summary="Tuner Audio Modes" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_TUNER_MODE_MONO</code></td><td valign="top">0</td><td valign="top">Play mono audio. When the tuner receives a stereo
signal this a down-mix of the left and right channel. When the tuner
receives a bilingual or SAP signal this mode selects the primary
language.</td></tr><tr><td valign="top"><code class="constant">V4L2_TUNER_MODE_STEREO</code></td><td valign="top">1</td><td valign="top"><p>Play stereo audio. When the tuner receives
bilingual audio it may play different languages on the left and right
channel or the primary language is played on both channels.</p><p>Playing
different languages in this mode is
deprecated. New drivers should do this only in
<code class="constant">MODE_LANG1_LANG2</code>.</p><p>When the tuner
receives no stereo signal or does not support stereo reception the
driver shall fall back to <code class="constant">MODE_MONO</code>.</p></td></tr><tr><td valign="top"><code class="constant">V4L2_TUNER_MODE_LANG1</code></td><td valign="top">3</td><td valign="top">Play the primary language, mono or stereo. Only
<code class="constant">V4L2_TUNER_ANALOG_TV</code> tuners support this
mode.</td></tr><tr><td valign="top"><code class="constant">V4L2_TUNER_MODE_LANG2</code></td><td valign="top">2</td><td valign="top">Play the secondary language, mono. When the tuner
receives no bilingual audio or SAP, or their reception is not
supported the driver shall fall back to mono or stereo mode. Only
<code class="constant">V4L2_TUNER_ANALOG_TV</code> tuners support this
mode.</td></tr><tr><td valign="top"><code class="constant">V4L2_TUNER_MODE_SAP</code></td><td valign="top">2</td><td valign="top">Play the Second Audio Program. When the tuner
receives no bilingual audio or SAP, or their reception is not
supported the driver shall fall back to mono or stereo mode. Only
<code class="constant">V4L2_TUNER_ANALOG_TV</code> tuners support this mode.
Note the <code class="constant">V4L2_TUNER_MODE_LANG2</code> and
<code class="constant">V4L2_TUNER_MODE_SAP</code> are synonyms.</td></tr><tr><td valign="top"><code class="constant">V4L2_TUNER_MODE_LANG1_LANG2</code></td><td valign="top">4</td><td valign="top">Play the primary language on the left channel, the
secondary language on the right channel. When the tuner receives no
bilingual audio or SAP, it shall fall back to
<code class="constant">MODE_LANG1</code> or <code class="constant">MODE_MONO</code>.
Only <code class="constant">V4L2_TUNER_ANALOG_TV</code> tuners support this
mode.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="tuner-matrix"></a><p class="title"><b>Table A.91. Tuner Audio Matrix</b></p><div class="table-contents"><table summary="Tuner Audio Matrix" width="100%" border="1"><colgroup><col align="left"><col align="center" class="c2"><col align="center"><col align="center"><col><col align="center" class="c6"></colgroup><thead><tr><th align="left"> </th><th colspan="5" align="center">Selected
<code class="constant">V4L2_TUNER_MODE_</code></th></tr><tr><th align="left">Received <code class="constant">V4L2_TUNER_SUB_</code></th><th align="center"><code class="constant">MONO</code></th><th align="center"><code class="constant">STEREO</code></th><th align="center"><code class="constant">LANG1</code></th><th align="center"><code class="constant">LANG2 = SAP</code></th><th align="center"><code class="constant">LANG1_LANG2</code><a href="media.html#ftn.idp82067120" class="footnote" name="idp82067120"><sup class="footnote">[a]</sup></a></th></tr></thead><tbody valign="top"><tr><td align="left" valign="top"><code class="constant">MONO</code></td><td align="center" valign="top">Mono</td><td align="center" valign="top">Mono/Mono</td><td align="center" valign="top">Mono</td><td align="center" valign="top">Mono</td><td align="center" valign="top">Mono/Mono</td></tr><tr><td align="left" valign="top"><code class="constant">MONO | SAP</code></td><td align="center" valign="top">Mono</td><td align="center" valign="top">Mono/Mono</td><td align="center" valign="top">Mono</td><td align="center" valign="top">SAP</td><td align="center" valign="top">Mono/SAP (preferred) or Mono/Mono</td></tr><tr><td align="left" valign="top"><code class="constant">STEREO</code></td><td align="center" valign="top">L+R</td><td align="center" valign="top">L/R</td><td align="center" valign="top">Stereo L/R (preferred) or Mono L+R</td><td align="center" valign="top">Stereo L/R (preferred) or Mono L+R</td><td align="center" valign="top">L/R (preferred) or L+R/L+R</td></tr><tr><td align="left" valign="top"><code class="constant">STEREO | SAP</code></td><td align="center" valign="top">L+R</td><td align="center" valign="top">L/R</td><td align="center" valign="top">Stereo L/R (preferred) or Mono L+R</td><td align="center" valign="top">SAP</td><td align="center" valign="top">L+R/SAP (preferred) or L/R or L+R/L+R</td></tr><tr><td align="left" valign="top"><code class="constant">LANG1 | LANG2</code></td><td align="center" valign="top">Language 1</td><td align="center" valign="top">Lang1/Lang2 (deprecated<a href="media.html#ftn.idp82081968" class="footnote" name="idp82081968"><sup class="footnote">[b]</sup></a>) or
Lang1/Lang1</td><td align="center" valign="top">Language 1</td><td align="center" valign="top">Language 2</td><td align="center" valign="top">Lang1/Lang2 (preferred) or Lang1/Lang1</td></tr></tbody><tbody class="footnotes"><tr><td colspan="6"><div id="ftn.idp82067120" class="footnote"><p><a href="media.html#idp82067120" class="para"><sup class="para">[a] </sup></a>This
mode has been added in Linux 2.6.17 and may not be supported by older
drivers.</p></div><div id="ftn.idp82081968" class="footnote"><p><a href="media.html#idp82081968" class="para"><sup class="para">[b] </sup></a>Playback of
both languages in <code class="constant">MODE_STEREO</code> is deprecated. In
the future drivers should produce only the primary language in this
mode. Applications should request
<code class="constant">MODE_LANG1_LANG2</code> to record both languages or a
stereo signal.</p></div></td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp82085888"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The struct <a class="link" href="media.html#v4l2-tuner" title="Table A.86. struct v4l2_tuner">v4l2_tuner</a> <em class="structfield"><code>index</code></em> is
out of bounds.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-log-status"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_LOG_STATUS &#8212; Log driver status information</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp82333184"></a><h2>Description</h2><p>As the video/audio devices become more complicated it
becomes harder to debug problems. When this ioctl is called the driver
will output the current device status to the kernel log. This is
particular useful when dealing with problems like no sound, no video
and incorrectly tuned channels. Also many modern devices autodetect
video and audio standards and this ioctl will report what the device
thinks what the standard is. Mismatches may give an indication where
the problem is.</p><p>This ioctl is optional and not all drivers support it. It
was introduced in Linux 2.6.15.</p></div><div class="refsect1"><a name="idp82335360"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-overlay"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_OVERLAY &#8212; Start or stop video overlay</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>const int *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp82327184"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_OVERLAY</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp82368640"></a><h2>Description</h2><p>This ioctl is part of the <a class="link" href="media.html#overlay" title="Video Overlay Interface">video
    overlay</a> I/O method. Applications call
    <code class="constant">VIDIOC_OVERLAY</code> to start or stop the
    overlay. It takes a pointer to an integer which must be set to
    zero by the application to stop overlay, to one to start.</p><p>Drivers do not support <a class="link" href="media.html#vidioc-streamon" title="ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF"><code class="constant">VIDIOC_STREAMON</code></a> or
<a class="link" href="media.html#vidioc-streamon" title="ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF"><code class="constant">VIDIOC_STREAMOFF</code></a> with <code class="constant">V4L2_BUF_TYPE_VIDEO_OVERLAY</code>.</p></div><div class="refsect1"><a name="idp82373840"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The overlay parameters have not been set up. See <a class="xref" href="media.html#overlay" title="Video Overlay Interface">the section called &#8220;Video Overlay Interface&#8221;</a> for the necessary steps.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-prepare-buf"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_PREPARE_BUF &#8212; Prepare a buffer for I/O</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_buffer *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp82418192"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_PREPARE_BUF</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp82426256"></a><h2>Description</h2><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Experimental</h3><p>This is an <a class="link" href="media.html#experimental" title="Experimental API Elements"> experimental </a>
      interface and may change in the future.</p></div><p>Applications can optionally call the
<code class="constant">VIDIOC_PREPARE_BUF</code> ioctl to pass ownership of the buffer
to the driver before actually enqueuing it, using the
<code class="constant">VIDIOC_QBUF</code> ioctl, and to prepare it for future I/O.
Such preparations may include cache invalidation or cleaning. Performing them
in advance saves time during the actual I/O. In case such cache operations are
not required, the application can use one of
<code class="constant">V4L2_BUF_FLAG_NO_CACHE_INVALIDATE</code> and
<code class="constant">V4L2_BUF_FLAG_NO_CACHE_CLEAN</code> flags to skip the respective
step.</p><p>The <span class="structname">v4l2_buffer</span> structure is
specified in <a class="xref" href="media.html#buffer" title="Buffers">the section called &#8220;Buffers&#8221;</a>.</p></div><div class="refsect1"><a name="idp82433392"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EBUSY</span></span></dt><dd><p>File I/O is in progress.</p></dd><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The buffer <em class="structfield"><code>type</code></em> is not
supported, or the <em class="structfield"><code>index</code></em> is out of bounds,
or no buffers have been allocated yet, or the
<em class="structfield"><code>userptr</code></em> or
<em class="structfield"><code>length</code></em> are invalid.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-qbuf"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_QBUF, VIDIOC_DQBUF &#8212; Exchange a buffer with the driver</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_buffer *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp82486528"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_QBUF, VIDIOC_DQBUF</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp82494672"></a><h2>Description</h2><p>Applications call the <code class="constant">VIDIOC_QBUF</code> ioctl
to enqueue an empty (capturing) or filled (output) buffer in the
driver's incoming queue. The semantics depend on the selected I/O
method.</p><p>To enqueue a buffer applications set the <em class="structfield"><code>type</code></em>
field of a struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a> to the same buffer type as was previously used
with struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a> <em class="structfield"><code>type</code></em> and struct <a class="link" href="media.html#v4l2-requestbuffers" title="Table A.99. struct v4l2_requestbuffers">v4l2_requestbuffers</a>
<em class="structfield"><code>type</code></em>. Applications must also set the
<em class="structfield"><code>index</code></em> field. Valid index numbers range from
zero to the number of buffers allocated with <a class="link" href="media.html#vidioc-reqbufs" title="ioctl VIDIOC_REQBUFS"><code class="constant">VIDIOC_REQBUFS</code></a>
(struct <a class="link" href="media.html#v4l2-requestbuffers" title="Table A.99. struct v4l2_requestbuffers">v4l2_requestbuffers</a> <em class="structfield"><code>count</code></em>) minus one. The
contents of the struct <span class="structname">v4l2_buffer</span> returned
by a <a class="link" href="media.html#vidioc-querybuf" title="ioctl VIDIOC_QUERYBUF"><code class="constant">VIDIOC_QUERYBUF</code></a> ioctl will do as well. When the buffer is
intended for output (<em class="structfield"><code>type</code></em> is
<code class="constant">V4L2_BUF_TYPE_VIDEO_OUTPUT</code>,
<code class="constant">V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE</code>, or
<code class="constant">V4L2_BUF_TYPE_VBI_OUTPUT</code>) applications must also
initialize the <em class="structfield"><code>bytesused</code></em>,
<em class="structfield"><code>field</code></em> and
<em class="structfield"><code>timestamp</code></em> fields, see <a class="xref" href="media.html#buffer" title="Buffers">the section called &#8220;Buffers&#8221;</a> for details.
Applications must also set <em class="structfield"><code>flags</code></em> to 0.
The <em class="structfield"><code>reserved2</code></em> and
<em class="structfield"><code>reserved</code></em> fields must be set to 0. When using
the <a class="link" href="media.html#planar-apis" title="Single- and multi-planar APIs">multi-planar API</a>, the
<em class="structfield"><code>m.planes</code></em> field must contain a userspace pointer
to a filled-in array of struct <a class="link" href="media.html#v4l2-plane" title="Table 3.2. struct v4l2_plane">v4l2_plane</a> and the <em class="structfield"><code>length</code></em>
field must be set to the number of elements in that array.
</p><p>To enqueue a <a class="link" href="media.html#mmap" title="Streaming I/O (Memory Mapping)">memory mapped</a>
buffer applications set the <em class="structfield"><code>memory</code></em>
field to <code class="constant">V4L2_MEMORY_MMAP</code>. When
<code class="constant">VIDIOC_QBUF</code> is called with a pointer to this
structure the driver sets the
<code class="constant">V4L2_BUF_FLAG_MAPPED</code> and
<code class="constant">V4L2_BUF_FLAG_QUEUED</code> flags and clears the
<code class="constant">V4L2_BUF_FLAG_DONE</code> flag in the
<em class="structfield"><code>flags</code></em> field, or it returns an
<span class="errorcode">EINVAL</span> error code.</p><p>To enqueue a <a class="link" href="media.html#userp" title="Streaming I/O (User Pointers)">user pointer</a>
buffer applications set the <em class="structfield"><code>memory</code></em>
field to <code class="constant">V4L2_MEMORY_USERPTR</code>, the
<em class="structfield"><code>m.userptr</code></em> field to the address of the
buffer and <em class="structfield"><code>length</code></em> to its size. When the multi-planar
API is used, <em class="structfield"><code>m.userptr</code></em> and
<em class="structfield"><code>length</code></em> members of the passed array of struct <a class="link" href="media.html#v4l2-plane" title="Table 3.2. struct v4l2_plane">v4l2_plane</a>
have to be used instead. When <code class="constant">VIDIOC_QBUF</code> is called with
a pointer to this structure the driver sets the
<code class="constant">V4L2_BUF_FLAG_QUEUED</code> flag and clears the
<code class="constant">V4L2_BUF_FLAG_MAPPED</code> and
<code class="constant">V4L2_BUF_FLAG_DONE</code> flags in the
<em class="structfield"><code>flags</code></em> field, or it returns an error code.
This ioctl locks the memory pages of the buffer in physical memory,
they cannot be swapped out to disk. Buffers remain locked until
dequeued, until the <a class="link" href="media.html#vidioc-streamon" title="ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF"><code class="constant">VIDIOC_STREAMOFF</code></a> or <a class="link" href="media.html#vidioc-reqbufs" title="ioctl VIDIOC_REQBUFS"><code class="constant">VIDIOC_REQBUFS</code></a> ioctl is
called, or until the device is closed.</p><p>To enqueue a <a class="link" href="media.html#dmabuf" title="Streaming I/O (DMA buffer importing)">DMABUF</a> buffer applications
set the <em class="structfield"><code>memory</code></em> field to
<code class="constant">V4L2_MEMORY_DMABUF</code> and the <em class="structfield"><code>m.fd</code></em>
field to a file descriptor associated with a DMABUF buffer. When the
multi-planar API is used the <em class="structfield"><code>m.fd</code></em> fields of the
passed array of struct <a class="link" href="media.html#v4l2-plane" title="Table 3.2. struct v4l2_plane">v4l2_plane</a> have to be used instead. When
<code class="constant">VIDIOC_QBUF</code> is called with a pointer to this structure the
driver sets the <code class="constant">V4L2_BUF_FLAG_QUEUED</code> flag and clears the
<code class="constant">V4L2_BUF_FLAG_MAPPED</code> and
<code class="constant">V4L2_BUF_FLAG_DONE</code> flags in the
<em class="structfield"><code>flags</code></em> field, or it returns an error code.  This
ioctl locks the buffer. Locking a buffer means passing it to a driver for a
hardware access (usually DMA).  If an application accesses (reads/writes) a
locked buffer then the result is undefined.  Buffers remain locked until
dequeued, until the <a class="link" href="media.html#vidioc-streamon" title="ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF"><code class="constant">VIDIOC_STREAMOFF</code></a> or <a class="link" href="media.html#vidioc-reqbufs" title="ioctl VIDIOC_REQBUFS"><code class="constant">VIDIOC_REQBUFS</code></a> ioctl is called, or
until the device is closed.</p><p>Applications call the <code class="constant">VIDIOC_DQBUF</code>
ioctl to dequeue a filled (capturing) or displayed (output) buffer
from the driver's outgoing queue. They just set the
<em class="structfield"><code>type</code></em>, <em class="structfield"><code>memory</code></em>
and <em class="structfield"><code>reserved</code></em>
fields of a struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a> as above, when <code class="constant">VIDIOC_DQBUF</code>
is called with a pointer to this structure the driver fills the
remaining fields or returns an error code. The driver may also set
<code class="constant">V4L2_BUF_FLAG_ERROR</code> in the <em class="structfield"><code>flags</code></em>
field. It indicates a non-critical (recoverable) streaming error. In such case
the application may continue as normal, but should be aware that data in the
dequeued buffer might be corrupted. When using the multi-planar API, the
planes array must be passed in as well.</p><p>By default <code class="constant">VIDIOC_DQBUF</code> blocks when no
buffer is in the outgoing queue. When the
<code class="constant">O_NONBLOCK</code> flag was given to the <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>
function, <code class="constant">VIDIOC_DQBUF</code> returns immediately
with an <span class="errorcode">EAGAIN</span> error code when no buffer is available.</p><p>The <span class="structname">v4l2_buffer</span> structure is
specified in <a class="xref" href="media.html#buffer" title="Buffers">the section called &#8220;Buffers&#8221;</a>.</p></div><div class="refsect1"><a name="idp82544304"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EAGAIN</span></span></dt><dd><p>Non-blocking I/O has been selected using
<code class="constant">O_NONBLOCK</code> and no buffer was in the outgoing
queue.</p></dd><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The buffer <em class="structfield"><code>type</code></em> is not
supported, or the <em class="structfield"><code>index</code></em> is out of bounds,
or no buffers have been allocated yet, or the
<em class="structfield"><code>userptr</code></em> or
<em class="structfield"><code>length</code></em> are invalid.</p></dd><dt><span class="term"><span class="errorcode">EIO</span></span></dt><dd><p><code class="constant">VIDIOC_DQBUF</code> failed due to an
internal error. Can also indicate temporary problems like signal
loss. Note the driver might dequeue an (empty) buffer despite
returning an error, or even stop capturing. Reusing such buffer may be unsafe
though and its details (e.g. <em class="structfield"><code>index</code></em>) may not be
returned either. It is recommended that drivers indicate recoverable errors
by setting the <code class="constant">V4L2_BUF_FLAG_ERROR</code> and returning 0 instead.
In that case the application should be able to safely reuse the buffer and
continue streaming.
	</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-querybuf"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_QUERYBUF &#8212; Query the status of a buffer</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_buffer *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp82648480"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_QUERYBUF</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp82656608"></a><h2>Description</h2><p>This ioctl is part of the <a class="link" href="media.html#mmap" title="Streaming I/O (Memory Mapping)">streaming
</a> I/O method. It can be used to query the status of a
buffer at any time after buffers have been allocated with the
<a class="link" href="media.html#vidioc-reqbufs" title="ioctl VIDIOC_REQBUFS"><code class="constant">VIDIOC_REQBUFS</code></a> ioctl.</p><p>Applications set the <em class="structfield"><code>type</code></em> field
    of a struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a> to the same buffer type as was previously used with
struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a> <em class="structfield"><code>type</code></em> and struct <a class="link" href="media.html#v4l2-requestbuffers" title="Table A.99. struct v4l2_requestbuffers">v4l2_requestbuffers</a>
<em class="structfield"><code>type</code></em>, and the <em class="structfield"><code>index</code></em>
    field. Valid index numbers range from zero
to the number of buffers allocated with <a class="link" href="media.html#vidioc-reqbufs" title="ioctl VIDIOC_REQBUFS"><code class="constant">VIDIOC_REQBUFS</code></a>
    (struct <a class="link" href="media.html#v4l2-requestbuffers" title="Table A.99. struct v4l2_requestbuffers">v4l2_requestbuffers</a> <em class="structfield"><code>count</code></em>) minus one.
The <em class="structfield"><code>reserved</code></em> field should to set to 0.
When using the <a class="link" href="media.html#planar-apis" title="Single- and multi-planar APIs">multi-planar API</a>, the
<em class="structfield"><code>m.planes</code></em> field must contain a userspace pointer to an
array of struct <a class="link" href="media.html#v4l2-plane" title="Table 3.2. struct v4l2_plane">v4l2_plane</a> and the <em class="structfield"><code>length</code></em> field has
to be set to the number of elements in that array.
After calling <code class="constant">VIDIOC_QUERYBUF</code> with a pointer to
    this structure drivers return an error code or fill the rest of
the structure.</p><p>In the <em class="structfield"><code>flags</code></em> field the
<code class="constant">V4L2_BUF_FLAG_MAPPED</code>,
<code class="constant">V4L2_BUF_FLAG_PREPARED</code>,
<code class="constant">V4L2_BUF_FLAG_QUEUED</code> and
<code class="constant">V4L2_BUF_FLAG_DONE</code> flags will be valid. The
<em class="structfield"><code>memory</code></em> field will be set to the current
I/O method. For the single-planar API, the <em class="structfield"><code>m.offset</code></em>
contains the offset of the buffer from the start of the device memory,
the <em class="structfield"><code>length</code></em> field its size. For the multi-planar API,
fields <em class="structfield"><code>m.mem_offset</code></em> and
<em class="structfield"><code>length</code></em> in the <em class="structfield"><code>m.planes</code></em>
array elements will be used instead and the <em class="structfield"><code>length</code></em>
field of struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a> is set to the number of filled-in array elements.
The driver may or may not set the remaining fields and flags, they are
meaningless in this context.</p><p>The <span class="structname">v4l2_buffer</span> structure is
    specified in <a class="xref" href="media.html#buffer" title="Buffers">the section called &#8220;Buffers&#8221;</a>.</p></div><div class="refsect1"><a name="idp82677872"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The buffer <em class="structfield"><code>type</code></em> is not
supported, or the <em class="structfield"><code>index</code></em> is out of bounds.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-querycap"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_QUERYCAP &#8212; Query device capabilities</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_capability *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp82738832"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_QUERYCAP</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp82746960"></a><h2>Description</h2><p>All V4L2 devices support the
<code class="constant">VIDIOC_QUERYCAP</code> ioctl. It is used to identify
kernel devices compatible with this specification and to obtain
information about driver and hardware capabilities. The ioctl takes a
pointer to a struct <a class="link" href="media.html#v4l2-capability" title="Table A.92. struct v4l2_capability">v4l2_capability</a> which is filled by the driver. When the
driver is not compatible with this specification the ioctl returns an
<span class="errorcode">EINVAL</span> error code.</p><div class="table"><a name="v4l2-capability"></a><p class="title"><b>Table A.92. struct <span class="structname">v4l2_capability</span></b></p><div class="table-contents"><table summary="struct v4l2_capability" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>driver</code></em>[16]</td><td valign="top"><p>Name of the driver, a unique NUL-terminated
ASCII string. For example: "bttv". Driver specific applications can
use this information to verify the driver identity. It is also useful
to work around known bugs, or to identify drivers in error reports.</p>
<p>Storing strings in fixed sized arrays is bad
practice but unavoidable here. Drivers and applications should take
precautions to never read or write beyond the end of the array and to
make sure the strings are properly NUL-terminated.</p></td></tr><tr><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>card</code></em>[32]</td><td valign="top">Name of the device, a NUL-terminated UTF-8 string.
For example: "Yoyodyne TV/FM". One driver may support different brands
or models of video hardware. This information is intended for users,
for example in a menu of available devices. Since multiple TV cards of
the same brand may be installed which are supported by the same
driver, this name should be combined with the character device file
name (e. g. <code class="filename">/dev/video2</code>) or the
<em class="structfield"><code>bus_info</code></em> string to avoid
ambiguities.</td></tr><tr><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>bus_info</code></em>[32]</td><td valign="top">Location of the device in the system, a
NUL-terminated ASCII string. For example: "PCI:0000:05:06.0". This
information is intended for users, to distinguish multiple
identical devices. If no such information is available the field must
simply count the devices controlled by the driver ("platform:vivi-000").
The bus_info must start with "PCI:" for PCI boards, "PCIe:" for PCI Express boards,
"usb-" for USB devices, "I2C:" for i2c devices, "ISA:" for ISA devices,
"parport" for parallel port devices and "platform:" for platform devices.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>version</code></em></td><td valign="top"><p>Version number of the driver.</p>
<p>Starting on kernel 3.1, the version reported is provided per
V4L2 subsystem, following the same Kernel numberation scheme. However, it
should not always return the same version as the kernel, if, for example,
an stable or distribution-modified kernel uses the V4L2 stack from a
newer kernel.</p>
<p>The version number is formatted using the
<code class="constant">KERNEL_VERSION()</code> macro:</p></td></tr><tr><td colspan="3" valign="top"><p>
</p><pre class="programlisting">
#define KERNEL_VERSION(a,b,c) (((a) &lt;&lt; 16) + ((b) &lt;&lt; 8) + (c))

__u32 version = KERNEL_VERSION(0, 8, 1);

printf ("Version: %u.%u.%u\n",
	(version &gt;&gt; 16) &amp; 0xFF,
	(version &gt;&gt; 8) &amp; 0xFF,
	 version &amp; 0xFF);
</pre></td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>capabilities</code></em></td><td valign="top">Available capabilities of the physical device as a whole, see <a class="xref" href="media.html#device-capabilities" title="Table A.93. Device Capabilities Flags">Table A.93, &#8220;Device Capabilities Flags&#8221;</a>. The same physical device can export
		multiple devices in /dev (e.g. /dev/videoX, /dev/vbiY and /dev/radioZ).
		The <em class="structfield"><code>capabilities</code></em> field should contain a union
		of all capabilities available around the several V4L2 devices exported
		to userspace.
		For all those devices the <em class="structfield"><code>capabilities</code></em> field
		returns the same set of	capabilities. This allows applications to open
		just one of the devices (typically the video device) and discover whether
		video, vbi and/or radio are also supported.
	    </td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>device_caps</code></em></td><td valign="top">Device capabilities of the opened device, see <a class="xref" href="media.html#device-capabilities" title="Table A.93. Device Capabilities Flags">Table A.93, &#8220;Device Capabilities Flags&#8221;</a>. Should contain the available capabilities
		of that specific device node. So, for example, <em class="structfield"><code>device_caps</code></em>
		of a radio device will only contain radio related capabilities and
		no video or vbi capabilities. This field is only set if the <em class="structfield"><code>capabilities</code></em>
		field contains the <code class="constant">V4L2_CAP_DEVICE_CAPS</code> capability.
		Only the <em class="structfield"><code>capabilities</code></em> field can have the
		<code class="constant">V4L2_CAP_DEVICE_CAPS</code> capability, <em class="structfield"><code>device_caps</code></em>
		will never set <code class="constant">V4L2_CAP_DEVICE_CAPS</code>.
	    </td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[3]</td><td valign="top">Reserved for future extensions. Drivers must set
this array to zero.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="device-capabilities"></a><p class="title"><b>Table A.93. Device Capabilities Flags</b></p><div class="table-contents"><table summary="Device Capabilities Flags" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_CAP_VIDEO_CAPTURE</code></td><td valign="top">0x00000001</td><td valign="top">The device supports the single-planar API through the <a class="link" href="media.html#capture" title="Video Capture Interface">Video Capture</a> interface.</td></tr><tr><td valign="top"><code class="constant">V4L2_CAP_VIDEO_CAPTURE_MPLANE</code></td><td valign="top">0x00001000</td><td valign="top">The device supports the
	    <a class="link" href="media.html#planar-apis" title="Single- and multi-planar APIs">multi-planar API</a> through the
	    <a class="link" href="media.html#capture" title="Video Capture Interface">Video Capture</a> interface.</td></tr><tr><td valign="top"><code class="constant">V4L2_CAP_VIDEO_OUTPUT</code></td><td valign="top">0x00000002</td><td valign="top">The device supports the single-planar API through the <a class="link" href="media.html#output" title="Video Output Interface">Video Output</a> interface.</td></tr><tr><td valign="top"><code class="constant">V4L2_CAP_VIDEO_OUTPUT_MPLANE</code></td><td valign="top">0x00002000</td><td valign="top">The device supports the
	    <a class="link" href="media.html#planar-apis" title="Single- and multi-planar APIs">multi-planar API</a> through the
	    <a class="link" href="media.html#output" title="Video Output Interface">Video Output</a> interface.</td></tr><tr><td valign="top"><code class="constant">V4L2_CAP_VIDEO_M2M</code></td><td valign="top">0x00004000</td><td valign="top">The device supports the single-planar API through the
	    Video Memory-To-Memory interface.</td></tr><tr><td valign="top"><code class="constant">V4L2_CAP_VIDEO_M2M_MPLANE</code></td><td valign="top">0x00008000</td><td valign="top">The device supports the
	    <a class="link" href="media.html#planar-apis" title="Single- and multi-planar APIs">multi-planar API</a> through the
	    Video Memory-To-Memory  interface.</td></tr><tr><td valign="top"><code class="constant">V4L2_CAP_VIDEO_OVERLAY</code></td><td valign="top">0x00000004</td><td valign="top">The device supports the <a class="link" href="media.html#overlay" title="Video Overlay Interface">Video Overlay</a> interface. A video overlay device
typically stores captured images directly in the video memory of a
graphics card, with hardware clipping and scaling.</td></tr><tr><td valign="top"><code class="constant">V4L2_CAP_VBI_CAPTURE</code></td><td valign="top">0x00000010</td><td valign="top">The device supports the <a class="link" href="media.html#raw-vbi" title="Raw VBI Data Interface">Raw
VBI Capture</a> interface, providing Teletext and Closed Caption
data.</td></tr><tr><td valign="top"><code class="constant">V4L2_CAP_VBI_OUTPUT</code></td><td valign="top">0x00000020</td><td valign="top">The device supports the <a class="link" href="media.html#raw-vbi" title="Raw VBI Data Interface">Raw VBI Output</a> interface.</td></tr><tr><td valign="top"><code class="constant">V4L2_CAP_SLICED_VBI_CAPTURE</code></td><td valign="top">0x00000040</td><td valign="top">The device supports the <a class="link" href="media.html#sliced" title="Sliced VBI Data Interface">Sliced VBI Capture</a> interface.</td></tr><tr><td valign="top"><code class="constant">V4L2_CAP_SLICED_VBI_OUTPUT</code></td><td valign="top">0x00000080</td><td valign="top">The device supports the <a class="link" href="media.html#sliced" title="Sliced VBI Data Interface">Sliced VBI Output</a> interface.</td></tr><tr><td valign="top"><code class="constant">V4L2_CAP_RDS_CAPTURE</code></td><td valign="top">0x00000100</td><td valign="top">The device supports the <a class="link" href="media.html#rds" title="RDS Interface">RDS</a> capture interface.</td></tr><tr><td valign="top"><code class="constant">V4L2_CAP_VIDEO_OUTPUT_OVERLAY</code></td><td valign="top">0x00000200</td><td valign="top">The device supports the <a class="link" href="media.html#osd" title="Video Output Overlay Interface">Video
Output Overlay</a> (OSD) interface. Unlike the <em class="wordasword">Video
Overlay</em> interface, this is a secondary function of video
output devices and overlays an image onto an outgoing video signal.
When the driver sets this flag, it must clear the
<code class="constant">V4L2_CAP_VIDEO_OVERLAY</code> flag and vice
versa.<a href="media.html#ftn.idp82824288" class="footnote" name="idp82824288"><sup class="footnote">[a]</sup></a></td></tr><tr><td valign="top"><code class="constant">V4L2_CAP_HW_FREQ_SEEK</code></td><td valign="top">0x00000400</td><td valign="top">The device supports the <a class="link" href="media.html#vidioc-s-hw-freq-seek" title="ioctl VIDIOC_S_HW_FREQ_SEEK"><code class="constant">VIDIOC_S_HW_FREQ_SEEK</code></a> ioctl for
hardware frequency seeking.</td></tr><tr><td valign="top"><code class="constant">V4L2_CAP_RDS_OUTPUT</code></td><td valign="top">0x00000800</td><td valign="top">The device supports the <a class="link" href="media.html#rds" title="RDS Interface">RDS</a> output interface.</td></tr><tr><td valign="top"><code class="constant">V4L2_CAP_TUNER</code></td><td valign="top">0x00010000</td><td valign="top">The device has some sort of tuner to
receive RF-modulated video signals. For more information about
tuner programming see
<a class="xref" href="media.html#tuner" title="Tuners and Modulators">the section called &#8220;Tuners and Modulators&#8221;</a>.</td></tr><tr><td valign="top"><code class="constant">V4L2_CAP_AUDIO</code></td><td valign="top">0x00020000</td><td valign="top">The device has audio inputs or outputs. It may or
may not support audio recording or playback, in PCM or compressed
formats. PCM audio support must be implemented as ALSA or OSS
interface. For more information on audio inputs and outputs see <a class="xref" href="media.html#audio" title="Audio Inputs and Outputs">the section called &#8220;Audio Inputs and Outputs&#8221;</a>.</td></tr><tr><td valign="top"><code class="constant">V4L2_CAP_RADIO</code></td><td valign="top">0x00040000</td><td valign="top">This is a radio receiver.</td></tr><tr><td valign="top"><code class="constant">V4L2_CAP_MODULATOR</code></td><td valign="top">0x00080000</td><td valign="top">The device has some sort of modulator to
emit RF-modulated video/audio signals. For more information about
modulator programming see
<a class="xref" href="media.html#tuner" title="Tuners and Modulators">the section called &#8220;Tuners and Modulators&#8221;</a>.</td></tr><tr><td valign="top"><code class="constant">V4L2_CAP_SDR_CAPTURE</code></td><td valign="top">0x00100000</td><td valign="top">The device supports the
<a class="link" href="media.html#sdr" title="Software Defined Radio Interface (SDR)">SDR Capture</a> interface.</td></tr><tr><td valign="top"><code class="constant">V4L2_CAP_EXT_PIX_FORMAT</code></td><td valign="top">0x00200000</td><td valign="top">The device supports the struct <a class="link" href="media.html#v4l2-pix-format" title="Table 2.1. struct v4l2_pix_format">v4l2_pix_format</a> extended
fields.</td></tr><tr><td valign="top"><code class="constant">V4L2_CAP_READWRITE</code></td><td valign="top">0x01000000</td><td valign="top">The device supports the <a class="link" href="media.html#rw" title="Read/Write">read()</a> and/or <a class="link" href="media.html#rw" title="Read/Write">write()</a>
I/O methods.</td></tr><tr><td valign="top"><code class="constant">V4L2_CAP_ASYNCIO</code></td><td valign="top">0x02000000</td><td valign="top">The device supports the <a class="link" href="media.html#async" title="Asynchronous I/O">asynchronous</a> I/O methods.</td></tr><tr><td valign="top"><code class="constant">V4L2_CAP_STREAMING</code></td><td valign="top">0x04000000</td><td valign="top">The device supports the <a class="link" href="media.html#mmap" title="Streaming I/O (Memory Mapping)">streaming</a> I/O method.</td></tr><tr><td valign="top"><code class="constant">V4L2_CAP_DEVICE_CAPS</code></td><td valign="top">0x80000000</td><td valign="top">The driver fills the <em class="structfield"><code>device_caps</code></em>
	    field. This capability can only appear in the <em class="structfield"><code>capabilities</code></em>
	    field and never in the <em class="structfield"><code>device_caps</code></em> field.</td></tr></tbody><tbody class="footnotes"><tr><td colspan="3"><div id="ftn.idp82824288" class="footnote"><p><a href="media.html#idp82824288" class="para"><sup class="para">[a] </sup></a>The struct <a class="link" href="media.html#v4l2-framebuffer" title="Table A.68. struct v4l2_framebuffer">v4l2_framebuffer</a> lacks an
enum <a class="link" href="media.html#v4l2-buf-type" title="Table 3.3. enum v4l2_buf_type">v4l2_buf_type</a> field, therefore the type of overlay is implied by the
driver capabilities.</p></div></td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp82858464"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-queryctrl"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU &#8212; Enumerate controls and menu control items</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_queryctrl *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_query_ext_ctrl *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_querymenu *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp83015984"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_QUERYCTRL, VIDIOC_QUERY_EXT_CTRL, VIDIOC_QUERYMENU</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp83024160"></a><h2>Description</h2><p>To query the attributes of a control applications set the
<em class="structfield"><code>id</code></em> field of a struct <a class="link" href="media.html#v4l2-queryctrl" title="Table A.94. struct v4l2_queryctrl">v4l2_queryctrl</a> and call the
<code class="constant">VIDIOC_QUERYCTRL</code> ioctl with a pointer to this
structure. The driver fills the rest of the structure or returns an
<span class="errorcode">EINVAL</span> error code when the <em class="structfield"><code>id</code></em> is invalid.</p><p>It is possible to enumerate controls by calling
<code class="constant">VIDIOC_QUERYCTRL</code> with successive
<em class="structfield"><code>id</code></em> values starting from
<code class="constant">V4L2_CID_BASE</code> up to and exclusive
<code class="constant">V4L2_CID_LASTP1</code>. Drivers may return
<span class="errorcode">EINVAL</span> if a control in this range is not
supported. Further applications can enumerate private controls, which
are not defined in this specification, by starting at
<code class="constant">V4L2_CID_PRIVATE_BASE</code> and incrementing
<em class="structfield"><code>id</code></em> until the driver returns
<span class="errorcode">EINVAL</span>.</p><p>In both cases, when the driver sets the
<code class="constant">V4L2_CTRL_FLAG_DISABLED</code> flag in the
<em class="structfield"><code>flags</code></em> field this control is permanently
disabled and should be ignored by the application.<a href="media.html#ftn.idp83034016" class="footnote" name="idp83034016"><sup class="footnote">[19]</sup></a></p><p>When the application ORs <em class="structfield"><code>id</code></em> with
<code class="constant">V4L2_CTRL_FLAG_NEXT_CTRL</code> the driver returns the
next supported non-compound control, or <span class="errorcode">EINVAL</span>
if there is none. In addition, the <code class="constant">V4L2_CTRL_FLAG_NEXT_COMPOUND</code>
flag can be specified to enumerate all compound controls (i.e. controls
with type &#8805; <code class="constant">V4L2_CTRL_COMPOUND_TYPES</code>). Specify both
<code class="constant">V4L2_CTRL_FLAG_NEXT_CTRL</code> and
<code class="constant">V4L2_CTRL_FLAG_NEXT_COMPOUND</code> in order to enumerate
all controls, compound or not. Drivers which do not support these flags yet
always return <span class="errorcode">EINVAL</span>.</p><p>The <code class="constant">VIDIOC_QUERY_EXT_CTRL</code> ioctl was
introduced in order to better support controls that can use compound
types, and to expose additional control information that cannot be
returned in struct <a class="link" href="media.html#v4l2-queryctrl" title="Table A.94. struct v4l2_queryctrl">v4l2_queryctrl</a> since that structure is full.</p><p><code class="constant">VIDIOC_QUERY_EXT_CTRL</code> is used in the
same way as <code class="constant">VIDIOC_QUERYCTRL</code>, except that the
<em class="structfield"><code>reserved</code></em> array must be zeroed as well.</p><p>Additional information is required for menu controls: the
names of the menu items. To query them applications set the
<em class="structfield"><code>id</code></em> and <em class="structfield"><code>index</code></em>
fields of struct <a class="link" href="media.html#v4l2-querymenu" title="Table A.96. struct v4l2_querymenu">v4l2_querymenu</a> and call the
<code class="constant">VIDIOC_QUERYMENU</code> ioctl with a pointer to this
structure. The driver fills the rest of the structure or returns an
<span class="errorcode">EINVAL</span> error code when the <em class="structfield"><code>id</code></em> or
<em class="structfield"><code>index</code></em> is invalid. Menu items are enumerated
by calling <code class="constant">VIDIOC_QUERYMENU</code> with successive
<em class="structfield"><code>index</code></em> values from struct <a class="link" href="media.html#v4l2-queryctrl" title="Table A.94. struct v4l2_queryctrl">v4l2_queryctrl</a>
<em class="structfield"><code>minimum</code></em> to
<em class="structfield"><code>maximum</code></em>, inclusive. Note that it is possible
for <code class="constant">VIDIOC_QUERYMENU</code> to return an <span class="errorcode">EINVAL</span> error code for some
indices between <em class="structfield"><code>minimum</code></em> and <em class="structfield"><code>maximum</code></em>.
In that case that particular menu item is not supported by this driver. Also note that
the <em class="structfield"><code>minimum</code></em> value is not necessarily 0.</p><p>See also the examples in <a class="xref" href="media.html#control" title="User Controls">the section called &#8220;User Controls&#8221;</a>.</p><div class="table"><a name="v4l2-queryctrl"></a><p class="title"><b>Table A.94. struct <span class="structname">v4l2_queryctrl</span></b></p><div class="table-contents"><table summary="struct v4l2_queryctrl" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>id</code></em></td><td valign="top">Identifies the control, set by the application. See
<a class="xref" href="media.html#control-id" title="Table 1.1. Control IDs">Table 1.1, &#8220;Control IDs&#8221;</a> for predefined IDs. When the ID is ORed
with V4L2_CTRL_FLAG_NEXT_CTRL the driver clears the flag and returns
the first control with a higher ID. Drivers which do not support this
flag yet always return an <span class="errorcode">EINVAL</span> error code.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>type</code></em></td><td valign="top">Type of control, see <a class="xref" href="media.html#v4l2-ctrl-type" title="Table A.97. enum v4l2_ctrl_type">Table A.97, &#8220;enum v4l2_ctrl_type&#8221;</a>.</td></tr><tr><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>name</code></em>[32]</td><td valign="top">Name of the control, a NUL-terminated ASCII
string. This information is intended for the user.</td></tr><tr><td valign="top">__s32</td><td valign="top"><em class="structfield"><code>minimum</code></em></td><td valign="top">Minimum value, inclusive. This field gives a lower
bound for the control. See enum <a class="link" href="media.html#v4l2-ctrl-type" title="Table A.97. enum v4l2_ctrl_type">v4l2_ctrl_type</a> how the minimum value is to
be used for each possible control type. Note that this a signed 32-bit value.</td></tr><tr><td valign="top">__s32</td><td valign="top"><em class="structfield"><code>maximum</code></em></td><td valign="top">Maximum value, inclusive. This field gives an upper
bound for the control. See enum <a class="link" href="media.html#v4l2-ctrl-type" title="Table A.97. enum v4l2_ctrl_type">v4l2_ctrl_type</a> how the maximum value is to
be used for each possible control type. Note that this a signed 32-bit value.</td></tr><tr><td valign="top">__s32</td><td valign="top"><em class="structfield"><code>step</code></em></td><td valign="top"><p>This field gives a step size for the control.
See enum <a class="link" href="media.html#v4l2-ctrl-type" title="Table A.97. enum v4l2_ctrl_type">v4l2_ctrl_type</a> how the step value is to be used for each possible
control type. Note that this an unsigned 32-bit value.
</p><p>Generally drivers should not scale hardware
control values. It may be necessary for example when the
<em class="structfield"><code>name</code></em> or <em class="structfield"><code>id</code></em> imply
a particular unit and the hardware actually accepts only multiples of
said unit. If so, drivers must take care values are properly rounded
when scaling, such that errors will not accumulate on repeated
read-write cycles.</p><p>This field gives the smallest change of
an integer control actually affecting hardware. Often the information
is needed when the user can change controls by keyboard or GUI
buttons, rather than a slider. When for example a hardware register
accepts values 0-511 and the driver reports 0-65535, step should be
128.</p><p>Note that although signed, the step value is supposed to
be always positive.</p></td></tr><tr><td valign="top">__s32</td><td valign="top"><em class="structfield"><code>default_value</code></em></td><td valign="top">The default value of a
<code class="constant">V4L2_CTRL_TYPE_INTEGER</code>,
<code class="constant">_BOOLEAN</code>, <code class="constant">_BITMASK</code>,
<code class="constant">_MENU</code> or <code class="constant">_INTEGER_MENU</code> control.
Not valid for other types of controls.
Note that drivers reset controls to their default value only when the
driver is first loaded, never afterwards.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>flags</code></em></td><td valign="top">Control flags, see <a class="xref" href="media.html#control-flags" title="Table A.98. Control Flags">Table A.98, &#8220;Control Flags&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[2]</td><td valign="top">Reserved for future extensions. Drivers must set
the array to zero.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-query-ext-ctrl"></a><p class="title"><b>Table A.95. struct <span class="structname">v4l2_query_ext_ctrl</span></b></p><div class="table-contents"><table summary="struct v4l2_query_ext_ctrl" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>id</code></em></td><td valign="top">Identifies the control, set by the application. See
<a class="xref" href="media.html#control-id" title="Table 1.1. Control IDs">Table 1.1, &#8220;Control IDs&#8221;</a> for predefined IDs. When the ID is ORed
with <code class="constant">V4L2_CTRL_FLAG_NEXT_CTRL</code> the driver clears the
flag and returns the first non-compound control with a higher ID. When the
ID is ORed with <code class="constant">V4L2_CTRL_FLAG_NEXT_COMPOUND</code> the driver
clears the flag and returns the first compound control with a higher ID.
Set both to get the first control (compound or not) with a higher ID.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>type</code></em></td><td valign="top">Type of control, see <a class="xref" href="media.html#v4l2-ctrl-type" title="Table A.97. enum v4l2_ctrl_type">Table A.97, &#8220;enum v4l2_ctrl_type&#8221;</a>.</td></tr><tr><td valign="top">char</td><td valign="top"><em class="structfield"><code>name</code></em>[32]</td><td valign="top">Name of the control, a NUL-terminated ASCII
string. This information is intended for the user.</td></tr><tr><td valign="top">__s64</td><td valign="top"><em class="structfield"><code>minimum</code></em></td><td valign="top">Minimum value, inclusive. This field gives a lower
bound for the control. See enum <a class="link" href="media.html#v4l2-ctrl-type" title="Table A.97. enum v4l2_ctrl_type">v4l2_ctrl_type</a> how the minimum value is to
be used for each possible control type. Note that this a signed 64-bit value.</td></tr><tr><td valign="top">__s64</td><td valign="top"><em class="structfield"><code>maximum</code></em></td><td valign="top">Maximum value, inclusive. This field gives an upper
bound for the control. See enum <a class="link" href="media.html#v4l2-ctrl-type" title="Table A.97. enum v4l2_ctrl_type">v4l2_ctrl_type</a> how the maximum value is to
be used for each possible control type. Note that this a signed 64-bit value.</td></tr><tr><td valign="top">__u64</td><td valign="top"><em class="structfield"><code>step</code></em></td><td valign="top"><p>This field gives a step size for the control.
See enum <a class="link" href="media.html#v4l2-ctrl-type" title="Table A.97. enum v4l2_ctrl_type">v4l2_ctrl_type</a> how the step value is to be used for each possible
control type. Note that this an unsigned 64-bit value.
</p><p>Generally drivers should not scale hardware
control values. It may be necessary for example when the
<em class="structfield"><code>name</code></em> or <em class="structfield"><code>id</code></em> imply
a particular unit and the hardware actually accepts only multiples of
said unit. If so, drivers must take care values are properly rounded
when scaling, such that errors will not accumulate on repeated
read-write cycles.</p><p>This field gives the smallest change of
an integer control actually affecting hardware. Often the information
is needed when the user can change controls by keyboard or GUI
buttons, rather than a slider. When for example a hardware register
accepts values 0-511 and the driver reports 0-65535, step should be
128.</p></td></tr><tr><td valign="top">__s64</td><td valign="top"><em class="structfield"><code>default_value</code></em></td><td valign="top">The default value of a
<code class="constant">V4L2_CTRL_TYPE_INTEGER</code>, <code class="constant">_INTEGER64</code>,
<code class="constant">_BOOLEAN</code>, <code class="constant">_BITMASK</code>,
<code class="constant">_MENU</code>, <code class="constant">_INTEGER_MENU</code>,
<code class="constant">_U8</code> or <code class="constant">_U16</code> control.
Not valid for other types of controls.
Note that drivers reset controls to their default value only when the
driver is first loaded, never afterwards.
</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>flags</code></em></td><td valign="top">Control flags, see <a class="xref" href="media.html#control-flags" title="Table A.98. Control Flags">Table A.98, &#8220;Control Flags&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>elem_size</code></em></td><td valign="top">The size in bytes of a single element of the array.
Given a char pointer <code class="constant">p</code> to a 3-dimensional array you can find the
position of cell <code class="constant">(z, y, x)</code> as follows:
<code class="constant">p + ((z * dims[1] + y) * dims[0] + x) * elem_size</code>. <em class="structfield"><code>elem_size</code></em>
is always valid, also when the control isn't an array. For string controls
<em class="structfield"><code>elem_size</code></em> is equal to <em class="structfield"><code>maximum + 1</code></em>.
</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>elems</code></em></td><td valign="top">The number of elements in the N-dimensional array. If this control
is not an array, then <em class="structfield"><code>elems</code></em> is 1. The <em class="structfield"><code>elems</code></em>
field can never be 0.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>nr_of_dims</code></em></td><td valign="top">The number of dimension in the N-dimensional array. If this control
is not an array, then this field is 0.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>dims[V4L2_CTRL_MAX_DIMS]</code></em></td><td valign="top">The size of each dimension. The first <em class="structfield"><code>nr_of_dims</code></em>
elements of this array must be non-zero, all remaining elements must be zero.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[32]</td><td valign="top">Reserved for future extensions. Applications and drivers
must set the array to zero.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-querymenu"></a><p class="title"><b>Table A.96. struct <span class="structname">v4l2_querymenu</span></b></p><div class="table-contents"><table summary="struct v4l2_querymenu" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"> </td><td valign="top"><em class="structfield"><code>id</code></em></td><td valign="top">Identifies the control, set by the application
from the respective struct <a class="link" href="media.html#v4l2-queryctrl" title="Table A.94. struct v4l2_queryctrl">v4l2_queryctrl</a>
<em class="structfield"><code>id</code></em>.</td></tr><tr><td valign="top">__u32</td><td valign="top"> </td><td valign="top"><em class="structfield"><code>index</code></em></td><td valign="top">Index of the menu item, starting at zero, set by
	    the application.</td></tr><tr><td valign="top">union</td><td valign="top"> </td><td valign="top"> </td><td valign="top"> </td></tr><tr><td valign="top"> </td><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>name</code></em>[32]</td><td valign="top">Name of the menu item, a NUL-terminated ASCII
string. This information is intended for the user. This field is valid
for <code class="constant">V4L2_CTRL_FLAG_MENU</code> type controls.</td></tr><tr><td valign="top"> </td><td valign="top">__s64</td><td valign="top"><em class="structfield"><code>value</code></em></td><td valign="top">
              Value of the integer menu item. This field is valid for
              <code class="constant">V4L2_CTRL_FLAG_INTEGER_MENU</code> type
              controls.
            </td></tr><tr><td valign="top">__u32</td><td valign="top"> </td><td valign="top"><em class="structfield"><code>reserved</code></em></td><td valign="top">Reserved for future extensions. Drivers must set
the array to zero.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-ctrl-type"></a><p class="title"><b>Table A.97. enum v4l2_ctrl_type</b></p><div class="table-contents"><table summary="enum v4l2_ctrl_type" width="100%" border="0"><colgroup><col align="left"><col align="center"><col align="center"><col align="center"><col align="left"></colgroup><thead><tr><th align="left">Type</th><th align="center"><em class="structfield"><code>minimum</code></em></th><th align="center"><em class="structfield"><code>step</code></em></th><th align="center"><em class="structfield"><code>maximum</code></em></th><th align="left">Description</th></tr></thead><tbody valign="top"><tr><td align="left" valign="top"><code class="constant">V4L2_CTRL_TYPE_INTEGER</code></td><td align="center" valign="top">any</td><td align="center" valign="top">any</td><td align="center" valign="top">any</td><td align="left" valign="top">An integer-valued control ranging from minimum to
maximum inclusive. The step value indicates the increment between
values which are actually different on the hardware.</td></tr><tr><td align="left" valign="top"><code class="constant">V4L2_CTRL_TYPE_BOOLEAN</code></td><td align="center" valign="top">0</td><td align="center" valign="top">1</td><td align="center" valign="top">1</td><td align="left" valign="top">A boolean-valued control. Zero corresponds to
"disabled", and one means "enabled".</td></tr><tr><td align="left" valign="top"><code class="constant">V4L2_CTRL_TYPE_MENU</code></td><td align="center" valign="top">&#8805; 0</td><td align="center" valign="top">1</td><td align="center" valign="top">N-1</td><td align="left" valign="top">The control has a menu of N choices. The names of
the menu items can be enumerated with the
<code class="constant">VIDIOC_QUERYMENU</code> ioctl.</td></tr><tr><td align="left" valign="top"><code class="constant">V4L2_CTRL_TYPE_INTEGER_MENU</code></td><td align="center" valign="top">&#8805; 0</td><td align="center" valign="top">1</td><td align="center" valign="top">N-1</td><td align="left" valign="top">
              The control has a menu of N choices. The values of the
              menu items can be enumerated with the
              <code class="constant">VIDIOC_QUERYMENU</code> ioctl. This is
              similar to <code class="constant">V4L2_CTRL_TYPE_MENU</code>
              except that instead of strings, the menu items are
              signed 64-bit integers.
            </td></tr><tr><td align="left" valign="top"><code class="constant">V4L2_CTRL_TYPE_BITMASK</code></td><td align="center" valign="top">0</td><td align="center" valign="top">n/a</td><td align="center" valign="top">any</td><td align="left" valign="top">A bitmask field. The maximum value is the set of bits that can
be used, all other bits are to be 0. The maximum value is interpreted as a __u32,
allowing the use of bit 31 in the bitmask.</td></tr><tr><td align="left" valign="top"><code class="constant">V4L2_CTRL_TYPE_BUTTON</code></td><td align="center" valign="top">0</td><td align="center" valign="top">0</td><td align="center" valign="top">0</td><td align="left" valign="top">A control which performs an action when set.
Drivers must ignore the value passed with
<code class="constant">VIDIOC_S_CTRL</code> and return an <span class="errorcode">EINVAL</span> error code on a
<code class="constant">VIDIOC_G_CTRL</code> attempt.</td></tr><tr><td align="left" valign="top"><code class="constant">V4L2_CTRL_TYPE_INTEGER64</code></td><td align="center" valign="top">any</td><td align="center" valign="top">any</td><td align="center" valign="top">any</td><td align="left" valign="top">A 64-bit integer valued control. Minimum, maximum
and step size cannot be queried using <code class="constant">VIDIOC_QUERYCTRL</code>.
Only <code class="constant">VIDIOC_QUERY_EXT_CTRL</code> can retrieve the 64-bit
min/max/step values, they should be interpreted as n/a when using
<code class="constant">VIDIOC_QUERYCTRL</code>.</td></tr><tr><td align="left" valign="top"><code class="constant">V4L2_CTRL_TYPE_STRING</code></td><td align="center" valign="top">&#8805; 0</td><td align="center" valign="top">&#8805; 1</td><td align="center" valign="top">&#8805; 0</td><td align="left" valign="top">The minimum and maximum string lengths. The step size
means that the string must be (minimum + N * step) characters long for
N &#8805; 0. These lengths do not include the terminating zero, so in order to
pass a string of length 8 to <a class="link" href="media.html#vidioc-g-ext-ctrls" title="ioctl VIDIOC_G_EXT_CTRLS, VIDIOC_S_EXT_CTRLS, VIDIOC_TRY_EXT_CTRLS"><code class="constant">VIDIOC_S_EXT_CTRLS</code></a> you need to set the
<em class="structfield"><code>size</code></em> field of struct <a class="link" href="media.html#v4l2-ext-control" title="Table A.65. struct v4l2_ext_control">v4l2_ext_control</a> to 9. For <a class="link" href="media.html#vidioc-g-ext-ctrls" title="ioctl VIDIOC_G_EXT_CTRLS, VIDIOC_S_EXT_CTRLS, VIDIOC_TRY_EXT_CTRLS"><code class="constant">VIDIOC_G_EXT_CTRLS</code></a> you can
set the <em class="structfield"><code>size</code></em> field to <em class="structfield"><code>maximum</code></em> + 1.
Which character encoding is used will depend on the string control itself and
should be part of the control documentation.</td></tr><tr><td align="left" valign="top"><code class="constant">V4L2_CTRL_TYPE_CTRL_CLASS</code></td><td align="center" valign="top">n/a</td><td align="center" valign="top">n/a</td><td align="center" valign="top">n/a</td><td align="left" valign="top">This is not a control. When
<code class="constant">VIDIOC_QUERYCTRL</code> is called with a control ID
equal to a control class code (see <a class="xref" href="media.html#ctrl-class" title="Table A.67. Control classes">Table A.67, &#8220;Control classes&#8221;</a>) + 1, the
ioctl returns the name of the control class and this control type.
Older drivers which do not support this feature return an
<span class="errorcode">EINVAL</span> error code.</td></tr><tr><td align="left" valign="top"><code class="constant">V4L2_CTRL_TYPE_U8</code></td><td align="center" valign="top">any</td><td align="center" valign="top">any</td><td align="center" valign="top">any</td><td align="left" valign="top">An unsigned 8-bit valued control ranging from minimum to
maximum inclusive. The step value indicates the increment between
values which are actually different on the hardware.
</td></tr><tr><td align="left" valign="top"><code class="constant">V4L2_CTRL_TYPE_U16</code></td><td align="center" valign="top">any</td><td align="center" valign="top">any</td><td align="center" valign="top">any</td><td align="left" valign="top">An unsigned 16-bit valued control ranging from minimum to
maximum inclusive. The step value indicates the increment between
values which are actually different on the hardware.
</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="control-flags"></a><p class="title"><b>Table A.98. Control Flags</b></p><div class="table-contents"><table summary="Control Flags" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_CTRL_FLAG_DISABLED</code></td><td valign="top">0x0001</td><td valign="top">This control is permanently disabled and should be
ignored by the application. Any attempt to change the control will
result in an <span class="errorcode">EINVAL</span> error code.</td></tr><tr><td valign="top"><code class="constant">V4L2_CTRL_FLAG_GRABBED</code></td><td valign="top">0x0002</td><td valign="top">This control is temporarily unchangeable, for
example because another application took over control of the
respective resource. Such controls may be displayed specially in a
user interface. Attempts to change the control may result in an
<span class="errorcode">EBUSY</span> error code.</td></tr><tr><td valign="top"><code class="constant">V4L2_CTRL_FLAG_READ_ONLY</code></td><td valign="top">0x0004</td><td valign="top">This control is permanently readable only. Any
attempt to change the control will result in an <span class="errorcode">EINVAL</span> error code.</td></tr><tr><td valign="top"><code class="constant">V4L2_CTRL_FLAG_UPDATE</code></td><td valign="top">0x0008</td><td valign="top">A hint that changing this control may affect the
value of other controls within the same control class. Applications
should update their user interface accordingly.</td></tr><tr><td valign="top"><code class="constant">V4L2_CTRL_FLAG_INACTIVE</code></td><td valign="top">0x0010</td><td valign="top">This control is not applicable to the current
configuration and should be displayed accordingly in a user interface.
For example the flag may be set on a MPEG audio level 2 bitrate
control when MPEG audio encoding level 1 was selected with another
control.</td></tr><tr><td valign="top"><code class="constant">V4L2_CTRL_FLAG_SLIDER</code></td><td valign="top">0x0020</td><td valign="top">A hint that this control is best represented as a
slider-like element in a user interface.</td></tr><tr><td valign="top"><code class="constant">V4L2_CTRL_FLAG_WRITE_ONLY</code></td><td valign="top">0x0040</td><td valign="top">This control is permanently writable only. Any
attempt to read the control will result in an <span class="errorcode">EACCES</span> error code error code. This
flag is typically present for relative controls or action controls where
writing a value will cause the device to carry out a given action
(e. g. motor control) but no meaningful value can be returned.</td></tr><tr><td valign="top"><code class="constant">V4L2_CTRL_FLAG_VOLATILE</code></td><td valign="top">0x0080</td><td valign="top">This control is volatile, which means that the value of the control
changes continuously. A typical example would be the current gain value if the device
is in auto-gain mode. In such a case the hardware calculates the gain value based on
the lighting conditions which can change over time. Note that setting a new value for
a volatile control will have no effect. The new value will just be ignored.</td></tr><tr><td valign="top"><code class="constant">V4L2_CTRL_FLAG_HAS_PAYLOAD</code></td><td valign="top">0x0100</td><td valign="top">This control has a pointer type, so its value has to be accessed
using one of the pointer fields of struct <a class="link" href="media.html#v4l2-ext-control" title="Table A.65. struct v4l2_ext_control">v4l2_ext_control</a>. This flag is set for controls
that are an array, string, or have a compound type. In all cases you have to set a
pointer to memory containing the payload of the control.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp83231120"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The struct <a class="link" href="media.html#v4l2-queryctrl" title="Table A.94. struct v4l2_queryctrl">v4l2_queryctrl</a> <em class="structfield"><code>id</code></em>
is invalid. The struct <a class="link" href="media.html#v4l2-querymenu" title="Table A.96. struct v4l2_querymenu">v4l2_querymenu</a> <em class="structfield"><code>id</code></em> is
invalid or <em class="structfield"><code>index</code></em> is out of range (less than
<em class="structfield"><code>minimum</code></em> or greater than <em class="structfield"><code>maximum</code></em>)
or this particular menu item is not supported by the driver.</p></dd><dt><span class="term"><span class="errorcode">EACCES</span></span></dt><dd><p>An attempt was made to read a write-only control.</p></dd></dl></div></div><div class="footnotes"><br><hr style="width:100; text-align:left;margin-left: 0"><div id="ftn.idp83034016" class="footnote"><p><a href="media.html#idp83034016" class="para"><sup class="para">[19] </sup></a><code class="constant">V4L2_CTRL_FLAG_DISABLED</code> was
intended for two purposes: Drivers can skip predefined controls not
supported by the hardware (although returning EINVAL would do as
well), or disable predefined and private controls after hardware
detection without the trouble of reordering control arrays and indices
(EINVAL cannot be used to skip private controls because it would
prematurely end the enumeration).</p></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-query-dv-timings"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_QUERY_DV_TIMINGS &#8212; Sense the DV preset received by the current
input</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_dv_timings *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp83508208"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_QUERY_DV_TIMINGS</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp83516272"></a><h2>Description</h2><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Experimental</h3><p>This is an <a class="link" href="media.html#experimental" title="Experimental API Elements"> experimental </a>
      interface and may change in the future.</p></div><p>The hardware may be able to detect the current DV timings
automatically, similar to sensing the video standard. To do so, applications
call <code class="constant">VIDIOC_QUERY_DV_TIMINGS</code> with a pointer to a
struct <a class="link" href="media.html#v4l2-dv-timings" title="Table A.57. struct v4l2_dv_timings">v4l2_dv_timings</a>. Once the hardware detects the timings, it will fill in the
timings structure.

If the timings could not be detected because there was no signal, then
<span class="errorcode">ENOLINK</span> is returned. If a signal was detected, but
it was unstable and the receiver could not lock to the signal, then
<span class="errorcode">ENOLCK</span> is returned. If the receiver could lock to the signal,
but the format is unsupported (e.g. because the pixelclock is out of range
of the hardware capabilities), then the driver fills in whatever timings it
could find and returns <span class="errorcode">ERANGE</span>. In that case the application
can call <a class="link" href="media.html#vidioc-dv-timings-cap" title="ioctl VIDIOC_DV_TIMINGS_CAP, VIDIOC_SUBDEV_DV_TIMINGS_CAP"><code class="constant">VIDIOC_DV_TIMINGS_CAP</code></a> to compare the found timings with the hardware's
capabilities in order to give more precise feedback to the user.
</p></div><div class="refsect1"><a name="idp83524464"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">ENODATA</span></span></dt><dd><p>Digital video timings are not supported for this input or output.</p></dd><dt><span class="term"><span class="errorcode">ENOLINK</span></span></dt><dd><p>No timings could be detected because no signal was found.
</p></dd><dt><span class="term"><span class="errorcode">ENOLCK</span></span></dt><dd><p>The signal was unstable and the hardware could not lock on to it.
</p></dd><dt><span class="term"><span class="errorcode">ERANGE</span></span></dt><dd><p>Timings were found, but they are out of range of the hardware
capabilities.
</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-querystd"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_QUERYSTD &#8212; Sense the video standard received by the current
input</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>v4l2_std_id *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp83583680"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_QUERYSTD</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp83591760"></a><h2>Description</h2><p>The hardware may be able to detect the current video
standard automatically. To do so, applications call <code class="constant">
VIDIOC_QUERYSTD</code> with a pointer to a <a class="link" href="media.html#v4l2-std-id" title="Table A.47. typedef v4l2_std_id">v4l2_std_id</a> type. The
driver stores here a set of candidates, this can be a single flag or a
set of supported standards if for example the hardware can only
distinguish between 50 and 60 Hz systems. If no signal was detected,
then the driver will return V4L2_STD_UNKNOWN. When detection is not
possible or fails, the set must contain all standards supported by the
current video input or output.</p></div><div class="refsect1"><a name="idp83594608"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">ENODATA</span></span></dt><dd><p>Standard video timings are not supported for this input or output.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-reqbufs"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_REQBUFS &#8212; Initiate Memory Mapping or User Pointer I/O</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_requestbuffers *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp83635408"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_REQBUFS</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp83643536"></a><h2>Description</h2><p>This ioctl is used to initiate <a class="link" href="media.html#mmap" title="Streaming I/O (Memory Mapping)">memory mapped</a>,
<a class="link" href="media.html#userp" title="Streaming I/O (User Pointers)">user pointer</a> or <a class="link" href="media.html#dmabuf" title="Streaming I/O (DMA buffer importing)">DMABUF</a> based I/O.  Memory mapped buffers are located in
device memory and must be allocated with this ioctl before they can be mapped
into the application's address space. User buffers are allocated by
applications themselves, and this ioctl is merely used to switch the driver
into user pointer I/O mode and to setup some internal structures.
Similarly, DMABUF buffers are allocated by applications through a device
driver, and this ioctl only configures the driver into DMABUF I/O mode without
performing any direct allocation.</p><p>To allocate device buffers applications initialize all fields of the
<span class="structname">v4l2_requestbuffers</span> structure.  They set the
<em class="structfield"><code>type</code></em> field to the respective stream or buffer type,
the <em class="structfield"><code>count</code></em> field to the desired number of buffers,
<em class="structfield"><code>memory</code></em> must be set to the requested I/O method and
the <em class="structfield"><code>reserved</code></em> array must be zeroed. When the ioctl is
called with a pointer to this structure the driver will attempt to allocate the
requested number of buffers and it stores the actual number allocated in the
<em class="structfield"><code>count</code></em> field. It can be smaller than the number
requested, even zero, when the driver runs out of free memory. A larger number
is also possible when the driver requires more buffers to function correctly.
For example video output requires at least two buffers, one displayed and one
filled by the application.</p><p>When the I/O method is not supported the ioctl
returns an <span class="errorcode">EINVAL</span> error code.</p><p>Applications can call <code class="constant">VIDIOC_REQBUFS</code>
again to change the number of buffers, however this cannot succeed
when any buffers are still mapped. A <em class="structfield"><code>count</code></em>
value of zero frees all buffers, after aborting or finishing any DMA
in progress, an implicit <a class="link" href="media.html#vidioc-streamon" title="ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF"><code class="constant">VIDIOC_STREAMOFF</code></a>. </p><div class="table"><a name="v4l2-requestbuffers"></a><p class="title"><b>Table A.99. struct <span class="structname">v4l2_requestbuffers</span></b></p><div class="table-contents"><table summary="struct v4l2_requestbuffers" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>count</code></em></td><td valign="top">The number of buffers requested or granted.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>type</code></em></td><td valign="top">Type of the stream or buffers, this is the same
as the struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a> <em class="structfield"><code>type</code></em> field. See <a class="xref" href="media.html#v4l2-buf-type" title="Table 3.3. enum v4l2_buf_type">Table 3.3, &#8220;enum v4l2_buf_type&#8221;</a> for valid values.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>memory</code></em></td><td valign="top">Applications set this field to
<code class="constant">V4L2_MEMORY_MMAP</code>,
<code class="constant">V4L2_MEMORY_DMABUF</code> or
<code class="constant">V4L2_MEMORY_USERPTR</code>. See <a class="xref" href="media.html#v4l2-memory" title="Table 3.5. enum v4l2_memory">Table 3.5, &#8220;enum v4l2_memory&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[2]</td><td valign="top">A place holder for future extensions. This array should
be zeroed by applications.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp83672688"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The buffer type (<em class="structfield"><code>type</code></em> field) or the
requested I/O method (<em class="structfield"><code>memory</code></em>) is not
supported.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-s-hw-freq-seek"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_S_HW_FREQ_SEEK &#8212; Perform a hardware frequency seek</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_hw_freq_seek
*<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp83742144"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_S_HW_FREQ_SEEK</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp83750272"></a><h2>Description</h2><p>Start a hardware frequency seek from the current frequency.
To do this applications initialize the <em class="structfield"><code>tuner</code></em>,
<em class="structfield"><code>type</code></em>, <em class="structfield"><code>seek_upward</code></em>,
<em class="structfield"><code>wrap_around</code></em>, <em class="structfield"><code>spacing</code></em>,
<em class="structfield"><code>rangelow</code></em> and <em class="structfield"><code>rangehigh</code></em>
fields, and zero out the <em class="structfield"><code>reserved</code></em> array of a
struct <a class="link" href="media.html#v4l2-hw-freq-seek" title="Table A.100. struct v4l2_hw_freq_seek">v4l2_hw_freq_seek</a> and call the <code class="constant">VIDIOC_S_HW_FREQ_SEEK</code>
ioctl with a pointer to this structure.</p><p>The <em class="structfield"><code>rangelow</code></em> and
<em class="structfield"><code>rangehigh</code></em> fields can be set to a non-zero value to
tell the driver to search a specific band. If the struct <a class="link" href="media.html#v4l2-tuner" title="Table A.86. struct v4l2_tuner">v4l2_tuner</a>
<em class="structfield"><code>capability</code></em> field has the
<code class="constant">V4L2_TUNER_CAP_HWSEEK_PROG_LIM</code> flag set, these values
must fall within one of the bands returned by <a class="link" href="media.html#vidioc-enum-freq-bands" title="ioctl VIDIOC_ENUM_FREQ_BANDS"><code class="constant">VIDIOC_ENUM_FREQ_BANDS</code></a>. If
the <code class="constant">V4L2_TUNER_CAP_HWSEEK_PROG_LIM</code> flag is not set,
then these values must exactly match those of one of the bands returned by
<a class="link" href="media.html#vidioc-enum-freq-bands" title="ioctl VIDIOC_ENUM_FREQ_BANDS"><code class="constant">VIDIOC_ENUM_FREQ_BANDS</code></a>. If the current frequency of the tuner does not fall
within the selected band it will be clamped to fit in the band before the
seek is started.</p><p>If an error is returned, then the original frequency will
    be restored.</p><p>This ioctl is supported if the <code class="constant">V4L2_CAP_HW_FREQ_SEEK</code> capability is set.</p><p>If this ioctl is called from a non-blocking filehandle, then <span class="errorcode">EAGAIN</span> error code is
    returned and no seek takes place.</p><div class="table"><a name="v4l2-hw-freq-seek"></a><p class="title"><b>Table A.100. struct <span class="structname">v4l2_hw_freq_seek</span></b></p><div class="table-contents"><table summary="struct v4l2_hw_freq_seek" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>tuner</code></em></td><td valign="top">The tuner index number. This is the
same value as in the struct <a class="link" href="media.html#v4l2-input" title="Table A.38. struct v4l2_input">v4l2_input</a> <em class="structfield"><code>tuner</code></em>
field and the struct <a class="link" href="media.html#v4l2-tuner" title="Table A.86. struct v4l2_tuner">v4l2_tuner</a> <em class="structfield"><code>index</code></em> field.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>type</code></em></td><td valign="top">The tuner type. This is the same value as in the
struct <a class="link" href="media.html#v4l2-tuner" title="Table A.86. struct v4l2_tuner">v4l2_tuner</a> <em class="structfield"><code>type</code></em> field. See <a class="xref" href="media.html#v4l2-tuner-type" title="Table A.87. enum v4l2_tuner_type">Table A.87, &#8220;enum v4l2_tuner_type&#8221;</a></td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>seek_upward</code></em></td><td valign="top">If non-zero, seek upward from the current frequency, else seek downward.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>wrap_around</code></em></td><td valign="top">If non-zero, wrap around when at the end of the frequency range, else stop seeking.
	    The struct <a class="link" href="media.html#v4l2-tuner" title="Table A.86. struct v4l2_tuner">v4l2_tuner</a> <em class="structfield"><code>capability</code></em> field will tell you what the
	    hardware supports.
	    </td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>spacing</code></em></td><td valign="top">If non-zero, defines the hardware seek resolution in Hz. The driver selects the nearest value that is supported by the device. If spacing is zero a reasonable default value is used.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>rangelow</code></em></td><td valign="top">If non-zero, the lowest tunable frequency of the band to
search in units of 62.5 kHz, or if the struct <a class="link" href="media.html#v4l2-tuner" title="Table A.86. struct v4l2_tuner">v4l2_tuner</a>
<em class="structfield"><code>capability</code></em> field has the
<code class="constant">V4L2_TUNER_CAP_LOW</code> flag set, in units of 62.5 Hz or if the struct <a class="link" href="media.html#v4l2-tuner" title="Table A.86. struct v4l2_tuner">v4l2_tuner</a>
<em class="structfield"><code>capability</code></em> field has the
<code class="constant">V4L2_TUNER_CAP_1HZ</code> flag set, in units of 1 Hz.
If <em class="structfield"><code>rangelow</code></em> is zero a reasonable default value
is used.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>rangehigh</code></em></td><td valign="top">If non-zero, the highest tunable frequency of the band to
search in units of 62.5 kHz, or if the struct <a class="link" href="media.html#v4l2-tuner" title="Table A.86. struct v4l2_tuner">v4l2_tuner</a>
<em class="structfield"><code>capability</code></em> field has the
<code class="constant">V4L2_TUNER_CAP_LOW</code> flag set, in units of 62.5 Hz or if the struct <a class="link" href="media.html#v4l2-tuner" title="Table A.86. struct v4l2_tuner">v4l2_tuner</a>
<em class="structfield"><code>capability</code></em> field has the
<code class="constant">V4L2_TUNER_CAP_1HZ</code> flag set, in units of 1 Hz.
If <em class="structfield"><code>rangehigh</code></em> is zero a reasonable default value
is used.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[5]</td><td valign="top">Reserved for future extensions. Applications
	    must set the array to zero.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp83798624"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The <em class="structfield"><code>tuner</code></em> index is out of
bounds, the <em class="structfield"><code>wrap_around</code></em> value is not supported or
one of the values in the <em class="structfield"><code>type</code></em>,
<em class="structfield"><code>rangelow</code></em> or <em class="structfield"><code>rangehigh</code></em>
fields is wrong.</p></dd><dt><span class="term"><span class="errorcode">EAGAIN</span></span></dt><dd><p>Attempted to call <code class="constant">VIDIOC_S_HW_FREQ_SEEK</code>
	  with the filehandle in non-blocking mode.</p></dd><dt><span class="term"><span class="errorcode">ENODATA</span></span></dt><dd><p>The hardware seek found no channels.</p></dd><dt><span class="term"><span class="errorcode">EBUSY</span></span></dt><dd><p>Another hardware seek is already in progress.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-streamon"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_STREAMON, VIDIOC_STREAMOFF &#8212; Start or stop streaming I/O</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>const int *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp83904864"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_STREAMON, VIDIOC_STREAMOFF</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp83913008"></a><h2>Description</h2><p>The <code class="constant">VIDIOC_STREAMON</code> and
<code class="constant">VIDIOC_STREAMOFF</code> ioctl start and stop the capture
or output process during streaming (<a class="link" href="media.html#mmap" title="Streaming I/O (Memory Mapping)">memory
mapping</a>, <a class="link" href="media.html#userp" title="Streaming I/O (User Pointers)">user pointer</a> or
<a class="link" href="media.html#dmabuf" title="Streaming I/O (DMA buffer importing)">DMABUF</a>) I/O.</p><p>Capture hardware is disabled and no input
buffers are filled (if there are any empty buffers in the incoming
queue) until <code class="constant">VIDIOC_STREAMON</code> has been called.
Output hardware is disabled and no video signal is
produced until <code class="constant">VIDIOC_STREAMON</code> has been called.
The ioctl will succeed when at least one output buffer is in the
incoming queue.</p><p>Memory-to-memory devices will not start until
<code class="constant">VIDIOC_STREAMON</code> has been called for both the capture
and output stream types.</p><p>If <code class="constant">VIDIOC_STREAMON</code> fails then any already
queued buffers will remain queued.</p><p>The <code class="constant">VIDIOC_STREAMOFF</code> ioctl, apart of
aborting or finishing any DMA in progress, unlocks any user pointer
buffers locked in physical memory, and it removes all buffers from the
incoming and outgoing queues. That means all images captured but not
dequeued yet will be lost, likewise all images enqueued for output but
not transmitted yet. I/O returns to the same state as after calling
<a class="link" href="media.html#vidioc-reqbufs" title="ioctl VIDIOC_REQBUFS"><code class="constant">VIDIOC_REQBUFS</code></a> and can be restarted accordingly.</p><p>If buffers have been queued with <a class="link" href="media.html#vidioc-qbuf" title="ioctl VIDIOC_QBUF, VIDIOC_DQBUF"><code class="constant">VIDIOC_QBUF</code></a> and
<code class="constant">VIDIOC_STREAMOFF</code> is called without ever having
called <code class="constant">VIDIOC_STREAMON</code>, then those queued buffers
will also be removed from the incoming queue and all are returned to the
same state as after calling <a class="link" href="media.html#vidioc-reqbufs" title="ioctl VIDIOC_REQBUFS"><code class="constant">VIDIOC_REQBUFS</code></a> and can be restarted
accordingly.</p><p>Both ioctls take a pointer to an integer, the desired buffer or
stream type. This is the same as struct <a class="link" href="media.html#v4l2-requestbuffers" title="Table A.99. struct v4l2_requestbuffers">v4l2_requestbuffers</a>
<em class="structfield"><code>type</code></em>.</p><p>If <code class="constant">VIDIOC_STREAMON</code> is called when streaming
is already in progress, or if <code class="constant">VIDIOC_STREAMOFF</code> is called
when streaming is already stopped, then 0 is returned. Nothing happens in the
case of <code class="constant">VIDIOC_STREAMON</code>, but <code class="constant">VIDIOC_STREAMOFF</code>
will return queued buffers to their starting state as mentioned above.</p><p>Note that applications can be preempted for unknown periods right
before or after the <code class="constant">VIDIOC_STREAMON</code> or
<code class="constant">VIDIOC_STREAMOFF</code> calls, there is no notion of
starting or stopping "now". Buffer timestamps can be used to
synchronize with other events.</p></div><div class="refsect1"><a name="idp83931712"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The buffer <em class="structfield"><code>type</code></em> is not supported,
	  or no buffers have been allocated (memory mapping) or enqueued
	  (output) yet.</p></dd><dt><span class="term"><span class="errorcode">EPIPE</span></span></dt><dd><p>The driver implements <a class="link" href="media.html#pad-level-formats" title="Pad-level Formats">pad-level format configuration</a> and
	  the pipeline configuration is invalid.
	  </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-subdev-enum-frame-interval"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_SUBDEV_ENUM_FRAME_INTERVAL &#8212; Enumerate frame intervals</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_subdev_frame_interval_enum *
	<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp83996064"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_SUBDEV_ENUM_FRAME_INTERVAL</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp84004208"></a><h2>Description</h2><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Experimental</h3><p>This is an <a class="link" href="media.html#experimental" title="Experimental API Elements">experimental</a>
      interface and may change in the future.</p></div><p>This ioctl lets applications enumerate available frame intervals on a
    given sub-device pad. Frame intervals only makes sense for sub-devices that
    can control the frame period on their own. This includes, for instance,
    image sensors and TV tuners.</p><p>For the common use case of image sensors, the frame intervals
    available on the sub-device output pad depend on the frame format and size
    on the same pad. Applications must thus specify the desired format and size
    when enumerating frame intervals.</p><p>To enumerate frame intervals applications initialize the
    <em class="structfield"><code>index</code></em>, <em class="structfield"><code>pad</code></em>,
    <em class="structfield"><code>code</code></em>, <em class="structfield"><code>width</code></em> and
    <em class="structfield"><code>height</code></em> fields of
    struct <a class="link" href="media.html#v4l2-subdev-frame-interval-enum" title="Table A.101. struct v4l2_subdev_frame_interval_enum">v4l2_subdev_frame_interval_enum</a> and call the
    <code class="constant">VIDIOC_SUBDEV_ENUM_FRAME_INTERVAL</code> ioctl with a pointer
    to this structure. Drivers fill the rest of the structure or return
    an <span class="errorcode">EINVAL</span> error code if one of the input fields is invalid. All frame intervals are
    enumerable by beginning at index zero and incrementing by one until
    <span class="errorcode">EINVAL</span> is returned.</p><p>Available frame intervals may depend on the current 'try' formats
    at other pads of the sub-device, as well as on the current active links. See
    <a class="link" href="media.html#vidioc-subdev-g-fmt" title="ioctl VIDIOC_SUBDEV_G_FMT, VIDIOC_SUBDEV_S_FMT"><code class="constant">VIDIOC_SUBDEV_G_FMT</code></a> for more information about the try formats.</p><p>Sub-devices that support the frame interval enumeration ioctl should
    implemented it on a single pad only. Its behaviour when supported on
    multiple pads of the same sub-device is not defined.</p><div class="table"><a name="v4l2-subdev-frame-interval-enum"></a><p class="title"><b>Table A.101. struct <span class="structname">v4l2_subdev_frame_interval_enum</span></b></p><div class="table-contents"><table summary="struct v4l2_subdev_frame_interval_enum" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>index</code></em></td><td valign="top">Number of the format in the enumeration, set by the
	    application.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>pad</code></em></td><td valign="top">Pad number as reported by the media controller API.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>code</code></em></td><td valign="top">The media bus format code, as defined in
	    <a class="xref" href="media.html#v4l2-mbus-format" title="Media Bus Formats">the section called &#8220;Media Bus Formats&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>width</code></em></td><td valign="top">Frame width, in pixels.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>height</code></em></td><td valign="top">Frame height, in pixels.</td></tr><tr><td valign="top">struct <a class="link" href="media.html#v4l2-fract" title="Table A.46. struct v4l2_fract">v4l2_fract</a></td><td valign="top"><em class="structfield"><code>interval</code></em></td><td valign="top">Period, in seconds, between consecutive video frames.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[9]</td><td valign="top">Reserved for future extensions. Applications and drivers must
	    set the array to zero.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp84037296"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The struct <a class="link" href="media.html#v4l2-subdev-frame-interval-enum" title="Table A.101. struct v4l2_subdev_frame_interval_enum">v4l2_subdev_frame_interval_enum</a>
	  <em class="structfield"><code>pad</code></em> references a non-existing pad, one of
	  the <em class="structfield"><code>code</code></em>, <em class="structfield"><code>width</code></em>
	  or <em class="structfield"><code>height</code></em> fields are invalid for the given
	  pad or the <em class="structfield"><code>index</code></em> field is out of bounds.
	  </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-subdev-enum-frame-size"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_SUBDEV_ENUM_FRAME_SIZE &#8212; Enumerate media bus frame sizes</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_subdev_frame_size_enum *
	<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp84114608"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_SUBDEV_ENUM_FRAME_SIZE</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp84122752"></a><h2>Description</h2><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Experimental</h3><p>This is an <a class="link" href="media.html#experimental" title="Experimental API Elements">experimental</a>
      interface and may change in the future.</p></div><p>This ioctl allows applications to enumerate all frame sizes
    supported by a sub-device on the given pad for the given media bus format.
    Supported formats can be retrieved with the <a class="link" href="media.html#vidioc-subdev-enum-mbus-code" title="ioctl VIDIOC_SUBDEV_ENUM_MBUS_CODE"><code class="constant">VIDIOC_SUBDEV_ENUM_MBUS_CODE</code></a>
    ioctl.</p><p>To enumerate frame sizes applications initialize the
    <em class="structfield"><code>pad</code></em>, <em class="structfield"><code>code</code></em> and
    <em class="structfield"><code>index</code></em> fields of the
    struct <a class="link" href="media.html#v4l2-subdev-mbus-code-enum" title="Table A.103. struct v4l2_subdev_mbus_code_enum">v4l2_subdev_mbus_code_enum</a> and call the
    <code class="constant">VIDIOC_SUBDEV_ENUM_FRAME_SIZE</code> ioctl with a pointer to
    the structure. Drivers fill the minimum and maximum frame sizes or return
    an <span class="errorcode">EINVAL</span> error code if one of the input parameters is invalid.</p><p>Sub-devices that only support discrete frame sizes (such as most
    sensors) will return one or more frame sizes with identical minimum and
    maximum values.</p><p>Not all possible sizes in given [minimum, maximum] ranges need to be
    supported. For instance, a scaler that uses a fixed-point scaling ratio
    might not be able to produce every frame size between the minimum and
    maximum values. Applications must use the <a class="link" href="media.html#vidioc-subdev-g-fmt" title="ioctl VIDIOC_SUBDEV_G_FMT, VIDIOC_SUBDEV_S_FMT"><code class="constant">VIDIOC_SUBDEV_S_FMT</code></a> ioctl to
    try the sub-device for an exact supported frame size.</p><p>Available frame sizes may depend on the current 'try' formats at other
    pads of the sub-device, as well as on the current active links and the
    current values of V4L2 controls. See <a class="link" href="media.html#vidioc-subdev-g-fmt" title="ioctl VIDIOC_SUBDEV_G_FMT, VIDIOC_SUBDEV_S_FMT"><code class="constant">VIDIOC_SUBDEV_G_FMT</code></a> for more
    information about try formats.</p><div class="table"><a name="v4l2-subdev-frame-size-enum"></a><p class="title"><b>Table A.102. struct <span class="structname">v4l2_subdev_frame_size_enum</span></b></p><div class="table-contents"><table summary="struct v4l2_subdev_frame_size_enum" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>index</code></em></td><td valign="top">Number of the format in the enumeration, set by the
	    application.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>pad</code></em></td><td valign="top">Pad number as reported by the media controller API.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>code</code></em></td><td valign="top">The media bus format code, as defined in
	    <a class="xref" href="media.html#v4l2-mbus-format" title="Media Bus Formats">the section called &#8220;Media Bus Formats&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>min_width</code></em></td><td valign="top">Minimum frame width, in pixels.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>max_width</code></em></td><td valign="top">Maximum frame width, in pixels.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>min_height</code></em></td><td valign="top">Minimum frame height, in pixels.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>max_height</code></em></td><td valign="top">Maximum frame height, in pixels.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[9]</td><td valign="top">Reserved for future extensions. Applications and drivers must
	    set the array to zero.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp84157728"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The struct <a class="link" href="media.html#v4l2-subdev-frame-size-enum" title="Table A.102. struct v4l2_subdev_frame_size_enum">v4l2_subdev_frame_size_enum</a> <em class="structfield"><code>pad</code></em>
	  references a non-existing pad, the <em class="structfield"><code>code</code></em> is
	  invalid for the given pad or the <em class="structfield"><code>index</code></em>
	  field is out of bounds.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-subdev-enum-mbus-code"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_SUBDEV_ENUM_MBUS_CODE &#8212; Enumerate media bus formats</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_subdev_mbus_code_enum *
	<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp84235504"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_SUBDEV_ENUM_MBUS_CODE</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp84243648"></a><h2>Description</h2><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Experimental</h3><p>This is an <a class="link" href="media.html#experimental" title="Experimental API Elements">experimental</a>
      interface and may change in the future.</p></div><p>To enumerate media bus formats available at a given sub-device pad
    applications initialize the <em class="structfield"><code>pad</code></em> and
    <em class="structfield"><code>index</code></em> fields of struct <a class="link" href="media.html#v4l2-subdev-mbus-code-enum" title="Table A.103. struct v4l2_subdev_mbus_code_enum">v4l2_subdev_mbus_code_enum</a> and
    call the <code class="constant">VIDIOC_SUBDEV_ENUM_MBUS_CODE</code> ioctl with a
    pointer to this structure. Drivers fill the rest of the structure or return
    an <span class="errorcode">EINVAL</span> error code if either the <em class="structfield"><code>pad</code></em> or
    <em class="structfield"><code>index</code></em> are invalid. All media bus formats are
    enumerable by beginning at index zero and incrementing by one until
    <span class="errorcode">EINVAL</span> is returned.</p><p>Available media bus formats may depend on the current 'try' formats
    at other pads of the sub-device, as well as on the current active links. See
    <a class="link" href="media.html#vidioc-subdev-g-fmt" title="ioctl VIDIOC_SUBDEV_G_FMT, VIDIOC_SUBDEV_S_FMT"><code class="constant">VIDIOC_SUBDEV_G_FMT</code></a> for more information about the try formats.</p><div class="table"><a name="v4l2-subdev-mbus-code-enum"></a><p class="title"><b>Table A.103. struct <span class="structname">v4l2_subdev_mbus_code_enum</span></b></p><div class="table-contents"><table summary="struct v4l2_subdev_mbus_code_enum" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>pad</code></em></td><td valign="top">Pad number as reported by the media controller API.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>index</code></em></td><td valign="top">Number of the format in the enumeration, set by the
	    application.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>code</code></em></td><td valign="top">The media bus format code, as defined in
	    <a class="xref" href="media.html#v4l2-mbus-format" title="Media Bus Formats">the section called &#8220;Media Bus Formats&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[9]</td><td valign="top">Reserved for future extensions. Applications and drivers must
	    set the array to zero.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp84267456"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The struct <a class="link" href="media.html#v4l2-subdev-mbus-code-enum" title="Table A.103. struct v4l2_subdev_mbus_code_enum">v4l2_subdev_mbus_code_enum</a> <em class="structfield"><code>pad</code></em>
	  references a non-existing pad, or the <em class="structfield"><code>index</code></em>
	  field is out of bounds.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-subdev-g-crop"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_SUBDEV_G_CROP, VIDIOC_SUBDEV_S_CROP &#8212; Get or set the crop rectangle on a subdev pad</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_subdev_crop *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>const struct v4l2_subdev_crop *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp84338528"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_SUBDEV_G_CROP, VIDIOC_SUBDEV_S_CROP</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp84346688"></a><h2>Description</h2><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Obsolete</h3><p>This is an <a class="link" href="media.html#obsolete" title="Obsolete API Elements">obsolete</a>
      interface and may be removed in the future. It is superseded by
      <a class="link" href="media.html#vidioc-subdev-g-selection" title="ioctl VIDIOC_SUBDEV_G_SELECTION, VIDIOC_SUBDEV_S_SELECTION">the selection
      API</a>.</p></div><p>To retrieve the current crop rectangle applications set the
    <em class="structfield"><code>pad</code></em> field of a struct <a class="link" href="media.html#v4l2-subdev-crop" title="Table A.104. struct v4l2_subdev_crop">v4l2_subdev_crop</a> to the
    desired pad number as reported by the media API and the
    <em class="structfield"><code>which</code></em> field to
    <code class="constant">V4L2_SUBDEV_FORMAT_ACTIVE</code>. They then call the
    <code class="constant">VIDIOC_SUBDEV_G_CROP</code> ioctl with a pointer to this
    structure. The driver fills the members of the <em class="structfield"><code>rect</code></em>
    field or returns <span class="errorcode">EINVAL</span> error code if the input arguments are invalid, or if cropping
    is not supported on the given pad.</p><p>To change the current crop rectangle applications set both the
    <em class="structfield"><code>pad</code></em> and <em class="structfield"><code>which</code></em> fields
    and all members of the <em class="structfield"><code>rect</code></em> field. They then call
    the <code class="constant">VIDIOC_SUBDEV_S_CROP</code> ioctl with a pointer to this
    structure. The driver verifies the requested crop rectangle, adjusts it
    based on the hardware capabilities and configures the device. Upon return
    the struct <a class="link" href="media.html#v4l2-subdev-crop" title="Table A.104. struct v4l2_subdev_crop">v4l2_subdev_crop</a> contains the current format as would be returned
    by a <code class="constant">VIDIOC_SUBDEV_G_CROP</code> call.</p><p>Applications can query the device capabilities by setting the
    <em class="structfield"><code>which</code></em> to
    <code class="constant">V4L2_SUBDEV_FORMAT_TRY</code>. When set, 'try' crop
    rectangles are not applied to the device by the driver, but are mangled
    exactly as active crop rectangles and stored in the sub-device file handle.
    Two applications querying the same sub-device would thus not interact with
    each other.</p><p>Drivers must not return an error solely because the requested crop
    rectangle doesn't match the device capabilities. They must instead modify
    the rectangle to match what the hardware can provide. The modified format
    should be as close as possible to the original request.</p><div class="table"><a name="v4l2-subdev-crop"></a><p class="title"><b>Table A.104. struct <span class="structname">v4l2_subdev_crop</span></b></p><div class="table-contents"><table summary="struct v4l2_subdev_crop" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>pad</code></em></td><td valign="top">Pad number as reported by the media framework.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>which</code></em></td><td valign="top">Crop rectangle to get or set, from
	    enum <a class="link" href="media.html#v4l2-subdev-format-whence" title="Table A.106. enum v4l2_subdev_format_whence">v4l2_subdev_format_whence</a>.</td></tr><tr><td valign="top">struct <a class="link" href="media.html#v4l2-rect" title="Table 4.3. struct v4l2_rect">v4l2_rect</a></td><td valign="top"><em class="structfield"><code>rect</code></em></td><td valign="top">Crop rectangle boundaries, in pixels.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[8]</td><td valign="top">Reserved for future extensions. Applications and drivers must
	    set the array to zero.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp84377760"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EBUSY</span></span></dt><dd><p>The crop rectangle can't be changed because the pad is currently
	  busy. This can be caused, for instance, by an active video stream on
	  the pad. The ioctl must not be retried without performing another
	  action to fix the problem first. Only returned by
	  <code class="constant">VIDIOC_SUBDEV_S_CROP</code></p></dd><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The struct <a class="link" href="media.html#v4l2-subdev-crop" title="Table A.104. struct v4l2_subdev_crop">v4l2_subdev_crop</a> <em class="structfield"><code>pad</code></em>
	  references a non-existing pad, the <em class="structfield"><code>which</code></em>
	  field references a non-existing format, or cropping is not supported
	  on the given subdev pad.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-subdev-g-fmt"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_SUBDEV_G_FMT, VIDIOC_SUBDEV_S_FMT &#8212; Get or set the data format on a subdev pad</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_subdev_format *<var class="pdparam">argp</var>
	<code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp84459888"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_SUBDEV_G_FMT, VIDIOC_SUBDEV_S_FMT</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp84468048"></a><h2>Description</h2><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Experimental</h3><p>This is an <a class="link" href="media.html#experimental" title="Experimental API Elements">experimental</a>
      interface and may change in the future.</p></div><p>These ioctls are used to negotiate the frame format at specific
    subdev pads in the image pipeline.</p><p>To retrieve the current format applications set the
    <em class="structfield"><code>pad</code></em> field of a struct <a class="link" href="media.html#v4l2-subdev-format" title="Table A.105. struct v4l2_subdev_format">v4l2_subdev_format</a> to the
    desired pad number as reported by the media API and the
    <em class="structfield"><code>which</code></em> field to
    <code class="constant">V4L2_SUBDEV_FORMAT_ACTIVE</code>. When they call the
    <code class="constant">VIDIOC_SUBDEV_G_FMT</code> ioctl with a pointer to this
    structure the driver fills the members of the <em class="structfield"><code>format</code></em>
    field.</p><p>To change the current format applications set both the
    <em class="structfield"><code>pad</code></em> and <em class="structfield"><code>which</code></em> fields
    and all members of the <em class="structfield"><code>format</code></em> field. When they
    call the <code class="constant">VIDIOC_SUBDEV_S_FMT</code> ioctl with a pointer to this
    structure the driver verifies the requested format, adjusts it based on the
    hardware capabilities and configures the device. Upon return the
    struct <a class="link" href="media.html#v4l2-subdev-format" title="Table A.105. struct v4l2_subdev_format">v4l2_subdev_format</a> contains the current format as would be returned by a
    <code class="constant">VIDIOC_SUBDEV_G_FMT</code> call.</p><p>Applications can query the device capabilities by setting the
    <em class="structfield"><code>which</code></em> to
    <code class="constant">V4L2_SUBDEV_FORMAT_TRY</code>. When set, 'try' formats are not
    applied to the device by the driver, but are changed exactly as active
    formats and stored in the sub-device file handle. Two applications querying
    the same sub-device would thus not interact with each other.</p><p>For instance, to try a format at the output pad of a sub-device,
    applications would first set the try format at the sub-device input with the
    <code class="constant">VIDIOC_SUBDEV_S_FMT</code> ioctl. They would then either
    retrieve the default format at the output pad with the
    <code class="constant">VIDIOC_SUBDEV_G_FMT</code> ioctl, or set the desired output
    pad format with the <code class="constant">VIDIOC_SUBDEV_S_FMT</code> ioctl and check
    the returned value.</p><p>Try formats do not depend on active formats, but can depend on the
    current links configuration or sub-device controls value. For instance, a
    low-pass noise filter might crop pixels at the frame boundaries, modifying
    its output frame size.</p><p>Drivers must not return an error solely because the requested format
    doesn't match the device capabilities. They must instead modify the format
    to match what the hardware can provide. The modified format should be as
    close as possible to the original request.</p><div class="table"><a name="v4l2-subdev-format"></a><p class="title"><b>Table A.105. struct <span class="structname">v4l2_subdev_format</span></b></p><div class="table-contents"><table summary="struct v4l2_subdev_format" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>pad</code></em></td><td valign="top">Pad number as reported by the media controller API.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>which</code></em></td><td valign="top">Format to modified, from enum <a class="link" href="media.html#v4l2-subdev-format-whence" title="Table A.106. enum v4l2_subdev_format_whence">v4l2_subdev_format_whence</a>.</td></tr><tr><td valign="top">struct <a class="link" href="media.html#v4l2-mbus-framefmt" title="Table 4.20. struct v4l2_mbus_framefmt">v4l2_mbus_framefmt</a></td><td valign="top"><em class="structfield"><code>format</code></em></td><td valign="top">Definition of an image format, see <a class="xref" href="media.html#v4l2-mbus-framefmt" title="Table 4.20. struct v4l2_mbus_framefmt">Table 4.20, &#8220;struct <span class="structname">v4l2_mbus_framefmt</span>&#8221;</a> for details.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[8]</td><td valign="top">Reserved for future extensions. Applications and drivers must
	    set the array to zero.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="v4l2-subdev-format-whence"></a><p class="title"><b>Table A.106. enum <span class="structname">v4l2_subdev_format_whence</span></b></p><div class="table-contents"><table summary="enum v4l2_subdev_format_whence" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">V4L2_SUBDEV_FORMAT_TRY</td><td valign="top">0</td><td valign="top">Try formats, used for querying device capabilities.</td></tr><tr><td valign="top">V4L2_SUBDEV_FORMAT_ACTIVE</td><td valign="top">1</td><td valign="top">Active formats, applied to the hardware.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp84509680"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EBUSY</span></span></dt><dd><p>The format can't be changed because the pad is currently busy.
	  This can be caused, for instance, by an active video stream on the
	  pad. The ioctl must not be retried without performing another action
	  to fix the problem first. Only returned by
	  <code class="constant">VIDIOC_SUBDEV_S_FMT</code></p></dd><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The struct <a class="link" href="media.html#v4l2-subdev-format" title="Table A.105. struct v4l2_subdev_format">v4l2_subdev_format</a> <em class="structfield"><code>pad</code></em>
	  references a non-existing pad, or the <em class="structfield"><code>which</code></em>
	  field references a non-existing format.</p></dd></dl></div></div><div class="refsect1"><a name="idp84519456"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-subdev-g-frame-interval"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_SUBDEV_G_FRAME_INTERVAL, VIDIOC_SUBDEV_S_FRAME_INTERVAL &#8212; Get or set the frame interval on a subdev pad</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_subdev_frame_interval *<var class="pdparam">argp</var>
	<code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp84606608"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_SUBDEV_G_FRAME_INTERVAL, VIDIOC_SUBDEV_S_FRAME_INTERVAL</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp84614784"></a><h2>Description</h2><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Experimental</h3><p>This is an <a class="link" href="media.html#experimental" title="Experimental API Elements">experimental</a>
      interface and may change in the future.</p></div><p>These ioctls are used to get and set the frame interval at specific
    subdev pads in the image pipeline. The frame interval only makes sense for
    sub-devices that can control the frame period on their own. This includes,
    for instance, image sensors and TV tuners. Sub-devices that don't support
    frame intervals must not implement these ioctls.</p><p>To retrieve the current frame interval applications set the
    <em class="structfield"><code>pad</code></em> field of a struct <a class="link" href="media.html#v4l2-subdev-frame-interval" title="Table A.107. struct v4l2_subdev_frame_interval">v4l2_subdev_frame_interval</a> to
    the desired pad number as reported by the media controller API. When they
    call the <code class="constant">VIDIOC_SUBDEV_G_FRAME_INTERVAL</code> ioctl with a
    pointer to this structure the driver fills the members of the
    <em class="structfield"><code>interval</code></em> field.</p><p>To change the current frame interval applications set both the
    <em class="structfield"><code>pad</code></em> field and all members of the
    <em class="structfield"><code>interval</code></em> field. When they call the
    <code class="constant">VIDIOC_SUBDEV_S_FRAME_INTERVAL</code> ioctl with a pointer to
    this structure the driver verifies the requested interval, adjusts it based
    on the hardware capabilities and configures the device. Upon return the
    struct <a class="link" href="media.html#v4l2-subdev-frame-interval" title="Table A.107. struct v4l2_subdev_frame_interval">v4l2_subdev_frame_interval</a> contains the current frame interval as would be
    returned by a <code class="constant">VIDIOC_SUBDEV_G_FRAME_INTERVAL</code> call.
    </p><p>Drivers must not return an error solely because the requested interval
    doesn't match the device capabilities. They must instead modify the interval
    to match what the hardware can provide. The modified interval should be as
    close as possible to the original request.</p><p>Sub-devices that support the frame interval ioctls should implement
    them on a single pad only. Their behaviour when supported on multiple pads
    of the same sub-device is not defined.</p><div class="table"><a name="v4l2-subdev-frame-interval"></a><p class="title"><b>Table A.107. struct <span class="structname">v4l2_subdev_frame_interval</span></b></p><div class="table-contents"><table summary="struct v4l2_subdev_frame_interval" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>pad</code></em></td><td valign="top">Pad number as reported by the media controller API.</td></tr><tr><td valign="top">struct <a class="link" href="media.html#v4l2-fract" title="Table A.46. struct v4l2_fract">v4l2_fract</a></td><td valign="top"><em class="structfield"><code>interval</code></em></td><td valign="top">Period, in seconds, between consecutive video frames.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[9]</td><td valign="top">Reserved for future extensions. Applications and drivers must
	    set the array to zero.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp84639088"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EBUSY</span></span></dt><dd><p>The frame interval can't be changed because the pad is currently
	  busy. This can be caused, for instance, by an active video stream on
	  the pad. The ioctl must not be retried without performing another
	  action to fix the problem first. Only returned by
	  <code class="constant">VIDIOC_SUBDEV_S_FRAME_INTERVAL</code></p></dd><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The struct <a class="link" href="media.html#v4l2-subdev-frame-interval" title="Table A.107. struct v4l2_subdev_frame_interval">v4l2_subdev_frame_interval</a> <em class="structfield"><code>pad</code></em>
	  references a non-existing pad, or the pad doesn't support frame
	  intervals.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-subdev-g-selection"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_SUBDEV_G_SELECTION, VIDIOC_SUBDEV_S_SELECTION &#8212; Get or set selection rectangles on a subdev pad</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_subdev_selection *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp84710016"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_SUBDEV_G_SELECTION, VIDIOC_SUBDEV_S_SELECTION</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp84718176"></a><h2>Description</h2><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Experimental</h3><p>This is an <a class="link" href="media.html#experimental" title="Experimental API Elements">experimental</a>
      interface and may change in the future.</p></div><p>The selections are used to configure various image
    processing functionality performed by the subdevs which affect the
    image size. This currently includes cropping, scaling and
    composition.</p><p>The selection API replaces <a class="link" href="media.html#vidioc-subdev-g-crop" title="ioctl VIDIOC_SUBDEV_G_CROP, VIDIOC_SUBDEV_S_CROP">the old subdev crop API</a>. All
    the function of the crop API, and more, are supported by the
    selections API.</p><p>See <a class="xref" href="media.html#subdev" title="Sub-device Interface">the section called &#8220;Sub-device Interface&#8221;</a> for
    more information on how each selection target affects the image
    processing pipeline inside the subdevice.</p><div class="refsect2"><a name="idp84724288"></a><h3>Types of selection targets</h3><p>There are two types of selection targets: actual and bounds. The
      actual targets are the targets which configure the hardware. The BOUNDS
      target will return a rectangle that contain all possible actual
      rectangles.</p></div><div class="refsect2"><a name="idp84725728"></a><h3>Discovering supported features</h3><p>To discover which targets are supported, the user can
      perform <code class="constant">VIDIOC_SUBDEV_G_SELECTION</code> on them.
      Any unsupported target will return
      <code class="constant">EINVAL</code>.</p><p>Selection targets and flags are documented in <a class="xref" href="media.html#v4l2-selections-common" title="Common selection definitions">the section called &#8220;Common selection definitions&#8221;</a>.</p><div class="table"><a name="v4l2-subdev-selection"></a><p class="title"><b>Table A.108. struct <span class="structname">v4l2_subdev_selection</span></b></p><div class="table-contents"><table summary="struct v4l2_subdev_selection" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>which</code></em></td><td valign="top">Active or try selection, from
	    enum <a class="link" href="media.html#v4l2-subdev-format-whence" title="Table A.106. enum v4l2_subdev_format_whence">v4l2_subdev_format_whence</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>pad</code></em></td><td valign="top">Pad number as reported by the media framework.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>target</code></em></td><td valign="top">Target selection rectangle. See
	    <a class="xref" href="media.html#v4l2-selections-common" title="Common selection definitions">the section called &#8220;Common selection definitions&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>flags</code></em></td><td valign="top">Flags. See
	    <a class="xref" href="media.html#v4l2-selection-flags" title="Selection flags">the section called &#8220;Selection flags&#8221;</a>.</td></tr><tr><td valign="top">struct <a class="link" href="media.html#v4l2-rect" title="Table 4.3. struct v4l2_rect">v4l2_rect</a></td><td valign="top"><em class="structfield"><code>r</code></em></td><td valign="top">Selection rectangle, in pixels.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[8]</td><td valign="top">Reserved for future extensions. Applications and drivers must
	    set the array to zero.</td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="refsect1"><a name="idp84748880"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EBUSY</span></span></dt><dd><p>The selection rectangle can't be changed because the
	  pad is currently busy. This can be caused, for instance, by
	  an active video stream on the pad. The ioctl must not be
	  retried without performing another action to fix the problem
	  first. Only returned by
	  <code class="constant">VIDIOC_SUBDEV_S_SELECTION</code></p></dd><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The struct <a class="link" href="media.html#v4l2-subdev-selection" title="Table A.108. struct v4l2_subdev_selection">v4l2_subdev_selection</a>
	  <em class="structfield"><code>pad</code></em> references a non-existing
	  pad, the <em class="structfield"><code>which</code></em> field references a
	  non-existing format, or the selection target is not
	  supported on the given subdev pad.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="vidioc-subscribe-event"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_SUBSCRIBE_EVENT, VIDIOC_UNSUBSCRIBE_EVENT &#8212; Subscribe or unsubscribe event</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct v4l2_event_subscription
*<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp84828672"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_SUBSCRIBE_EVENT, VIDIOC_UNSUBSCRIBE_EVENT</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp84836832"></a><h2>Description</h2><p>Subscribe or unsubscribe V4L2 event. Subscribed events are
    dequeued by using the <a class="link" href="media.html#vidioc-dqevent" title="ioctl VIDIOC_DQEVENT"><code class="constant">VIDIOC_DQEVENT</code></a> ioctl.</p><div class="table"><a name="v4l2-event-subscription"></a><p class="title"><b>Table A.109. struct <span class="structname">v4l2_event_subscription</span></b></p><div class="table-contents"><table summary="struct v4l2_event_subscription" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>type</code></em></td><td valign="top">Type of the event.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>id</code></em></td><td valign="top">ID of the event source. If there is no ID associated with
		the event source, then set this to 0. Whether or not an event
		needs an ID depends on the event type.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>flags</code></em></td><td valign="top">Event flags, see <a class="xref" href="media.html#event-flags" title="Table A.111. Event Flags">Table A.111, &#8220;Event Flags&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[5]</td><td valign="top">Reserved for future extensions. Drivers and applications
	    must set the array to zero.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="event-type"></a><p class="title"><b>Table A.110. Event Types</b></p><div class="table-contents"><table summary="Event Types" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_EVENT_ALL</code></td><td valign="top">0</td><td valign="top">All events. V4L2_EVENT_ALL is valid only for
	    VIDIOC_UNSUBSCRIBE_EVENT for unsubscribing all events at once.
	    </td></tr><tr><td valign="top"><code class="constant">V4L2_EVENT_VSYNC</code></td><td valign="top">1</td><td valign="top">This event is triggered on the vertical sync.
	    This event has a struct <a class="link" href="media.html#v4l2-event-vsync" title="Table A.13. struct v4l2_event_vsync">v4l2_event_vsync</a> associated with it.
	    </td></tr><tr><td valign="top"><code class="constant">V4L2_EVENT_EOS</code></td><td valign="top">2</td><td valign="top">This event is triggered when the end of a stream is reached.
	    This is typically used with MPEG decoders to report to the application
	    when the last of the MPEG stream has been decoded.
	    </td></tr><tr><td valign="top"><code class="constant">V4L2_EVENT_CTRL</code></td><td valign="top">3</td><td valign="top"><p>This event requires that the <em class="structfield"><code>id</code></em>
		matches the control ID from which you want to receive events.
		This event is triggered if the control's value changes, if a
		button control is pressed or if the control's flags change.
	    	This event has a struct <a class="link" href="media.html#v4l2-event-ctrl" title="Table A.14. struct v4l2_event_ctrl">v4l2_event_ctrl</a> associated with it. This struct
		contains much of the same information as struct <a class="link" href="media.html#v4l2-queryctrl" title="Table A.94. struct v4l2_queryctrl">v4l2_queryctrl</a> and
		struct <a class="link" href="media.html#v4l2-control" title="Table A.55. struct v4l2_control">v4l2_control</a>.</p>

		<p>If the event is generated due to a call to <a class="link" href="media.html#vidioc-g-ctrl" title="ioctl VIDIOC_G_CTRL, VIDIOC_S_CTRL"><code class="constant">VIDIOC_S_CTRL</code></a> or
		<a class="link" href="media.html#vidioc-g-ext-ctrls" title="ioctl VIDIOC_G_EXT_CTRLS, VIDIOC_S_EXT_CTRLS, VIDIOC_TRY_EXT_CTRLS"><code class="constant">VIDIOC_S_EXT_CTRLS</code></a>, then the event will <span class="emphasis"><em>not</em></span> be sent to
		the file handle that called the ioctl function. This prevents
		nasty feedback loops. If you <span class="emphasis"><em>do</em></span> want to get the
		event, then set the <code class="constant">V4L2_EVENT_SUB_FL_ALLOW_FEEDBACK</code>
		flag.
		</p>

		<p>This event type will ensure that no information is lost when
		more events are raised than there is room internally. In that
		case the struct <a class="link" href="media.html#v4l2-event-ctrl" title="Table A.14. struct v4l2_event_ctrl">v4l2_event_ctrl</a> of the second-oldest event is kept,
		but the <em class="structfield"><code>changes</code></em> field of the
		second-oldest event is ORed with the <em class="structfield"><code>changes</code></em>
		field of the oldest event.</p>
	    </td></tr><tr><td valign="top"><code class="constant">V4L2_EVENT_FRAME_SYNC</code></td><td valign="top">4</td><td valign="top">
	      <p>Triggered immediately when the reception of a
	      frame has begun. This event has a
	      struct <a class="link" href="media.html#v4l2-event-frame-sync" title="Table A.15. struct v4l2_event_frame_sync">v4l2_event_frame_sync</a> associated with it.</p>

	      <p>If the hardware needs to be stopped in the case of a
	      buffer underrun it might not be able to generate this event.
	      In such cases the <em class="structfield"><code>frame_sequence</code></em>
	      field in struct <a class="link" href="media.html#v4l2-event-frame-sync" title="Table A.15. struct v4l2_event_frame_sync">v4l2_event_frame_sync</a> will not be incremented. This
	      causes two consecutive frame sequence numbers to have n times
	      frame interval in between them.</p>
	    </td></tr><tr><td valign="top"><code class="constant">V4L2_EVENT_SOURCE_CHANGE</code></td><td valign="top">5</td><td valign="top">
	      <p>This event is triggered when a source parameter change is
	       detected during runtime by the video device. It can be a
	       runtime resolution change triggered by a video decoder or the
	       format change happening on an input connector.
	       This event requires that the <em class="structfield"><code>id</code></em>
	       matches the input index (when used with a video device node)
	       or the pad index (when used with a subdevice node) from which
	       you want to receive events.</p>

              <p>This event has a struct <a class="link" href="media.html#v4l2-event-src-change" title="Table A.16. struct v4l2_event_src_change">v4l2_event_src_change</a> associated
	      with it. The <em class="structfield"><code>changes</code></em> bitfield denotes
	      what has changed for the subscribed pad. If multiple events
	      occurred before application could dequeue them, then the changes
	      will have the ORed value of all the events generated.</p>
	    </td></tr><tr><td valign="top"><code class="constant">V4L2_EVENT_MOTION_DET</code></td><td valign="top">6</td><td valign="top">
	      <p>Triggered whenever the motion detection state for one or more of the regions
	      changes. This event has a struct <a class="link" href="media.html#v4l2-event-motion-det" title="Table A.17. struct v4l2_event_motion_det">v4l2_event_motion_det</a> associated with it.</p>
	    </td></tr><tr><td valign="top"><code class="constant">V4L2_EVENT_PRIVATE_START</code></td><td valign="top">0x08000000</td><td valign="top">Base event number for driver-private events.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="event-flags"></a><p class="title"><b>Table A.111. Event Flags</b></p><div class="table-contents"><table summary="Event Flags" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_EVENT_SUB_FL_SEND_INITIAL</code></td><td valign="top">0x0001</td><td valign="top">When this event is subscribed an initial event will be sent
		containing the current status. This only makes sense for events
		that are triggered by a status change such as <code class="constant">V4L2_EVENT_CTRL</code>.
		Other events will ignore this flag.</td></tr><tr><td valign="top"><code class="constant">V4L2_EVENT_SUB_FL_ALLOW_FEEDBACK</code></td><td valign="top">0x0002</td><td valign="top"><p>If set, then events directly caused by an ioctl will also be sent to
		the filehandle that called that ioctl. For example, changing a control using
		<a class="link" href="media.html#vidioc-g-ctrl" title="ioctl VIDIOC_G_CTRL, VIDIOC_S_CTRL"><code class="constant">VIDIOC_S_CTRL</code></a> will cause a V4L2_EVENT_CTRL to be sent back to that same
		filehandle. Normally such events are suppressed to prevent feedback loops
		where an application changes a control to a one value and then another, and
		then receives an event telling it that that control has changed to the first
		value.</p>

		<p>Since it can't tell whether that event was caused by another application
		or by the <a class="link" href="media.html#vidioc-g-ctrl" title="ioctl VIDIOC_G_CTRL, VIDIOC_S_CTRL"><code class="constant">VIDIOC_S_CTRL</code></a> call it is hard to decide whether to set the
		control to the value in the event, or ignore it.</p>

		<p>Think carefully when you set this flag so you won't get into situations
		like that.</p>
	    </td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp84904608"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="func-mmap"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>v4l2-mmap &#8212; Map device memory into application address space</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">
#include &lt;unistd.h&gt;
#include &lt;sys/mman.h&gt;</pre><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void *<b class="fsfunc">mmap</b>(</code></td><td>void *<var class="pdparam">start</var>, </td></tr><tr><td> </td><td>size_t <var class="pdparam">length</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">prot</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">flags</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>off_t <var class="pdparam">offset</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp85012672"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>start</code></em></span></dt><dd><p>Map the buffer to this address in the
application's address space. When the <code class="constant">MAP_FIXED</code>
flag is specified, <em class="parameter"><code>start</code></em> must be a multiple of the
pagesize and mmap will fail when the specified address
cannot be used. Use of this option is discouraged; applications should
just specify a <code class="constant">NULL</code> pointer here.</p></dd><dt><span class="term"><em class="parameter"><code>length</code></em></span></dt><dd><p>Length of the memory area to map. This must be the
same value as returned by the driver in the struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a>
<em class="structfield"><code>length</code></em> field for the
single-planar API, and the same value as returned by the driver
in the struct <a class="link" href="media.html#v4l2-plane" title="Table 3.2. struct v4l2_plane">v4l2_plane</a> <em class="structfield"><code>length</code></em> field for the
multi-planar API.</p></dd><dt><span class="term"><em class="parameter"><code>prot</code></em></span></dt><dd><p>The <em class="parameter"><code>prot</code></em> argument describes the
desired memory protection. Regardless of the device type and the
direction of data exchange it should be set to
<code class="constant">PROT_READ</code> | <code class="constant">PROT_WRITE</code>,
permitting read and write access to image buffers. Drivers should
support at least this combination of flags. Note the Linux
<code class="filename">video-buf</code> kernel module, which is used by the
bttv, saa7134, saa7146, cx88 and vivi driver supports only
<code class="constant">PROT_READ</code> | <code class="constant">PROT_WRITE</code>. When
the driver does not support the desired protection the
<code class="function">mmap()</code> function fails.</p><p>Note device memory accesses (e. g. the memory on a
graphics card with video capturing hardware) may incur a performance
penalty compared to main memory accesses, or reads may be
significantly slower than writes or vice versa. Other I/O methods may
be more efficient in this case.</p></dd><dt><span class="term"><em class="parameter"><code>flags</code></em></span></dt><dd><p>The <em class="parameter"><code>flags</code></em> parameter
specifies the type of the mapped object, mapping options and whether
modifications made to the mapped copy of the page are private to the
process or are to be shared with other references.</p><p><code class="constant">MAP_FIXED</code> requests that the
driver selects no other address than the one specified. If the
specified address cannot be used, <code class="function">mmap()</code> will fail. If
<code class="constant">MAP_FIXED</code> is specified,
<em class="parameter"><code>start</code></em> must be a multiple of the pagesize. Use
of this option is discouraged.</p><p>One of the <code class="constant">MAP_SHARED</code> or
<code class="constant">MAP_PRIVATE</code> flags must be set.
<code class="constant">MAP_SHARED</code> allows applications to share the
mapped memory with other (e. g. child-) processes. Note the Linux
<code class="filename">video-buf</code> module which is used by the bttv,
saa7134, saa7146, cx88 and vivi driver supports only
<code class="constant">MAP_SHARED</code>. <code class="constant">MAP_PRIVATE</code>
requests copy-on-write semantics. V4L2 applications should not set the
<code class="constant">MAP_PRIVATE</code>, <code class="constant">MAP_DENYWRITE</code>,
<code class="constant">MAP_EXECUTABLE</code> or <code class="constant">MAP_ANON</code>
flag.</p></dd><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>offset</code></em></span></dt><dd><p>Offset of the buffer in device memory. This must be the
same value as returned by the driver in the struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a>
<em class="structfield"><code>m</code></em> union <em class="structfield"><code>offset</code></em> field for
the single-planar API, and the same value as returned by the driver
in the struct <a class="link" href="media.html#v4l2-plane" title="Table 3.2. struct v4l2_plane">v4l2_plane</a> <em class="structfield"><code>m</code></em> union
<em class="structfield"><code>mem_offset</code></em> field for the multi-planar API.</p></dd></dl></div></div><div class="refsect1"><a name="idp85048512"></a><h2>Description</h2><p>The <code class="function">mmap()</code> function asks to map
<em class="parameter"><code>length</code></em> bytes starting at
<em class="parameter"><code>offset</code></em> in the memory of the device specified by
<em class="parameter"><code>fd</code></em> into the application address space,
preferably at address <em class="parameter"><code>start</code></em>. This latter
address is a hint only, and is usually specified as 0.</p><p>Suitable length and offset parameters are queried with the
<a class="link" href="media.html#vidioc-querybuf" title="ioctl VIDIOC_QUERYBUF"><code class="constant">VIDIOC_QUERYBUF</code></a> ioctl. Buffers must be allocated with the
<a class="link" href="media.html#vidioc-reqbufs" title="ioctl VIDIOC_REQBUFS"><code class="constant">VIDIOC_REQBUFS</code></a> ioctl before they can be queried.</p><p>To unmap buffers the <a class="link" href="media.html#func-munmap" title="V4L2 munmap()"><code class="function">munmap()</code></a> function is used.</p></div><div class="refsect1"><a name="idp85057088"></a><h2>Return Value</h2><p>On success <code class="function">mmap()</code> returns a pointer to
the mapped buffer. On error <code class="constant">MAP_FAILED</code> (-1) is
returned, and the <code class="varname">errno</code> variable is set
appropriately. Possible error codes are:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EBADF</span></span></dt><dd><p><em class="parameter"><code>fd</code></em> is not a valid file
descriptor.</p></dd><dt><span class="term"><span class="errorcode">EACCES</span></span></dt><dd><p><em class="parameter"><code>fd</code></em> is
not open for reading and writing.</p></dd><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The <em class="parameter"><code>start</code></em> or
<em class="parameter"><code>length</code></em> or <em class="parameter"><code>offset</code></em> are not
suitable. (E. g. they are too large, or not aligned on a
<code class="constant">PAGESIZE</code> boundary.)</p><p>The <em class="parameter"><code>flags</code></em> or
<em class="parameter"><code>prot</code></em> value is not supported.</p><p>No buffers have been allocated with the
<a class="link" href="media.html#vidioc-reqbufs" title="ioctl VIDIOC_REQBUFS"><code class="constant">VIDIOC_REQBUFS</code></a> ioctl.</p></dd><dt><span class="term"><span class="errorcode">ENOMEM</span></span></dt><dd><p>Not enough physical or virtual memory was available to
complete the request.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="func-munmap"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>v4l2-munmap &#8212; Unmap device memory</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">
#include &lt;unistd.h&gt;
#include &lt;sys/mman.h&gt;</pre><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">munmap</b>(</code></td><td>void *<var class="pdparam">start</var>, </td></tr><tr><td> </td><td>size_t <var class="pdparam">length</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp85161984"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>start</code></em></span></dt><dd><p>Address of the mapped buffer as returned by the
<a class="link" href="media.html#func-mmap" title="V4L2 mmap()"><code class="function">mmap()</code></a> function.</p></dd><dt><span class="term"><em class="parameter"><code>length</code></em></span></dt><dd><p>Length of the mapped buffer. This must be the same
value as given to <code class="function">mmap()</code> and returned by the
driver in the struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a> <em class="structfield"><code>length</code></em>
field for the single-planar API and in the struct <a class="link" href="media.html#v4l2-plane" title="Table 3.2. struct v4l2_plane">v4l2_plane</a>
<em class="structfield"><code>length</code></em> field for the multi-planar API.</p></dd></dl></div></div><div class="refsect1"><a name="idp85171312"></a><h2>Description</h2><p>Unmaps a previously with the <a class="link" href="media.html#func-mmap" title="V4L2 mmap()"><code class="function">mmap()</code></a> function mapped
buffer and frees it, if possible. </p></div><div class="refsect1"><a name="idp85173696"></a><h2>Return Value</h2><p>On success <code class="function">munmap()</code> returns 0, on
failure -1 and the <code class="varname">errno</code> variable is set
appropriately:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The <em class="parameter"><code>start</code></em> or
<em class="parameter"><code>length</code></em> is incorrect, or no buffers have been
mapped yet.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="func-open"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>v4l2-open &#8212; Open a V4L2 device</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">#include &lt;fcntl.h&gt;</pre><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">open</b>(</code></td><td>const char *<var class="pdparam">device_name</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp85216736"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>device_name</code></em></span></dt><dd><p>Device to be opened.</p></dd><dt><span class="term"><em class="parameter"><code>flags</code></em></span></dt><dd><p>Open flags. Access mode must be
<code class="constant">O_RDWR</code>. This is just a technicality, input devices
still support only reading and output devices only writing.</p><p>When the <code class="constant">O_NONBLOCK</code> flag is
given, the read() function and the <a class="link" href="media.html#vidioc-qbuf" title="ioctl VIDIOC_QBUF, VIDIOC_DQBUF"><code class="constant">VIDIOC_DQBUF</code></a> ioctl will return
the <span class="errorcode">EAGAIN</span> error code when no data is available or no buffer is in the driver
outgoing queue, otherwise these functions block until data becomes
available. All V4L2 drivers exchanging data with applications must
support the <code class="constant">O_NONBLOCK</code> flag.</p><p>Other flags have no effect.</p></dd></dl></div></div><div class="refsect1"><a name="idp85225968"></a><h2>Description</h2><p>To open a V4L2 device applications call
<code class="function">open()</code> with the desired device name. This
function has no side effects; all data format parameters, current
input or output, control values or other properties remain unchanged.
At the first <code class="function">open()</code> call after loading the driver
they will be reset to default values, drivers are never in an
undefined state.</p></div><div class="refsect1"><a name="idp85228928"></a><h2>Return Value</h2><p>On success <code class="function">open</code> returns the new file
descriptor. On error -1 is returned, and the <code class="varname">errno</code>
variable is set appropriately. Possible error codes are:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EACCES</span></span></dt><dd><p>The caller has no permission to access the
device.</p></dd><dt><span class="term"><span class="errorcode">EBUSY</span></span></dt><dd><p>The driver does not support multiple opens and the
device is already in use.</p></dd><dt><span class="term"><span class="errorcode">ENXIO</span></span></dt><dd><p>No device corresponding to this device special file
exists.</p></dd><dt><span class="term"><span class="errorcode">ENOMEM</span></span></dt><dd><p>Not enough kernel memory was available to complete the
request.</p></dd><dt><span class="term"><span class="errorcode">EMFILE</span></span></dt><dd><p>The  process  already  has  the  maximum number of
files open.</p></dd><dt><span class="term"><span class="errorcode">ENFILE</span></span></dt><dd><p>The limit on the total number of files open on the
system has been reached.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="func-poll"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>v4l2-poll &#8212; Wait for some event on a file descriptor</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">#include &lt;sys/poll.h&gt;</pre><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">poll</b>(</code></td><td>struct pollfd *<var class="pdparam">ufds</var>, </td></tr><tr><td> </td><td>unsigned int <var class="pdparam">nfds</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">timeout</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp85291232"></a><h2>Description</h2><p>With the <code class="function">poll()</code> function applications
can suspend execution until the driver has captured data or is ready
to accept data for output.</p><p>When streaming I/O has been negotiated this function waits
until a buffer has been filled by the capture device and can be dequeued
with the <a class="link" href="media.html#vidioc-qbuf" title="ioctl VIDIOC_QBUF, VIDIOC_DQBUF"><code class="constant">VIDIOC_DQBUF</code></a> ioctl. For output devices this function waits
until the device is ready to accept a new buffer to be queued up with
the <a class="link" href="media.html#vidioc-qbuf" title="ioctl VIDIOC_QBUF, VIDIOC_DQBUF"><code class="constant">VIDIOC_QBUF</code></a> ioctl for display. When buffers are already in the outgoing
queue of the driver (capture) or the incoming queue isn't full (display)
the function returns immediately.</p><p>On success <code class="function">poll()</code> returns the number of
file descriptors that have been selected (that is, file descriptors
for which the <em class="structfield"><code>revents</code></em> field of the
respective <span class="structname">pollfd</span> structure is non-zero).
Capture devices set the <code class="constant">POLLIN</code> and
<code class="constant">POLLRDNORM</code> flags in the
<em class="structfield"><code>revents</code></em> field, output devices the
<code class="constant">POLLOUT</code> and <code class="constant">POLLWRNORM</code>
flags. When the function timed out it returns a value of zero, on
failure it returns <span class="returnvalue">-1</span> and the
<code class="varname">errno</code> variable is set appropriately. When the
application did not call <a class="link" href="media.html#vidioc-streamon" title="ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF"><code class="constant">VIDIOC_STREAMON</code></a> the
<code class="function">poll()</code> function succeeds, but sets the
<code class="constant">POLLERR</code> flag in the
<em class="structfield"><code>revents</code></em> field. When the
application has called <a class="link" href="media.html#vidioc-streamon" title="ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF"><code class="constant">VIDIOC_STREAMON</code></a> for a capture device but hasn't
yet called <a class="link" href="media.html#vidioc-qbuf" title="ioctl VIDIOC_QBUF, VIDIOC_DQBUF"><code class="constant">VIDIOC_QBUF</code></a>, the <code class="function">poll()</code> function
succeeds and sets the <code class="constant">POLLERR</code> flag in the
<em class="structfield"><code>revents</code></em> field. For output devices this
same situation will cause <code class="function">poll()</code> to succeed
as well, but it sets the <code class="constant">POLLOUT</code> and
<code class="constant">POLLWRNORM</code> flags in the <em class="structfield"><code>revents</code></em>
field.</p><p>If an event occurred (see <a class="link" href="media.html#vidioc-dqevent" title="ioctl VIDIOC_DQEVENT"><code class="constant">VIDIOC_DQEVENT</code></a>) then
<code class="constant">POLLPRI</code> will be set in the <em class="structfield"><code>revents</code></em>
field and <code class="function">poll()</code> will return.</p><p>When use of the <code class="function">read()</code> function has
been negotiated and the driver does not capture yet, the
<code class="function">poll</code> function starts capturing. When that fails
it returns a <code class="constant">POLLERR</code> as above. Otherwise it waits
until data has been captured and can be read. When the driver captures
continuously (as opposed to, for example, still images) the function
may return immediately.</p><p>When use of the <code class="function">write()</code> function has
been negotiated and the driver does not stream yet, the
<code class="function">poll</code> function starts streaming. When that fails
it returns a <code class="constant">POLLERR</code> as above. Otherwise it waits
until the driver is ready for a non-blocking
<code class="function">write()</code> call.</p><p>If the caller is only interested in events (just
<code class="constant">POLLPRI</code> is set in the <em class="structfield"><code>events</code></em>
field), then <code class="function">poll()</code> will <span class="emphasis"><em>not</em></span>
start streaming if the driver does not stream yet. This makes it
possible to just poll for events and not for buffers.</p><p>All drivers implementing the <code class="function">read()</code> or
<code class="function">write()</code> function or streaming I/O must also
support the <code class="function">poll()</code> function.</p><p>For more details see the
<code class="function">poll()</code> manual page.</p></div><div class="refsect1"><a name="idp85324048"></a><h2>Return Value</h2><p>On success, <code class="function">poll()</code> returns the number
structures which have non-zero <em class="structfield"><code>revents</code></em>
fields, or zero if the call timed out. On error
<span class="returnvalue">-1</span> is returned, and the
<code class="varname">errno</code> variable is set appropriately:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EBADF</span></span></dt><dd><p>One or more of the <em class="parameter"><code>ufds</code></em> members
specify an invalid file descriptor.</p></dd><dt><span class="term"><span class="errorcode">EBUSY</span></span></dt><dd><p>The driver does not support multiple read or write
streams and the device is already in use.</p></dd><dt><span class="term"><span class="errorcode">EFAULT</span></span></dt><dd><p><em class="parameter"><code>ufds</code></em> references an inaccessible
memory area.</p></dd><dt><span class="term"><span class="errorcode">EINTR</span></span></dt><dd><p>The call was interrupted by a signal.</p></dd><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The <em class="parameter"><code>nfds</code></em> argument is greater
than <code class="constant">OPEN_MAX</code>.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="func-read"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>v4l2-read &#8212; Read from a V4L2 device</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">#include &lt;unistd.h&gt;</pre><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">ssize_t <b class="fsfunc">read</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>void *<var class="pdparam">buf</var>, </td></tr><tr><td> </td><td>size_t <var class="pdparam">count</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp85409968"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>buf</code></em></span></dt><dd><p></p></dd><dt><span class="term"><em class="parameter"><code>count</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp85417904"></a><h2>Description</h2><p><code class="function">read()</code> attempts to read up to
<em class="parameter"><code>count</code></em> bytes from file descriptor
<em class="parameter"><code>fd</code></em> into the buffer starting at
<em class="parameter"><code>buf</code></em>. The layout of the data in the buffer is
discussed in the respective device interface section, see ##. If <em class="parameter"><code>count</code></em> is zero,
<code class="function">read()</code> returns zero and has no other results. If
<em class="parameter"><code>count</code></em> is greater than
<code class="constant">SSIZE_MAX</code>, the result is unspecified. Regardless
of the <em class="parameter"><code>count</code></em> value each
<code class="function">read()</code> call will provide at most one frame (two
fields) worth of data.</p><p>By default <code class="function">read()</code> blocks until data
becomes available. When the <code class="constant">O_NONBLOCK</code> flag was
given to the <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a> function it
returns immediately with an <span class="errorcode">EAGAIN</span> error code when no data is available. The
<a class="link" href="media.html#func-select" title="V4L2 select()"><code class="function">select()</code></a> or <a class="link" href="media.html#func-poll" title="V4L2 poll()"><code class="function">poll()</code></a> functions
can always be used to suspend execution until data becomes available. All
drivers supporting the <code class="function">read()</code> function must also
support <code class="function">select()</code> and
<code class="function">poll()</code>.</p><p>Drivers can implement read functionality in different
ways, using a single or multiple buffers and discarding the oldest or
newest frames once the internal buffers are filled.</p><p><code class="function">read()</code> never returns a "snapshot" of a
buffer being filled. Using a single buffer the driver will stop
capturing when the application starts reading the buffer until the
read is finished. Thus only the period of the vertical blanking
interval is available for reading, or the capture rate must fall below
the nominal frame rate of the video standard.</p><p>The behavior of
<code class="function">read()</code> when called during the active picture
period or the vertical blanking separating the top and bottom field
depends on the discarding policy. A driver discarding the oldest
frames keeps capturing into an internal buffer, continuously
overwriting the previously, not read frame, and returns the frame
being received at the time of the <code class="function">read()</code> call as
soon as it is complete.</p><p>A driver discarding the newest frames stops capturing until
the next <code class="function">read()</code> call. The frame being received at
<code class="function">read()</code> time is discarded, returning the following
frame instead. Again this implies a reduction of the capture rate to
one half or less of the nominal frame rate. An example of this model
is the video read mode of the bttv driver, initiating a DMA to user
memory when <code class="function">read()</code> is called and returning when
the DMA finished.</p><p>In the multiple buffer model drivers maintain a ring of
internal buffers, automatically advancing to the next free buffer.
This allows continuous capturing when the application can empty the
buffers fast enough. Again, the behavior when the driver runs out of
free buffers depends on the discarding policy.</p><p>Applications can get and set the number of buffers used
internally by the driver with the <a class="link" href="media.html#vidioc-g-parm" title="ioctl VIDIOC_G_PARM, VIDIOC_S_PARM"><code class="constant">VIDIOC_G_PARM</code></a> and <a class="link" href="media.html#vidioc-g-parm" title="ioctl VIDIOC_G_PARM, VIDIOC_S_PARM"><code class="constant">VIDIOC_S_PARM</code></a>
ioctls. They are optional, however. The discarding policy is not
reported and cannot be changed. For minimum requirements see <a class="xref" href="media.html#devices" title="Chapter 4. Interfaces">Chapter 4, <i>Interfaces</i></a>.</p></div><div class="refsect1"><a name="idp85444672"></a><h2>Return Value</h2><p>On success, the number of bytes read is returned. It is not
an error if this number is smaller than the number of bytes requested,
or the amount of data required for one frame. This may happen for
example because <code class="function">read()</code> was interrupted by a
signal. On error, -1 is returned, and the <code class="varname">errno</code>
variable is set appropriately. In this case the next read will start
at the beginning of a new frame. Possible error codes are:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EAGAIN</span></span></dt><dd><p>Non-blocking I/O has been selected using
O_NONBLOCK and no data was immediately available for reading.</p></dd><dt><span class="term"><span class="errorcode">EBADF</span></span></dt><dd><p><em class="parameter"><code>fd</code></em> is not a valid file
descriptor or is not open for reading, or the process already has the
maximum number of files open.</p></dd><dt><span class="term"><span class="errorcode">EBUSY</span></span></dt><dd><p>The driver does not support multiple read streams and the
device is already in use.</p></dd><dt><span class="term"><span class="errorcode">EFAULT</span></span></dt><dd><p><em class="parameter"><code>buf</code></em> references an inaccessible
memory area.</p></dd><dt><span class="term"><span class="errorcode">EINTR</span></span></dt><dd><p>The call was interrupted by a signal before any
data was read.</p></dd><dt><span class="term"><span class="errorcode">EIO</span></span></dt><dd><p>I/O error. This indicates some hardware problem or a
failure to communicate with a remote device (USB camera etc.).</p></dd><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The <code class="function">read()</code> function is not
supported by this driver, not on this device, or generally not on this
type of device.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="func-select"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>v4l2-select &#8212; Synchronous I/O multiplexing</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;</pre><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">select</b>(</code></td><td>int <var class="pdparam">nfds</var>, </td></tr><tr><td> </td><td>fd_set *<var class="pdparam">readfds</var>, </td></tr><tr><td> </td><td>fd_set *<var class="pdparam">writefds</var>, </td></tr><tr><td> </td><td>fd_set *<var class="pdparam">exceptfds</var>, </td></tr><tr><td> </td><td>struct timeval *<var class="pdparam">timeout</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp85541664"></a><h2>Description</h2><p>With the <code class="function">select()</code> function applications
can suspend execution until the driver has captured data or is ready
to accept data for output.</p><p>When streaming I/O has been negotiated this function waits
until a buffer has been filled or displayed and can be dequeued with
the <a class="link" href="media.html#vidioc-qbuf" title="ioctl VIDIOC_QBUF, VIDIOC_DQBUF"><code class="constant">VIDIOC_DQBUF</code></a> ioctl. When buffers are already in the outgoing
queue of the driver the function returns immediately.</p><p>On success <code class="function">select()</code> returns the total
number of bits set in the <span class="structname">fd_set</span>s. When the
function timed out it returns a value of zero. On failure it returns
<span class="returnvalue">-1</span> and the <code class="varname">errno</code>
variable is set appropriately. When the application did not call
<a class="link" href="media.html#vidioc-qbuf" title="ioctl VIDIOC_QBUF, VIDIOC_DQBUF"><code class="constant">VIDIOC_QBUF</code></a> or <a class="link" href="media.html#vidioc-streamon" title="ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF"><code class="constant">VIDIOC_STREAMON</code></a> yet the
<code class="function">select()</code> function succeeds, setting the bit of
the file descriptor in <em class="parameter"><code>readfds</code></em> or
<em class="parameter"><code>writefds</code></em>, but subsequent <a class="link" href="media.html#vidioc-qbuf" title="ioctl VIDIOC_QBUF, VIDIOC_DQBUF"><code class="constant">VIDIOC_DQBUF</code></a> calls
will fail.<a href="media.html#ftn.idp85552160" class="footnote" name="idp85552160"><sup class="footnote">[20]</sup></a></p><p>When use of the <code class="function">read()</code> function has
been negotiated and the driver does not capture yet, the
<code class="function">select()</code> function starts capturing. When that
fails, <code class="function">select()</code> returns successful and a
subsequent <code class="function">read()</code> call, which also attempts to
start capturing, will return an appropriate error code. When the
driver captures continuously (as opposed to, for example, still
images) and data is already available the
<code class="function">select()</code> function returns immediately.</p><p>When use of the <code class="function">write()</code> function has
been negotiated the <code class="function">select()</code> function just waits
until the driver is ready for a non-blocking
<code class="function">write()</code> call.</p><p>All drivers implementing the <code class="function">read()</code> or
<code class="function">write()</code> function or streaming I/O must also
support the <code class="function">select()</code> function.</p><p>For more details see the <code class="function">select()</code>
manual page.</p></div><div class="refsect1"><a name="idp85566688"></a><h2>Return Value</h2><p>On success, <code class="function">select()</code> returns the number
of descriptors contained in the three returned descriptor sets, which
will be zero if the timeout expired. On error
<span class="returnvalue">-1</span> is returned, and the
<code class="varname">errno</code> variable is set appropriately; the sets and
<em class="parameter"><code>timeout</code></em> are undefined. Possible error codes
are:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EBADF</span></span></dt><dd><p>One or more of the file descriptor sets specified a
file descriptor that is not open.</p></dd><dt><span class="term"><span class="errorcode">EBUSY</span></span></dt><dd><p>The driver does not support multiple read or write
streams and the device is already in use.</p></dd><dt><span class="term"><span class="errorcode">EFAULT</span></span></dt><dd><p>The <em class="parameter"><code>readfds</code></em>,
<em class="parameter"><code>writefds</code></em>, <em class="parameter"><code>exceptfds</code></em> or
<em class="parameter"><code>timeout</code></em> pointer references an inaccessible memory
area.</p></dd><dt><span class="term"><span class="errorcode">EINTR</span></span></dt><dd><p>The call was interrupted by a signal.</p></dd><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The <em class="parameter"><code>nfds</code></em> argument is less than
zero or greater than <code class="constant">FD_SETSIZE</code>.</p></dd></dl></div></div><div class="footnotes"><br><hr style="width:100; text-align:left;margin-left: 0"><div id="ftn.idp85552160" class="footnote"><p><a href="media.html#idp85552160" class="para"><sup class="para">[20] </sup></a>The Linux kernel implements
<code class="function">select()</code> like the <a class="link" href="media.html#func-poll" title="V4L2 poll()"><code class="function">poll()</code></a> function, but
<code class="function">select()</code> cannot return a
<code class="constant">POLLERR</code>.</p></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="func-write"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>v4l2-write &#8212; Write to a V4L2 device</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">#include &lt;unistd.h&gt;</pre><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">ssize_t <b class="fsfunc">write</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>void *<var class="pdparam">buf</var>, </td></tr><tr><td> </td><td>size_t <var class="pdparam">count</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp85650704"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>buf</code></em></span></dt><dd><p></p></dd><dt><span class="term"><em class="parameter"><code>count</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp85658592"></a><h2>Description</h2><p><code class="function">write()</code> writes up to
<em class="parameter"><code>count</code></em> bytes to the device referenced by the
file descriptor <em class="parameter"><code>fd</code></em> from the buffer starting at
<em class="parameter"><code>buf</code></em>. When the hardware outputs are not active
yet, this function enables them. When <em class="parameter"><code>count</code></em> is
zero, <code class="function">write()</code> returns
<span class="returnvalue">0</span> without any other effect.</p><p>When the application does not provide more data in time, the
previous video frame, raw VBI image, sliced VPS or WSS data is
displayed again. Sliced Teletext or Closed Caption data is not
repeated, the driver inserts a blank line instead.</p></div><div class="refsect1"><a name="idp85665088"></a><h2>Return Value</h2><p>On success, the number of bytes written are returned. Zero
indicates nothing was written. On error, <span class="returnvalue">-1</span>
is returned, and the <code class="varname">errno</code> variable is set
appropriately. In this case the next write will start at the beginning
of a new frame. Possible error codes are:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EAGAIN</span></span></dt><dd><p>Non-blocking I/O has been selected using the <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="constant">O_NONBLOCK</code></a> flag and no
buffer space was available to write the data immediately.</p></dd><dt><span class="term"><span class="errorcode">EBADF</span></span></dt><dd><p><em class="parameter"><code>fd</code></em> is not a valid file
descriptor or is not open for writing.</p></dd><dt><span class="term"><span class="errorcode">EBUSY</span></span></dt><dd><p>The driver does not support multiple write streams and the
device is already in use.</p></dd><dt><span class="term"><span class="errorcode">EFAULT</span></span></dt><dd><p><em class="parameter"><code>buf</code></em> references an inaccessible
memory area.</p></dd><dt><span class="term"><span class="errorcode">EINTR</span></span></dt><dd><p>The call was interrupted by a signal before any
data was written.</p></dd><dt><span class="term"><span class="errorcode">EIO</span></span></dt><dd><p>I/O error. This indicates some hardware problem.</p></dd><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The <code class="function">write()</code> function is not
supported by this driver, not on this device, or generally not on this
type of device.</p></dd></dl></div></div></div><div class="footnotes"><br><hr style="width:100; text-align:left;margin-left: 0"><div id="ftn.idp78223936" class="footnote"><p><a href="media.html#idp78223936" class="para"><sup class="para">[18] </sup></a>The supported standards may overlap and we need an
unambiguous set to find the current standard returned by
<code class="constant">VIDIOC_G_STD</code>.</p></div><div id="ftn.idp83034016" class="footnote"><p><a href="media.html#idp83034016" class="para"><sup class="para">[19] </sup></a><code class="constant">V4L2_CTRL_FLAG_DISABLED</code> was
intended for two purposes: Drivers can skip predefined controls not
supported by the hardware (although returning EINVAL would do as
well), or disable predefined and private controls after hardware
detection without the trouble of reordering control arrays and indices
(EINVAL cannot be used to skip private controls because it would
prematurely end the enumeration).</p></div><div id="ftn.idp85552160" class="footnote"><p><a href="media.html#idp85552160" class="para"><sup class="para">[20] </sup></a>The Linux kernel implements
<code class="function">select()</code> like the <a class="link" href="media.html#func-poll" title="V4L2 poll()"><code class="function">poll()</code></a> function, but
<code class="function">select()</code> cannot return a
<code class="constant">POLLERR</code>.</p></div></div></div><div class="appendix"><div class="titlepage"><div><div><h2 class="title"><a name="idp85688448"></a>Appendix B. Common definitions for V4L2 and V4L2 subdev interfaces</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="media.html#v4l2-selections-common">Common selection definitions</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#v4l2-selection-targets">Selection targets</a></span></dt><dt><span class="section"><a href="media.html#v4l2-selection-flags">Selection flags</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="v4l2-selections-common"></a>Common selection definitions</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#v4l2-selection-targets">Selection targets</a></span></dt><dt><span class="section"><a href="media.html#v4l2-selection-flags">Selection flags</a></span></dt></dl></div><p>While the <a class="link" href="media.html#selection-api" title="Experimental API for cropping, composing and scaling">V4L2 selection
  API</a> and <a class="link" href="media.html#v4l2-subdev-selections" title="Selections: cropping, scaling and composition">V4L2 subdev
  selection APIs</a> are very similar, there's one fundamental
  difference between the two. On sub-device API, the selection
  rectangle refers to the media bus format, and is bound to a
  sub-device's pad. On the V4L2 interface the selection rectangles
  refer to the in-memory pixel format.</p><p>This section defines the common definitions of the
  selection interfaces on the two APIs.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="v4l2-selection-targets"></a>Selection targets</h3></div></div></div><p>The precise meaning of the selection targets may be
    dependent on which of the two interfaces they are used.</p><div class="table"><a name="v4l2-selection-targets-table"></a><p class="title"><b>Table B.1. Selection target definitions</b></p><div class="table-contents"><table summary="Selection target definitions" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"><col class="c5"></colgroup><thead><tr><th align="left">Target name</th><th align="left">id</th><th align="left">Definition</th><th align="left">Valid for V4L2</th><th align="left">Valid for V4L2 subdev</th></tr></thead><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_SEL_TGT_CROP</code></td><td valign="top">0x0000</td><td valign="top">Crop rectangle. Defines the cropped area.</td><td valign="top">Yes</td><td valign="top">Yes</td></tr><tr><td valign="top"><code class="constant">V4L2_SEL_TGT_CROP_DEFAULT</code></td><td valign="top">0x0001</td><td valign="top">Suggested cropping rectangle that covers the "whole picture".</td><td valign="top">Yes</td><td valign="top">No</td></tr><tr><td valign="top"><code class="constant">V4L2_SEL_TGT_CROP_BOUNDS</code></td><td valign="top">0x0002</td><td valign="top">Bounds of the crop rectangle. All valid crop
	    rectangles fit inside the crop bounds rectangle.
	    </td><td valign="top">Yes</td><td valign="top">Yes</td></tr><tr><td valign="top"><code class="constant">V4L2_SEL_TGT_NATIVE_SIZE</code></td><td valign="top">0x0003</td><td valign="top">The native size of the device, e.g. a sensor's
	    pixel array. <em class="structfield"><code>left</code></em> and
	    <em class="structfield"><code>top</code></em> fields are zero for this
	    target. Setting the native size will generally only make
	    sense for memory to memory devices where the software can
	    create a canvas of a given size in which for example a
	    video frame can be composed. In that case
	    V4L2_SEL_TGT_NATIVE_SIZE can be used to configure the size
	    of that canvas.
	    </td><td valign="top">Yes</td><td valign="top">Yes</td></tr><tr><td valign="top"><code class="constant">V4L2_SEL_TGT_COMPOSE</code></td><td valign="top">0x0100</td><td valign="top">Compose rectangle. Used to configure scaling
	    and composition.</td><td valign="top">Yes</td><td valign="top">Yes</td></tr><tr><td valign="top"><code class="constant">V4L2_SEL_TGT_COMPOSE_DEFAULT</code></td><td valign="top">0x0101</td><td valign="top">Suggested composition rectangle that covers the "whole picture".</td><td valign="top">Yes</td><td valign="top">No</td></tr><tr><td valign="top"><code class="constant">V4L2_SEL_TGT_COMPOSE_BOUNDS</code></td><td valign="top">0x0102</td><td valign="top">Bounds of the compose rectangle. All valid compose
	    rectangles fit inside the compose bounds rectangle.</td><td valign="top">Yes</td><td valign="top">Yes</td></tr><tr><td valign="top"><code class="constant">V4L2_SEL_TGT_COMPOSE_PADDED</code></td><td valign="top">0x0103</td><td valign="top">The active area and all padding pixels that are inserted or
	    modified by hardware.</td><td valign="top">Yes</td><td valign="top">No</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="v4l2-selection-flags"></a>Selection flags</h3></div></div></div><div class="table"><a name="v4l2-selection-flags-table"></a><p class="title"><b>Table B.2. Selection flag definitions</b></p><div class="table-contents"><table summary="Selection flag definitions" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"><col class="c5"></colgroup><thead><tr><th align="left">Flag name</th><th align="left">id</th><th align="left">Definition</th><th align="left">Valid for V4L2</th><th align="left">Valid for V4L2 subdev</th></tr></thead><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_SEL_FLAG_GE</code></td><td valign="top">(1 &lt;&lt; 0)</td><td valign="top">Suggest the driver it should choose greater or
	    equal rectangle (in size) than was requested. Albeit the
	    driver may choose a lesser size, it will only do so due to
	    hardware limitations. Without this flag (and
	    <code class="constant">V4L2_SEL_FLAG_LE</code>) the
	    behaviour is to choose the closest possible
	    rectangle.</td><td valign="top">Yes</td><td valign="top">Yes</td></tr><tr><td valign="top"><code class="constant">V4L2_SEL_FLAG_LE</code></td><td valign="top">(1 &lt;&lt; 1)</td><td valign="top">Suggest the driver it
	    should choose lesser or equal rectangle (in size) than was
	    requested. Albeit the driver may choose a greater size, it
	    will only do so due to hardware limitations.</td><td valign="top">Yes</td><td valign="top">Yes</td></tr><tr><td valign="top"><code class="constant">V4L2_SEL_FLAG_KEEP_CONFIG</code></td><td valign="top">(1 &lt;&lt; 2)</td><td valign="top">The configuration must not be propagated to any
	    further processing steps. If this flag is not given, the
	    configuration is propagated inside the subdevice to all
	    further processing steps.</td><td valign="top">No</td><td valign="top">Yes</td></tr></tbody></table></div></div><br class="table-break"></div></div></div><div class="appendix"><div class="titlepage"><div><div><h2 class="title"><a name="videodev"></a>Appendix C. Video For Linux Two Header File</h2></div></div></div><pre class="programlisting">
/*
 *  Video for Linux Two header file
 *
 *  Copyright (C) 1999-2012 the contributors
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  Alternatively you can redistribute this file under the terms of the
 *  BSD license as stated below:
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in
 *     the documentation and/or other materials provided with the
 *     distribution.
 *  3. The names of its contributors may not be used to endorse or promote
 *     products derived from this software without specific prior written
 *     permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 *  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *      Header file for v4l or V4L2 drivers and applications
 * with public API.
 * All kernel-specific stuff were moved to media/v4l2-dev.h, so
 * no #if __KERNEL tests are allowed here
 *
 *      See http://linuxtv.org for more info
 *
 *      Author: Bill Dirks &lt;bill@thedirks.org&gt;
 *              Justin Schoeman
 *              Hans Verkuil &lt;hverkuil@xs4all.nl&gt;
 *              et al.
 */
#ifndef _UAPI__LINUX_VIDEODEV2_H
#define _UAPI__LINUX_VIDEODEV2_H

#ifndef __KERNEL__
#include &lt;sys/time.h&gt;
#endif
#include &lt;linux/compiler.h&gt;
#include &lt;linux/ioctl.h&gt;
#include &lt;linux/types.h&gt;
#include &lt;linux/v4l2-common.h&gt;
#include &lt;linux/v4l2-controls.h&gt;

/*
 * Common stuff for both V4L1 and V4L2
 * Moved from videodev.h
 */
#define VIDEO_MAX_FRAME               32
#define VIDEO_MAX_PLANES               8

/*
 *      M I S C E L L A N E O U S
 */

/*  Four-character-code (FOURCC) */
#define v4l2_fourcc(a, b, c, d)\
        ((__u32)(a) | ((__u32)(b) &lt;&lt; 8) | ((__u32)(c) &lt;&lt; 16) | ((__u32)(d) &lt;&lt; 24))
#define v4l2_fourcc_be(a, b, c, d)      (v4l2_fourcc(a, b, c, d) | (1 &lt;&lt; 31))

/*
 *      E N U M S
 */
enum <a class="link" href="media.html#v4l2-field" title="Table 3.9. enum v4l2_field">v4l2_field</a> {
        V4L2_FIELD_ANY           = 0, /* driver can choose from none,
                                         top, bottom, interlaced
                                         depending on whatever it thinks
                                         is approximate ... */
        V4L2_FIELD_NONE          = 1, /* this device has no fields ... */
        V4L2_FIELD_TOP           = 2, /* top field only */
        V4L2_FIELD_BOTTOM        = 3, /* bottom field only */
        V4L2_FIELD_INTERLACED    = 4, /* both fields interlaced */
        V4L2_FIELD_SEQ_TB        = 5, /* both fields sequential into one
                                         buffer, top-bottom order */
        V4L2_FIELD_SEQ_BT        = 6, /* same as above + bottom-top order */
        V4L2_FIELD_ALTERNATE     = 7, /* both fields alternating into
                                         separate buffers */
        V4L2_FIELD_INTERLACED_TB = 8, /* both fields interlaced, top field
                                         first and the top field is
                                         transmitted first */
        V4L2_FIELD_INTERLACED_BT = 9, /* both fields interlaced, top field
                                         first and the bottom field is
                                         transmitted first */
};
#define V4L2_FIELD_HAS_TOP(field)       \
        ((field) == V4L2_FIELD_TOP      ||\
         (field) == V4L2_FIELD_INTERLACED ||\
         (field) == V4L2_FIELD_INTERLACED_TB ||\
         (field) == V4L2_FIELD_INTERLACED_BT ||\
         (field) == V4L2_FIELD_SEQ_TB   ||\
         (field) == V4L2_FIELD_SEQ_BT)
#define V4L2_FIELD_HAS_BOTTOM(field)    \
        ((field) == V4L2_FIELD_BOTTOM   ||\
         (field) == V4L2_FIELD_INTERLACED ||\
         (field) == V4L2_FIELD_INTERLACED_TB ||\
         (field) == V4L2_FIELD_INTERLACED_BT ||\
         (field) == V4L2_FIELD_SEQ_TB   ||\
         (field) == V4L2_FIELD_SEQ_BT)
#define V4L2_FIELD_HAS_BOTH(field)      \
        ((field) == V4L2_FIELD_INTERLACED ||\
         (field) == V4L2_FIELD_INTERLACED_TB ||\
         (field) == V4L2_FIELD_INTERLACED_BT ||\
         (field) == V4L2_FIELD_SEQ_TB ||\
         (field) == V4L2_FIELD_SEQ_BT)
#define V4L2_FIELD_HAS_T_OR_B(field)    \
        ((field) == V4L2_FIELD_BOTTOM ||\
         (field) == V4L2_FIELD_TOP ||\
         (field) == V4L2_FIELD_ALTERNATE)

enum <a class="link" href="media.html#v4l2-buf-type" title="Table 3.3. enum v4l2_buf_type">v4l2_buf_type</a> {
        V4L2_BUF_TYPE_VIDEO_CAPTURE        = 1,
        V4L2_BUF_TYPE_VIDEO_OUTPUT         = 2,
        V4L2_BUF_TYPE_VIDEO_OVERLAY        = 3,
        V4L2_BUF_TYPE_VBI_CAPTURE          = 4,
        V4L2_BUF_TYPE_VBI_OUTPUT           = 5,
        V4L2_BUF_TYPE_SLICED_VBI_CAPTURE   = 6,
        V4L2_BUF_TYPE_SLICED_VBI_OUTPUT    = 7,
#if 1
        /* Experimental */
        V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY = 8,
#endif
        V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE = 9,
        V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE  = 10,
        V4L2_BUF_TYPE_SDR_CAPTURE          = 11,
        /* Deprecated, do not use */
        V4L2_BUF_TYPE_PRIVATE              = 0x80,
};

#define V4L2_TYPE_IS_MULTIPLANAR(type)                  \
        ((type) == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE   \
         || (type) == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)

#define V4L2_TYPE_IS_OUTPUT(type)                               \
        ((type) == V4L2_BUF_TYPE_VIDEO_OUTPUT                   \
         || (type) == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE         \
         || (type) == V4L2_BUF_TYPE_VIDEO_OVERLAY               \
         || (type) == V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY        \
         || (type) == V4L2_BUF_TYPE_VBI_OUTPUT                  \
         || (type) == V4L2_BUF_TYPE_SLICED_VBI_OUTPUT)

enum <a class="link" href="media.html#v4l2-tuner-type" title="Table A.87. enum v4l2_tuner_type">v4l2_tuner_type</a> {
        V4L2_TUNER_RADIO             = 1,
        V4L2_TUNER_ANALOG_TV         = 2,
        V4L2_TUNER_DIGITAL_TV        = 3,
        V4L2_TUNER_ADC               = 4,
        V4L2_TUNER_RF                = 5,
};

enum <a class="link" href="media.html#v4l2-memory" title="Table 3.5. enum v4l2_memory">v4l2_memory</a> {
        V4L2_MEMORY_MMAP             = 1,
        V4L2_MEMORY_USERPTR          = 2,
        V4L2_MEMORY_OVERLAY          = 3,
        V4L2_MEMORY_DMABUF           = 4,
};

/* see also http://vektor.theorem.ca/graphics/ycbcr/ */
enum <a class="link" href="media.html#v4l2-colorspace" title="Table 2.4. V4L2 Colorspaces">v4l2_colorspace</a> {
        /* SMPTE 170M: used for broadcast NTSC/PAL SDTV */
        V4L2_COLORSPACE_SMPTE170M     = 1,

        /* Obsolete pre-1998 SMPTE 240M HDTV standard, superseded by Rec 709 */
        V4L2_COLORSPACE_SMPTE240M     = 2,

        /* Rec.709: used for HDTV */
        V4L2_COLORSPACE_REC709        = 3,

        /*
         * Deprecated, do not use. No driver will ever return this. This was
         * based on a misunderstanding of the bt878 datasheet.
         */
        V4L2_COLORSPACE_BT878         = 4,

        /*
         * NTSC 1953 colorspace. This only makes sense when dealing with
         * really, really old NTSC recordings. Superseded by SMPTE 170M.
         */
        V4L2_COLORSPACE_470_SYSTEM_M  = 5,

        /*
         * EBU Tech 3213 PAL/SECAM colorspace. This only makes sense when
         * dealing with really old PAL/SECAM recordings. Superseded by
         * SMPTE 170M.
         */
        V4L2_COLORSPACE_470_SYSTEM_BG = 6,

        /*
         * Effectively shorthand for V4L2_COLORSPACE_SRGB, V4L2_YCBCR_ENC_601
         * and V4L2_QUANTIZATION_FULL_RANGE. To be used for (Motion-)JPEG.
         */
        V4L2_COLORSPACE_JPEG          = 7,

        /* For RGB colorspaces such as produces by most webcams. */
        V4L2_COLORSPACE_SRGB          = 8,

        /* AdobeRGB colorspace */
        V4L2_COLORSPACE_ADOBERGB      = 9,

        /* BT.2020 colorspace, used for UHDTV. */
        V4L2_COLORSPACE_BT2020        = 10,
};

enum <a class="link" href="media.html#v4l2-ycbcr-encoding" title="Table 2.5. V4L2 Y'CbCr Encodings">v4l2_ycbcr_encoding</a> {
        /*
         * Mapping of V4L2_YCBCR_ENC_DEFAULT to actual encodings for the
         * various colorspaces:
         *
         * V4L2_COLORSPACE_SMPTE170M, V4L2_COLORSPACE_470_SYSTEM_M,
         * V4L2_COLORSPACE_470_SYSTEM_BG, V4L2_COLORSPACE_ADOBERGB and
         * V4L2_COLORSPACE_JPEG: V4L2_YCBCR_ENC_601
         *
         * V4L2_COLORSPACE_REC709: V4L2_YCBCR_ENC_709
         *
         * V4L2_COLORSPACE_SRGB: V4L2_YCBCR_ENC_SYCC
         *
         * V4L2_COLORSPACE_BT2020: V4L2_YCBCR_ENC_BT2020
         *
         * V4L2_COLORSPACE_SMPTE240M: V4L2_YCBCR_ENC_SMPTE240M
         */
        V4L2_YCBCR_ENC_DEFAULT        = 0,

        /* ITU-R 601 -- SDTV */
        V4L2_YCBCR_ENC_601            = 1,

        /* Rec. 709 -- HDTV */
        V4L2_YCBCR_ENC_709            = 2,

        /* ITU-R 601/EN 61966-2-4 Extended Gamut -- SDTV */
        V4L2_YCBCR_ENC_XV601          = 3,

        /* Rec. 709/EN 61966-2-4 Extended Gamut -- HDTV */
        V4L2_YCBCR_ENC_XV709          = 4,

        /* sYCC (Y'CbCr encoding of sRGB) */
        V4L2_YCBCR_ENC_SYCC           = 5,

        /* BT.2020 Non-constant Luminance Y'CbCr */
        V4L2_YCBCR_ENC_BT2020         = 6,

        /* BT.2020 Constant Luminance Y'CbcCrc */
        V4L2_YCBCR_ENC_BT2020_CONST_LUM = 7,

        /* SMPTE 240M -- Obsolete HDTV */
        V4L2_YCBCR_ENC_SMPTE240M      = 8,
};

enum <a class="link" href="media.html#v4l2-quantization" title="Table 2.6. V4L2 Quantization Methods">v4l2_quantization</a> {
        /*
         * The default for R'G'B' quantization is always full range. For
         * Y'CbCr the quantization is always limited range, except for
         * SYCC, XV601, XV709 or JPEG: those are full range.
         */
        V4L2_QUANTIZATION_DEFAULT     = 0,
        V4L2_QUANTIZATION_FULL_RANGE  = 1,
        V4L2_QUANTIZATION_LIM_RANGE   = 2,
};

enum <a class="link" href="media.html#v4l2-priority" title="Table A.82. enum v4l2_priority">v4l2_priority</a> {
        V4L2_PRIORITY_UNSET       = 0,  /* not initialized */
        V4L2_PRIORITY_BACKGROUND  = 1,
        V4L2_PRIORITY_INTERACTIVE = 2,
        V4L2_PRIORITY_RECORD      = 3,
        V4L2_PRIORITY_DEFAULT     = V4L2_PRIORITY_INTERACTIVE,
};

struct <a class="link" href="media.html#v4l2-rect" title="Table 4.3. struct v4l2_rect">v4l2_rect</a> {
        __s32   left;
        __s32   top;
        __u32   width;
        __u32   height;
};

struct <a class="link" href="media.html#v4l2-fract" title="Table A.46. struct v4l2_fract">v4l2_fract</a> {
        __u32   numerator;
        __u32   denominator;
};

/**
  * struct <a class="link" href="media.html#v4l2-capability" title="Table A.92. struct v4l2_capability">v4l2_capability</a> - Describes V4L2 device caps returned by VIDIOC_QUERYCAP
  *
  * @driver:       name of the driver module (e.g. "bttv")
  * @card:         name of the card (e.g. "Hauppauge WinTV")
  * @bus_info:     name of the bus (e.g. "PCI:" + pci_name(pci_dev) )
  * @version:      KERNEL_VERSION
  * @capabilities: capabilities of the physical device as a whole
  * @device_caps:  capabilities accessed via this particular device (node)
  * @reserved:     reserved fields for future extensions
  */
struct <a class="link" href="media.html#v4l2-capability" title="Table A.92. struct v4l2_capability">v4l2_capability</a> {
        __u8    driver[16];
        __u8    card[32];
        __u8    bus_info[32];
        __u32   version;
        __u32   capabilities;
        __u32   device_caps;
        __u32   reserved[3];
};

/* Values for 'capabilities' field */
#define V4L2_CAP_VIDEO_CAPTURE          0x00000001  /* Is a video capture device */
#define V4L2_CAP_VIDEO_OUTPUT           0x00000002  /* Is a video output device */
#define V4L2_CAP_VIDEO_OVERLAY          0x00000004  /* Can do video overlay */
#define V4L2_CAP_VBI_CAPTURE            0x00000010  /* Is a raw VBI capture device */
#define V4L2_CAP_VBI_OUTPUT             0x00000020  /* Is a raw VBI output device */
#define V4L2_CAP_SLICED_VBI_CAPTURE     0x00000040  /* Is a sliced VBI capture device */
#define V4L2_CAP_SLICED_VBI_OUTPUT      0x00000080  /* Is a sliced VBI output device */
#define V4L2_CAP_RDS_CAPTURE            0x00000100  /* RDS data capture */
#define V4L2_CAP_VIDEO_OUTPUT_OVERLAY   0x00000200  /* Can do video output overlay */
#define V4L2_CAP_HW_FREQ_SEEK           0x00000400  /* Can do hardware frequency seek  */
#define V4L2_CAP_RDS_OUTPUT             0x00000800  /* Is an RDS encoder */

/* Is a video capture device that supports multiplanar formats */
#define V4L2_CAP_VIDEO_CAPTURE_MPLANE   0x00001000
/* Is a video output device that supports multiplanar formats */
#define V4L2_CAP_VIDEO_OUTPUT_MPLANE    0x00002000
/* Is a video mem-to-mem device that supports multiplanar formats */
#define V4L2_CAP_VIDEO_M2M_MPLANE       0x00004000
/* Is a video mem-to-mem device */
#define V4L2_CAP_VIDEO_M2M              0x00008000

#define V4L2_CAP_TUNER                  0x00010000  /* has a tuner */
#define V4L2_CAP_AUDIO                  0x00020000  /* has audio support */
#define V4L2_CAP_RADIO                  0x00040000  /* is a radio device */
#define V4L2_CAP_MODULATOR              0x00080000  /* has a modulator */

#define V4L2_CAP_SDR_CAPTURE            0x00100000  /* Is a SDR capture device */
#define V4L2_CAP_EXT_PIX_FORMAT         0x00200000  /* Supports the extended pixel format */

#define V4L2_CAP_READWRITE              0x01000000  /* read/write systemcalls */
#define V4L2_CAP_ASYNCIO                0x02000000  /* async I/O */
#define V4L2_CAP_STREAMING              0x04000000  /* streaming I/O ioctls */

#define V4L2_CAP_DEVICE_CAPS            0x80000000  /* sets device capabilities field */

/*
 *      V I D E O   I M A G E   F O R M A T
 */
struct <a class="link" href="media.html#v4l2-pix-format" title="Table 2.1. struct v4l2_pix_format">v4l2_pix_format</a> {
        __u32                   width;
        __u32                   height;
        __u32                   pixelformat;
        __u32                   field;          /* enum <a class="link" href="media.html#v4l2-field" title="Table 3.9. enum v4l2_field">v4l2_field</a> */
        __u32                   bytesperline;   /* for padding, zero if unused */
        __u32                   sizeimage;
        __u32                   colorspace;     /* enum <a class="link" href="media.html#v4l2-colorspace" title="Table 2.4. V4L2 Colorspaces">v4l2_colorspace</a> */
        __u32                   priv;           /* private data, depends on pixelformat */
        __u32                   flags;          /* format flags (V4L2_PIX_FMT_FLAG_*) */
        __u32                   ycbcr_enc;      /* enum <a class="link" href="media.html#v4l2-ycbcr-encoding" title="Table 2.5. V4L2 Y'CbCr Encodings">v4l2_ycbcr_encoding</a> */
        __u32                   quantization;   /* enum <a class="link" href="media.html#v4l2-quantization" title="Table 2.6. V4L2 Quantization Methods">v4l2_quantization</a> */
};

/*      Pixel format         FOURCC                          depth  Description  */

/* RGB formats */
#define <a class="link" href="media.html#V4L2-PIX-FMT-RGB332">V4L2_PIX_FMT_RGB332</a>  v4l2_fourcc('R', 'G', 'B', '1') /*  8  RGB-3-3-2     */
#define <a class="link" href="media.html#V4L2-PIX-FMT-RGB444">V4L2_PIX_FMT_RGB444</a>  v4l2_fourcc('R', '4', '4', '4') /* 16  xxxxrrrr ggggbbbb */
#define <a class="link" href="media.html#V4L2-PIX-FMT-ARGB444">V4L2_PIX_FMT_ARGB444</a> v4l2_fourcc('A', 'R', '1', '2') /* 16  aaaarrrr ggggbbbb */
#define <a class="link" href="media.html#V4L2-PIX-FMT-XRGB444">V4L2_PIX_FMT_XRGB444</a> v4l2_fourcc('X', 'R', '1', '2') /* 16  xxxxrrrr ggggbbbb */
#define <a class="link" href="media.html#V4L2-PIX-FMT-RGB555">V4L2_PIX_FMT_RGB555</a>  v4l2_fourcc('R', 'G', 'B', 'O') /* 16  RGB-5-5-5     */
#define <a class="link" href="media.html#V4L2-PIX-FMT-ARGB555">V4L2_PIX_FMT_ARGB555</a> v4l2_fourcc('A', 'R', '1', '5') /* 16  ARGB-1-5-5-5  */
#define <a class="link" href="media.html#V4L2-PIX-FMT-XRGB555">V4L2_PIX_FMT_XRGB555</a> v4l2_fourcc('X', 'R', '1', '5') /* 16  XRGB-1-5-5-5  */
#define <a class="link" href="media.html#V4L2-PIX-FMT-RGB565">V4L2_PIX_FMT_RGB565</a>  v4l2_fourcc('R', 'G', 'B', 'P') /* 16  RGB-5-6-5     */
#define <a class="link" href="media.html#V4L2-PIX-FMT-RGB555X">V4L2_PIX_FMT_RGB555X</a> v4l2_fourcc('R', 'G', 'B', 'Q') /* 16  RGB-5-5-5 BE  */
#define <a class="link" href="media.html#V4L2-PIX-FMT-ARGB555X">V4L2_PIX_FMT_ARGB555X</a> v4l2_fourcc_be('A', 'R', '1', '5') /* 16  ARGB-5-5-5 BE */
#define <a class="link" href="media.html#V4L2-PIX-FMT-XRGB555X">V4L2_PIX_FMT_XRGB555X</a> v4l2_fourcc_be('X', 'R', '1', '5') /* 16  XRGB-5-5-5 BE */
#define <a class="link" href="media.html#V4L2-PIX-FMT-RGB565X">V4L2_PIX_FMT_RGB565X</a> v4l2_fourcc('R', 'G', 'B', 'R') /* 16  RGB-5-6-5 BE  */
#define <a class="link" href="media.html#V4L2-PIX-FMT-BGR666">V4L2_PIX_FMT_BGR666</a>  v4l2_fourcc('B', 'G', 'R', 'H') /* 18  BGR-6-6-6     */
#define <a class="link" href="media.html#V4L2-PIX-FMT-BGR24">V4L2_PIX_FMT_BGR24</a>   v4l2_fourcc('B', 'G', 'R', '3') /* 24  BGR-8-8-8     */
#define <a class="link" href="media.html#V4L2-PIX-FMT-RGB24">V4L2_PIX_FMT_RGB24</a>   v4l2_fourcc('R', 'G', 'B', '3') /* 24  RGB-8-8-8     */
#define <a class="link" href="media.html#V4L2-PIX-FMT-BGR32">V4L2_PIX_FMT_BGR32</a>   v4l2_fourcc('B', 'G', 'R', '4') /* 32  BGR-8-8-8-8   */
#define <a class="link" href="media.html#V4L2-PIX-FMT-ABGR32">V4L2_PIX_FMT_ABGR32</a>  v4l2_fourcc('A', 'R', '2', '4') /* 32  BGRA-8-8-8-8  */
#define <a class="link" href="media.html#V4L2-PIX-FMT-XBGR32">V4L2_PIX_FMT_XBGR32</a>  v4l2_fourcc('X', 'R', '2', '4') /* 32  BGRX-8-8-8-8  */
#define <a class="link" href="media.html#V4L2-PIX-FMT-RGB32">V4L2_PIX_FMT_RGB32</a>   v4l2_fourcc('R', 'G', 'B', '4') /* 32  RGB-8-8-8-8   */
#define <a class="link" href="media.html#V4L2-PIX-FMT-ARGB32">V4L2_PIX_FMT_ARGB32</a>  v4l2_fourcc('B', 'A', '2', '4') /* 32  ARGB-8-8-8-8  */
#define <a class="link" href="media.html#V4L2-PIX-FMT-XRGB32">V4L2_PIX_FMT_XRGB32</a>  v4l2_fourcc('B', 'X', '2', '4') /* 32  XRGB-8-8-8-8  */

/* Grey formats */
#define <a class="link" href="media.html#V4L2-PIX-FMT-GREY" title="V4L2_PIX_FMT_GREY ('GREY')">V4L2_PIX_FMT_GREY</a>    v4l2_fourcc('G', 'R', 'E', 'Y') /*  8  Greyscale     */
#define <a class="link" href="media.html#V4L2-PIX-FMT-Y4">V4L2_PIX_FMT_Y4</a>      v4l2_fourcc('Y', '0', '4', ' ') /*  4  Greyscale     */
#define <a class="link" href="media.html#V4L2-PIX-FMT-Y6">V4L2_PIX_FMT_Y6</a>      v4l2_fourcc('Y', '0', '6', ' ') /*  6  Greyscale     */
#define <a class="link" href="media.html#V4L2-PIX-FMT-Y10" title="V4L2_PIX_FMT_Y10 ('Y10 ')">V4L2_PIX_FMT_Y10</a>     v4l2_fourcc('Y', '1', '0', ' ') /* 10  Greyscale     */
#define <a class="link" href="media.html#V4L2-PIX-FMT-Y12" title="V4L2_PIX_FMT_Y12 ('Y12 ')">V4L2_PIX_FMT_Y12</a>     v4l2_fourcc('Y', '1', '2', ' ') /* 12  Greyscale     */
#define <a class="link" href="media.html#V4L2-PIX-FMT-Y16" title="V4L2_PIX_FMT_Y16 ('Y16 ')">V4L2_PIX_FMT_Y16</a>     v4l2_fourcc('Y', '1', '6', ' ') /* 16  Greyscale     */

/* Grey bit-packed formats */
#define <a class="link" href="media.html#V4L2-PIX-FMT-Y10BPACK" title="V4L2_PIX_FMT_Y10BPACK ('Y10B')">V4L2_PIX_FMT_Y10BPACK</a>    v4l2_fourcc('Y', '1', '0', 'B') /* 10  Greyscale bit-packed */

/* Palette formats */
#define <a class="link" href="media.html#V4L2-PIX-FMT-PAL8">V4L2_PIX_FMT_PAL8</a>    v4l2_fourcc('P', 'A', 'L', '8') /*  8  8-bit palette */

/* Chrominance formats */
#define <a class="link" href="media.html#V4L2-PIX-FMT-UV8" title="V4L2_PIX_FMT_UV8 ('UV8')">V4L2_PIX_FMT_UV8</a>     v4l2_fourcc('U', 'V', '8', ' ') /*  8  UV 4:4 */

/* Luminance+Chrominance formats */
#define <a class="link" href="media.html#V4L2-PIX-FMT-YVU410">V4L2_PIX_FMT_YVU410</a>  v4l2_fourcc('Y', 'V', 'U', '9') /*  9  YVU 4:1:0     */
#define <a class="link" href="media.html#V4L2-PIX-FMT-YVU420">V4L2_PIX_FMT_YVU420</a>  v4l2_fourcc('Y', 'V', '1', '2') /* 12  YVU 4:2:0     */
#define <a class="link" href="media.html#V4L2-PIX-FMT-YUYV" title="V4L2_PIX_FMT_YUYV ('YUYV')">V4L2_PIX_FMT_YUYV</a>    v4l2_fourcc('Y', 'U', 'Y', 'V') /* 16  YUV 4:2:2     */
#define <a class="link" href="media.html#V4L2-PIX-FMT-YYUV">V4L2_PIX_FMT_YYUV</a>    v4l2_fourcc('Y', 'Y', 'U', 'V') /* 16  YUV 4:2:2     */
#define <a class="link" href="media.html#V4L2-PIX-FMT-YVYU" title="V4L2_PIX_FMT_YVYU ('YVYU')">V4L2_PIX_FMT_YVYU</a>    v4l2_fourcc('Y', 'V', 'Y', 'U') /* 16 YVU 4:2:2 */
#define <a class="link" href="media.html#V4L2-PIX-FMT-UYVY" title="V4L2_PIX_FMT_UYVY ('UYVY')">V4L2_PIX_FMT_UYVY</a>    v4l2_fourcc('U', 'Y', 'V', 'Y') /* 16  YUV 4:2:2     */
#define <a class="link" href="media.html#V4L2-PIX-FMT-VYUY" title="V4L2_PIX_FMT_VYUY ('VYUY')">V4L2_PIX_FMT_VYUY</a>    v4l2_fourcc('V', 'Y', 'U', 'Y') /* 16  YUV 4:2:2     */
#define <a class="link" href="media.html#V4L2-PIX-FMT-YUV422P" title="V4L2_PIX_FMT_YUV422P ('422P')">V4L2_PIX_FMT_YUV422P</a> v4l2_fourcc('4', '2', '2', 'P') /* 16  YVU422 planar */
#define <a class="link" href="media.html#V4L2-PIX-FMT-YUV411P" title="V4L2_PIX_FMT_YUV411P ('411P')">V4L2_PIX_FMT_YUV411P</a> v4l2_fourcc('4', '1', '1', 'P') /* 16  YVU411 planar */
#define <a class="link" href="media.html#V4L2-PIX-FMT-Y41P" title="V4L2_PIX_FMT_Y41P ('Y41P')">V4L2_PIX_FMT_Y41P</a>    v4l2_fourcc('Y', '4', '1', 'P') /* 12  YUV 4:1:1     */
#define <a class="link" href="media.html#V4L2-PIX-FMT-YUV444">V4L2_PIX_FMT_YUV444</a>  v4l2_fourcc('Y', '4', '4', '4') /* 16  xxxxyyyy uuuuvvvv */
#define <a class="link" href="media.html#V4L2-PIX-FMT-YUV555">V4L2_PIX_FMT_YUV555</a>  v4l2_fourcc('Y', 'U', 'V', 'O') /* 16  YUV-5-5-5     */
#define <a class="link" href="media.html#V4L2-PIX-FMT-YUV565">V4L2_PIX_FMT_YUV565</a>  v4l2_fourcc('Y', 'U', 'V', 'P') /* 16  YUV-5-6-5     */
#define <a class="link" href="media.html#V4L2-PIX-FMT-YUV32">V4L2_PIX_FMT_YUV32</a>   v4l2_fourcc('Y', 'U', 'V', '4') /* 32  YUV-8-8-8-8   */
#define <a class="link" href="media.html#V4L2-PIX-FMT-YUV410">V4L2_PIX_FMT_YUV410</a>  v4l2_fourcc('Y', 'U', 'V', '9') /*  9  YUV 4:1:0     */
#define <a class="link" href="media.html#V4L2-PIX-FMT-YUV420">V4L2_PIX_FMT_YUV420</a>  v4l2_fourcc('Y', 'U', '1', '2') /* 12  YUV 4:2:0     */
#define <a class="link" href="media.html#V4L2-PIX-FMT-HI240">V4L2_PIX_FMT_HI240</a>   v4l2_fourcc('H', 'I', '2', '4') /*  8  8-bit color   */
#define <a class="link" href="media.html#V4L2-PIX-FMT-HM12">V4L2_PIX_FMT_HM12</a>    v4l2_fourcc('H', 'M', '1', '2') /*  8  YUV 4:2:0 16x16 macroblocks */
#define <a class="link" href="media.html#V4L2-PIX-FMT-M420" title="V4L2_PIX_FMT_M420 ('M420')">V4L2_PIX_FMT_M420</a>    v4l2_fourcc('M', '4', '2', '0') /* 12  YUV 4:2:0 2 lines y, 1 line uv interleaved */

/* two planes -- one Y, one Cr + Cb interleaved  */
#define <a class="link" href="media.html#V4L2-PIX-FMT-NV12">V4L2_PIX_FMT_NV12</a>    v4l2_fourcc('N', 'V', '1', '2') /* 12  Y/CbCr 4:2:0  */
#define <a class="link" href="media.html#V4L2-PIX-FMT-NV21">V4L2_PIX_FMT_NV21</a>    v4l2_fourcc('N', 'V', '2', '1') /* 12  Y/CrCb 4:2:0  */
#define <a class="link" href="media.html#V4L2-PIX-FMT-NV16">V4L2_PIX_FMT_NV16</a>    v4l2_fourcc('N', 'V', '1', '6') /* 16  Y/CbCr 4:2:2  */
#define <a class="link" href="media.html#V4L2-PIX-FMT-NV61">V4L2_PIX_FMT_NV61</a>    v4l2_fourcc('N', 'V', '6', '1') /* 16  Y/CrCb 4:2:2  */
#define <a class="link" href="media.html#V4L2-PIX-FMT-NV24">V4L2_PIX_FMT_NV24</a>    v4l2_fourcc('N', 'V', '2', '4') /* 24  Y/CbCr 4:4:4  */
#define <a class="link" href="media.html#V4L2-PIX-FMT-NV42">V4L2_PIX_FMT_NV42</a>    v4l2_fourcc('N', 'V', '4', '2') /* 24  Y/CrCb 4:4:4  */

/* two non contiguous planes - one Y, one Cr + Cb interleaved  */
#define <a class="link" href="media.html#V4L2-PIX-FMT-NV12M">V4L2_PIX_FMT_NV12M</a>   v4l2_fourcc('N', 'M', '1', '2') /* 12  Y/CbCr 4:2:0  */
#define <a class="link" href="media.html#V4L2-PIX-FMT-NV21M">V4L2_PIX_FMT_NV21M</a>   v4l2_fourcc('N', 'M', '2', '1') /* 21  Y/CrCb 4:2:0  */
#define <a class="link" href="media.html#V4L2-PIX-FMT-NV16M">V4L2_PIX_FMT_NV16M</a>   v4l2_fourcc('N', 'M', '1', '6') /* 16  Y/CbCr 4:2:2  */
#define <a class="link" href="media.html#V4L2-PIX-FMT-NV61M">V4L2_PIX_FMT_NV61M</a>   v4l2_fourcc('N', 'M', '6', '1') /* 16  Y/CrCb 4:2:2  */
#define <a class="link" href="media.html#V4L2-PIX-FMT-NV12MT">V4L2_PIX_FMT_NV12MT</a>  v4l2_fourcc('T', 'M', '1', '2') /* 12  Y/CbCr 4:2:0 64x32 macroblocks */
#define <a class="link" href="media.html#V4L2-PIX-FMT-NV12MT-16X16">V4L2_PIX_FMT_NV12MT_16X16</a> v4l2_fourcc('V', 'M', '1', '2') /* 12  Y/CbCr 4:2:0 16x16 macroblocks */

/* three non contiguous planes - Y, Cb, Cr */
#define <a class="link" href="media.html#V4L2-PIX-FMT-YUV420M" title="V4L2_PIX_FMT_YUV420M ('YM12')">V4L2_PIX_FMT_YUV420M</a> v4l2_fourcc('Y', 'M', '1', '2') /* 12  YUV420 planar */
#define <a class="link" href="media.html#V4L2-PIX-FMT-YVU420M" title="V4L2_PIX_FMT_YVU420M ('YM21')">V4L2_PIX_FMT_YVU420M</a> v4l2_fourcc('Y', 'M', '2', '1') /* 12  YVU420 planar */

/* Bayer formats - see http://www.siliconimaging.com/RGB%20Bayer.htm */
#define <a class="link" href="media.html#V4L2-PIX-FMT-SBGGR8" title="V4L2_PIX_FMT_SBGGR8 ('BA81')">V4L2_PIX_FMT_SBGGR8</a>  v4l2_fourcc('B', 'A', '8', '1') /*  8  BGBG.. GRGR.. */
#define <a class="link" href="media.html#V4L2-PIX-FMT-SGBRG8" title="V4L2_PIX_FMT_SGBRG8 ('GBRG')">V4L2_PIX_FMT_SGBRG8</a>  v4l2_fourcc('G', 'B', 'R', 'G') /*  8  GBGB.. RGRG.. */
#define <a class="link" href="media.html#V4L2-PIX-FMT-SGRBG8" title="V4L2_PIX_FMT_SGRBG8 ('GRBG')">V4L2_PIX_FMT_SGRBG8</a>  v4l2_fourcc('G', 'R', 'B', 'G') /*  8  GRGR.. BGBG.. */
#define <a class="link" href="media.html#V4L2-PIX-FMT-SRGGB8" title="V4L2_PIX_FMT_SRGGB8 ('RGGB')">V4L2_PIX_FMT_SRGGB8</a>  v4l2_fourcc('R', 'G', 'G', 'B') /*  8  RGRG.. GBGB.. */
#define <a class="link" href="media.html#V4L2-PIX-FMT-SBGGR10">V4L2_PIX_FMT_SBGGR10</a> v4l2_fourcc('B', 'G', '1', '0') /* 10  BGBG.. GRGR.. */
#define <a class="link" href="media.html#V4L2-PIX-FMT-SGBRG10">V4L2_PIX_FMT_SGBRG10</a> v4l2_fourcc('G', 'B', '1', '0') /* 10  GBGB.. RGRG.. */
#define <a class="link" href="media.html#V4L2-PIX-FMT-SGRBG10">V4L2_PIX_FMT_SGRBG10</a> v4l2_fourcc('B', 'A', '1', '0') /* 10  GRGR.. BGBG.. */
#define <a class="link" href="media.html#V4L2-PIX-FMT-SRGGB10">V4L2_PIX_FMT_SRGGB10</a> v4l2_fourcc('R', 'G', '1', '0') /* 10  RGRG.. GBGB.. */
#define <a class="link" href="media.html#V4L2-PIX-FMT-SBGGR12">V4L2_PIX_FMT_SBGGR12</a> v4l2_fourcc('B', 'G', '1', '2') /* 12  BGBG.. GRGR.. */
#define <a class="link" href="media.html#V4L2-PIX-FMT-SGBRG12">V4L2_PIX_FMT_SGBRG12</a> v4l2_fourcc('G', 'B', '1', '2') /* 12  GBGB.. RGRG.. */
#define <a class="link" href="media.html#V4L2-PIX-FMT-SGRBG12">V4L2_PIX_FMT_SGRBG12</a> v4l2_fourcc('B', 'A', '1', '2') /* 12  GRGR.. BGBG.. */
#define <a class="link" href="media.html#V4L2-PIX-FMT-SRGGB12">V4L2_PIX_FMT_SRGGB12</a> v4l2_fourcc('R', 'G', '1', '2') /* 12  RGRG.. GBGB.. */
        /* 10bit raw bayer a-law compressed to 8 bits */
#define <a class="link" href="media.html#V4L2-PIX-FMT-SBGGR10ALAW8">V4L2_PIX_FMT_SBGGR10ALAW8</a> v4l2_fourcc('a', 'B', 'A', '8')
#define <a class="link" href="media.html#V4L2-PIX-FMT-SGBRG10ALAW8">V4L2_PIX_FMT_SGBRG10ALAW8</a> v4l2_fourcc('a', 'G', 'A', '8')
#define <a class="link" href="media.html#V4L2-PIX-FMT-SGRBG10ALAW8">V4L2_PIX_FMT_SGRBG10ALAW8</a> v4l2_fourcc('a', 'g', 'A', '8')
#define <a class="link" href="media.html#V4L2-PIX-FMT-SRGGB10ALAW8">V4L2_PIX_FMT_SRGGB10ALAW8</a> v4l2_fourcc('a', 'R', 'A', '8')
        /* 10bit raw bayer DPCM compressed to 8 bits */
#define <a class="link" href="media.html#V4L2-PIX-FMT-SBGGR10DPCM8">V4L2_PIX_FMT_SBGGR10DPCM8</a> v4l2_fourcc('b', 'B', 'A', '8')
#define <a class="link" href="media.html#V4L2-PIX-FMT-SGBRG10DPCM8">V4L2_PIX_FMT_SGBRG10DPCM8</a> v4l2_fourcc('b', 'G', 'A', '8')
#define <a class="link" href="media.html#V4L2-PIX-FMT-SGRBG10DPCM8">V4L2_PIX_FMT_SGRBG10DPCM8</a> v4l2_fourcc('B', 'D', '1', '0')
#define <a class="link" href="media.html#V4L2-PIX-FMT-SRGGB10DPCM8">V4L2_PIX_FMT_SRGGB10DPCM8</a> v4l2_fourcc('b', 'R', 'A', '8')
        /*
         * 10bit raw bayer, expanded to 16 bits
         * xxxxrrrrrrrrrrxxxxgggggggggg xxxxggggggggggxxxxbbbbbbbbbb...
         */
#define <a class="link" href="media.html#V4L2-PIX-FMT-SBGGR16" title="V4L2_PIX_FMT_SBGGR16 ('BYR2')">V4L2_PIX_FMT_SBGGR16</a> v4l2_fourcc('B', 'Y', 'R', '2') /* 16  BGBG.. GRGR.. */

/* compressed formats */
#define <a class="link" href="media.html#V4L2-PIX-FMT-MJPEG">V4L2_PIX_FMT_MJPEG</a>    v4l2_fourcc('M', 'J', 'P', 'G') /* Motion-JPEG   */
#define <a class="link" href="media.html#V4L2-PIX-FMT-JPEG">V4L2_PIX_FMT_JPEG</a>     v4l2_fourcc('J', 'P', 'E', 'G') /* JFIF JPEG     */
#define <a class="link" href="media.html#V4L2-PIX-FMT-DV">V4L2_PIX_FMT_DV</a>       v4l2_fourcc('d', 'v', 's', 'd') /* 1394          */
#define <a class="link" href="media.html#V4L2-PIX-FMT-MPEG">V4L2_PIX_FMT_MPEG</a>     v4l2_fourcc('M', 'P', 'E', 'G') /* MPEG-1/2/4 Multiplexed */
#define <a class="link" href="media.html#V4L2-PIX-FMT-H264">V4L2_PIX_FMT_H264</a>     v4l2_fourcc('H', '2', '6', '4') /* H264 with start codes */
#define <a class="link" href="media.html#V4L2-PIX-FMT-H264-NO-SC">V4L2_PIX_FMT_H264_NO_SC</a> v4l2_fourcc('A', 'V', 'C', '1') /* H264 without start codes */
#define <a class="link" href="media.html#V4L2-PIX-FMT-H264-MVC">V4L2_PIX_FMT_H264_MVC</a> v4l2_fourcc('M', '2', '6', '4') /* H264 MVC */
#define <a class="link" href="media.html#V4L2-PIX-FMT-H263">V4L2_PIX_FMT_H263</a>     v4l2_fourcc('H', '2', '6', '3') /* H263          */
#define <a class="link" href="media.html#V4L2-PIX-FMT-MPEG1">V4L2_PIX_FMT_MPEG1</a>    v4l2_fourcc('M', 'P', 'G', '1') /* MPEG-1 ES     */
#define <a class="link" href="media.html#V4L2-PIX-FMT-MPEG2">V4L2_PIX_FMT_MPEG2</a>    v4l2_fourcc('M', 'P', 'G', '2') /* MPEG-2 ES     */
#define <a class="link" href="media.html#V4L2-PIX-FMT-MPEG4">V4L2_PIX_FMT_MPEG4</a>    v4l2_fourcc('M', 'P', 'G', '4') /* MPEG-4 part 2 ES */
#define <a class="link" href="media.html#V4L2-PIX-FMT-XVID">V4L2_PIX_FMT_XVID</a>     v4l2_fourcc('X', 'V', 'I', 'D') /* Xvid           */
#define <a class="link" href="media.html#V4L2-PIX-FMT-VC1-ANNEX-G">V4L2_PIX_FMT_VC1_ANNEX_G</a> v4l2_fourcc('V', 'C', '1', 'G') /* SMPTE 421M Annex G compliant stream */
#define <a class="link" href="media.html#V4L2-PIX-FMT-VC1-ANNEX-L">V4L2_PIX_FMT_VC1_ANNEX_L</a> v4l2_fourcc('V', 'C', '1', 'L') /* SMPTE 421M Annex L compliant stream */
#define <a class="link" href="media.html#V4L2-PIX-FMT-VP8">V4L2_PIX_FMT_VP8</a>      v4l2_fourcc('V', 'P', '8', '0') /* VP8 */

/*  Vendor-specific formats   */
#define <a class="link" href="media.html#V4L2-PIX-FMT-CPIA1">V4L2_PIX_FMT_CPIA1</a>    v4l2_fourcc('C', 'P', 'I', 'A') /* cpia1 YUV */
#define <a class="link" href="media.html#V4L2-PIX-FMT-WNVA">V4L2_PIX_FMT_WNVA</a>     v4l2_fourcc('W', 'N', 'V', 'A') /* Winnov hw compress */
#define <a class="link" href="media.html#V4L2-PIX-FMT-SN9C10X">V4L2_PIX_FMT_SN9C10X</a>  v4l2_fourcc('S', '9', '1', '0') /* SN9C10x compression */
#define <a class="link" href="media.html#V4L2-PIX-FMT-SN9C20X-I420">V4L2_PIX_FMT_SN9C20X_I420</a> v4l2_fourcc('S', '9', '2', '0') /* SN9C20x YUV 4:2:0 */
#define <a class="link" href="media.html#V4L2-PIX-FMT-PWC1">V4L2_PIX_FMT_PWC1</a>     v4l2_fourcc('P', 'W', 'C', '1') /* pwc older webcam */
#define <a class="link" href="media.html#V4L2-PIX-FMT-PWC2">V4L2_PIX_FMT_PWC2</a>     v4l2_fourcc('P', 'W', 'C', '2') /* pwc newer webcam */
#define <a class="link" href="media.html#V4L2-PIX-FMT-ET61X251">V4L2_PIX_FMT_ET61X251</a> v4l2_fourcc('E', '6', '2', '5') /* ET61X251 compression */
#define <a class="link" href="media.html#V4L2-PIX-FMT-SPCA501">V4L2_PIX_FMT_SPCA501</a>  v4l2_fourcc('S', '5', '0', '1') /* YUYV per line */
#define <a class="link" href="media.html#V4L2-PIX-FMT-SPCA505">V4L2_PIX_FMT_SPCA505</a>  v4l2_fourcc('S', '5', '0', '5') /* YYUV per line */
#define <a class="link" href="media.html#V4L2-PIX-FMT-SPCA508">V4L2_PIX_FMT_SPCA508</a>  v4l2_fourcc('S', '5', '0', '8') /* YUVY per line */
#define <a class="link" href="media.html#V4L2-PIX-FMT-SPCA561">V4L2_PIX_FMT_SPCA561</a>  v4l2_fourcc('S', '5', '6', '1') /* compressed GBRG bayer */
#define <a class="link" href="media.html#V4L2-PIX-FMT-PAC207">V4L2_PIX_FMT_PAC207</a>   v4l2_fourcc('P', '2', '0', '7') /* compressed BGGR bayer */
#define <a class="link" href="media.html#V4L2-PIX-FMT-MR97310A">V4L2_PIX_FMT_MR97310A</a> v4l2_fourcc('M', '3', '1', '0') /* compressed BGGR bayer */
#define <a class="link" href="media.html#V4L2-PIX-FMT-JL2005BCD">V4L2_PIX_FMT_JL2005BCD</a> v4l2_fourcc('J', 'L', '2', '0') /* compressed RGGB bayer */
#define <a class="link" href="media.html#V4L2-PIX-FMT-SN9C2028">V4L2_PIX_FMT_SN9C2028</a> v4l2_fourcc('S', 'O', 'N', 'X') /* compressed GBRG bayer */
#define <a class="link" href="media.html#V4L2-PIX-FMT-SQ905C">V4L2_PIX_FMT_SQ905C</a>   v4l2_fourcc('9', '0', '5', 'C') /* compressed RGGB bayer */
#define <a class="link" href="media.html#V4L2-PIX-FMT-PJPG">V4L2_PIX_FMT_PJPG</a>     v4l2_fourcc('P', 'J', 'P', 'G') /* Pixart 73xx JPEG */
#define <a class="link" href="media.html#V4L2-PIX-FMT-OV511">V4L2_PIX_FMT_OV511</a>    v4l2_fourcc('O', '5', '1', '1') /* ov511 JPEG */
#define <a class="link" href="media.html#V4L2-PIX-FMT-OV518">V4L2_PIX_FMT_OV518</a>    v4l2_fourcc('O', '5', '1', '8') /* ov518 JPEG */
#define <a class="link" href="media.html#V4L2-PIX-FMT-STV0680">V4L2_PIX_FMT_STV0680</a>  v4l2_fourcc('S', '6', '8', '0') /* stv0680 bayer */
#define <a class="link" href="media.html#V4L2-PIX-FMT-TM6000">V4L2_PIX_FMT_TM6000</a>   v4l2_fourcc('T', 'M', '6', '0') /* tm5600/tm60x0 */
#define <a class="link" href="media.html#V4L2-PIX-FMT-CIT-YYVYUY">V4L2_PIX_FMT_CIT_YYVYUY</a> v4l2_fourcc('C', 'I', 'T', 'V') /* one line of Y then 1 line of VYUY */
#define <a class="link" href="media.html#V4L2-PIX-FMT-KONICA420">V4L2_PIX_FMT_KONICA420</a>  v4l2_fourcc('K', 'O', 'N', 'I') /* YUV420 planar in blocks of 256 pixels */
#define <a class="link" href="media.html#V4L2-PIX-FMT-JPGL">V4L2_PIX_FMT_JPGL</a>       v4l2_fourcc('J', 'P', 'G', 'L') /* JPEG-Lite */
#define <a class="link" href="media.html#V4L2-PIX-FMT-SE401">V4L2_PIX_FMT_SE401</a>      v4l2_fourcc('S', '4', '0', '1') /* se401 janggu compressed rgb */
#define <a class="link" href="media.html#V4L2-PIX-FMT-S5C-UYVY-JPG">V4L2_PIX_FMT_S5C_UYVY_JPG</a> v4l2_fourcc('S', '5', 'C', 'I') /* S5C73M3 interleaved UYVY/JPEG */

/* SDR formats - used only for Software Defined Radio devices */
#define V4L2_SDR_FMT_CU8          v4l2_fourcc('C', 'U', '0', '8') /* IQ u8 */
#define V4L2_SDR_FMT_CU16LE       v4l2_fourcc('C', 'U', '1', '6') /* IQ u16le */
#define V4L2_SDR_FMT_CS8          v4l2_fourcc('C', 'S', '0', '8') /* complex s8 */
#define V4L2_SDR_FMT_CS14LE       v4l2_fourcc('C', 'S', '1', '4') /* complex s14le */
#define V4L2_SDR_FMT_RU12LE       v4l2_fourcc('R', 'U', '1', '2') /* real u12le */

/* priv field value to indicates that subsequent fields are valid. */
#define V4L2_PIX_FMT_PRIV_MAGIC         0xfeedcafe

/* Flags */
#define V4L2_PIX_FMT_FLAG_PREMUL_ALPHA  0x00000001

/*
 *      F O R M A T   E N U M E R A T I O N
 */
struct <a class="link" href="media.html#v4l2-fmtdesc" title="Table A.27. struct v4l2_fmtdesc">v4l2_fmtdesc</a> {
        __u32               index;             /* Format number      */
        __u32               type;              /* enum <a class="link" href="media.html#v4l2-buf-type" title="Table 3.3. enum v4l2_buf_type">v4l2_buf_type</a> */
        __u32               flags;
        __u8                description[32];   /* Description string */
        __u32               pixelformat;       /* Format fourcc      */
        __u32               reserved[4];
};

#define V4L2_FMT_FLAG_COMPRESSED 0x0001
#define V4L2_FMT_FLAG_EMULATED   0x0002

#if 1
        /* Experimental Frame Size and frame rate enumeration */
/*
 *      F R A M E   S I Z E   E N U M E R A T I O N
 */
enum <a class="link" href="media.html#v4l2-frmsizetypes" title="Table A.32. enum v4l2_frmsizetypes">v4l2_frmsizetypes</a> {
        V4L2_FRMSIZE_TYPE_DISCRETE      = 1,
        V4L2_FRMSIZE_TYPE_CONTINUOUS    = 2,
        V4L2_FRMSIZE_TYPE_STEPWISE      = 3,
};

struct <a class="link" href="media.html#v4l2-frmsize-discrete" title="Table A.29. struct v4l2_frmsize_discrete">v4l2_frmsize_discrete</a> {
        __u32                   width;          /* Frame width [pixel] */
        __u32                   height;         /* Frame height [pixel] */
};

struct <a class="link" href="media.html#v4l2-frmsize-stepwise" title="Table A.30. struct v4l2_frmsize_stepwise">v4l2_frmsize_stepwise</a> {
        __u32                   min_width;      /* Minimum frame width [pixel] */
        __u32                   max_width;      /* Maximum frame width [pixel] */
        __u32                   step_width;     /* Frame width step size [pixel] */
        __u32                   min_height;     /* Minimum frame height [pixel] */
        __u32                   max_height;     /* Maximum frame height [pixel] */
        __u32                   step_height;    /* Frame height step size [pixel] */
};

struct <a class="link" href="media.html#v4l2-frmsizeenum" title="Table A.31. struct v4l2_frmsizeenum">v4l2_frmsizeenum</a> {
        __u32                   index;          /* Frame size number */
        __u32                   pixel_format;   /* Pixel format */
        __u32                   type;           /* Frame size type the device supports. */

        union {                                 /* Frame size */
                struct <a class="link" href="media.html#v4l2-frmsize-discrete" title="Table A.29. struct v4l2_frmsize_discrete">v4l2_frmsize_discrete</a>    discrete;
                struct <a class="link" href="media.html#v4l2-frmsize-stepwise" title="Table A.30. struct v4l2_frmsize_stepwise">v4l2_frmsize_stepwise</a>    stepwise;
        };

        __u32   reserved[2];                    /* Reserved space for future use */
};

/*
 *      F R A M E   R A T E   E N U M E R A T I O N
 */
enum <a class="link" href="media.html#v4l2-frmivaltypes" title="Table A.35. enum v4l2_frmivaltypes">v4l2_frmivaltypes</a> {
        V4L2_FRMIVAL_TYPE_DISCRETE      = 1,
        V4L2_FRMIVAL_TYPE_CONTINUOUS    = 2,
        V4L2_FRMIVAL_TYPE_STEPWISE      = 3,
};

struct <a class="link" href="media.html#v4l2-frmival-stepwise" title="Table A.33. struct v4l2_frmival_stepwise">v4l2_frmival_stepwise</a> {
        struct <a class="link" href="media.html#v4l2-fract" title="Table A.46. struct v4l2_fract">v4l2_fract</a>       min;            /* Minimum frame interval [s] */
        struct <a class="link" href="media.html#v4l2-fract" title="Table A.46. struct v4l2_fract">v4l2_fract</a>       max;            /* Maximum frame interval [s] */
        struct <a class="link" href="media.html#v4l2-fract" title="Table A.46. struct v4l2_fract">v4l2_fract</a>       step;           /* Frame interval step size [s] */
};

struct <a class="link" href="media.html#v4l2-frmivalenum" title="Table A.34. struct v4l2_frmivalenum">v4l2_frmivalenum</a> {
        __u32                   index;          /* Frame format index */
        __u32                   pixel_format;   /* Pixel format */
        __u32                   width;          /* Frame width */
        __u32                   height;         /* Frame height */
        __u32                   type;           /* Frame interval type the device supports. */

        union {                                 /* Frame interval */
                struct <a class="link" href="media.html#v4l2-fract" title="Table A.46. struct v4l2_fract">v4l2_fract</a>               discrete;
                struct <a class="link" href="media.html#v4l2-frmival-stepwise" title="Table A.33. struct v4l2_frmival_stepwise">v4l2_frmival_stepwise</a>    stepwise;
        };

        __u32   reserved[2];                    /* Reserved space for future use */
};
#endif

/*
 *      T I M E C O D E
 */
struct <a class="link" href="media.html#v4l2-timecode" title="Table 3.6. struct v4l2_timecode">v4l2_timecode</a> {
        __u32   type;
        __u32   flags;
        __u8    frames;
        __u8    seconds;
        __u8    minutes;
        __u8    hours;
        __u8    userbits[4];
};

/*  Type  */
#define V4L2_TC_TYPE_24FPS              1
#define V4L2_TC_TYPE_25FPS              2
#define V4L2_TC_TYPE_30FPS              3
#define V4L2_TC_TYPE_50FPS              4
#define V4L2_TC_TYPE_60FPS              5

/*  Flags  */
#define V4L2_TC_FLAG_DROPFRAME          0x0001 /* "drop-frame" mode */
#define V4L2_TC_FLAG_COLORFRAME         0x0002
#define V4L2_TC_USERBITS_field          0x000C
#define V4L2_TC_USERBITS_USERDEFINED    0x0000
#define V4L2_TC_USERBITS_8BITCHARS      0x0008
/* The above is based on SMPTE timecodes */

struct <a class="link" href="media.html#v4l2-jpegcompression" title="Table A.73. struct v4l2_jpegcompression">v4l2_jpegcompression</a> {
        int quality;

        int  APPn;              /* Number of APP segment to be written,
                                 * must be 0..15 */
        int  APP_len;           /* Length of data in JPEG APPn segment */
        char APP_data[60];      /* Data in the JPEG APPn segment. */

        int  COM_len;           /* Length of data in JPEG COM segment */
        char COM_data[60];      /* Data in JPEG COM segment */

        __u32 jpeg_markers;     /* Which markers should go into the JPEG
                                 * output. Unless you exactly know what
                                 * you do, leave them untouched.
                                 * Including less markers will make the
                                 * resulting code smaller, but there will
                                 * be fewer applications which can read it.
                                 * The presence of the APP and COM marker
                                 * is influenced by APP_len and COM_len
                                 * ONLY, not by this property! */

#define V4L2_JPEG_MARKER_DHT (1&lt;&lt;3)    /* Define Huffman Tables */
#define V4L2_JPEG_MARKER_DQT (1&lt;&lt;4)    /* Define Quantization Tables */
#define V4L2_JPEG_MARKER_DRI (1&lt;&lt;5)    /* Define Restart Interval */
#define V4L2_JPEG_MARKER_COM (1&lt;&lt;6)    /* Comment segment */
#define V4L2_JPEG_MARKER_APP (1&lt;&lt;7)    /* App segment, driver will
                                        * always use APP0 */
};

/*
 *      M E M O R Y - M A P P I N G   B U F F E R S
 */
struct <a class="link" href="media.html#v4l2-requestbuffers" title="Table A.99. struct v4l2_requestbuffers">v4l2_requestbuffers</a> {
        __u32                   count;
        __u32                   type;           /* enum <a class="link" href="media.html#v4l2-buf-type" title="Table 3.3. enum v4l2_buf_type">v4l2_buf_type</a> */
        __u32                   memory;         /* enum <a class="link" href="media.html#v4l2-memory" title="Table 3.5. enum v4l2_memory">v4l2_memory</a> */
        __u32                   reserved[2];
};

/**
 * struct <a class="link" href="media.html#v4l2-plane" title="Table 3.2. struct v4l2_plane">v4l2_plane</a> - plane info for multi-planar buffers
 * @bytesused:          number of bytes occupied by data in the plane (payload)
 * @length:             size of this plane (NOT the payload) in bytes
 * @mem_offset:         when memory in the associated struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a> is
 *                      V4L2_MEMORY_MMAP, equals the offset from the start of
 *                      the device memory for this plane (or is a "cookie" that
 *                      should be passed to mmap() called on the video node)
 * @userptr:            when memory is V4L2_MEMORY_USERPTR, a userspace pointer
 *                      pointing to this plane
 * @fd:                 when memory is V4L2_MEMORY_DMABUF, a userspace file
 *                      descriptor associated with this plane
 * @data_offset:        offset in the plane to the start of data; usually 0,
 *                      unless there is a header in front of the data
 *
 * Multi-planar buffers consist of one or more planes, e.g. an YCbCr buffer
 * with two planes can have one plane for Y, and another for interleaved CbCr
 * components. Each plane can reside in a separate memory buffer, or even in
 * a completely separate memory node (e.g. in embedded devices).
 */
struct <a class="link" href="media.html#v4l2-plane" title="Table 3.2. struct v4l2_plane">v4l2_plane</a> {
        __u32                   bytesused;
        __u32                   length;
        union {
                __u32           mem_offset;
                unsigned long   userptr;
                __s32           fd;
        } m;
        __u32                   data_offset;
        __u32                   reserved[11];
};

/**
 * struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a> - video buffer info
 * @index:      id number of the buffer
 * @type:       enum <a class="link" href="media.html#v4l2-buf-type" title="Table 3.3. enum v4l2_buf_type">v4l2_buf_type</a>; buffer type (type == *_MPLANE for
 *              multiplanar buffers);
 * @bytesused:  number of bytes occupied by data in the buffer (payload);
 *              unused (set to 0) for multiplanar buffers
 * @flags:      buffer informational flags
 * @field:      enum <a class="link" href="media.html#v4l2-field" title="Table 3.9. enum v4l2_field">v4l2_field</a>; field order of the image in the buffer
 * @timestamp:  frame timestamp
 * @timecode:   frame timecode
 * @sequence:   sequence count of this frame
 * @memory:     enum <a class="link" href="media.html#v4l2-memory" title="Table 3.5. enum v4l2_memory">v4l2_memory</a>; the method, in which the actual video data is
 *              passed
 * @offset:     for non-multiplanar buffers with memory == V4L2_MEMORY_MMAP;
 *              offset from the start of the device memory for this plane,
 *              (or a "cookie" that should be passed to mmap() as offset)
 * @userptr:    for non-multiplanar buffers with memory == V4L2_MEMORY_USERPTR;
 *              a userspace pointer pointing to this buffer
 * @fd:         for non-multiplanar buffers with memory == V4L2_MEMORY_DMABUF;
 *              a userspace file descriptor associated with this buffer
 * @planes:     for multiplanar buffers; userspace pointer to the array of plane
 *              info structs for this buffer
 * @length:     size in bytes of the buffer (NOT its payload) for single-plane
 *              buffers (when type != *_MPLANE); number of elements in the
 *              planes array for multi-plane buffers
 *
 * Contains data exchanged by application and driver using one of the Streaming
 * I/O methods.
 */
struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a> {
        __u32                   index;
        __u32                   type;
        __u32                   bytesused;
        __u32                   flags;
        __u32                   field;
        struct timeval          timestamp;
        struct <a class="link" href="media.html#v4l2-timecode" title="Table 3.6. struct v4l2_timecode">v4l2_timecode</a>    timecode;
        __u32                   sequence;

        /* memory location */
        __u32                   memory;
        union {
                __u32           offset;
                unsigned long   userptr;
                struct <a class="link" href="media.html#v4l2-plane" title="Table 3.2. struct v4l2_plane">v4l2_plane</a> *planes;
                __s32           fd;
        } m;
        __u32                   length;
        __u32                   reserved2;
        __u32                   reserved;
};

/*  Flags for 'flags' field */
/* Buffer is mapped (flag) */
#define V4L2_BUF_FLAG_MAPPED                    0x00000001
/* Buffer is queued for processing */
#define V4L2_BUF_FLAG_QUEUED                    0x00000002
/* Buffer is ready */
#define V4L2_BUF_FLAG_DONE                      0x00000004
/* Image is a keyframe (I-frame) */
#define V4L2_BUF_FLAG_KEYFRAME                  0x00000008
/* Image is a P-frame */
#define V4L2_BUF_FLAG_PFRAME                    0x00000010
/* Image is a B-frame */
#define V4L2_BUF_FLAG_BFRAME                    0x00000020
/* Buffer is ready, but the data contained within is corrupted. */
#define V4L2_BUF_FLAG_ERROR                     0x00000040
/* timecode field is valid */
#define V4L2_BUF_FLAG_TIMECODE                  0x00000100
/* Buffer is prepared for queuing */
#define V4L2_BUF_FLAG_PREPARED                  0x00000400
/* Cache handling flags */
#define V4L2_BUF_FLAG_NO_CACHE_INVALIDATE       0x00000800
#define V4L2_BUF_FLAG_NO_CACHE_CLEAN            0x00001000
/* Timestamp type */
#define V4L2_BUF_FLAG_TIMESTAMP_MASK            0x0000e000
#define V4L2_BUF_FLAG_TIMESTAMP_UNKNOWN         0x00000000
#define V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC       0x00002000
#define V4L2_BUF_FLAG_TIMESTAMP_COPY            0x00004000
/* Timestamp sources. */
#define V4L2_BUF_FLAG_TSTAMP_SRC_MASK           0x00070000
#define V4L2_BUF_FLAG_TSTAMP_SRC_EOF            0x00000000
#define V4L2_BUF_FLAG_TSTAMP_SRC_SOE            0x00010000

/**
 * struct <a class="link" href="media.html#v4l2-exportbuffer" title="Table A.49. struct v4l2_exportbuffer">v4l2_exportbuffer</a> - export of video buffer as DMABUF file descriptor
 *
 * @index:      id number of the buffer
 * @type:       enum <a class="link" href="media.html#v4l2-buf-type" title="Table 3.3. enum v4l2_buf_type">v4l2_buf_type</a>; buffer type (type == *_MPLANE for
 *              multiplanar buffers);
 * @plane:      index of the plane to be exported, 0 for single plane queues
 * @flags:      flags for newly created file, currently only O_CLOEXEC is
 *              supported, refer to manual of open syscall for more details
 * @fd:         file descriptor associated with DMABUF (set by driver)
 *
 * Contains data used for exporting a video buffer as DMABUF file descriptor.
 * The buffer is identified by a 'cookie' returned by VIDIOC_QUERYBUF
 * (identical to the cookie used to mmap() the buffer to userspace). All
 * reserved fields must be set to zero. The field reserved0 is expected to
 * become a structure 'type' allowing an alternative layout of the structure
 * content. Therefore this field should not be used for any other extensions.
 */
struct <a class="link" href="media.html#v4l2-exportbuffer" title="Table A.49. struct v4l2_exportbuffer">v4l2_exportbuffer</a> {
        __u32           type; /* enum <a class="link" href="media.html#v4l2-buf-type" title="Table 3.3. enum v4l2_buf_type">v4l2_buf_type</a> */
        __u32           index;
        __u32           plane;
        __u32           flags;
        __s32           fd;
        __u32           reserved[11];
};

/*
 *      O V E R L A Y   P R E V I E W
 */
struct <a class="link" href="media.html#v4l2-framebuffer" title="Table A.68. struct v4l2_framebuffer">v4l2_framebuffer</a> {
        __u32                   capability;
        __u32                   flags;
/* FIXME: in theory we should pass something like PCI device + memory
 * region + offset instead of some physical address */
        void                    *base;
        struct {
                __u32           width;
                __u32           height;
                __u32           pixelformat;
                __u32           field;          /* enum <a class="link" href="media.html#v4l2-field" title="Table 3.9. enum v4l2_field">v4l2_field</a> */
                __u32           bytesperline;   /* for padding, zero if unused */
                __u32           sizeimage;
                __u32           colorspace;     /* enum <a class="link" href="media.html#v4l2-colorspace" title="Table 2.4. V4L2 Colorspaces">v4l2_colorspace</a> */
                __u32           priv;           /* reserved field, set to 0 */
        } fmt;
};
/*  Flags for the 'capability' field. Read only */
#define V4L2_FBUF_CAP_EXTERNOVERLAY     0x0001
#define V4L2_FBUF_CAP_CHROMAKEY         0x0002
#define V4L2_FBUF_CAP_LIST_CLIPPING     0x0004
#define V4L2_FBUF_CAP_BITMAP_CLIPPING   0x0008
#define V4L2_FBUF_CAP_LOCAL_ALPHA       0x0010
#define V4L2_FBUF_CAP_GLOBAL_ALPHA      0x0020
#define V4L2_FBUF_CAP_LOCAL_INV_ALPHA   0x0040
#define V4L2_FBUF_CAP_SRC_CHROMAKEY     0x0080
/*  Flags for the 'flags' field. */
#define V4L2_FBUF_FLAG_PRIMARY          0x0001
#define V4L2_FBUF_FLAG_OVERLAY          0x0002
#define V4L2_FBUF_FLAG_CHROMAKEY        0x0004
#define V4L2_FBUF_FLAG_LOCAL_ALPHA      0x0008
#define V4L2_FBUF_FLAG_GLOBAL_ALPHA     0x0010
#define V4L2_FBUF_FLAG_LOCAL_INV_ALPHA  0x0020
#define V4L2_FBUF_FLAG_SRC_CHROMAKEY    0x0040

struct <a class="link" href="media.html#v4l2-clip" title="Table 4.2. struct v4l2_clip">v4l2_clip</a> {
        struct <a class="link" href="media.html#v4l2-rect" title="Table 4.3. struct v4l2_rect">v4l2_rect</a>        c;
        struct <a class="link" href="media.html#v4l2-clip" title="Table 4.2. struct v4l2_clip">v4l2_clip</a>        __user *next;
};

struct <a class="link" href="media.html#v4l2-window" title="Table 4.1. struct v4l2_window">v4l2_window</a> {
        struct <a class="link" href="media.html#v4l2-rect" title="Table 4.3. struct v4l2_rect">v4l2_rect</a>        w;
        __u32                   field;   /* enum <a class="link" href="media.html#v4l2-field" title="Table 3.9. enum v4l2_field">v4l2_field</a> */
        __u32                   chromakey;
        struct <a class="link" href="media.html#v4l2-clip" title="Table 4.2. struct v4l2_clip">v4l2_clip</a>        __user *clips;
        __u32                   clipcount;
        void                    __user *bitmap;
        __u8                    global_alpha;
};

/*
 *      C A P T U R E   P A R A M E T E R S
 */
struct <a class="link" href="media.html#v4l2-captureparm" title="Table A.78. struct v4l2_captureparm">v4l2_captureparm</a> {
        __u32              capability;    /*  Supported modes */
        __u32              capturemode;   /*  Current mode */
        struct <a class="link" href="media.html#v4l2-fract" title="Table A.46. struct v4l2_fract">v4l2_fract</a>  timeperframe;  /*  Time per frame in seconds */
        __u32              extendedmode;  /*  Driver-specific extensions */
        __u32              readbuffers;   /*  # of buffers for read */
        __u32              reserved[4];
};

/*  Flags for 'capability' and 'capturemode' fields */
#define V4L2_MODE_HIGHQUALITY   0x0001  /*  High quality imaging mode */
#define V4L2_CAP_TIMEPERFRAME   0x1000  /*  timeperframe field is supported */

struct <a class="link" href="media.html#v4l2-outputparm" title="Table A.79. struct v4l2_outputparm">v4l2_outputparm</a> {
        __u32              capability;   /*  Supported modes */
        __u32              outputmode;   /*  Current mode */
        struct <a class="link" href="media.html#v4l2-fract" title="Table A.46. struct v4l2_fract">v4l2_fract</a>  timeperframe; /*  Time per frame in seconds */
        __u32              extendedmode; /*  Driver-specific extensions */
        __u32              writebuffers; /*  # of buffers for write */
        __u32              reserved[4];
};

/*
 *      I N P U T   I M A G E   C R O P P I N G
 */
struct <a class="link" href="media.html#v4l2-cropcap" title="Table A.2. struct v4l2_cropcap">v4l2_cropcap</a> {
        __u32                   type;   /* enum <a class="link" href="media.html#v4l2-buf-type" title="Table 3.3. enum v4l2_buf_type">v4l2_buf_type</a> */
        struct <a class="link" href="media.html#v4l2-rect" title="Table 4.3. struct v4l2_rect">v4l2_rect</a>        bounds;
        struct <a class="link" href="media.html#v4l2-rect" title="Table 4.3. struct v4l2_rect">v4l2_rect</a>        defrect;
        struct <a class="link" href="media.html#v4l2-fract" title="Table A.46. struct v4l2_fract">v4l2_fract</a>       pixelaspect;
};

struct <a class="link" href="media.html#v4l2-crop" title="Table A.54. struct v4l2_crop">v4l2_crop</a> {
        __u32                   type;   /* enum <a class="link" href="media.html#v4l2-buf-type" title="Table 3.3. enum v4l2_buf_type">v4l2_buf_type</a> */
        struct <a class="link" href="media.html#v4l2-rect" title="Table 4.3. struct v4l2_rect">v4l2_rect</a>        c;
};

/**
 * struct <a class="link" href="media.html#v4l2-selection" title="Table A.83. struct v4l2_selection">v4l2_selection</a> - selection info
 * @type:       buffer type (do not use *_MPLANE types)
 * @target:     Selection target, used to choose one of possible rectangles;
 *              defined in v4l2-common.h; V4L2_SEL_TGT_* .
 * @flags:      constraints flags, defined in v4l2-common.h; V4L2_SEL_FLAG_*.
 * @r:          coordinates of selection window
 * @reserved:   for future use, rounds structure size to 64 bytes, set to zero
 *
 * Hardware may use multiple helper windows to process a video stream.
 * The structure is used to exchange this selection areas between
 * an application and a driver.
 */
struct <a class="link" href="media.html#v4l2-selection" title="Table A.83. struct v4l2_selection">v4l2_selection</a> {
        __u32                   type;
        __u32                   target;
        __u32                   flags;
        struct <a class="link" href="media.html#v4l2-rect" title="Table 4.3. struct v4l2_rect">v4l2_rect</a>        r;
        __u32                   reserved[9];
};


/*
 *      A N A L O G   V I D E O   S T A N D A R D
 */

typedef __u64 v4l2_std_id;

/* one bit for each */
#define V4L2_STD_PAL_B          ((v4l2_std_id)0x00000001)
#define V4L2_STD_PAL_B1         ((v4l2_std_id)0x00000002)
#define V4L2_STD_PAL_G          ((v4l2_std_id)0x00000004)
#define V4L2_STD_PAL_H          ((v4l2_std_id)0x00000008)
#define V4L2_STD_PAL_I          ((v4l2_std_id)0x00000010)
#define V4L2_STD_PAL_D          ((v4l2_std_id)0x00000020)
#define V4L2_STD_PAL_D1         ((v4l2_std_id)0x00000040)
#define V4L2_STD_PAL_K          ((v4l2_std_id)0x00000080)

#define V4L2_STD_PAL_M          ((v4l2_std_id)0x00000100)
#define V4L2_STD_PAL_N          ((v4l2_std_id)0x00000200)
#define V4L2_STD_PAL_Nc         ((v4l2_std_id)0x00000400)
#define V4L2_STD_PAL_60         ((v4l2_std_id)0x00000800)

#define V4L2_STD_NTSC_M         ((v4l2_std_id)0x00001000)       /* BTSC */
#define V4L2_STD_NTSC_M_JP      ((v4l2_std_id)0x00002000)       /* EIA-J */
#define V4L2_STD_NTSC_443       ((v4l2_std_id)0x00004000)
#define V4L2_STD_NTSC_M_KR      ((v4l2_std_id)0x00008000)       /* FM A2 */

#define V4L2_STD_SECAM_B        ((v4l2_std_id)0x00010000)
#define V4L2_STD_SECAM_D        ((v4l2_std_id)0x00020000)
#define V4L2_STD_SECAM_G        ((v4l2_std_id)0x00040000)
#define V4L2_STD_SECAM_H        ((v4l2_std_id)0x00080000)
#define V4L2_STD_SECAM_K        ((v4l2_std_id)0x00100000)
#define V4L2_STD_SECAM_K1       ((v4l2_std_id)0x00200000)
#define V4L2_STD_SECAM_L        ((v4l2_std_id)0x00400000)
#define V4L2_STD_SECAM_LC       ((v4l2_std_id)0x00800000)

/* ATSC/HDTV */
#define V4L2_STD_ATSC_8_VSB     ((v4l2_std_id)0x01000000)
#define V4L2_STD_ATSC_16_VSB    ((v4l2_std_id)0x02000000)

/* FIXME:
   Although std_id is 64 bits, there is an issue on PPC32 architecture that
   makes switch(__u64) to break. So, there's a hack on v4l2-common.c rounding
   this value to 32 bits.
   As, currently, the max value is for V4L2_STD_ATSC_16_VSB (30 bits wide),
   it should work fine. However, if needed to add more than two standards,
   v4l2-common.c should be fixed.
 */

/*
 * Some macros to merge video standards in order to make live easier for the
 * drivers and V4L2 applications
 */

/*
 * "Common" NTSC/M - It should be noticed that V4L2_STD_NTSC_443 is
 * Missing here.
 */
#define V4L2_STD_NTSC           (V4L2_STD_NTSC_M        |\
                                 V4L2_STD_NTSC_M_JP     |\
                                 V4L2_STD_NTSC_M_KR)
/* Secam macros */
#define V4L2_STD_SECAM_DK       (V4L2_STD_SECAM_D       |\
                                 V4L2_STD_SECAM_K       |\
                                 V4L2_STD_SECAM_K1)
/* All Secam Standards */
#define V4L2_STD_SECAM          (V4L2_STD_SECAM_B       |\
                                 V4L2_STD_SECAM_G       |\
                                 V4L2_STD_SECAM_H       |\
                                 V4L2_STD_SECAM_DK      |\
                                 V4L2_STD_SECAM_L       |\
                                 V4L2_STD_SECAM_LC)
/* PAL macros */
#define V4L2_STD_PAL_BG         (V4L2_STD_PAL_B         |\
                                 V4L2_STD_PAL_B1        |\
                                 V4L2_STD_PAL_G)
#define V4L2_STD_PAL_DK         (V4L2_STD_PAL_D         |\
                                 V4L2_STD_PAL_D1        |\
                                 V4L2_STD_PAL_K)
/*
 * "Common" PAL - This macro is there to be compatible with the old
 * V4L1 concept of "PAL": /BGDKHI.
 * Several PAL standards are missing here: /M, /N and /Nc
 */
#define V4L2_STD_PAL            (V4L2_STD_PAL_BG        |\
                                 V4L2_STD_PAL_DK        |\
                                 V4L2_STD_PAL_H         |\
                                 V4L2_STD_PAL_I)
/* Chroma "agnostic" standards */
#define V4L2_STD_B              (V4L2_STD_PAL_B         |\
                                 V4L2_STD_PAL_B1        |\
                                 V4L2_STD_SECAM_B)
#define V4L2_STD_G              (V4L2_STD_PAL_G         |\
                                 V4L2_STD_SECAM_G)
#define V4L2_STD_H              (V4L2_STD_PAL_H         |\
                                 V4L2_STD_SECAM_H)
#define V4L2_STD_L              (V4L2_STD_SECAM_L       |\
                                 V4L2_STD_SECAM_LC)
#define V4L2_STD_GH             (V4L2_STD_G             |\
                                 V4L2_STD_H)
#define V4L2_STD_DK             (V4L2_STD_PAL_DK        |\
                                 V4L2_STD_SECAM_DK)
#define V4L2_STD_BG             (V4L2_STD_B             |\
                                 V4L2_STD_G)
#define V4L2_STD_MN             (V4L2_STD_PAL_M         |\
                                 V4L2_STD_PAL_N         |\
                                 V4L2_STD_PAL_Nc        |\
                                 V4L2_STD_NTSC)

/* Standards where MTS/BTSC stereo could be found */
#define V4L2_STD_MTS            (V4L2_STD_NTSC_M        |\
                                 V4L2_STD_PAL_M         |\
                                 V4L2_STD_PAL_N         |\
                                 V4L2_STD_PAL_Nc)

/* Standards for Countries with 60Hz Line frequency */
#define V4L2_STD_525_60         (V4L2_STD_PAL_M         |\
                                 V4L2_STD_PAL_60        |\
                                 V4L2_STD_NTSC          |\
                                 V4L2_STD_NTSC_443)
/* Standards for Countries with 50Hz Line frequency */
#define V4L2_STD_625_50         (V4L2_STD_PAL           |\
                                 V4L2_STD_PAL_N         |\
                                 V4L2_STD_PAL_Nc        |\
                                 V4L2_STD_SECAM)

#define V4L2_STD_ATSC           (V4L2_STD_ATSC_8_VSB    |\
                                 V4L2_STD_ATSC_16_VSB)
/* Macros with none and all analog standards */
#define V4L2_STD_UNKNOWN        0
#define V4L2_STD_ALL            (V4L2_STD_525_60        |\
                                 V4L2_STD_625_50)

struct <a class="link" href="media.html#v4l2-standard" title="Table A.45. struct v4l2_standard">v4l2_standard</a> {
        __u32                index;
        v4l2_std_id          id;
        __u8                 name[24];
        struct <a class="link" href="media.html#v4l2-fract" title="Table A.46. struct v4l2_fract">v4l2_fract</a>    frameperiod; /* Frames, not fields */
        __u32                framelines;
        __u32                reserved[4];
};

/*
 *      D V     B T     T I M I N G S
 */

/** struct <a class="link" href="media.html#v4l2-bt-timings" title="Table A.56. struct v4l2_bt_timings">v4l2_bt_timings</a> - BT.656/BT.1120 timing data
 * @width:      total width of the active video in pixels
 * @height:     total height of the active video in lines
 * @interlaced: Interlaced or progressive
 * @polarities: Positive or negative polarities
 * @pixelclock: Pixel clock in HZ. Ex. 74.25MHz-&gt;74250000
 * @hfrontporch:Horizontal front porch in pixels
 * @hsync:      Horizontal Sync length in pixels
 * @hbackporch: Horizontal back porch in pixels
 * @vfrontporch:Vertical front porch in lines
 * @vsync:      Vertical Sync length in lines
 * @vbackporch: Vertical back porch in lines
 * @il_vfrontporch:Vertical front porch for the even field
 *              (aka field 2) of interlaced field formats
 * @il_vsync:   Vertical Sync length for the even field
 *              (aka field 2) of interlaced field formats
 * @il_vbackporch:Vertical back porch for the even field
 *              (aka field 2) of interlaced field formats
 * @standards:  Standards the timing belongs to
 * @flags:      Flags
 * @reserved:   Reserved fields, must be zeroed.
 *
 * A note regarding vertical interlaced timings: height refers to the total
 * height of the active video frame (= two fields). The blanking timings refer
 * to the blanking of each field. So the height of the total frame is
 * calculated as follows:
 *
 * tot_height = height + vfrontporch + vsync + vbackporch +
 *                       il_vfrontporch + il_vsync + il_vbackporch
 *
 * The active height of each field is height / 2.
 */
struct <a class="link" href="media.html#v4l2-bt-timings" title="Table A.56. struct v4l2_bt_timings">v4l2_bt_timings</a> {
        __u32   width;
        __u32   height;
        __u32   interlaced;
        __u32   polarities;
        __u64   pixelclock;
        __u32   hfrontporch;
        __u32   hsync;
        __u32   hbackporch;
        __u32   vfrontporch;
        __u32   vsync;
        __u32   vbackporch;
        __u32   il_vfrontporch;
        __u32   il_vsync;
        __u32   il_vbackporch;
        __u32   standards;
        __u32   flags;
        __u32   reserved[14];
} __attribute__ ((packed));

/* Interlaced or progressive format */
#define V4L2_DV_PROGRESSIVE     0
#define V4L2_DV_INTERLACED      1

/* Polarities. If bit is not set, it is assumed to be negative polarity */
#define V4L2_DV_VSYNC_POS_POL   0x00000001
#define V4L2_DV_HSYNC_POS_POL   0x00000002

/* Timings standards */
#define V4L2_DV_BT_STD_CEA861   (1 &lt;&lt; 0)  /* CEA-861 Digital TV Profile */
#define V4L2_DV_BT_STD_DMT      (1 &lt;&lt; 1)  /* VESA Discrete Monitor Timings */
#define V4L2_DV_BT_STD_CVT      (1 &lt;&lt; 2)  /* VESA Coordinated Video Timings */
#define V4L2_DV_BT_STD_GTF      (1 &lt;&lt; 3)  /* VESA Generalized Timings Formula */

/* Flags */

/* CVT/GTF specific: timing uses reduced blanking (CVT) or the 'Secondary
   GTF' curve (GTF). In both cases the horizontal and/or vertical blanking
   intervals are reduced, allowing a higher resolution over the same
   bandwidth. This is a read-only flag. */
#define V4L2_DV_FL_REDUCED_BLANKING             (1 &lt;&lt; 0)
/* CEA-861 specific: set for CEA-861 formats with a framerate of a multiple
   of six. These formats can be optionally played at 1 / 1.001 speed.
   This is a read-only flag. */
#define V4L2_DV_FL_CAN_REDUCE_FPS               (1 &lt;&lt; 1)
/* CEA-861 specific: only valid for video transmitters, the flag is cleared
   by receivers.
   If the framerate of the format is a multiple of six, then the pixelclock
   used to set up the transmitter is divided by 1.001 to make it compatible
   with 60 Hz based standards such as NTSC and PAL-M that use a framerate of
   29.97 Hz. Otherwise this flag is cleared. If the transmitter can't generate
   such frequencies, then the flag will also be cleared. */
#define V4L2_DV_FL_REDUCED_FPS                  (1 &lt;&lt; 2)
/* Specific to interlaced formats: if set, then field 1 is really one half-line
   longer and field 2 is really one half-line shorter, so each field has
   exactly the same number of half-lines. Whether half-lines can be detected
   or used depends on the hardware. */
#define V4L2_DV_FL_HALF_LINE                    (1 &lt;&lt; 3)

/* A few useful defines to calculate the total blanking and frame sizes */
#define V4L2_DV_BT_BLANKING_WIDTH(bt) \
        ((bt)-&gt;hfrontporch + (bt)-&gt;hsync + (bt)-&gt;hbackporch)
#define V4L2_DV_BT_FRAME_WIDTH(bt) \
        ((bt)-&gt;width + V4L2_DV_BT_BLANKING_WIDTH(bt))
#define V4L2_DV_BT_BLANKING_HEIGHT(bt) \
        ((bt)-&gt;vfrontporch + (bt)-&gt;vsync + (bt)-&gt;vbackporch + \
         (bt)-&gt;il_vfrontporch + (bt)-&gt;il_vsync + (bt)-&gt;il_vbackporch)
#define V4L2_DV_BT_FRAME_HEIGHT(bt) \
        ((bt)-&gt;height + V4L2_DV_BT_BLANKING_HEIGHT(bt))

/** struct <a class="link" href="media.html#v4l2-dv-timings" title="Table A.57. struct v4l2_dv_timings">v4l2_dv_timings</a> - DV timings
 * @type:       the type of the timings
 * @bt: BT656/1120 timings
 */
struct <a class="link" href="media.html#v4l2-dv-timings" title="Table A.57. struct v4l2_dv_timings">v4l2_dv_timings</a> {
        __u32 type;
        union {
                struct <a class="link" href="media.html#v4l2-bt-timings" title="Table A.56. struct v4l2_bt_timings">v4l2_bt_timings</a>  bt;
                __u32   reserved[32];
        };
} __attribute__ ((packed));

/* Values for the type field */
#define V4L2_DV_BT_656_1120     0       /* BT.656/1120 timing type */


/** struct <a class="link" href="media.html#v4l2-enum-dv-timings" title="Table A.26. struct v4l2_enum_dv_timings">v4l2_enum_dv_timings</a> - DV timings enumeration
 * @index:      enumeration index
 * @pad:        the pad number for which to enumerate timings (used with
 *              v4l-subdev nodes only)
 * @reserved:   must be zeroed
 * @timings:    the timings for the given index
 */
struct <a class="link" href="media.html#v4l2-enum-dv-timings" title="Table A.26. struct v4l2_enum_dv_timings">v4l2_enum_dv_timings</a> {
        __u32 index;
        __u32 pad;
        __u32 reserved[2];
        struct <a class="link" href="media.html#v4l2-dv-timings" title="Table A.57. struct v4l2_dv_timings">v4l2_dv_timings</a> timings;
};

/** struct <a class="link" href="media.html#v4l2-bt-timings-cap" title="Table A.20. struct v4l2_bt_timings_cap">v4l2_bt_timings_cap</a> - BT.656/BT.1120 timing capabilities
 * @min_width:          width in pixels
 * @max_width:          width in pixels
 * @min_height:         height in lines
 * @max_height:         height in lines
 * @min_pixelclock:     Pixel clock in HZ. Ex. 74.25MHz-&gt;74250000
 * @max_pixelclock:     Pixel clock in HZ. Ex. 74.25MHz-&gt;74250000
 * @standards:          Supported standards
 * @capabilities:       Supported capabilities
 * @reserved:           Must be zeroed
 */
struct <a class="link" href="media.html#v4l2-bt-timings-cap" title="Table A.20. struct v4l2_bt_timings_cap">v4l2_bt_timings_cap</a> {
        __u32   min_width;
        __u32   max_width;
        __u32   min_height;
        __u32   max_height;
        __u64   min_pixelclock;
        __u64   max_pixelclock;
        __u32   standards;
        __u32   capabilities;
        __u32   reserved[16];
} __attribute__ ((packed));

/* Supports interlaced formats */
#define V4L2_DV_BT_CAP_INTERLACED       (1 &lt;&lt; 0)
/* Supports progressive formats */
#define V4L2_DV_BT_CAP_PROGRESSIVE      (1 &lt;&lt; 1)
/* Supports CVT/GTF reduced blanking */
#define V4L2_DV_BT_CAP_REDUCED_BLANKING (1 &lt;&lt; 2)
/* Supports custom formats */
#define V4L2_DV_BT_CAP_CUSTOM           (1 &lt;&lt; 3)

/** struct <a class="link" href="media.html#v4l2-dv-timings-cap" title="Table A.21. struct v4l2_dv_timings_cap">v4l2_dv_timings_cap</a> - DV timings capabilities
 * @type:       the type of the timings (same as in struct <a class="link" href="media.html#v4l2-dv-timings" title="Table A.57. struct v4l2_dv_timings">v4l2_dv_timings</a>)
 * @pad:        the pad number for which to query capabilities (used with
 *              v4l-subdev nodes only)
 * @bt:         the BT656/1120 timings capabilities
 */
struct <a class="link" href="media.html#v4l2-dv-timings-cap" title="Table A.21. struct v4l2_dv_timings_cap">v4l2_dv_timings_cap</a> {
        __u32 type;
        __u32 pad;
        __u32 reserved[2];
        union {
                struct <a class="link" href="media.html#v4l2-bt-timings-cap" title="Table A.20. struct v4l2_bt_timings_cap">v4l2_bt_timings_cap</a> bt;
                __u32 raw_data[32];
        };
};


/*
 *      V I D E O   I N P U T S
 */
struct <a class="link" href="media.html#v4l2-input" title="Table A.38. struct v4l2_input">v4l2_input</a> {
        __u32        index;             /*  Which input */
        __u8         name[32];          /*  Label */
        __u32        type;              /*  Type of input */
        __u32        audioset;          /*  Associated audios (bitfield) */
        __u32        tuner;             /*  enum <a class="link" href="media.html#v4l2-tuner-type" title="Table A.87. enum v4l2_tuner_type">v4l2_tuner_type</a> */
        v4l2_std_id  std;
        __u32        status;
        __u32        capabilities;
        __u32        reserved[3];
};

/*  Values for the 'type' field */
#define V4L2_INPUT_TYPE_TUNER           1
#define V4L2_INPUT_TYPE_CAMERA          2

/* field 'status' - general */
#define V4L2_IN_ST_NO_POWER    0x00000001  /* Attached device is off */
#define V4L2_IN_ST_NO_SIGNAL   0x00000002
#define V4L2_IN_ST_NO_COLOR    0x00000004

/* field 'status' - sensor orientation */
/* If sensor is mounted upside down set both bits */
#define V4L2_IN_ST_HFLIP       0x00000010 /* Frames are flipped horizontally */
#define V4L2_IN_ST_VFLIP       0x00000020 /* Frames are flipped vertically */

/* field 'status' - analog */
#define V4L2_IN_ST_NO_H_LOCK   0x00000100  /* No horizontal sync lock */
#define V4L2_IN_ST_COLOR_KILL  0x00000200  /* Color killer is active */

/* field 'status' - digital */
#define V4L2_IN_ST_NO_SYNC     0x00010000  /* No synchronization lock */
#define V4L2_IN_ST_NO_EQU      0x00020000  /* No equalizer lock */
#define V4L2_IN_ST_NO_CARRIER  0x00040000  /* Carrier recovery failed */

/* field 'status' - VCR and set-top box */
#define V4L2_IN_ST_MACROVISION 0x01000000  /* Macrovision detected */
#define V4L2_IN_ST_NO_ACCESS   0x02000000  /* Conditional access denied */
#define V4L2_IN_ST_VTR         0x04000000  /* VTR time constant */

/* capabilities flags */
#define V4L2_IN_CAP_DV_TIMINGS          0x00000002 /* Supports S_DV_TIMINGS */
#define V4L2_IN_CAP_CUSTOM_TIMINGS      V4L2_IN_CAP_DV_TIMINGS /* For compatibility */
#define V4L2_IN_CAP_STD                 0x00000004 /* Supports S_STD */
#define V4L2_IN_CAP_NATIVE_SIZE         0x00000008 /* Supports setting native size */

/*
 *      V I D E O   O U T P U T S
 */
struct <a class="link" href="media.html#v4l2-output" title="Table A.42. struct v4l2_output">v4l2_output</a> {
        __u32        index;             /*  Which output */
        __u8         name[32];          /*  Label */
        __u32        type;              /*  Type of output */
        __u32        audioset;          /*  Associated audios (bitfield) */
        __u32        modulator;         /*  Associated modulator */
        v4l2_std_id  std;
        __u32        capabilities;
        __u32        reserved[3];
};
/*  Values for the 'type' field */
#define V4L2_OUTPUT_TYPE_MODULATOR              1
#define V4L2_OUTPUT_TYPE_ANALOG                 2
#define V4L2_OUTPUT_TYPE_ANALOGVGAOVERLAY       3

/* capabilities flags */
#define V4L2_OUT_CAP_DV_TIMINGS         0x00000002 /* Supports S_DV_TIMINGS */
#define V4L2_OUT_CAP_CUSTOM_TIMINGS     V4L2_OUT_CAP_DV_TIMINGS /* For compatibility */
#define V4L2_OUT_CAP_STD                0x00000004 /* Supports S_STD */
#define V4L2_OUT_CAP_NATIVE_SIZE        0x00000008 /* Supports setting native size */

/*
 *      C O N T R O L S
 */
struct <a class="link" href="media.html#v4l2-control" title="Table A.55. struct v4l2_control">v4l2_control</a> {
        __u32                id;
        __s32                value;
};

struct <a class="link" href="media.html#v4l2-ext-control" title="Table A.65. struct v4l2_ext_control">v4l2_ext_control</a> {
        __u32 id;
        __u32 size;
        __u32 reserved2[1];
        union {
                __s32 value;
                __s64 value64;
                char __user *string;
                __u8 __user *p_u8;
                __u16 __user *p_u16;
                __u32 __user *p_u32;
                void __user *ptr;
        };
} __attribute__ ((packed));

struct <a class="link" href="media.html#v4l2-ext-controls" title="Table A.66. struct v4l2_ext_controls">v4l2_ext_controls</a> {
        __u32 ctrl_class;
        __u32 count;
        __u32 error_idx;
        __u32 reserved[2];
        struct <a class="link" href="media.html#v4l2-ext-control" title="Table A.65. struct v4l2_ext_control">v4l2_ext_control</a> *controls;
};

#define V4L2_CTRL_ID_MASK         (0x0fffffff)
#define V4L2_CTRL_ID2CLASS(id)    ((id) &amp; 0x0fff0000UL)
#define V4L2_CTRL_DRIVER_PRIV(id) (((id) &amp; 0xffff) &gt;= 0x1000)
#define V4L2_CTRL_MAX_DIMS        (4)

enum <a class="link" href="media.html#v4l2-ctrl-type" title="Table A.97. enum v4l2_ctrl_type">v4l2_ctrl_type</a> {
        V4L2_CTRL_TYPE_INTEGER       = 1,
        V4L2_CTRL_TYPE_BOOLEAN       = 2,
        V4L2_CTRL_TYPE_MENU          = 3,
        V4L2_CTRL_TYPE_BUTTON        = 4,
        V4L2_CTRL_TYPE_INTEGER64     = 5,
        V4L2_CTRL_TYPE_CTRL_CLASS    = 6,
        V4L2_CTRL_TYPE_STRING        = 7,
        V4L2_CTRL_TYPE_BITMASK       = 8,
        V4L2_CTRL_TYPE_INTEGER_MENU  = 9,

        /* Compound types are &gt;= 0x0100 */
        V4L2_CTRL_COMPOUND_TYPES     = 0x0100,
        V4L2_CTRL_TYPE_U8            = 0x0100,
        V4L2_CTRL_TYPE_U16           = 0x0101,
        V4L2_CTRL_TYPE_U32           = 0x0102,
};

/*  Used in the VIDIOC_QUERYCTRL ioctl for querying controls */
struct <a class="link" href="media.html#v4l2-queryctrl" title="Table A.94. struct v4l2_queryctrl">v4l2_queryctrl</a> {
        __u32                id;
        __u32                type;      /* enum <a class="link" href="media.html#v4l2-ctrl-type" title="Table A.97. enum v4l2_ctrl_type">v4l2_ctrl_type</a> */
        __u8                 name[32];  /* Whatever */
        __s32                minimum;   /* Note signedness */
        __s32                maximum;
        __s32                step;
        __s32                default_value;
        __u32                flags;
        __u32                reserved[2];
};

/*  Used in the VIDIOC_QUERY_EXT_CTRL ioctl for querying extended controls */
struct <a class="link" href="media.html#v4l2-query-ext-ctrl" title="Table A.95. struct v4l2_query_ext_ctrl">v4l2_query_ext_ctrl</a> {
        __u32                id;
        __u32                type;
        char                 name[32];
        __s64                minimum;
        __s64                maximum;
        __u64                step;
        __s64                default_value;
        __u32                flags;
        __u32                elem_size;
        __u32                elems;
        __u32                nr_of_dims;
        __u32                dims[V4L2_CTRL_MAX_DIMS];
        __u32                reserved[32];
};

/*  Used in the VIDIOC_QUERYMENU ioctl for querying menu items */
struct <a class="link" href="media.html#v4l2-querymenu" title="Table A.96. struct v4l2_querymenu">v4l2_querymenu</a> {
        __u32           id;
        __u32           index;
        union {
                __u8    name[32];       /* Whatever */
                __s64   value;
        };
        __u32           reserved;
} __attribute__ ((packed));

/*  Control flags  */
#define V4L2_CTRL_FLAG_DISABLED         0x0001
#define V4L2_CTRL_FLAG_GRABBED          0x0002
#define V4L2_CTRL_FLAG_READ_ONLY        0x0004
#define V4L2_CTRL_FLAG_UPDATE           0x0008
#define V4L2_CTRL_FLAG_INACTIVE         0x0010
#define V4L2_CTRL_FLAG_SLIDER           0x0020
#define V4L2_CTRL_FLAG_WRITE_ONLY       0x0040
#define V4L2_CTRL_FLAG_VOLATILE         0x0080
#define V4L2_CTRL_FLAG_HAS_PAYLOAD      0x0100

/*  Query flags, to be ORed with the control ID */
#define V4L2_CTRL_FLAG_NEXT_CTRL        0x80000000
#define V4L2_CTRL_FLAG_NEXT_COMPOUND    0x40000000

/*  User-class control IDs defined by V4L2 */
#define V4L2_CID_MAX_CTRLS              1024
/*  IDs reserved for driver specific controls */
#define V4L2_CID_PRIVATE_BASE           0x08000000


/*
 *      T U N I N G
 */
struct <a class="link" href="media.html#v4l2-tuner" title="Table A.86. struct v4l2_tuner">v4l2_tuner</a> {
        __u32                   index;
        __u8                    name[32];
        __u32                   type;   /* enum <a class="link" href="media.html#v4l2-tuner-type" title="Table A.87. enum v4l2_tuner_type">v4l2_tuner_type</a> */
        __u32                   capability;
        __u32                   rangelow;
        __u32                   rangehigh;
        __u32                   rxsubchans;
        __u32                   audmode;
        __s32                   signal;
        __s32                   afc;
        __u32                   reserved[4];
};

struct <a class="link" href="media.html#v4l2-modulator" title="Table A.75. struct v4l2_modulator">v4l2_modulator</a> {
        __u32                   index;
        __u8                    name[32];
        __u32                   capability;
        __u32                   rangelow;
        __u32                   rangehigh;
        __u32                   txsubchans;
        __u32                   reserved[4];
};

/*  Flags for the 'capability' field */
#define V4L2_TUNER_CAP_LOW              0x0001
#define V4L2_TUNER_CAP_NORM             0x0002
#define V4L2_TUNER_CAP_HWSEEK_BOUNDED   0x0004
#define V4L2_TUNER_CAP_HWSEEK_WRAP      0x0008
#define V4L2_TUNER_CAP_STEREO           0x0010
#define V4L2_TUNER_CAP_LANG2            0x0020
#define V4L2_TUNER_CAP_SAP              0x0020
#define V4L2_TUNER_CAP_LANG1            0x0040
#define V4L2_TUNER_CAP_RDS              0x0080
#define V4L2_TUNER_CAP_RDS_BLOCK_IO     0x0100
#define V4L2_TUNER_CAP_RDS_CONTROLS     0x0200
#define V4L2_TUNER_CAP_FREQ_BANDS       0x0400
#define V4L2_TUNER_CAP_HWSEEK_PROG_LIM  0x0800
#define V4L2_TUNER_CAP_1HZ              0x1000

/*  Flags for the 'rxsubchans' field */
#define V4L2_TUNER_SUB_MONO             0x0001
#define V4L2_TUNER_SUB_STEREO           0x0002
#define V4L2_TUNER_SUB_LANG2            0x0004
#define V4L2_TUNER_SUB_SAP              0x0004
#define V4L2_TUNER_SUB_LANG1            0x0008
#define V4L2_TUNER_SUB_RDS              0x0010

/*  Values for the 'audmode' field */
#define V4L2_TUNER_MODE_MONO            0x0000
#define V4L2_TUNER_MODE_STEREO          0x0001
#define V4L2_TUNER_MODE_LANG2           0x0002
#define V4L2_TUNER_MODE_SAP             0x0002
#define V4L2_TUNER_MODE_LANG1           0x0003
#define V4L2_TUNER_MODE_LANG1_LANG2     0x0004

struct <a class="link" href="media.html#v4l2-frequency" title="Table A.72. struct v4l2_frequency">v4l2_frequency</a> {
        __u32   tuner;
        __u32   type;   /* enum <a class="link" href="media.html#v4l2-tuner-type" title="Table A.87. enum v4l2_tuner_type">v4l2_tuner_type</a> */
        __u32   frequency;
        __u32   reserved[8];
};

#define V4L2_BAND_MODULATION_VSB        (1 &lt;&lt; 1)
#define V4L2_BAND_MODULATION_FM         (1 &lt;&lt; 2)
#define V4L2_BAND_MODULATION_AM         (1 &lt;&lt; 3)

struct <a class="link" href="media.html#v4l2-frequency-band" title="Table A.36. struct v4l2_frequency_band">v4l2_frequency_band</a> {
        __u32   tuner;
        __u32   type;   /* enum <a class="link" href="media.html#v4l2-tuner-type" title="Table A.87. enum v4l2_tuner_type">v4l2_tuner_type</a> */
        __u32   index;
        __u32   capability;
        __u32   rangelow;
        __u32   rangehigh;
        __u32   modulation;
        __u32   reserved[9];
};

struct <a class="link" href="media.html#v4l2-hw-freq-seek" title="Table A.100. struct v4l2_hw_freq_seek">v4l2_hw_freq_seek</a> {
        __u32   tuner;
        __u32   type;   /* enum <a class="link" href="media.html#v4l2-tuner-type" title="Table A.87. enum v4l2_tuner_type">v4l2_tuner_type</a> */
        __u32   seek_upward;
        __u32   wrap_around;
        __u32   spacing;
        __u32   rangelow;
        __u32   rangehigh;
        __u32   reserved[5];
};

/*
 *      R D S
 */

struct <a class="link" href="media.html#v4l2-rds-data" title="Table 4.15. struct v4l2_rds_data">v4l2_rds_data</a> {
        __u8    lsb;
        __u8    msb;
        __u8    block;
} __attribute__ ((packed));

#define V4L2_RDS_BLOCK_MSK       0x7
#define V4L2_RDS_BLOCK_A         0
#define V4L2_RDS_BLOCK_B         1
#define V4L2_RDS_BLOCK_C         2
#define V4L2_RDS_BLOCK_D         3
#define V4L2_RDS_BLOCK_C_ALT     4
#define V4L2_RDS_BLOCK_INVALID   7

#define V4L2_RDS_BLOCK_CORRECTED 0x40
#define V4L2_RDS_BLOCK_ERROR     0x80

/*
 *      A U D I O
 */
struct <a class="link" href="media.html#v4l2-audio" title="Table A.50. struct v4l2_audio">v4l2_audio</a> {
        __u32   index;
        __u8    name[32];
        __u32   capability;
        __u32   mode;
        __u32   reserved[2];
};

/*  Flags for the 'capability' field */
#define V4L2_AUDCAP_STEREO              0x00001
#define V4L2_AUDCAP_AVL                 0x00002

/*  Flags for the 'mode' field */
#define V4L2_AUDMODE_AVL                0x00001

struct <a class="link" href="media.html#v4l2-audioout" title="Table A.53. struct v4l2_audioout">v4l2_audioout</a> {
        __u32   index;
        __u8    name[32];
        __u32   capability;
        __u32   mode;
        __u32   reserved[2];
};

/*
 *      M P E G   S E R V I C E S
 *
 *      NOTE: EXPERIMENTAL API
 */
#if 1
#define V4L2_ENC_IDX_FRAME_I    (0)
#define V4L2_ENC_IDX_FRAME_P    (1)
#define V4L2_ENC_IDX_FRAME_B    (2)
#define V4L2_ENC_IDX_FRAME_MASK (0xf)

struct <a class="link" href="media.html#v4l2-enc-idx-entry" title="Table A.63. struct v4l2_enc_idx_entry">v4l2_enc_idx_entry</a> {
        __u64 offset;
        __u64 pts;
        __u32 length;
        __u32 flags;
        __u32 reserved[2];
};

#define V4L2_ENC_IDX_ENTRIES (64)
struct <a class="link" href="media.html#v4l2-enc-idx" title="Table A.62. struct v4l2_enc_idx">v4l2_enc_idx</a> {
        __u32 entries;
        __u32 entries_cap;
        __u32 reserved[4];
        struct <a class="link" href="media.html#v4l2-enc-idx-entry" title="Table A.63. struct v4l2_enc_idx_entry">v4l2_enc_idx_entry</a> entry[V4L2_ENC_IDX_ENTRIES];
};


#define V4L2_ENC_CMD_START      (0)
#define V4L2_ENC_CMD_STOP       (1)
#define V4L2_ENC_CMD_PAUSE      (2)
#define V4L2_ENC_CMD_RESUME     (3)

/* Flags for V4L2_ENC_CMD_STOP */
#define V4L2_ENC_CMD_STOP_AT_GOP_END    (1 &lt;&lt; 0)

struct <a class="link" href="media.html#v4l2-encoder-cmd" title="Table A.23. struct v4l2_encoder_cmd">v4l2_encoder_cmd</a> {
        __u32 cmd;
        __u32 flags;
        union {
                struct {
                        __u32 data[8];
                } raw;
        };
};

/* Decoder commands */
#define V4L2_DEC_CMD_START       (0)
#define V4L2_DEC_CMD_STOP        (1)
#define V4L2_DEC_CMD_PAUSE       (2)
#define V4L2_DEC_CMD_RESUME      (3)

/* Flags for V4L2_DEC_CMD_START */
#define V4L2_DEC_CMD_START_MUTE_AUDIO   (1 &lt;&lt; 0)

/* Flags for V4L2_DEC_CMD_PAUSE */
#define V4L2_DEC_CMD_PAUSE_TO_BLACK     (1 &lt;&lt; 0)

/* Flags for V4L2_DEC_CMD_STOP */
#define V4L2_DEC_CMD_STOP_TO_BLACK      (1 &lt;&lt; 0)
#define V4L2_DEC_CMD_STOP_IMMEDIATELY   (1 &lt;&lt; 1)

/* Play format requirements (returned by the driver): */

/* The decoder has no special format requirements */
#define V4L2_DEC_START_FMT_NONE         (0)
/* The decoder requires full GOPs */
#define V4L2_DEC_START_FMT_GOP          (1)

/* The structure must be zeroed before use by the application
   This ensures it can be extended safely in the future. */
struct <a class="link" href="media.html#v4l2-decoder-cmd" title="Table A.10. struct v4l2_decoder_cmd">v4l2_decoder_cmd</a> {
        __u32 cmd;
        __u32 flags;
        union {
                struct {
                        __u64 pts;
                } stop;

                struct {
                        /* 0 or 1000 specifies normal speed,
                           1 specifies forward single stepping,
                           -1 specifies backward single stepping,
                           &gt;1: playback at speed/1000 of the normal speed,
                           &lt;-1: reverse playback at (-speed/1000) of the normal speed. */
                        __s32 speed;
                        __u32 format;
                } start;

                struct {
                        __u32 data[16];
                } raw;
        };
};
#endif


/*
 *      D A T A   S E R V I C E S   ( V B I )
 *
 *      Data services API by Michael Schimek
 */

/* Raw VBI */
struct <a class="link" href="media.html#v4l2-vbi-format" title="Table 4.4. struct v4l2_vbi_format">v4l2_vbi_format</a> {
        __u32   sampling_rate;          /* in 1 Hz */
        __u32   offset;
        __u32   samples_per_line;
        __u32   sample_format;          /* V4L2_PIX_FMT_* */
        __s32   start[2];
        __u32   count[2];
        __u32   flags;                  /* V4L2_VBI_* */
        __u32   reserved[2];            /* must be zero */
};

/*  VBI flags  */
#define V4L2_VBI_UNSYNC         (1 &lt;&lt; 0)
#define V4L2_VBI_INTERLACED     (1 &lt;&lt; 1)

/* ITU-R start lines for each field */
#define V4L2_VBI_ITU_525_F1_START (1)
#define V4L2_VBI_ITU_525_F2_START (264)
#define V4L2_VBI_ITU_625_F1_START (1)
#define V4L2_VBI_ITU_625_F2_START (314)

/* Sliced VBI
 *
 *    This implements is a proposal V4L2 API to allow SLICED VBI
 * required for some hardware encoders. It should change without
 * notice in the definitive implementation.
 */

struct <a class="link" href="media.html#v4l2-sliced-vbi-format" title="Table 4.6. struct v4l2_sliced_vbi_format">v4l2_sliced_vbi_format</a> {
        __u16   service_set;
        /* service_lines[0][...] specifies lines 0-23 (1-23 used) of the first field
           service_lines[1][...] specifies lines 0-23 (1-23 used) of the second field
                                 (equals frame lines 313-336 for 625 line video
                                  standards, 263-286 for 525 line standards) */
        __u16   service_lines[2][24];
        __u32   io_size;
        __u32   reserved[2];            /* must be zero */
};

/* Teletext World System Teletext
   (WST), defined on ITU-R BT.653-2 */
#define V4L2_SLICED_TELETEXT_B          (0x0001)
/* Video Program System, defined on ETS 300 231*/
#define V4L2_SLICED_VPS                 (0x0400)
/* Closed Caption, defined on EIA-608 */
#define V4L2_SLICED_CAPTION_525         (0x1000)
/* Wide Screen System, defined on ITU-R BT1119.1 */
#define V4L2_SLICED_WSS_625             (0x4000)

#define V4L2_SLICED_VBI_525             (V4L2_SLICED_CAPTION_525)
#define V4L2_SLICED_VBI_625             (V4L2_SLICED_TELETEXT_B | V4L2_SLICED_VPS | V4L2_SLICED_WSS_625)

struct <a class="link" href="media.html#v4l2-sliced-vbi-cap" title="Table A.84. struct v4l2_sliced_vbi_cap">v4l2_sliced_vbi_cap</a> {
        __u16   service_set;
        /* service_lines[0][...] specifies lines 0-23 (1-23 used) of the first field
           service_lines[1][...] specifies lines 0-23 (1-23 used) of the second field
                                 (equals frame lines 313-336 for 625 line video
                                  standards, 263-286 for 525 line standards) */
        __u16   service_lines[2][24];
        __u32   type;           /* enum <a class="link" href="media.html#v4l2-buf-type" title="Table 3.3. enum v4l2_buf_type">v4l2_buf_type</a> */
        __u32   reserved[3];    /* must be 0 */
};

struct <a class="link" href="media.html#v4l2-sliced-vbi-data" title="Table 4.8. struct v4l2_sliced_vbi_data">v4l2_sliced_vbi_data</a> {
        __u32   id;
        __u32   field;          /* 0: first field, 1: second field */
        __u32   line;           /* 1-23 */
        __u32   reserved;       /* must be 0 */
        __u8    data[48];
};

/*
 * Sliced VBI data inserted into MPEG Streams
 */

/*
 * V4L2_MPEG_STREAM_VBI_FMT_IVTV:
 *
 * Structure of payload contained in an MPEG 2 Private Stream 1 PES Packet in an
 * MPEG-2 Program Pack that contains V4L2_MPEG_STREAM_VBI_FMT_IVTV Sliced VBI
 * data
 *
 * Note, the MPEG-2 Program Pack and Private Stream 1 PES packet header
 * definitions are not included here.  See the MPEG-2 specifications for details
 * on these headers.
 */

/* Line type IDs */
#define V4L2_MPEG_VBI_IVTV_TELETEXT_B     (1)
#define V4L2_MPEG_VBI_IVTV_CAPTION_525    (4)
#define V4L2_MPEG_VBI_IVTV_WSS_625        (5)
#define V4L2_MPEG_VBI_IVTV_VPS            (7)

struct <a class="link" href="media.html#v4l2-mpeg-vbi-itv0-line" title="Table 4.13. struct v4l2_mpeg_vbi_itv0_line">v4l2_mpeg_vbi_itv0_line</a> {
        __u8 id;        /* One of V4L2_MPEG_VBI_IVTV_* above */
        __u8 data[42];  /* Sliced VBI data for the line */
} __attribute__ ((packed));

struct <a class="link" href="media.html#v4l2-mpeg-vbi-itv0" title="Table 4.11. struct v4l2_mpeg_vbi_itv0">v4l2_mpeg_vbi_itv0</a> {
        __le32 linemask[2]; /* Bitmasks of VBI service lines present */
        struct <a class="link" href="media.html#v4l2-mpeg-vbi-itv0-line" title="Table 4.13. struct v4l2_mpeg_vbi_itv0_line">v4l2_mpeg_vbi_itv0_line</a> line[35];
} __attribute__ ((packed));

struct <a class="link" href="media.html#v4l2-mpeg-vbi-itv0-1" title="Table 4.12. struct v4l2_mpeg_vbi_ITV0">v4l2_mpeg_vbi_ITV0</a> {
        struct <a class="link" href="media.html#v4l2-mpeg-vbi-itv0-line" title="Table 4.13. struct v4l2_mpeg_vbi_itv0_line">v4l2_mpeg_vbi_itv0_line</a> line[36];
} __attribute__ ((packed));

#define V4L2_MPEG_VBI_IVTV_MAGIC0       "itv0"
#define V4L2_MPEG_VBI_IVTV_MAGIC1       "ITV0"

struct <a class="link" href="media.html#v4l2-mpeg-vbi-fmt-ivtv" title="Table 4.9. struct v4l2_mpeg_vbi_fmt_ivtv">v4l2_mpeg_vbi_fmt_ivtv</a> {
        __u8 magic[4];
        union {
                struct <a class="link" href="media.html#v4l2-mpeg-vbi-itv0" title="Table 4.11. struct v4l2_mpeg_vbi_itv0">v4l2_mpeg_vbi_itv0</a> itv0;
                struct <a class="link" href="media.html#v4l2-mpeg-vbi-itv0-1" title="Table 4.12. struct v4l2_mpeg_vbi_ITV0">v4l2_mpeg_vbi_ITV0</a> ITV0;
        };
} __attribute__ ((packed));

/*
 *      A G G R E G A T E   S T R U C T U R E S
 */

/**
 * struct <a class="link" href="media.html#v4l2-plane-pix-format" title="Table 2.2. struct v4l2_plane_pix_format">v4l2_plane_pix_format</a> - additional, per-plane format definition
 * @sizeimage:          maximum size in bytes required for data, for which
 *                      this plane will be used
 * @bytesperline:       distance in bytes between the leftmost pixels in two
 *                      adjacent lines
 */
struct <a class="link" href="media.html#v4l2-plane-pix-format" title="Table 2.2. struct v4l2_plane_pix_format">v4l2_plane_pix_format</a> {
        __u32           sizeimage;
        __u16           bytesperline;
        __u16           reserved[7];
} __attribute__ ((packed));

/**
 * struct <a class="link" href="media.html#v4l2-pix-format-mplane" title="Table 2.3. struct v4l2_pix_format_mplane">v4l2_pix_format_mplane</a> - multiplanar format definition
 * @width:              image width in pixels
 * @height:             image height in pixels
 * @pixelformat:        little endian four character code (fourcc)
 * @field:              enum <a class="link" href="media.html#v4l2-field" title="Table 3.9. enum v4l2_field">v4l2_field</a>; field order (for interlaced video)
 * @colorspace:         enum <a class="link" href="media.html#v4l2-colorspace" title="Table 2.4. V4L2 Colorspaces">v4l2_colorspace</a>; supplemental to pixelformat
 * @plane_fmt:          per-plane information
 * @num_planes:         number of planes for this format
 * @flags:              format flags (V4L2_PIX_FMT_FLAG_*)
 * @ycbcr_enc:          enum <a class="link" href="media.html#v4l2-ycbcr-encoding" title="Table 2.5. V4L2 Y'CbCr Encodings">v4l2_ycbcr_encoding</a>, Y'CbCr encoding
 * @quantization:       enum <a class="link" href="media.html#v4l2-quantization" title="Table 2.6. V4L2 Quantization Methods">v4l2_quantization</a>, colorspace quantization
 */
struct <a class="link" href="media.html#v4l2-pix-format-mplane" title="Table 2.3. struct v4l2_pix_format_mplane">v4l2_pix_format_mplane</a> {
        __u32                           width;
        __u32                           height;
        __u32                           pixelformat;
        __u32                           field;
        __u32                           colorspace;

        struct <a class="link" href="media.html#v4l2-plane-pix-format" title="Table 2.2. struct v4l2_plane_pix_format">v4l2_plane_pix_format</a>    plane_fmt[VIDEO_MAX_PLANES];
        __u8                            num_planes;
        __u8                            flags;
        __u8                            ycbcr_enc;
        __u8                            quantization;
        __u8                            reserved[8];
} __attribute__ ((packed));

/**
 * struct <a class="link" href="media.html#v4l2-sdr-format" title="Table 4.18. struct v4l2_sdr_format">v4l2_sdr_format</a> - SDR format definition
 * @pixelformat:        little endian four character code (fourcc)
 * @buffersize:         maximum size in bytes required for data
 */
struct <a class="link" href="media.html#v4l2-sdr-format" title="Table 4.18. struct v4l2_sdr_format">v4l2_sdr_format</a> {
        __u32                           pixelformat;
        __u32                           buffersize;
        __u8                            reserved[24];
} __attribute__ ((packed));

/**
 * struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a> - stream data format
 * @type:       enum <a class="link" href="media.html#v4l2-buf-type" title="Table 3.3. enum v4l2_buf_type">v4l2_buf_type</a>; type of the data stream
 * @pix:        definition of an image format
 * @pix_mp:     definition of a multiplanar image format
 * @win:        definition of an overlaid image
 * @vbi:        raw VBI capture or output parameters
 * @sliced:     sliced VBI capture or output parameters
 * @raw_data:   placeholder for future extensions and custom formats
 */
struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a> {
        __u32    type;
        union {
                struct <a class="link" href="media.html#v4l2-pix-format" title="Table 2.1. struct v4l2_pix_format">v4l2_pix_format</a>          pix;     /* V4L2_BUF_TYPE_VIDEO_CAPTURE */
                struct <a class="link" href="media.html#v4l2-pix-format-mplane" title="Table 2.3. struct v4l2_pix_format_mplane">v4l2_pix_format_mplane</a>   pix_mp;  /* V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE */
                struct <a class="link" href="media.html#v4l2-window" title="Table 4.1. struct v4l2_window">v4l2_window</a>              win;     /* V4L2_BUF_TYPE_VIDEO_OVERLAY */
                struct <a class="link" href="media.html#v4l2-vbi-format" title="Table 4.4. struct v4l2_vbi_format">v4l2_vbi_format</a>          vbi;     /* V4L2_BUF_TYPE_VBI_CAPTURE */
                struct <a class="link" href="media.html#v4l2-sliced-vbi-format" title="Table 4.6. struct v4l2_sliced_vbi_format">v4l2_sliced_vbi_format</a>   sliced;  /* V4L2_BUF_TYPE_SLICED_VBI_CAPTURE */
                struct <a class="link" href="media.html#v4l2-sdr-format" title="Table 4.18. struct v4l2_sdr_format">v4l2_sdr_format</a>          sdr;     /* V4L2_BUF_TYPE_SDR_CAPTURE */
                __u8    raw_data[200];                   /* user-defined */
        } fmt;
};

/*      Stream type-dependent parameters
 */
struct <a class="link" href="media.html#v4l2-streamparm" title="Table A.77. struct v4l2_streamparm">v4l2_streamparm</a> {
        __u32    type;                  /* enum <a class="link" href="media.html#v4l2-buf-type" title="Table 3.3. enum v4l2_buf_type">v4l2_buf_type</a> */
        union {
                struct <a class="link" href="media.html#v4l2-captureparm" title="Table A.78. struct v4l2_captureparm">v4l2_captureparm</a> capture;
                struct <a class="link" href="media.html#v4l2-outputparm" title="Table A.79. struct v4l2_outputparm">v4l2_outputparm</a>  output;
                __u8    raw_data[200];  /* user-defined */
        } parm;
};

/*
 *      E V E N T S
 */

#define V4L2_EVENT_ALL                          0
#define V4L2_EVENT_VSYNC                        1
#define V4L2_EVENT_EOS                          2
#define V4L2_EVENT_CTRL                         3
#define V4L2_EVENT_FRAME_SYNC                   4
#define V4L2_EVENT_SOURCE_CHANGE                5
#define V4L2_EVENT_MOTION_DET                   6
#define V4L2_EVENT_PRIVATE_START                0x08000000

/* Payload for V4L2_EVENT_VSYNC */
struct <a class="link" href="media.html#v4l2-event-vsync" title="Table A.13. struct v4l2_event_vsync">v4l2_event_vsync</a> {
        /* Can be V4L2_FIELD_ANY, _NONE, _TOP or _BOTTOM */
        __u8 field;
} __attribute__ ((packed));

/* Payload for V4L2_EVENT_CTRL */
#define V4L2_EVENT_CTRL_CH_VALUE                (1 &lt;&lt; 0)
#define V4L2_EVENT_CTRL_CH_FLAGS                (1 &lt;&lt; 1)
#define V4L2_EVENT_CTRL_CH_RANGE                (1 &lt;&lt; 2)

struct <a class="link" href="media.html#v4l2-event-ctrl" title="Table A.14. struct v4l2_event_ctrl">v4l2_event_ctrl</a> {
        __u32 changes;
        __u32 type;
        union {
                __s32 value;
                __s64 value64;
        };
        __u32 flags;
        __s32 minimum;
        __s32 maximum;
        __s32 step;
        __s32 default_value;
};

struct <a class="link" href="media.html#v4l2-event-frame-sync" title="Table A.15. struct v4l2_event_frame_sync">v4l2_event_frame_sync</a> {
        __u32 frame_sequence;
};

#define V4L2_EVENT_SRC_CH_RESOLUTION            (1 &lt;&lt; 0)

struct <a class="link" href="media.html#v4l2-event-src-change" title="Table A.16. struct v4l2_event_src_change">v4l2_event_src_change</a> {
        __u32 changes;
};

#define V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ (1 &lt;&lt; 0)

/**
 * struct <a class="link" href="media.html#v4l2-event-motion-det" title="Table A.17. struct v4l2_event_motion_det">v4l2_event_motion_det</a> - motion detection event
 * @flags:             if V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ is set, then the
 *                     frame_sequence field is valid.
 * @frame_sequence:    the frame sequence number associated with this event.
 * @region_mask:       which regions detected motion.
 */
struct <a class="link" href="media.html#v4l2-event-motion-det" title="Table A.17. struct v4l2_event_motion_det">v4l2_event_motion_det</a> {
        __u32 flags;
        __u32 frame_sequence;
        __u32 region_mask;
};

struct <a class="link" href="media.html#v4l2-event" title="Table A.12. struct v4l2_event">v4l2_event</a> {
        __u32                           type;
        union {
                struct <a class="link" href="media.html#v4l2-event-vsync" title="Table A.13. struct v4l2_event_vsync">v4l2_event_vsync</a>         vsync;
                struct <a class="link" href="media.html#v4l2-event-ctrl" title="Table A.14. struct v4l2_event_ctrl">v4l2_event_ctrl</a>          ctrl;
                struct <a class="link" href="media.html#v4l2-event-frame-sync" title="Table A.15. struct v4l2_event_frame_sync">v4l2_event_frame_sync</a>    frame_sync;
                struct <a class="link" href="media.html#v4l2-event-src-change" title="Table A.16. struct v4l2_event_src_change">v4l2_event_src_change</a>    src_change;
                struct <a class="link" href="media.html#v4l2-event-motion-det" title="Table A.17. struct v4l2_event_motion_det">v4l2_event_motion_det</a>    motion_det;
                __u8                            data[64];
        } u;
        __u32                           pending;
        __u32                           sequence;
        struct timespec                 timestamp;
        __u32                           id;
        __u32                           reserved[8];
};

#define V4L2_EVENT_SUB_FL_SEND_INITIAL          (1 &lt;&lt; 0)
#define V4L2_EVENT_SUB_FL_ALLOW_FEEDBACK        (1 &lt;&lt; 1)

struct <a class="link" href="media.html#v4l2-event-subscription" title="Table A.109. struct v4l2_event_subscription">v4l2_event_subscription</a> {
        __u32                           type;
        __u32                           id;
        __u32                           flags;
        __u32                           reserved[5];
};

/*
 *      A D V A N C E D   D E B U G G I N G
 *
 *      NOTE: EXPERIMENTAL API, NEVER RELY ON THIS IN APPLICATIONS!
 *      FOR DEBUGGING, TESTING AND INTERNAL USE ONLY!
 */

/* VIDIOC_DBG_G_REGISTER and VIDIOC_DBG_S_REGISTER */

#define V4L2_CHIP_MATCH_BRIDGE      0  /* Match against chip ID on the bridge (0 for the bridge) */
#define V4L2_CHIP_MATCH_SUBDEV      4  /* Match against subdev index */

/* The following four defines are no longer in use */
#define V4L2_CHIP_MATCH_HOST V4L2_CHIP_MATCH_BRIDGE
#define V4L2_CHIP_MATCH_I2C_DRIVER  1  /* Match against I2C driver name */
#define V4L2_CHIP_MATCH_I2C_ADDR    2  /* Match against I2C 7-bit address */
#define V4L2_CHIP_MATCH_AC97        3  /* Match against ancillary AC97 chip */

struct <a class="link" href="media.html#v4l2-dbg-match" title="Table A.7. struct v4l2_dbg_match">v4l2_dbg_match</a> {
        __u32 type; /* Match type */
        union {     /* Match this chip, meaning determined by type */
                __u32 addr;
                char name[32];
        };
} __attribute__ ((packed));

struct <a class="link" href="media.html#v4l2-dbg-register" title="Table A.8. struct v4l2_dbg_register">v4l2_dbg_register</a> {
        struct <a class="link" href="media.html#v4l2-dbg-match" title="Table A.7. struct v4l2_dbg_match">v4l2_dbg_match</a> match;
        __u32 size;     /* register size in bytes */
        __u64 reg;
        __u64 val;
} __attribute__ ((packed));

#define V4L2_CHIP_FL_READABLE (1 &lt;&lt; 0)
#define V4L2_CHIP_FL_WRITABLE (1 &lt;&lt; 1)

/* VIDIOC_DBG_G_CHIP_INFO */
struct <a class="link" href="media.html#v4l2-dbg-chip-info" title="Table A.5. struct v4l2_dbg_chip_info">v4l2_dbg_chip_info</a> {
        struct <a class="link" href="media.html#v4l2-dbg-match" title="Table A.7. struct v4l2_dbg_match">v4l2_dbg_match</a> match;
        char name[32];
        __u32 flags;
        __u32 reserved[32];
} __attribute__ ((packed));

/**
 * struct <a class="link" href="media.html#v4l2-create-buffers" title="Table A.1. struct v4l2_create_buffers">v4l2_create_buffers</a> - VIDIOC_CREATE_BUFS argument
 * @index:      on return, index of the first created buffer
 * @count:      entry: number of requested buffers,
 *              return: number of created buffers
 * @memory:     enum <a class="link" href="media.html#v4l2-memory" title="Table 3.5. enum v4l2_memory">v4l2_memory</a>; buffer memory type
 * @format:     frame format, for which buffers are requested
 * @reserved:   future extensions
 */
struct <a class="link" href="media.html#v4l2-create-buffers" title="Table A.1. struct v4l2_create_buffers">v4l2_create_buffers</a> {
        __u32                   index;
        __u32                   count;
        __u32                   memory;
        struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a>      format;
        __u32                   reserved[8];
};

/*
 *      I O C T L   C O D E S   F O R   V I D E O   D E V I C E S
 *
 */
#define VIDIOC_QUERYCAP          _IOR('V',  0, struct <a class="link" href="media.html#v4l2-capability" title="Table A.92. struct v4l2_capability">v4l2_capability</a>)
#define VIDIOC_RESERVED           _IO('V',  1)
#define VIDIOC_ENUM_FMT         _IOWR('V',  2, struct <a class="link" href="media.html#v4l2-fmtdesc" title="Table A.27. struct v4l2_fmtdesc">v4l2_fmtdesc</a>)
#define VIDIOC_G_FMT            _IOWR('V',  4, struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a>)
#define VIDIOC_S_FMT            _IOWR('V',  5, struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a>)
#define VIDIOC_REQBUFS          _IOWR('V',  8, struct <a class="link" href="media.html#v4l2-requestbuffers" title="Table A.99. struct v4l2_requestbuffers">v4l2_requestbuffers</a>)
#define VIDIOC_QUERYBUF         _IOWR('V',  9, struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a>)
#define VIDIOC_G_FBUF            _IOR('V', 10, struct <a class="link" href="media.html#v4l2-framebuffer" title="Table A.68. struct v4l2_framebuffer">v4l2_framebuffer</a>)
#define VIDIOC_S_FBUF            _IOW('V', 11, struct <a class="link" href="media.html#v4l2-framebuffer" title="Table A.68. struct v4l2_framebuffer">v4l2_framebuffer</a>)
#define VIDIOC_OVERLAY           _IOW('V', 14, int)
#define VIDIOC_QBUF             _IOWR('V', 15, struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a>)
#define VIDIOC_EXPBUF           _IOWR('V', 16, struct <a class="link" href="media.html#v4l2-exportbuffer" title="Table A.49. struct v4l2_exportbuffer">v4l2_exportbuffer</a>)
#define VIDIOC_DQBUF            _IOWR('V', 17, struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a>)
#define VIDIOC_STREAMON          _IOW('V', 18, int)
#define VIDIOC_STREAMOFF         _IOW('V', 19, int)
#define VIDIOC_G_PARM           _IOWR('V', 21, struct <a class="link" href="media.html#v4l2-streamparm" title="Table A.77. struct v4l2_streamparm">v4l2_streamparm</a>)
#define VIDIOC_S_PARM           _IOWR('V', 22, struct <a class="link" href="media.html#v4l2-streamparm" title="Table A.77. struct v4l2_streamparm">v4l2_streamparm</a>)
#define VIDIOC_G_STD             _IOR('V', 23, v4l2_std_id)
#define VIDIOC_S_STD             _IOW('V', 24, v4l2_std_id)
#define VIDIOC_ENUMSTD          _IOWR('V', 25, struct <a class="link" href="media.html#v4l2-standard" title="Table A.45. struct v4l2_standard">v4l2_standard</a>)
#define VIDIOC_ENUMINPUT        _IOWR('V', 26, struct <a class="link" href="media.html#v4l2-input" title="Table A.38. struct v4l2_input">v4l2_input</a>)
#define VIDIOC_G_CTRL           _IOWR('V', 27, struct <a class="link" href="media.html#v4l2-control" title="Table A.55. struct v4l2_control">v4l2_control</a>)
#define VIDIOC_S_CTRL           _IOWR('V', 28, struct <a class="link" href="media.html#v4l2-control" title="Table A.55. struct v4l2_control">v4l2_control</a>)
#define VIDIOC_G_TUNER          _IOWR('V', 29, struct <a class="link" href="media.html#v4l2-tuner" title="Table A.86. struct v4l2_tuner">v4l2_tuner</a>)
#define VIDIOC_S_TUNER           _IOW('V', 30, struct <a class="link" href="media.html#v4l2-tuner" title="Table A.86. struct v4l2_tuner">v4l2_tuner</a>)
#define VIDIOC_G_AUDIO           _IOR('V', 33, struct <a class="link" href="media.html#v4l2-audio" title="Table A.50. struct v4l2_audio">v4l2_audio</a>)
#define VIDIOC_S_AUDIO           _IOW('V', 34, struct <a class="link" href="media.html#v4l2-audio" title="Table A.50. struct v4l2_audio">v4l2_audio</a>)
#define VIDIOC_QUERYCTRL        _IOWR('V', 36, struct <a class="link" href="media.html#v4l2-queryctrl" title="Table A.94. struct v4l2_queryctrl">v4l2_queryctrl</a>)
#define VIDIOC_QUERYMENU        _IOWR('V', 37, struct <a class="link" href="media.html#v4l2-querymenu" title="Table A.96. struct v4l2_querymenu">v4l2_querymenu</a>)
#define VIDIOC_G_INPUT           _IOR('V', 38, int)
#define VIDIOC_S_INPUT          _IOWR('V', 39, int)
#define VIDIOC_G_EDID           _IOWR('V', 40, struct <a class="link" href="media.html#v4l2-edid" title="Table A.61. struct v4l2_edid">v4l2_edid</a>)
#define VIDIOC_S_EDID           _IOWR('V', 41, struct <a class="link" href="media.html#v4l2-edid" title="Table A.61. struct v4l2_edid">v4l2_edid</a>)
#define VIDIOC_G_OUTPUT          _IOR('V', 46, int)
#define VIDIOC_S_OUTPUT         _IOWR('V', 47, int)
#define VIDIOC_ENUMOUTPUT       _IOWR('V', 48, struct <a class="link" href="media.html#v4l2-output" title="Table A.42. struct v4l2_output">v4l2_output</a>)
#define VIDIOC_G_AUDOUT          _IOR('V', 49, struct <a class="link" href="media.html#v4l2-audioout" title="Table A.53. struct v4l2_audioout">v4l2_audioout</a>)
#define VIDIOC_S_AUDOUT          _IOW('V', 50, struct <a class="link" href="media.html#v4l2-audioout" title="Table A.53. struct v4l2_audioout">v4l2_audioout</a>)
#define VIDIOC_G_MODULATOR      _IOWR('V', 54, struct <a class="link" href="media.html#v4l2-modulator" title="Table A.75. struct v4l2_modulator">v4l2_modulator</a>)
#define VIDIOC_S_MODULATOR       _IOW('V', 55, struct <a class="link" href="media.html#v4l2-modulator" title="Table A.75. struct v4l2_modulator">v4l2_modulator</a>)
#define VIDIOC_G_FREQUENCY      _IOWR('V', 56, struct <a class="link" href="media.html#v4l2-frequency" title="Table A.72. struct v4l2_frequency">v4l2_frequency</a>)
#define VIDIOC_S_FREQUENCY       _IOW('V', 57, struct <a class="link" href="media.html#v4l2-frequency" title="Table A.72. struct v4l2_frequency">v4l2_frequency</a>)
#define VIDIOC_CROPCAP          _IOWR('V', 58, struct <a class="link" href="media.html#v4l2-cropcap" title="Table A.2. struct v4l2_cropcap">v4l2_cropcap</a>)
#define VIDIOC_G_CROP           _IOWR('V', 59, struct <a class="link" href="media.html#v4l2-crop" title="Table A.54. struct v4l2_crop">v4l2_crop</a>)
#define VIDIOC_S_CROP            _IOW('V', 60, struct <a class="link" href="media.html#v4l2-crop" title="Table A.54. struct v4l2_crop">v4l2_crop</a>)
#define VIDIOC_G_JPEGCOMP        _IOR('V', 61, struct <a class="link" href="media.html#v4l2-jpegcompression" title="Table A.73. struct v4l2_jpegcompression">v4l2_jpegcompression</a>)
#define VIDIOC_S_JPEGCOMP        _IOW('V', 62, struct <a class="link" href="media.html#v4l2-jpegcompression" title="Table A.73. struct v4l2_jpegcompression">v4l2_jpegcompression</a>)
#define VIDIOC_QUERYSTD          _IOR('V', 63, v4l2_std_id)
#define VIDIOC_TRY_FMT          _IOWR('V', 64, struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a>)
#define VIDIOC_ENUMAUDIO        _IOWR('V', 65, struct <a class="link" href="media.html#v4l2-audio" title="Table A.50. struct v4l2_audio">v4l2_audio</a>)
#define VIDIOC_ENUMAUDOUT       _IOWR('V', 66, struct <a class="link" href="media.html#v4l2-audioout" title="Table A.53. struct v4l2_audioout">v4l2_audioout</a>)
#define VIDIOC_G_PRIORITY        _IOR('V', 67, __u32) /* enum <a class="link" href="media.html#v4l2-priority" title="Table A.82. enum v4l2_priority">v4l2_priority</a> */
#define VIDIOC_S_PRIORITY        _IOW('V', 68, __u32) /* enum <a class="link" href="media.html#v4l2-priority" title="Table A.82. enum v4l2_priority">v4l2_priority</a> */
#define VIDIOC_G_SLICED_VBI_CAP _IOWR('V', 69, struct <a class="link" href="media.html#v4l2-sliced-vbi-cap" title="Table A.84. struct v4l2_sliced_vbi_cap">v4l2_sliced_vbi_cap</a>)
#define VIDIOC_LOG_STATUS         _IO('V', 70)
#define VIDIOC_G_EXT_CTRLS      _IOWR('V', 71, struct <a class="link" href="media.html#v4l2-ext-controls" title="Table A.66. struct v4l2_ext_controls">v4l2_ext_controls</a>)
#define VIDIOC_S_EXT_CTRLS      _IOWR('V', 72, struct <a class="link" href="media.html#v4l2-ext-controls" title="Table A.66. struct v4l2_ext_controls">v4l2_ext_controls</a>)
#define VIDIOC_TRY_EXT_CTRLS    _IOWR('V', 73, struct <a class="link" href="media.html#v4l2-ext-controls" title="Table A.66. struct v4l2_ext_controls">v4l2_ext_controls</a>)
#define VIDIOC_ENUM_FRAMESIZES  _IOWR('V', 74, struct <a class="link" href="media.html#v4l2-frmsizeenum" title="Table A.31. struct v4l2_frmsizeenum">v4l2_frmsizeenum</a>)
#define VIDIOC_ENUM_FRAMEINTERVALS _IOWR('V', 75, struct <a class="link" href="media.html#v4l2-frmivalenum" title="Table A.34. struct v4l2_frmivalenum">v4l2_frmivalenum</a>)
#define VIDIOC_G_ENC_INDEX       _IOR('V', 76, struct <a class="link" href="media.html#v4l2-enc-idx" title="Table A.62. struct v4l2_enc_idx">v4l2_enc_idx</a>)
#define VIDIOC_ENCODER_CMD      _IOWR('V', 77, struct <a class="link" href="media.html#v4l2-encoder-cmd" title="Table A.23. struct v4l2_encoder_cmd">v4l2_encoder_cmd</a>)
#define VIDIOC_TRY_ENCODER_CMD  _IOWR('V', 78, struct <a class="link" href="media.html#v4l2-encoder-cmd" title="Table A.23. struct v4l2_encoder_cmd">v4l2_encoder_cmd</a>)

/* Experimental, meant for debugging, testing and internal use.
   Only implemented if CONFIG_VIDEO_ADV_DEBUG is defined.
   You must be root to use these ioctls. Never use these in applications! */
#define VIDIOC_DBG_S_REGISTER    _IOW('V', 79, struct <a class="link" href="media.html#v4l2-dbg-register" title="Table A.8. struct v4l2_dbg_register">v4l2_dbg_register</a>)
#define VIDIOC_DBG_G_REGISTER   _IOWR('V', 80, struct <a class="link" href="media.html#v4l2-dbg-register" title="Table A.8. struct v4l2_dbg_register">v4l2_dbg_register</a>)

#define VIDIOC_S_HW_FREQ_SEEK    _IOW('V', 82, struct <a class="link" href="media.html#v4l2-hw-freq-seek" title="Table A.100. struct v4l2_hw_freq_seek">v4l2_hw_freq_seek</a>)

#define VIDIOC_S_DV_TIMINGS     _IOWR('V', 87, struct <a class="link" href="media.html#v4l2-dv-timings" title="Table A.57. struct v4l2_dv_timings">v4l2_dv_timings</a>)
#define VIDIOC_G_DV_TIMINGS     _IOWR('V', 88, struct <a class="link" href="media.html#v4l2-dv-timings" title="Table A.57. struct v4l2_dv_timings">v4l2_dv_timings</a>)
#define VIDIOC_DQEVENT           _IOR('V', 89, struct <a class="link" href="media.html#v4l2-event" title="Table A.12. struct v4l2_event">v4l2_event</a>)
#define VIDIOC_SUBSCRIBE_EVENT   _IOW('V', 90, struct <a class="link" href="media.html#v4l2-event-subscription" title="Table A.109. struct v4l2_event_subscription">v4l2_event_subscription</a>)
#define VIDIOC_UNSUBSCRIBE_EVENT _IOW('V', 91, struct <a class="link" href="media.html#v4l2-event-subscription" title="Table A.109. struct v4l2_event_subscription">v4l2_event_subscription</a>)

/* Experimental, the below two ioctls may change over the next couple of kernel
   versions */
#define VIDIOC_CREATE_BUFS      _IOWR('V', 92, struct <a class="link" href="media.html#v4l2-create-buffers" title="Table A.1. struct v4l2_create_buffers">v4l2_create_buffers</a>)
#define VIDIOC_PREPARE_BUF      _IOWR('V', 93, struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a>)

/* Experimental selection API */
#define VIDIOC_G_SELECTION      _IOWR('V', 94, struct <a class="link" href="media.html#v4l2-selection" title="Table A.83. struct v4l2_selection">v4l2_selection</a>)
#define VIDIOC_S_SELECTION      _IOWR('V', 95, struct <a class="link" href="media.html#v4l2-selection" title="Table A.83. struct v4l2_selection">v4l2_selection</a>)

/* Experimental, these two ioctls may change over the next couple of kernel
   versions. */
#define VIDIOC_DECODER_CMD      _IOWR('V', 96, struct <a class="link" href="media.html#v4l2-decoder-cmd" title="Table A.10. struct v4l2_decoder_cmd">v4l2_decoder_cmd</a>)
#define VIDIOC_TRY_DECODER_CMD  _IOWR('V', 97, struct <a class="link" href="media.html#v4l2-decoder-cmd" title="Table A.10. struct v4l2_decoder_cmd">v4l2_decoder_cmd</a>)

/* Experimental, these three ioctls may change over the next couple of kernel
   versions. */
#define VIDIOC_ENUM_DV_TIMINGS  _IOWR('V', 98, struct <a class="link" href="media.html#v4l2-enum-dv-timings" title="Table A.26. struct v4l2_enum_dv_timings">v4l2_enum_dv_timings</a>)
#define VIDIOC_QUERY_DV_TIMINGS  _IOR('V', 99, struct <a class="link" href="media.html#v4l2-dv-timings" title="Table A.57. struct v4l2_dv_timings">v4l2_dv_timings</a>)
#define VIDIOC_DV_TIMINGS_CAP   _IOWR('V', 100, struct <a class="link" href="media.html#v4l2-dv-timings-cap" title="Table A.21. struct v4l2_dv_timings_cap">v4l2_dv_timings_cap</a>)

/* Experimental, this ioctl may change over the next couple of kernel
   versions. */
#define VIDIOC_ENUM_FREQ_BANDS  _IOWR('V', 101, struct <a class="link" href="media.html#v4l2-frequency-band" title="Table A.36. struct v4l2_frequency_band">v4l2_frequency_band</a>)

/* Experimental, meant for debugging, testing and internal use.
   Never use these in applications! */
#define VIDIOC_DBG_G_CHIP_INFO  _IOWR('V', 102, struct <a class="link" href="media.html#v4l2-dbg-chip-info" title="Table A.5. struct v4l2_dbg_chip_info">v4l2_dbg_chip_info</a>)

#define VIDIOC_QUERY_EXT_CTRL   _IOWR('V', 103, struct <a class="link" href="media.html#v4l2-query-ext-ctrl" title="Table A.95. struct v4l2_query_ext_ctrl">v4l2_query_ext_ctrl</a>)

/* Reminder: when adding new ioctls please add support for them to
   drivers/media/video/v4l2-compat-ioctl32.c as well! */

#define BASE_VIDIOC_PRIVATE     192             /* 192-255 are private */

#endif /* _UAPI__LINUX_VIDEODEV2_H */
</pre></div><div class="appendix"><div class="titlepage"><div><div><h2 class="title"><a name="capture-example"></a>Appendix D. Video Capture Example</h2></div></div></div><pre class="programlisting">
/*
 *  V4L2 video capture example
 *
 *  This program can be used and distributed without restrictions.
 *
 *      This program is provided with the V4L2 API
 * see http://linuxtv.org/docs.php for more information
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

#include &lt;getopt.h&gt;             /* getopt_long() */

#include &lt;fcntl.h&gt;              /* low-level i/o */
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/ioctl.h&gt;

#include &lt;linux/videodev2.h&gt;

#define CLEAR(x) memset(&amp;(x), 0, sizeof(x))

enum io_method {
        IO_METHOD_READ,
        IO_METHOD_MMAP,
        IO_METHOD_USERPTR,
};

struct buffer {
        void   *start;
        size_t  length;
};

static char            *dev_name;
static enum io_method   io = IO_METHOD_MMAP;
static int              fd = -1;
struct buffer          *buffers;
static unsigned int     n_buffers;
static int              out_buf;
static int              force_format;
static int              frame_count = 70;

static void errno_exit(const char *s)
{
        fprintf(stderr, "%s error %d, %s\n", s, errno, strerror(errno));
        exit(EXIT_FAILURE);
}

static int xioctl(int fh, int request, void *arg)
{
        int r;

        do {
                r = ioctl(fh, request, arg);
        } while (-1 == r &amp;&amp; EINTR == errno);

        return r;
}

static void process_image(const void *p, int size)
{
        if (out_buf)
                fwrite(p, size, 1, stdout);

        fflush(stderr);
        fprintf(stderr, ".");
        fflush(stdout);
}

static int read_frame(void)
{
        struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a> buf;
        unsigned int i;

        switch (io) {
        case IO_METHOD_READ:
                if (-1 == read(fd, buffers[0].start, buffers[0].length)) {
                        switch (errno) {
                        case EAGAIN:
                                return 0;

                        case EIO:
                                /* Could ignore EIO, see spec. */

                                /* fall through */

                        default:
                                errno_exit("read");
                        }
                }

                process_image(buffers[0].start, buffers[0].length);
                break;

        case IO_METHOD_MMAP:
                CLEAR(buf);

                buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
                buf.memory = V4L2_MEMORY_MMAP;

                if (-1 == xioctl(fd, VIDIOC_DQBUF, &amp;buf)) {
                        switch (errno) {
                        case EAGAIN:
                                return 0;

                        case EIO:
                                /* Could ignore EIO, see spec. */

                                /* fall through */

                        default:
                                errno_exit("VIDIOC_DQBUF");
                        }
                }

                assert(buf.index &lt; n_buffers);

                process_image(buffers[buf.index].start, buf.bytesused);

                if (-1 == xioctl(fd, VIDIOC_QBUF, &amp;buf))
                        errno_exit("VIDIOC_QBUF");
                break;

        case IO_METHOD_USERPTR:
                CLEAR(buf);

                buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
                buf.memory = V4L2_MEMORY_USERPTR;

                if (-1 == xioctl(fd, VIDIOC_DQBUF, &amp;buf)) {
                        switch (errno) {
                        case EAGAIN:
                                return 0;

                        case EIO:
                                /* Could ignore EIO, see spec. */

                                /* fall through */

                        default:
                                errno_exit("VIDIOC_DQBUF");
                        }
                }

                for (i = 0; i &lt; n_buffers; ++i)
                        if (buf.m.userptr == (unsigned long)buffers[i].start
                            &amp;&amp; buf.length == buffers[i].length)
                                break;

                assert(i &lt; n_buffers);

                process_image((void *)buf.m.userptr, buf.bytesused);

                if (-1 == xioctl(fd, VIDIOC_QBUF, &amp;buf))
                        errno_exit("VIDIOC_QBUF");
                break;
        }

        return 1;
}

static void mainloop(void)
{
        unsigned int count;

        count = frame_count;

        while (count-- &gt; 0) {
                for (;;) {
                        fd_set fds;
                        struct timeval tv;
                        int r;

                        FD_ZERO(&amp;fds);
                        FD_SET(fd, &amp;fds);

                        /* Timeout. */
                        tv.tv_sec = 2;
                        tv.tv_usec = 0;

                        r = select(fd + 1, &amp;fds, NULL, NULL, &amp;tv);

                        if (-1 == r) {
                                if (EINTR == errno)
                                        continue;
                                errno_exit("select");
                        }

                        if (0 == r) {
                                fprintf(stderr, "select timeout\n");
                                exit(EXIT_FAILURE);
                        }

                        if (read_frame())
                                break;
                        /* EAGAIN - continue select loop. */
                }
        }
}

static void stop_capturing(void)
{
        enum <a class="link" href="media.html#v4l2-buf-type" title="Table 3.3. enum v4l2_buf_type">v4l2_buf_type</a> type;

        switch (io) {
        case IO_METHOD_READ:
                /* Nothing to do. */
                break;

        case IO_METHOD_MMAP:
        case IO_METHOD_USERPTR:
                type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
                if (-1 == xioctl(fd, VIDIOC_STREAMOFF, &amp;type))
                        errno_exit("VIDIOC_STREAMOFF");
                break;
        }
}

static void start_capturing(void)
{
        unsigned int i;
        enum <a class="link" href="media.html#v4l2-buf-type" title="Table 3.3. enum v4l2_buf_type">v4l2_buf_type</a> type;

        switch (io) {
        case IO_METHOD_READ:
                /* Nothing to do. */
                break;

        case IO_METHOD_MMAP:
                for (i = 0; i &lt; n_buffers; ++i) {
                        struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a> buf;

                        CLEAR(buf);
                        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
                        buf.memory = V4L2_MEMORY_MMAP;
                        buf.index = i;

                        if (-1 == xioctl(fd, VIDIOC_QBUF, &amp;buf))
                                errno_exit("VIDIOC_QBUF");
                }
                type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
                if (-1 == xioctl(fd, VIDIOC_STREAMON, &amp;type))
                        errno_exit("VIDIOC_STREAMON");
                break;

        case IO_METHOD_USERPTR:
                for (i = 0; i &lt; n_buffers; ++i) {
                        struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a> buf;

                        CLEAR(buf);
                        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
                        buf.memory = V4L2_MEMORY_USERPTR;
                        buf.index = i;
                        buf.m.userptr = (unsigned long)buffers[i].start;
                        buf.length = buffers[i].length;

                        if (-1 == xioctl(fd, VIDIOC_QBUF, &amp;buf))
                                errno_exit("VIDIOC_QBUF");
                }
                type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
                if (-1 == xioctl(fd, VIDIOC_STREAMON, &amp;type))
                        errno_exit("VIDIOC_STREAMON");
                break;
        }
}

static void uninit_device(void)
{
        unsigned int i;

        switch (io) {
        case IO_METHOD_READ:
                free(buffers[0].start);
                break;

        case IO_METHOD_MMAP:
                for (i = 0; i &lt; n_buffers; ++i)
                        if (-1 == munmap(buffers[i].start, buffers[i].length))
                                errno_exit("munmap");
                break;

        case IO_METHOD_USERPTR:
                for (i = 0; i &lt; n_buffers; ++i)
                        free(buffers[i].start);
                break;
        }

        free(buffers);
}

static void init_read(unsigned int buffer_size)
{
        buffers = calloc(1, sizeof(*buffers));

        if (!buffers) {
                fprintf(stderr, "Out of memory\n");
                exit(EXIT_FAILURE);
        }

        buffers[0].length = buffer_size;
        buffers[0].start = malloc(buffer_size);

        if (!buffers[0].start) {
                fprintf(stderr, "Out of memory\n");
                exit(EXIT_FAILURE);
        }
}

static void init_mmap(void)
{
        struct <a class="link" href="media.html#v4l2-requestbuffers" title="Table A.99. struct v4l2_requestbuffers">v4l2_requestbuffers</a> req;

        CLEAR(req);

        req.count = 4;
        req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
        req.memory = V4L2_MEMORY_MMAP;

        if (-1 == xioctl(fd, VIDIOC_REQBUFS, &amp;req)) {
                if (EINVAL == errno) {
                        fprintf(stderr, "%s does not support "
                                 "memory mapping\n", dev_name);
                        exit(EXIT_FAILURE);
                } else {
                        errno_exit("VIDIOC_REQBUFS");
                }
        }

        if (req.count &lt; 2) {
                fprintf(stderr, "Insufficient buffer memory on %s\n",
                         dev_name);
                exit(EXIT_FAILURE);
        }

        buffers = calloc(req.count, sizeof(*buffers));

        if (!buffers) {
                fprintf(stderr, "Out of memory\n");
                exit(EXIT_FAILURE);
        }

        for (n_buffers = 0; n_buffers &lt; req.count; ++n_buffers) {
                struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a> buf;

                CLEAR(buf);

                buf.type        = V4L2_BUF_TYPE_VIDEO_CAPTURE;
                buf.memory      = V4L2_MEMORY_MMAP;
                buf.index       = n_buffers;

                if (-1 == xioctl(fd, VIDIOC_QUERYBUF, &amp;buf))
                        errno_exit("VIDIOC_QUERYBUF");

                buffers[n_buffers].length = buf.length;
                buffers[n_buffers].start =
                        mmap(NULL /* start anywhere */,
                              buf.length,
                              PROT_READ | PROT_WRITE /* required */,
                              MAP_SHARED /* recommended */,
                              fd, buf.m.offset);

                if (MAP_FAILED == buffers[n_buffers].start)
                        errno_exit("mmap");
        }
}

static void init_userp(unsigned int buffer_size)
{
        struct <a class="link" href="media.html#v4l2-requestbuffers" title="Table A.99. struct v4l2_requestbuffers">v4l2_requestbuffers</a> req;

        CLEAR(req);

        req.count  = 4;
        req.type   = V4L2_BUF_TYPE_VIDEO_CAPTURE;
        req.memory = V4L2_MEMORY_USERPTR;

        if (-1 == xioctl(fd, VIDIOC_REQBUFS, &amp;req)) {
                if (EINVAL == errno) {
                        fprintf(stderr, "%s does not support "
                                 "user pointer i/o\n", dev_name);
                        exit(EXIT_FAILURE);
                } else {
                        errno_exit("VIDIOC_REQBUFS");
                }
        }

        buffers = calloc(4, sizeof(*buffers));

        if (!buffers) {
                fprintf(stderr, "Out of memory\n");
                exit(EXIT_FAILURE);
        }

        for (n_buffers = 0; n_buffers &lt; 4; ++n_buffers) {
                buffers[n_buffers].length = buffer_size;
                buffers[n_buffers].start = malloc(buffer_size);

                if (!buffers[n_buffers].start) {
                        fprintf(stderr, "Out of memory\n");
                        exit(EXIT_FAILURE);
                }
        }
}

static void init_device(void)
{
        struct <a class="link" href="media.html#v4l2-capability" title="Table A.92. struct v4l2_capability">v4l2_capability</a> cap;
        struct <a class="link" href="media.html#v4l2-cropcap" title="Table A.2. struct v4l2_cropcap">v4l2_cropcap</a> cropcap;
        struct <a class="link" href="media.html#v4l2-crop" title="Table A.54. struct v4l2_crop">v4l2_crop</a> crop;
        struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a> fmt;
        unsigned int min;

        if (-1 == xioctl(fd, VIDIOC_QUERYCAP, &amp;cap)) {
                if (EINVAL == errno) {
                        fprintf(stderr, "%s is no V4L2 device\n",
                                 dev_name);
                        exit(EXIT_FAILURE);
                } else {
                        errno_exit("VIDIOC_QUERYCAP");
                }
        }

        if (!(cap.capabilities &amp; V4L2_CAP_VIDEO_CAPTURE)) {
                fprintf(stderr, "%s is no video capture device\n",
                         dev_name);
                exit(EXIT_FAILURE);
        }

        switch (io) {
        case IO_METHOD_READ:
                if (!(cap.capabilities &amp; V4L2_CAP_READWRITE)) {
                        fprintf(stderr, "%s does not support read i/o\n",
                                 dev_name);
                        exit(EXIT_FAILURE);
                }
                break;

        case IO_METHOD_MMAP:
        case IO_METHOD_USERPTR:
                if (!(cap.capabilities &amp; V4L2_CAP_STREAMING)) {
                        fprintf(stderr, "%s does not support streaming i/o\n",
                                 dev_name);
                        exit(EXIT_FAILURE);
                }
                break;
        }


        /* Select video input, video standard and tune here. */


        CLEAR(cropcap);

        cropcap.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

        if (0 == xioctl(fd, VIDIOC_CROPCAP, &amp;cropcap)) {
                crop.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
                crop.c = cropcap.defrect; /* reset to default */

                if (-1 == xioctl(fd, VIDIOC_S_CROP, &amp;crop)) {
                        switch (errno) {
                        case EINVAL:
                                /* Cropping not supported. */
                                break;
                        default:
                                /* Errors ignored. */
                                break;
                        }
                }
        } else {
                /* Errors ignored. */
        }


        CLEAR(fmt);

        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
        if (force_format) {
                fmt.fmt.pix.width       = 640;
                fmt.fmt.pix.height      = 480;
                fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUYV;
                fmt.fmt.pix.field       = V4L2_FIELD_INTERLACED;

                if (-1 == xioctl(fd, VIDIOC_S_FMT, &amp;fmt))
                        errno_exit("VIDIOC_S_FMT");

                /* Note VIDIOC_S_FMT may change width and height. */
        } else {
                /* Preserve original settings as set by v4l2-ctl for example */
                if (-1 == xioctl(fd, VIDIOC_G_FMT, &amp;fmt))
                        errno_exit("VIDIOC_G_FMT");
        }

        /* Buggy driver paranoia. */
        min = fmt.fmt.pix.width * 2;
        if (fmt.fmt.pix.bytesperline &lt; min)
                fmt.fmt.pix.bytesperline = min;
        min = fmt.fmt.pix.bytesperline * fmt.fmt.pix.height;
        if (fmt.fmt.pix.sizeimage &lt; min)
                fmt.fmt.pix.sizeimage = min;

        switch (io) {
        case IO_METHOD_READ:
                init_read(fmt.fmt.pix.sizeimage);
                break;

        case IO_METHOD_MMAP:
                init_mmap();
                break;

        case IO_METHOD_USERPTR:
                init_userp(fmt.fmt.pix.sizeimage);
                break;
        }
}

static void close_device(void)
{
        if (-1 == close(fd))
                errno_exit("close");

        fd = -1;
}

static void open_device(void)
{
        struct stat st;

        if (-1 == stat(dev_name, &amp;st)) {
                fprintf(stderr, "Cannot identify '%s': %d, %s\n",
                         dev_name, errno, strerror(errno));
                exit(EXIT_FAILURE);
        }

        if (!S_ISCHR(st.st_mode)) {
                fprintf(stderr, "%s is no device\n", dev_name);
                exit(EXIT_FAILURE);
        }

        fd = open(dev_name, O_RDWR /* required */ | O_NONBLOCK, 0);

        if (-1 == fd) {
                fprintf(stderr, "Cannot open '%s': %d, %s\n",
                         dev_name, errno, strerror(errno));
                exit(EXIT_FAILURE);
        }
}

static void usage(FILE *fp, int argc, char **argv)
{
        fprintf(fp,
                 "Usage: %s [options]\n\n"
                 "Version 1.3\n"
                 "Options:\n"
                 "-d | --device name   Video device name [%s]\n"
                 "-h | --help          Print this message\n"
                 "-m | --mmap          Use memory mapped buffers [default]\n"
                 "-r | --read          Use read() calls\n"
                 "-u | --userp         Use application allocated buffers\n"
                 "-o | --output        Outputs stream to stdout\n"
                 "-f | --format        Force format to 640x480 YUYV\n"
                 "-c | --count         Number of frames to grab [%i]\n"
                 "",
                 argv[0], dev_name, frame_count);
}

static const char short_options[] = "d:hmruofc:";

static const struct option
long_options[] = {
        { "device", required_argument, NULL, 'd' },
        { "help",   no_argument,       NULL, 'h' },
        { "mmap",   no_argument,       NULL, 'm' },
        { "read",   no_argument,       NULL, 'r' },
        { "userp",  no_argument,       NULL, 'u' },
        { "output", no_argument,       NULL, 'o' },
        { "format", no_argument,       NULL, 'f' },
        { "count",  required_argument, NULL, 'c' },
        { 0, 0, 0, 0 }
};

int main(int argc, char **argv)
{
        dev_name = "/dev/video0";

        for (;;) {
                int idx;
                int c;

                c = getopt_long(argc, argv,
                                short_options, long_options, &amp;idx);

                if (-1 == c)
                        break;

                switch (c) {
                case 0: /* getopt_long() flag */
                        break;

                case 'd':
                        dev_name = optarg;
                        break;

                case 'h':
                        usage(stdout, argc, argv);
                        exit(EXIT_SUCCESS);

                case 'm':
                        io = IO_METHOD_MMAP;
                        break;

                case 'r':
                        io = IO_METHOD_READ;
                        break;

                case 'u':
                        io = IO_METHOD_USERPTR;
                        break;

                case 'o':
                        out_buf++;
                        break;

                case 'f':
                        force_format++;
                        break;

                case 'c':
                        errno = 0;
                        frame_count = strtol(optarg, NULL, 0);
                        if (errno)
                                errno_exit(optarg);
                        break;

                default:
                        usage(stderr, argc, argv);
                        exit(EXIT_FAILURE);
                }
        }

        open_device();
        init_device();
        start_capturing();
        mainloop();
        stop_capturing();
        uninit_device();
        close_device();
        fprintf(stderr, "\n");
        return 0;
}
</pre></div><div class="appendix"><div class="titlepage"><div><div><h2 class="title"><a name="v4l2grab-example"></a>Appendix E. Video Grabber example using libv4l</h2></div></div></div><p>This program demonstrates how to grab V4L2 images in ppm format by
using libv4l handlers. The advantage is that this grabber can potentially work
with any V4L2 driver.</p><pre class="programlisting">
/* V4L2 video picture grabber
   Copyright (C) 2009 Mauro Carvalho Chehab &lt;mchehab@infradead.org&gt;

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation version 2 of the License.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;linux/videodev2.h&gt;
#include "../libv4l/include/libv4l2.h"

#define CLEAR(x) memset(&amp;(x), 0, sizeof(x))

struct buffer {
        void   *start;
        size_t length;
};

static void xioctl(int fh, int request, void *arg)
{
        int r;

        do {
                r = v4l2_ioctl(fh, request, arg);
        } while (r == -1 &amp;&amp; ((errno == EINTR) || (errno == EAGAIN)));

        if (r == -1) {
                fprintf(stderr, "error %d, %s\n", errno, strerror(errno));
                exit(EXIT_FAILURE);
        }
}

int main(int argc, char **argv)
{
        struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a>              fmt;
        struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a>              buf;
        struct <a class="link" href="media.html#v4l2-requestbuffers" title="Table A.99. struct v4l2_requestbuffers">v4l2_requestbuffers</a>      req;
        enum <a class="link" href="media.html#v4l2-buf-type" title="Table 3.3. enum v4l2_buf_type">v4l2_buf_type</a>              type;
        fd_set                          fds;
        struct timeval                  tv;
        int                             r, fd = -1;
        unsigned int                    i, n_buffers;
        char                            *dev_name = "/dev/video0";
        char                            out_name[256];
        FILE                            *fout;
        struct buffer                   *buffers;

        fd = v4l2_open(dev_name, O_RDWR | O_NONBLOCK, 0);
        if (fd &lt; 0) {
                perror("Cannot open device");
                exit(EXIT_FAILURE);
        }

        CLEAR(fmt);
        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
        fmt.fmt.pix.width       = 640;
        fmt.fmt.pix.height      = 480;
        fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_RGB24;
        fmt.fmt.pix.field       = V4L2_FIELD_INTERLACED;
        xioctl(fd, VIDIOC_S_FMT, &amp;fmt);
        if (fmt.fmt.pix.pixelformat != V4L2_PIX_FMT_RGB24) {
                printf("Libv4l didn't accept RGB24 format. Can't proceed.\n");
                exit(EXIT_FAILURE);
        }
        if ((fmt.fmt.pix.width != 640) || (fmt.fmt.pix.height != 480))
                printf("Warning: driver is sending image at %dx%d\n",
                        fmt.fmt.pix.width, fmt.fmt.pix.height);

        CLEAR(req);
        req.count = 2;
        req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
        req.memory = V4L2_MEMORY_MMAP;
        xioctl(fd, VIDIOC_REQBUFS, &amp;req);

        buffers = calloc(req.count, sizeof(*buffers));
        for (n_buffers = 0; n_buffers &lt; req.count; ++n_buffers) {
                CLEAR(buf);

                buf.type        = V4L2_BUF_TYPE_VIDEO_CAPTURE;
                buf.memory      = V4L2_MEMORY_MMAP;
                buf.index       = n_buffers;

                xioctl(fd, VIDIOC_QUERYBUF, &amp;buf);

                buffers[n_buffers].length = buf.length;
                buffers[n_buffers].start = v4l2_mmap(NULL, buf.length,
                              PROT_READ | PROT_WRITE, MAP_SHARED,
                              fd, buf.m.offset);

                if (MAP_FAILED == buffers[n_buffers].start) {
                        perror("mmap");
                        exit(EXIT_FAILURE);
                }
        }

        for (i = 0; i &lt; n_buffers; ++i) {
                CLEAR(buf);
                buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
                buf.memory = V4L2_MEMORY_MMAP;
                buf.index = i;
                xioctl(fd, VIDIOC_QBUF, &amp;buf);
        }
        type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

        xioctl(fd, VIDIOC_STREAMON, &amp;type);
        for (i = 0; i &lt; 20; i++) {
                do {
                        FD_ZERO(&amp;fds);
                        FD_SET(fd, &amp;fds);

                        /* Timeout. */
                        tv.tv_sec = 2;
                        tv.tv_usec = 0;

                        r = select(fd + 1, &amp;fds, NULL, NULL, &amp;tv);
                } while ((r == -1 &amp;&amp; (errno = EINTR)));
                if (r == -1) {
                        perror("select");
                        return errno;
                }

                CLEAR(buf);
                buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
                buf.memory = V4L2_MEMORY_MMAP;
                xioctl(fd, VIDIOC_DQBUF, &amp;buf);

                sprintf(out_name, "out%03d.ppm", i);
                fout = fopen(out_name, "w");
                if (!fout) {
                        perror("Cannot open image");
                        exit(EXIT_FAILURE);
                }
                fprintf(fout, "P6\n%d %d 255\n",
                        fmt.fmt.pix.width, fmt.fmt.pix.height);
                fwrite(buffers[buf.index].start, buf.bytesused, 1, fout);
                fclose(fout);

                xioctl(fd, VIDIOC_QBUF, &amp;buf);
        }

        type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
        xioctl(fd, VIDIOC_STREAMOFF, &amp;type);
        for (i = 0; i &lt; n_buffers; ++i)
                v4l2_munmap(buffers[i].start, buffers[i].length);
        v4l2_close(fd);

        return 0;
}
</pre></div><div class="index"><div class="titlepage"><div><div><h2 class="title"><a name="idp86648832"></a>List of Types</h2></div></div></div><dl><dt><a class="link" href="media.html#v4l2-std-id" title="Table A.47. typedef v4l2_std_id">v4l2_std_id</a></dt><dd></dd><dt><a class="link" href="media.html#fe-type-t" title="Frontend type">fe_type_t</a></dt><dd></dd><dt><a class="link" href="media.html#fe-caps-t" title="frontend capabilities">fe_caps_t</a></dt><dd></dd><dt><a class="link" href="media.html#fe-sec-voltage-t" title="diseqc slave reply">fe_sec_voltage_t</a></dt><dd></dd><dt><a class="link" href="media.html#fe-sec-tone-mode-t" title="SEC continuous tone">fe_sec_tone_mode_t</a></dt><dd></dd><dt><a class="link" href="media.html#fe-sec-mini-cmd-t" title="SEC tone burst">fe_sec_mini_cmd_t</a></dt><dd></dd><dt><a class="link" href="media.html#fe-status-t" title="frontend status">fe_status_t</a></dt><dd></dd><dt><a class="link" href="media.html#fe-spectral-inversion-t" title="frontend spectral inversion">fe_spectral_inversion_t</a></dt><dd></dd><dt><a class="link" href="media.html#fe-code-rate-t" title="frontend code rate">fe_code_rate_t</a></dt><dd></dd><dt><a class="link" href="media.html#fe-modulation-t" title="frontend modulation type for QAM, OFDM and VSB">fe_modulation_t</a></dt><dd></dd><dt><a class="link" href="media.html#fe-transmit-mode-t" title="Number of carriers per channel">fe_transmit_mode_t</a></dt><dd></dd><dt><a class="link" href="media.html#fe-bandwidth-t" title="frontend bandwidth">fe_bandwidth_t</a></dt><dd></dd><dt><a class="link" href="media.html#fe-guard-interval-t" title="frontend guard inverval">fe_guard_interval_t</a></dt><dd></dd><dt><a class="link" href="media.html#fe-hierarchy-t" title="frontend hierarchy">fe_hierarchy_t</a></dt><dd></dd><dt><a class="link" href="media.html#fe-pilot-t" title="fe_pilot type">fe_pilot_t</a></dt><dd></dd><dt><a class="link" href="media.html#fe-rolloff-t" title="fe_rolloff type">fe_rolloff_t</a></dt><dd></dd><dt><a class="link" href="media.html#fe-delivery-system-t" title="fe_delivery_system type">fe_delivery_system_t</a></dt><dd></dd><dt>enum <a class="link" href="media.html#v4l2-field" title="Table 3.9. enum v4l2_field">v4l2_field</a></dt><dd></dd><dt>enum <a class="link" href="media.html#v4l2-buf-type" title="Table 3.3. enum v4l2_buf_type">v4l2_buf_type</a></dt><dd></dd><dt>enum <a class="link" href="media.html#v4l2-tuner-type" title="Table A.87. enum v4l2_tuner_type">v4l2_tuner_type</a></dt><dd></dd><dt>enum <a class="link" href="media.html#v4l2-memory" title="Table 3.5. enum v4l2_memory">v4l2_memory</a></dt><dd></dd><dt>enum <a class="link" href="media.html#v4l2-colorspace" title="Table 2.4. V4L2 Colorspaces">v4l2_colorspace</a></dt><dd></dd><dt>enum <a class="link" href="media.html#v4l2-ycbcr-encoding" title="Table 2.5. V4L2 Y'CbCr Encodings">v4l2_ycbcr_encoding</a></dt><dd></dd><dt>enum <a class="link" href="media.html#v4l2-quantization" title="Table 2.6. V4L2 Quantization Methods">v4l2_quantization</a></dt><dd></dd><dt>enum <a class="link" href="media.html#v4l2-priority" title="Table A.82. enum v4l2_priority">v4l2_priority</a></dt><dd></dd><dt>enum <a class="link" href="media.html#v4l2-frmsizetypes" title="Table A.32. enum v4l2_frmsizetypes">v4l2_frmsizetypes</a></dt><dd></dd><dt>enum <a class="link" href="media.html#v4l2-frmivaltypes" title="Table A.35. enum v4l2_frmivaltypes">v4l2_frmivaltypes</a></dt><dd></dd><dt>enum <a class="link" href="media.html#v4l2-ctrl-type" title="Table A.97. enum v4l2_ctrl_type">v4l2_ctrl_type</a></dt><dd></dd><dt>enum <a class="link" href="media.html#fe-interleaving">fe_interleaving</a></dt><dd></dd><dt>enum <a class="link" href="media.html#atscmh-sccc-block-mode">atscmh_sccc_block_mode</a></dt><dd></dd><dt>enum <a class="link" href="media.html#atscmh-sccc-code-mode">atscmh_sccc_code_mode</a></dt><dd></dd><dt>enum <a class="link" href="media.html#atscmh-rs-frame-ensemble">atscmh_rs_frame_ensemble</a></dt><dd></dd><dt>enum <a class="link" href="media.html#atscmh-rs-frame-mode">atscmh_rs_frame_mode</a></dt><dd></dd><dt>enum <a class="link" href="media.html#atscmh-rs-code-mode">atscmh_rs_code_mode</a></dt><dd></dd><dt>enum <a class="link" href="media.html#fecap-scale-params">fecap_scale_params</a></dt><dd></dd><dt>enum <a class="link" href="media.html#v4l2-mbus-pixelcode" title="Media Bus Pixel Codes">v4l2_mbus_pixelcode</a></dt><dd></dd><dt>enum <a class="link" href="media.html#v4l2-subdev-format-whence" title="Table A.106. enum v4l2_subdev_format_whence">v4l2_subdev_format_whence</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-rect" title="Table 4.3. struct v4l2_rect">v4l2_rect</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-fract" title="Table A.46. struct v4l2_fract">v4l2_fract</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-capability" title="Table A.92. struct v4l2_capability">v4l2_capability</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-pix-format" title="Table 2.1. struct v4l2_pix_format">v4l2_pix_format</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-fmtdesc" title="Table A.27. struct v4l2_fmtdesc">v4l2_fmtdesc</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-frmsize-discrete" title="Table A.29. struct v4l2_frmsize_discrete">v4l2_frmsize_discrete</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-frmsize-stepwise" title="Table A.30. struct v4l2_frmsize_stepwise">v4l2_frmsize_stepwise</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-frmsizeenum" title="Table A.31. struct v4l2_frmsizeenum">v4l2_frmsizeenum</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-frmival-stepwise" title="Table A.33. struct v4l2_frmival_stepwise">v4l2_frmival_stepwise</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-frmivalenum" title="Table A.34. struct v4l2_frmivalenum">v4l2_frmivalenum</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-timecode" title="Table 3.6. struct v4l2_timecode">v4l2_timecode</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-jpegcompression" title="Table A.73. struct v4l2_jpegcompression">v4l2_jpegcompression</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-requestbuffers" title="Table A.99. struct v4l2_requestbuffers">v4l2_requestbuffers</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-plane" title="Table 3.2. struct v4l2_plane">v4l2_plane</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-buffer" title="Table 3.1. struct v4l2_buffer">v4l2_buffer</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-exportbuffer" title="Table A.49. struct v4l2_exportbuffer">v4l2_exportbuffer</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-framebuffer" title="Table A.68. struct v4l2_framebuffer">v4l2_framebuffer</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-clip" title="Table 4.2. struct v4l2_clip">v4l2_clip</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-window" title="Table 4.1. struct v4l2_window">v4l2_window</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-captureparm" title="Table A.78. struct v4l2_captureparm">v4l2_captureparm</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-outputparm" title="Table A.79. struct v4l2_outputparm">v4l2_outputparm</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-cropcap" title="Table A.2. struct v4l2_cropcap">v4l2_cropcap</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-crop" title="Table A.54. struct v4l2_crop">v4l2_crop</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-selection" title="Table A.83. struct v4l2_selection">v4l2_selection</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-standard" title="Table A.45. struct v4l2_standard">v4l2_standard</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-bt-timings" title="Table A.56. struct v4l2_bt_timings">v4l2_bt_timings</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-dv-timings" title="Table A.57. struct v4l2_dv_timings">v4l2_dv_timings</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-enum-dv-timings" title="Table A.26. struct v4l2_enum_dv_timings">v4l2_enum_dv_timings</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-bt-timings-cap" title="Table A.20. struct v4l2_bt_timings_cap">v4l2_bt_timings_cap</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-dv-timings-cap" title="Table A.21. struct v4l2_dv_timings_cap">v4l2_dv_timings_cap</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-input" title="Table A.38. struct v4l2_input">v4l2_input</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-output" title="Table A.42. struct v4l2_output">v4l2_output</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-control" title="Table A.55. struct v4l2_control">v4l2_control</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-ext-control" title="Table A.65. struct v4l2_ext_control">v4l2_ext_control</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-ext-controls" title="Table A.66. struct v4l2_ext_controls">v4l2_ext_controls</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-queryctrl" title="Table A.94. struct v4l2_queryctrl">v4l2_queryctrl</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-query-ext-ctrl" title="Table A.95. struct v4l2_query_ext_ctrl">v4l2_query_ext_ctrl</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-querymenu" title="Table A.96. struct v4l2_querymenu">v4l2_querymenu</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-tuner" title="Table A.86. struct v4l2_tuner">v4l2_tuner</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-modulator" title="Table A.75. struct v4l2_modulator">v4l2_modulator</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-frequency" title="Table A.72. struct v4l2_frequency">v4l2_frequency</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-frequency-band" title="Table A.36. struct v4l2_frequency_band">v4l2_frequency_band</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-hw-freq-seek" title="Table A.100. struct v4l2_hw_freq_seek">v4l2_hw_freq_seek</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-rds-data" title="Table 4.15. struct v4l2_rds_data">v4l2_rds_data</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-audio" title="Table A.50. struct v4l2_audio">v4l2_audio</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-audioout" title="Table A.53. struct v4l2_audioout">v4l2_audioout</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-enc-idx-entry" title="Table A.63. struct v4l2_enc_idx_entry">v4l2_enc_idx_entry</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-enc-idx" title="Table A.62. struct v4l2_enc_idx">v4l2_enc_idx</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-encoder-cmd" title="Table A.23. struct v4l2_encoder_cmd">v4l2_encoder_cmd</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-decoder-cmd" title="Table A.10. struct v4l2_decoder_cmd">v4l2_decoder_cmd</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-vbi-format" title="Table 4.4. struct v4l2_vbi_format">v4l2_vbi_format</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-sliced-vbi-format" title="Table 4.6. struct v4l2_sliced_vbi_format">v4l2_sliced_vbi_format</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-sliced-vbi-cap" title="Table A.84. struct v4l2_sliced_vbi_cap">v4l2_sliced_vbi_cap</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-sliced-vbi-data" title="Table 4.8. struct v4l2_sliced_vbi_data">v4l2_sliced_vbi_data</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-mpeg-vbi-itv0-line" title="Table 4.13. struct v4l2_mpeg_vbi_itv0_line">v4l2_mpeg_vbi_itv0_line</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-mpeg-vbi-itv0" title="Table 4.11. struct v4l2_mpeg_vbi_itv0">v4l2_mpeg_vbi_itv0</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-mpeg-vbi-itv0-1" title="Table 4.12. struct v4l2_mpeg_vbi_ITV0">v4l2_mpeg_vbi_ITV0</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-mpeg-vbi-fmt-ivtv" title="Table 4.9. struct v4l2_mpeg_vbi_fmt_ivtv">v4l2_mpeg_vbi_fmt_ivtv</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-plane-pix-format" title="Table 2.2. struct v4l2_plane_pix_format">v4l2_plane_pix_format</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-pix-format-mplane" title="Table 2.3. struct v4l2_pix_format_mplane">v4l2_pix_format_mplane</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-sdr-format" title="Table 4.18. struct v4l2_sdr_format">v4l2_sdr_format</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-format" title="Table A.71. struct v4l2_format">v4l2_format</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-streamparm" title="Table A.77. struct v4l2_streamparm">v4l2_streamparm</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-event-vsync" title="Table A.13. struct v4l2_event_vsync">v4l2_event_vsync</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-event-ctrl" title="Table A.14. struct v4l2_event_ctrl">v4l2_event_ctrl</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-event-frame-sync" title="Table A.15. struct v4l2_event_frame_sync">v4l2_event_frame_sync</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-event-src-change" title="Table A.16. struct v4l2_event_src_change">v4l2_event_src_change</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-event-motion-det" title="Table A.17. struct v4l2_event_motion_det">v4l2_event_motion_det</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-event" title="Table A.12. struct v4l2_event">v4l2_event</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-event-subscription" title="Table A.109. struct v4l2_event_subscription">v4l2_event_subscription</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-dbg-match" title="Table A.7. struct v4l2_dbg_match">v4l2_dbg_match</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-dbg-register" title="Table A.8. struct v4l2_dbg_register">v4l2_dbg_register</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-dbg-chip-info" title="Table A.5. struct v4l2_dbg_chip_info">v4l2_dbg_chip_info</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-create-buffers" title="Table A.1. struct v4l2_create_buffers">v4l2_create_buffers</a></dt><dd></dd><dt>struct <a class="link" href="media.html#audio-karaoke" title="struct audio_karaoke">audio_karaoke</a></dt><dd></dd><dt>struct <a class="link" href="media.html#dmx-sct-filter-params" title="struct dmx_sct_filter_params">dmx_sct_filter_params</a></dt><dd></dd><dt>struct <a class="link" href="media.html#dmx-pes-filter-params" title="struct dmx_pes_filter_params">dmx_pes_filter_params</a></dt><dd></dd><dt>struct <a class="link" href="media.html#dmx-stc" title="struct dmx_stc">dmx_stc</a></dt><dd></dd><dt>struct <a class="link" href="media.html#dvb-frontend-info" title="frontend information">dvb_frontend_info</a></dt><dd></dd><dt>struct <a class="link" href="media.html#dvb-diseqc-master-cmd" title="diseqc master command">dvb_diseqc_master_cmd</a></dt><dd></dd><dt>struct <a class="link" href="media.html#dvb-diseqc-slave-reply" title="diseqc slave reply">dvb_diseqc_slave_reply</a></dt><dd></dd><dt>struct <a class="link" href="media.html#dvb-qpsk-parameters" title="QPSK parameters">dvb_qpsk_parameters</a></dt><dd></dd><dt>struct <a class="link" href="media.html#dvb-qam-parameters" title="QAM parameters">dvb_qam_parameters</a></dt><dd></dd><dt>struct <a class="link" href="media.html#dvb-vsb-parameters" title="VSB parameters">dvb_vsb_parameters</a></dt><dd></dd><dt>struct <a class="link" href="media.html#dvb-ofdm-parameters" title="OFDM parameters">dvb_ofdm_parameters</a></dt><dd></dd><dt>struct <a class="link" href="media.html#dvb-frontend-parameters" title="frontend parameters">dvb_frontend_parameters</a></dt><dd></dd><dt>struct <a class="link" href="media.html#dvb-frontend-event" title="frontend events">dvb_frontend_event</a></dt><dd></dd><dt>struct <a class="link" href="media.html#dtv-stats" title="DTV stats type">dtv_stats</a></dt><dd></dd><dt>struct <a class="link" href="media.html#dtv-fe-stats" title="DTV stats type">dtv_fe_stats</a></dt><dd></dd><dt>struct <a class="link" href="media.html#dtv-property" title="DTV property type">dtv_property</a></dt><dd></dd><dt>struct <a class="link" href="media.html#dtv-properties" title="DTV properties type">dtv_properties</a></dt><dd></dd><dt>struct <a class="link" href="media.html#video-command" title="struct video_command">video_command</a></dt><dd></dd><dt>struct <a class="link" href="media.html#video-event" title="struct video_event">video_event</a></dt><dd></dd><dt>struct <a class="link" href="media.html#video-status" title="struct video_status">video_status</a></dt><dd></dd><dt>struct <a class="link" href="media.html#video-still-picture" title="struct video_still_picture">video_still_picture</a></dt><dd></dd><dt>struct <a class="link" href="media.html#video-highlight" title="struct video_highlight">video_highlight</a></dt><dd></dd><dt>struct <a class="link" href="media.html#media-device-info" title="Table L.1. struct media_device_info">media_device_info</a></dt><dd></dd><dt>struct <a class="link" href="media.html#media-entity-desc" title="Table L.2. struct media_entity_desc">media_entity_desc</a></dt><dd></dd><dt>struct <a class="link" href="media.html#media-pad-desc" title="Table L.6. struct media_pad_desc">media_pad_desc</a></dt><dd></dd><dt>struct <a class="link" href="media.html#media-link-desc" title="Table L.8. struct media_link_desc">media_link_desc</a></dt><dd></dd><dt>struct <a class="link" href="media.html#media-links-enum" title="Table L.5. struct media_links_enum">media_links_enum</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-subdev-format" title="Table A.105. struct v4l2_subdev_format">v4l2_subdev_format</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-subdev-crop" title="Table A.104. struct v4l2_subdev_crop">v4l2_subdev_crop</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-subdev-mbus-code-enum" title="Table A.103. struct v4l2_subdev_mbus_code_enum">v4l2_subdev_mbus_code_enum</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-subdev-frame-size-enum" title="Table A.102. struct v4l2_subdev_frame_size_enum">v4l2_subdev_frame_size_enum</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-subdev-frame-interval" title="Table A.107. struct v4l2_subdev_frame_interval">v4l2_subdev_frame_interval</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-subdev-frame-interval-enum" title="Table A.101. struct v4l2_subdev_frame_interval_enum">v4l2_subdev_frame_interval_enum</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-subdev-selection" title="Table A.108. struct v4l2_subdev_selection">v4l2_subdev_selection</a></dt><dd></dd><dt>struct <a class="link" href="media.html#v4l2-mbus-framefmt" title="Table 4.20. struct v4l2_mbus_framefmt">v4l2_mbus_framefmt</a></dt><dd></dd></dl></div><div class="bibliography"><div class="titlepage"><div><div><h2 class="title"><a name="idp87100320"></a>References</h2></div></div></div><div class="biblioentry"><a name="eia608"></a><p>[<abbr class="abbrev">EIA 608-B</abbr>] <span class="authorgroup"><span class="corpauthor">Electronic Industries Alliance (<a class="ulink" href="http://www.eia.org" target="_top">http://www.eia.org</a>)</span>. </span><span class="title"><i>EIA 608-B "Recommended Practice for Line 21 Data
Service"</i>. </span></p></div><div class="biblioentry"><a name="en300294"></a><p>[<abbr class="abbrev">EN 300 294</abbr>] <span class="authorgroup"><span class="corpauthor">European Telecommunication Standards Institute
(<a class="ulink" href="http://www.etsi.org" target="_top">http://www.etsi.org</a>)</span>. </span><span class="title"><i>EN 300 294 "625-line television Wide Screen Signalling
(WSS)"</i>. </span></p></div><div class="biblioentry"><a name="ets300231"></a><p>[<abbr class="abbrev">ETS 300 231</abbr>] <span class="authorgroup"><span class="corpauthor">European Telecommunication Standards Institute
(<a class="ulink" href="http://www.etsi.org" target="_top">http://www.etsi.org</a>)</span>. </span><span class="title"><i>ETS 300 231 "Specification of the domestic video
Programme Delivery Control system (PDC)"</i>. </span></p></div><div class="biblioentry"><a name="ets300706"></a><p>[<abbr class="abbrev">ETS 300 706</abbr>] <span class="authorgroup"><span class="corpauthor">European Telecommunication Standards Institute
(<a class="ulink" href="http://www.etsi.org" target="_top">http://www.etsi.org</a>)</span>. </span><span class="title"><i>ETS 300 706 "Enhanced Teletext specification"</i>. </span></p></div><div class="biblioentry"><a name="mpeg2part1"></a><p>[<abbr class="abbrev">ISO 13818-1</abbr>] <span class="authorgroup"><span class="corpauthor">International Telecommunication Union (<a class="ulink" href="http://www.itu.ch" target="_top">http://www.itu.ch</a>), International
Organisation for Standardisation (<a class="ulink" href="http://www.iso.ch" target="_top">http://www.iso.ch</a>)</span>. </span><span class="title"><i>ITU-T Rec. H.222.0 | ISO/IEC 13818-1 "Information
technology &#8212; Generic coding of moving pictures and associated
audio information: Systems"</i>. </span></p></div><div class="biblioentry"><a name="mpeg2part2"></a><p>[<abbr class="abbrev">ISO 13818-2</abbr>] <span class="authorgroup"><span class="corpauthor">International Telecommunication Union (<a class="ulink" href="http://www.itu.ch" target="_top">http://www.itu.ch</a>), International
Organisation for Standardisation (<a class="ulink" href="http://www.iso.ch" target="_top">http://www.iso.ch</a>)</span>. </span><span class="title"><i>ITU-T Rec. H.262 | ISO/IEC 13818-2 "Information
technology &#8212; Generic coding of moving pictures and associated
audio information: Video"</i>. </span></p></div><div class="biblioentry"><a name="itu470"></a><p>[<abbr class="abbrev">ITU BT.470</abbr>] <span class="authorgroup"><span class="corpauthor">International Telecommunication Union (<a class="ulink" href="http://www.itu.ch" target="_top">http://www.itu.ch</a>)</span>. </span><span class="title"><i>ITU-R Recommendation BT.470-6 "Conventional Television
Systems"</i>. </span></p></div><div class="biblioentry"><a name="itu601"></a><p>[<abbr class="abbrev">ITU BT.601</abbr>] <span class="authorgroup"><span class="corpauthor">International Telecommunication Union (<a class="ulink" href="http://www.itu.ch" target="_top">http://www.itu.ch</a>)</span>. </span><span class="title"><i>ITU-R Recommendation BT.601-5 "Studio Encoding Parameters
of Digital Television for Standard 4:3 and Wide-Screen 16:9 Aspect
Ratios"</i>. </span></p></div><div class="biblioentry"><a name="itu653"></a><p>[<abbr class="abbrev">ITU BT.653</abbr>] <span class="authorgroup"><span class="corpauthor">International Telecommunication Union (<a class="ulink" href="http://www.itu.ch" target="_top">http://www.itu.ch</a>)</span>. </span><span class="title"><i>ITU-R Recommendation BT.653-3 "Teletext systems"</i>. </span></p></div><div class="biblioentry"><a name="itu709"></a><p>[<abbr class="abbrev">ITU BT.709</abbr>] <span class="authorgroup"><span class="corpauthor">International Telecommunication Union (<a class="ulink" href="http://www.itu.ch" target="_top">http://www.itu.ch</a>)</span>. </span><span class="title"><i>ITU-R Recommendation BT.709-5 "Parameter values for the
HDTV standards for production and international programme
exchange"</i>. </span></p></div><div class="biblioentry"><a name="itu1119"></a><p>[<abbr class="abbrev">ITU BT.1119</abbr>] <span class="authorgroup"><span class="corpauthor">International Telecommunication Union (<a class="ulink" href="http://www.itu.ch" target="_top">http://www.itu.ch</a>)</span>. </span><span class="title"><i>ITU-R Recommendation BT.1119 "625-line
television Wide Screen Signalling (WSS)"</i>. </span></p></div><div class="biblioentry"><a name="jfif"></a><p>[<abbr class="abbrev">JFIF</abbr>] <span class="authorgroup"><span class="corpauthor">Independent JPEG Group (<a class="ulink" href="http://www.ijg.org" target="_top">http://www.ijg.org</a>)</span>. </span><span class="title"><i>JPEG File Interchange Format</i>. </span><span class="subtitle">Version 1.02. </span></p></div><div class="biblioentry"><a name="itu-t81"></a><p>[<abbr class="abbrev">ITU-T.81</abbr>] <span class="authorgroup"><span class="corpauthor">International Telecommunication Union
(<a class="ulink" href="http://www.itu.int" target="_top">http://www.itu.int</a>)</span>. </span><span class="title"><i>ITU-T Recommendation T.81
"Information Technology &#8212; Digital Compression and Coding of Continous-Tone
Still Images &#8212; Requirements and Guidelines"</i>. </span></p></div><div class="biblioentry"><a name="w3c-jpeg-jfif"></a><p>[<abbr class="abbrev">W3C JPEG JFIF</abbr>] <span class="authorgroup"><span class="corpauthor">The World Wide Web Consortium (<a class="ulink" href="http://www.w3.org/Graphics/JPEG" target="_top">http://www.w3.org</a>)</span>. </span><span class="title"><i>JPEG JFIF</i>. </span></p></div><div class="biblioentry"><a name="smpte12m"></a><p>[<abbr class="abbrev">SMPTE 12M</abbr>] <span class="authorgroup"><span class="corpauthor">Society of Motion Picture and Television Engineers
(<a class="ulink" href="http://www.smpte.org" target="_top">http://www.smpte.org</a>)</span>. </span><span class="title"><i>SMPTE 12M-1999 "Television, Audio and Film - Time and
Control Code"</i>. </span></p></div><div class="biblioentry"><a name="smpte170m"></a><p>[<abbr class="abbrev">SMPTE 170M</abbr>] <span class="authorgroup"><span class="corpauthor">Society of Motion Picture and Television Engineers
(<a class="ulink" href="http://www.smpte.org" target="_top">http://www.smpte.org</a>)</span>. </span><span class="title"><i>SMPTE 170M-1999 "Television - Composite Analog Video
Signal - NTSC for Studio Applications"</i>. </span></p></div><div class="biblioentry"><a name="smpte240m"></a><p>[<abbr class="abbrev">SMPTE 240M</abbr>] <span class="authorgroup"><span class="corpauthor">Society of Motion Picture and Television Engineers
(<a class="ulink" href="http://www.smpte.org" target="_top">http://www.smpte.org</a>)</span>. </span><span class="title"><i>SMPTE 240M-1999 "Television - Signal Parameters -
1125-Line High-Definition Production"</i>. </span></p></div><div class="biblioentry"><a name="srgb"></a><p>[<abbr class="abbrev">sRGB</abbr>] <span class="authorgroup"><span class="corpauthor">International Electrotechnical Commission
(<a class="ulink" href="http://www.iec.ch" target="_top">http://www.iec.ch</a>)</span>. </span><span class="title"><i>IEC 61966-2-1 ed1.0 "Multimedia systems and equipment - Colour measurement
and management - Part 2-1: Colour management - Default RGB colour space - sRGB"</i>. </span></p></div><div class="biblioentry"><a name="sycc"></a><p>[<abbr class="abbrev">sYCC</abbr>] <span class="authorgroup"><span class="corpauthor">International Electrotechnical Commission
(<a class="ulink" href="http://www.iec.ch" target="_top">http://www.iec.ch</a>)</span>. </span><span class="title"><i>IEC 61966-2-1-am1 ed1.0 "Amendment 1 - Multimedia systems and equipment - Colour measurement
and management - Part 2-1: Colour management - Default RGB colour space - sRGB"</i>. </span></p></div><div class="biblioentry"><a name="xvycc"></a><p>[<abbr class="abbrev">xvYCC</abbr>] <span class="authorgroup"><span class="corpauthor">International Electrotechnical Commission
(<a class="ulink" href="http://www.iec.ch" target="_top">http://www.iec.ch</a>)</span>. </span><span class="title"><i>IEC 61966-2-4 ed1.0 "Multimedia systems and equipment - Colour measurement
and management - Part 2-4: Colour management - Extended-gamut YCC colour space for video
applications - xvYCC"</i>. </span></p></div><div class="biblioentry"><a name="adobergb"></a><p>[<abbr class="abbrev">AdobeRGB</abbr>] <span class="authorgroup"><span class="corpauthor">Adobe Systems Incorporated (<a class="ulink" href="http://www.adobe.com" target="_top">http://www.adobe.com</a>)</span>. </span><span class="title"><i>Adobe© RGB (1998) Color Image Encoding Version 2005-05</i>. </span></p></div><div class="biblioentry"><a name="oprgb"></a><p>[<abbr class="abbrev">opRGB</abbr>] <span class="authorgroup"><span class="corpauthor">International Electrotechnical Commission
(<a class="ulink" href="http://www.iec.ch" target="_top">http://www.iec.ch</a>)</span>. </span><span class="title"><i>IEC 61966-2-5 "Multimedia systems and equipment - Colour measurement
and management - Part 2-5: Colour management - Optional RGB colour space - opRGB"</i>. </span></p></div><div class="biblioentry"><a name="itu2020"></a><p>[<abbr class="abbrev">ITU BT.2020</abbr>] <span class="authorgroup"><span class="corpauthor">International Telecommunication Union (<a class="ulink" href="http://www.itu.ch" target="_top">http://www.itu.ch</a>)</span>. </span><span class="title"><i>ITU-R Recommendation BT.2020 (08/2012) "Parameter values for ultra-high
definition television systems for production and international programme exchange"
</i>. </span></p></div><div class="biblioentry"><a name="tech3213"></a><p>[<abbr class="abbrev">EBU Tech 3213</abbr>] <span class="authorgroup"><span class="corpauthor">European Broadcast Union (<a class="ulink" href="http://www.ebu.ch" target="_top">http://www.ebu.ch</a>)</span>. </span><span class="title"><i>E.B.U. Standard for Chromaticity Tolerances for Studio Monitors"</i>. </span></p></div><div class="biblioentry"><a name="iec62106"></a><p>[<abbr class="abbrev">IEC 62106</abbr>] <span class="authorgroup"><span class="corpauthor">International Electrotechnical Commission
(<a class="ulink" href="http://www.iec.ch" target="_top">http://www.iec.ch</a>)</span>. </span><span class="title"><i>Specification of the radio data system (RDS) for VHF/FM sound broadcasting
in the frequency range from 87,5 to 108,0 MHz</i>. </span></p></div><div class="biblioentry"><a name="nrsc4"></a><p>[<abbr class="abbrev">NRSC-4-B</abbr>] <span class="authorgroup"><span class="corpauthor">National Radio Systems Committee
(<a class="ulink" href="http://www.nrscstandards.org" target="_top">http://www.nrscstandards.org</a>)</span>. </span><span class="title"><i>NRSC-4-B: United States RBDS Standard</i>. </span></p></div><div class="biblioentry"><a name="iso12232"></a><p>[<abbr class="abbrev">ISO 12232:2006</abbr>] <span class="authorgroup"><span class="corpauthor">International Organization for Standardization
(<a class="ulink" href="http://www.iso.org" target="_top">http://www.iso.org</a>)</span>. </span><span class="title"><i>Photography &#8212; Digital still cameras &#8212; Determination
      of exposure index, ISO speed ratings, standard output sensitivity, and
      recommended exposure index</i>. </span></p></div><div class="biblioentry"><a name="cea861"></a><p>[<abbr class="abbrev">CEA-861-E</abbr>] <span class="authorgroup"><span class="corpauthor">Consumer Electronics Association
(<a class="ulink" href="http://www.ce.org" target="_top">http://www.ce.org</a>)</span>. </span><span class="title"><i>A DTV Profile for Uncompressed High Speed Digital Interfaces</i>. </span></p></div><div class="biblioentry"><a name="vesadmt"></a><p>[<abbr class="abbrev">VESA DMT</abbr>] <span class="authorgroup"><span class="corpauthor">Video Electronics Standards Association
(<a class="ulink" href="http://www.vesa.org" target="_top">http://www.vesa.org</a>)</span>. </span><span class="title"><i>VESA and Industry Standards and Guidelines for Computer Display Monitor Timing (DMT)</i>. </span></p></div><div class="biblioentry"><a name="vesaedid"></a><p>[<abbr class="abbrev">EDID</abbr>] <span class="authorgroup"><span class="corpauthor">Video Electronics Standards Association
(<a class="ulink" href="http://www.vesa.org" target="_top">http://www.vesa.org</a>)</span>. </span><span class="title"><i>VESA Enhanced Extended Display Identification Data Standard</i>. </span><span class="subtitle">Release A, Revision 2. </span></p></div><div class="biblioentry"><a name="hdcp"></a><p>[<abbr class="abbrev">HDCP</abbr>] <span class="authorgroup"><span class="corpauthor">Digital Content Protection LLC
(<a class="ulink" href="http://www.digital-cp.com" target="_top">http://www.digital-cp.com</a>)</span>. </span><span class="title"><i>High-bandwidth Digital Content Protection System</i>. </span><span class="subtitle">Revision 1.3. </span></p></div><div class="biblioentry"><a name="hdmi"></a><p>[<abbr class="abbrev">HDMI</abbr>] <span class="authorgroup"><span class="corpauthor">HDMI Licensing LLC
(<a class="ulink" href="http://www.hdmi.org" target="_top">http://www.hdmi.org</a>)</span>. </span><span class="title"><i>High-Definition Multimedia Interface</i>. </span><span class="subtitle">Specification Version 1.4a. </span></p></div><div class="biblioentry"><a name="dp"></a><p>[<abbr class="abbrev">DP</abbr>] <span class="authorgroup"><span class="corpauthor">Video Electronics Standards Association
(<a class="ulink" href="http://www.vesa.org" target="_top">http://www.vesa.org</a>)</span>. </span><span class="title"><i>VESA DisplayPort Standard</i>. </span><span class="subtitle">Version 1, Revision 2. </span></p></div><div class="biblioentry"><a name="poynton"></a><p>[<abbr class="abbrev">poynton</abbr>] <span class="authorgroup"><span class="corpauthor">Charles Poynton</span>. </span><span class="title"><i>Digital Video and HDTV, Algorithms and Interfaces</i>. </span></p></div><div class="biblioentry"><a name="colimg"></a><p>[<abbr class="abbrev">colimg</abbr>] <span class="authorgroup"><span class="corpauthor">Erik Reinhard et al.</span>. </span><span class="title"><i>Color Imaging: Fundamentals and Applications</i>. </span></p></div></div></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="dvbapi"></a>Part II. LINUX DVB API</h1></div><div><h2 class="subtitle">Version 5.10</h2></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Ralph</span> <span class="othername">J. K.</span> <span class="surname">Metzler</span></h3><div class="affiliation"><div class="address"><p><code class="email">&lt;<a class="email" href="mailto:rjkm@metzlerbros.de">rjkm@metzlerbros.de</a>&gt;</code></p></div></div></div><div class="author"><h3 class="author"><span class="firstname">Marcus</span> <span class="othername">O. C.</span> <span class="surname">Metzler</span></h3><div class="affiliation"><div class="address"><p><code class="email">&lt;<a class="email" href="mailto:rjkm@metzlerbros.de">rjkm@metzlerbros.de</a>&gt;</code></p></div></div></div></div></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Mauro</span> <span class="othername">Carvalho</span> <span class="surname">Chehab</span></h3><span class="contrib">Ported document to Docbook XML.</span> <div class="affiliation"><div class="address"><p><code class="email">&lt;<a class="email" href="mailto:m.chehab@samsung.com">m.chehab@samsung.com</a>&gt;</code></p></div></div></div></div></div><div><p class="copyright">Copyright © 2002, 2003 Convergence GmbH</p></div><div><p class="copyright">Copyright © 2009-2014 Mauro Carvalho Chehab</p></div><div><div class="revhistory"><table style="border-style:solid; width:100%;" summary="Revision History"><tr><th align="left" valign="top" colspan="3"><b>Revision History</b></th></tr><tr><td align="left">Revision 2.0.4</td><td align="left">2011-05-06</td><td align="left">mcc</td></tr><tr><td align="left" colspan="3">
		Add more information about DVB APIv5, better describing the frontend GET/SET props ioctl's.
	</td></tr><tr><td align="left">Revision 2.0.3</td><td align="left">2010-07-03</td><td align="left">mcc</td></tr><tr><td align="left" colspan="3">
		Add some frontend capabilities flags, present on kernel, but missing at the specs.
	</td></tr><tr><td align="left">Revision 2.0.2</td><td align="left">2009-10-25</td><td align="left">mcc</td></tr><tr><td align="left" colspan="3">
		documents FE_SET_FRONTEND_TUNE_MODE and FE_DISHETWORK_SEND_LEGACY_CMD ioctls.
	</td></tr><tr><td align="left">Revision 2.0.1</td><td align="left">2009-09-16</td><td align="left">mcc</td></tr><tr><td align="left" colspan="3">
Added ISDB-T test originally written by Patrick Boettcher
</td></tr><tr><td align="left">Revision 2.0.0</td><td align="left">2009-09-06</td><td align="left">mcc</td></tr><tr><td align="left" colspan="3">Conversion from LaTex to DocBook XML. The
	contents is the same as the original LaTex version.</td></tr><tr><td align="left">Revision 1.0.0</td><td align="left">2003-07-24</td><td align="left">rjkm</td></tr><tr><td align="left" colspan="3">Initial revision on LaTEX.</td></tr></table></div></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="chapter"><a href="media.html#dvb_introdution">8. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#requisites">What you need to know</a></span></dt><dt><span class="section"><a href="media.html#history">History</a></span></dt><dt><span class="section"><a href="media.html#overview">Overview</a></span></dt><dt><span class="section"><a href="media.html#dvb_devices">Linux DVB Devices</a></span></dt><dt><span class="section"><a href="media.html#include_files">API include files</a></span></dt></dl></dd><dt><span class="chapter"><a href="media.html#dvb_frontend">9. DVB Frontend API</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#frontend_types">Frontend Data Types</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#fe-type-t">Frontend type</a></span></dt><dt><span class="section"><a href="media.html#fe-caps-t">frontend capabilities</a></span></dt><dt><span class="section"><a href="media.html#dvb-frontend-info">frontend information</a></span></dt><dt><span class="section"><a href="media.html#dvb-diseqc-master-cmd">diseqc master command</a></span></dt><dt><span class="section"><a href="media.html#dvb-diseqc-slave-reply">diseqc slave reply</a></span></dt><dt><span class="section"><a href="media.html#fe-sec-voltage-t">diseqc slave reply</a></span></dt><dt><span class="section"><a href="media.html#fe-sec-tone-mode-t">SEC continuous tone</a></span></dt><dt><span class="section"><a href="media.html#fe-sec-mini-cmd-t">SEC tone burst</a></span></dt><dt><span class="section"><a href="media.html#fe-status-t">frontend status</a></span></dt><dt><span class="section"><a href="media.html#dvb-frontend-parameters">frontend parameters</a></span></dt><dt><span class="section"><a href="media.html#dvb-frontend-event">frontend events</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#frontend_fcalls">Frontend Function Calls</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#frontend_f_open">open()</a></span></dt><dt><span class="section"><a href="media.html#frontend_f_close">close()</a></span></dt><dt><span class="section"><a href="media.html#FE_READ_STATUS">FE_READ_STATUS</a></span></dt><dt><span class="section"><a href="media.html#FE_READ_BER">FE_READ_BER</a></span></dt><dt><span class="section"><a href="media.html#FE_READ_SNR">FE_READ_SNR</a></span></dt><dt><span class="section"><a href="media.html#FE_READ_SIGNAL_STRENGTH">FE_READ_SIGNAL_STRENGTH</a></span></dt><dt><span class="section"><a href="media.html#FE_READ_UNCORRECTED_BLOCKS">FE_READ_UNCORRECTED_BLOCKS</a></span></dt><dt><span class="section"><a href="media.html#FE_SET_FRONTEND">FE_SET_FRONTEND</a></span></dt><dt><span class="section"><a href="media.html#FE_GET_FRONTEND">FE_GET_FRONTEND</a></span></dt><dt><span class="section"><a href="media.html#FE_GET_EVENT">FE_GET_EVENT</a></span></dt><dt><span class="section"><a href="media.html#FE_GET_INFO">FE_GET_INFO</a></span></dt><dt><span class="section"><a href="media.html#FE_DISEQC_RESET_OVERLOAD">FE_DISEQC_RESET_OVERLOAD</a></span></dt><dt><span class="section"><a href="media.html#FE_DISEQC_SEND_MASTER_CMD">FE_DISEQC_SEND_MASTER_CMD</a></span></dt><dt><span class="section"><a href="media.html#FE_DISEQC_RECV_SLAVE_REPLY">FE_DISEQC_RECV_SLAVE_REPLY</a></span></dt><dt><span class="section"><a href="media.html#FE_DISEQC_SEND_BURST">FE_DISEQC_SEND_BURST</a></span></dt><dt><span class="section"><a href="media.html#FE_SET_TONE">FE_SET_TONE</a></span></dt><dt><span class="section"><a href="media.html#FE_SET_VOLTAGE">FE_SET_VOLTAGE</a></span></dt><dt><span class="section"><a href="media.html#FE_ENABLE_HIGH_LNB_VOLTAGE">FE_ENABLE_HIGH_LNB_VOLTAGE</a></span></dt><dt><span class="section"><a href="media.html#FE_SET_FRONTEND_TUNE_MODE">FE_SET_FRONTEND_TUNE_MODE</a></span></dt><dt><span class="section"><a href="media.html#FE_DISHNETWORK_SEND_LEGACY_CMD">FE_DISHNETWORK_SEND_LEGACY_CMD</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#FE_GET_SET_PROPERTY"><code class="constant">FE_GET_PROPERTY/FE_SET_PROPERTY</code></a></span></dt><dd><dl><dt><span class="section"><a href="media.html#dtv-stats">DTV stats type</a></span></dt><dt><span class="section"><a href="media.html#dtv-fe-stats">DTV stats type</a></span></dt><dt><span class="section"><a href="media.html#dtv-property">DTV property type</a></span></dt><dt><span class="section"><a href="media.html#dtv-properties">DTV properties type</a></span></dt><dt><span class="section"><a href="media.html#FE_GET_PROPERTY">FE_GET_PROPERTY</a></span></dt><dt><span class="section"><a href="media.html#FE_SET_PROPERTY">FE_SET_PROPERTY</a></span></dt><dt><span class="section"><a href="media.html#idp105068368">Property types</a></span></dt><dt><span class="section"><a href="media.html#fe_property_parameters">Digital TV property parameters</a></span></dt><dt><span class="section"><a href="media.html#frontend-stat-properties">Frontend statistics indicators</a></span></dt><dt><span class="section"><a href="media.html#frontend-property-terrestrial-systems">Properties used on terrestrial delivery systems</a></span></dt><dt><span class="section"><a href="media.html#frontend-property-cable-systems">Properties used on cable delivery systems</a></span></dt><dt><span class="section"><a href="media.html#frontend-property-satellital-systems">Properties used on satellital delivery systems</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="media.html#dvb_demux">10. DVB Demux Device</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#dmx_types">Demux Data Types</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#dmx-output-t">dmx_output_t</a></span></dt><dt><span class="section"><a href="media.html#dmx-input-t">dmx_input_t</a></span></dt><dt><span class="section"><a href="media.html#dmx-pes-type-t">dmx_pes_type_t</a></span></dt><dt><span class="section"><a href="media.html#dmx-filter">struct dmx_filter</a></span></dt><dt><span class="section"><a href="media.html#dmx-sct-filter-params">struct dmx_sct_filter_params</a></span></dt><dt><span class="section"><a href="media.html#dmx-pes-filter-params">struct dmx_pes_filter_params</a></span></dt><dt><span class="section"><a href="media.html#dmx-event">struct dmx_event</a></span></dt><dt><span class="section"><a href="media.html#dmx-stc">struct dmx_stc</a></span></dt><dt><span class="section"><a href="media.html#dmx-caps">struct dmx_caps</a></span></dt><dt><span class="section"><a href="media.html#dmx-source-t">enum dmx_source_t</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#dmx_fcalls">Demux Function Calls</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#dmx_fopen">open()</a></span></dt><dt><span class="section"><a href="media.html#dmx_fclose">close()</a></span></dt><dt><span class="section"><a href="media.html#dmx_fread">read()</a></span></dt><dt><span class="section"><a href="media.html#dmx_fwrite">write()</a></span></dt><dt><span class="section"><a href="media.html#DMX_START">DMX_START</a></span></dt><dt><span class="section"><a href="media.html#DMX_STOP">DMX_STOP</a></span></dt><dt><span class="section"><a href="media.html#DMX_SET_FILTER">DMX_SET_FILTER</a></span></dt><dt><span class="section"><a href="media.html#DMX_SET_PES_FILTER">DMX_SET_PES_FILTER</a></span></dt><dt><span class="section"><a href="media.html#DMX_SET_BUFFER_SIZE">DMX_SET_BUFFER_SIZE</a></span></dt><dt><span class="section"><a href="media.html#DMX_GET_EVENT">DMX_GET_EVENT</a></span></dt><dt><span class="section"><a href="media.html#DMX_GET_STC">DMX_GET_STC</a></span></dt><dt><span class="section"><a href="media.html#DMX_GET_PES_PIDS">DMX_GET_PES_PIDS</a></span></dt><dt><span class="section"><a href="media.html#DMX_GET_CAPS">DMX_GET_CAPS</a></span></dt><dt><span class="section"><a href="media.html#DMX_SET_SOURCE">DMX_SET_SOURCE</a></span></dt><dt><span class="section"><a href="media.html#DMX_ADD_PID">DMX_ADD_PID</a></span></dt><dt><span class="section"><a href="media.html#DMX_REMOVE_PID">DMX_REMOVE_PID</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="media.html#dvb_video">11. DVB Video Device</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#video_types">Video Data Types</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#video-format-t">video_format_t</a></span></dt><dt><span class="section"><a href="media.html#video-displayformat-t">video_displayformat_t</a></span></dt><dt><span class="section"><a href="media.html#video-stream-source-t">video_stream_source_t</a></span></dt><dt><span class="section"><a href="media.html#video-play-state-t">video_play_state_t</a></span></dt><dt><span class="section"><a href="media.html#video-command">struct video_command</a></span></dt><dt><span class="section"><a href="media.html#video-size-t">video_size_t</a></span></dt><dt><span class="section"><a href="media.html#video-event">struct video_event</a></span></dt><dt><span class="section"><a href="media.html#video-status">struct video_status</a></span></dt><dt><span class="section"><a href="media.html#video-still-picture">struct video_still_picture</a></span></dt><dt><span class="section"><a href="media.html#video_caps">video capabilities</a></span></dt><dt><span class="section"><a href="media.html#video-system">video_system_t</a></span></dt><dt><span class="section"><a href="media.html#video-highlight">struct video_highlight</a></span></dt><dt><span class="section"><a href="media.html#video-spu">struct video_spu</a></span></dt><dt><span class="section"><a href="media.html#video-spu-palette">struct video_spu_palette</a></span></dt><dt><span class="section"><a href="media.html#video-navi-pack">struct video_navi_pack</a></span></dt><dt><span class="section"><a href="media.html#video-attributes-t">video_attributes_t</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#video_function_calls">Video Function Calls</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#video_fopen">open()</a></span></dt><dt><span class="section"><a href="media.html#video_fclose">close()</a></span></dt><dt><span class="section"><a href="media.html#video_fwrite">write()</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_STOP">VIDEO_STOP</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_PLAY">VIDEO_PLAY</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_FREEZE">VIDEO_FREEZE</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_CONTINUE">VIDEO_CONTINUE</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SELECT_SOURCE">VIDEO_SELECT_SOURCE</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_BLANK">VIDEO_SET_BLANK</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_GET_STATUS">VIDEO_GET_STATUS</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_GET_FRAME_COUNT">VIDEO_GET_FRAME_COUNT</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_GET_PTS">VIDEO_GET_PTS</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_GET_FRAME_RATE">VIDEO_GET_FRAME_RATE</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_GET_EVENT">VIDEO_GET_EVENT</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_COMMAND">VIDEO_COMMAND</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_TRY_COMMAND">VIDEO_TRY_COMMAND</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_GET_SIZE">VIDEO_GET_SIZE</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_DISPLAY_FORMAT">VIDEO_SET_DISPLAY_FORMAT</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_STILLPICTURE">VIDEO_STILLPICTURE</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_FAST_FORWARD">VIDEO_FAST_FORWARD</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SLOWMOTION">VIDEO_SLOWMOTION</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_GET_CAPABILITIES">VIDEO_GET_CAPABILITIES</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_ID">VIDEO_SET_ID</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_CLEAR_BUFFER">VIDEO_CLEAR_BUFFER</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_STREAMTYPE">VIDEO_SET_STREAMTYPE</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_FORMAT">VIDEO_SET_FORMAT</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_SYSTEM">VIDEO_SET_SYSTEM</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_HIGHLIGHT">VIDEO_SET_HIGHLIGHT</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_SPU">VIDEO_SET_SPU</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_SPU_PALETTE">VIDEO_SET_SPU_PALETTE</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_GET_NAVI">VIDEO_GET_NAVI</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_ATTRIBUTES">VIDEO_SET_ATTRIBUTES</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="media.html#dvb_audio">12. DVB Audio Device</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#audio_data_types">Audio Data Types</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#audio-stream-source-t">audio_stream_source_t</a></span></dt><dt><span class="section"><a href="media.html#audio-play-state-t">audio_play_state_t</a></span></dt><dt><span class="section"><a href="media.html#audio-channel-select-t">audio_channel_select_t</a></span></dt><dt><span class="section"><a href="media.html#audio-status">struct audio_status</a></span></dt><dt><span class="section"><a href="media.html#audio-mixer">struct audio_mixer</a></span></dt><dt><span class="section"><a href="media.html#audio_encodings">audio encodings</a></span></dt><dt><span class="section"><a href="media.html#audio-karaoke">struct audio_karaoke</a></span></dt><dt><span class="section"><a href="media.html#audio-attributes-t">audio attributes</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#audio_function_calls">Audio Function Calls</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#audio_fopen">open()</a></span></dt><dt><span class="section"><a href="media.html#audio_fclose">close()</a></span></dt><dt><span class="section"><a href="media.html#audio_fwrite">write()</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_STOP">AUDIO_STOP</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_PLAY">AUDIO_PLAY</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_PAUSE">AUDIO_PAUSE</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_CONTINUE">AUDIO_CONTINUE</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SELECT_SOURCE">AUDIO_SELECT_SOURCE</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_MUTE">AUDIO_SET_MUTE</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_AV_SYNC">AUDIO_SET_AV_SYNC</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_BYPASS_MODE">AUDIO_SET_BYPASS_MODE</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_CHANNEL_SELECT">AUDIO_CHANNEL_SELECT</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_BILINGUAL_CHANNEL_SELECT">AUDIO_BILINGUAL_CHANNEL_SELECT</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_GET_PTS">AUDIO_GET_PTS</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_GET_STATUS">AUDIO_GET_STATUS</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_GET_CAPABILITIES">AUDIO_GET_CAPABILITIES</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_CLEAR_BUFFER">AUDIO_CLEAR_BUFFER</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_ID">AUDIO_SET_ID</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_MIXER">AUDIO_SET_MIXER</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_STREAMTYPE">AUDIO_SET_STREAMTYPE</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_EXT_ID">AUDIO_SET_EXT_ID</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_ATTRIBUTES">AUDIO_SET_ATTRIBUTES</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_KARAOKE">AUDIO_SET_KARAOKE</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="media.html#dvb_ca">13. DVB CA Device</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#ca_data_types">CA Data Types</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#ca-slot-info">ca_slot_info_t</a></span></dt><dt><span class="section"><a href="media.html#ca-descr-info">ca_descr_info_t</a></span></dt><dt><span class="section"><a href="media.html#ca-caps">ca_caps_t</a></span></dt><dt><span class="section"><a href="media.html#ca-msg">ca_msg_t</a></span></dt><dt><span class="section"><a href="media.html#ca-descr">ca_descr_t</a></span></dt><dt><span class="section"><a href="media.html#ca-pid">ca-pid</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#ca_function_calls">CA Function Calls</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#ca_fopen">open()</a></span></dt><dt><span class="section"><a href="media.html#ca_fclose">close()</a></span></dt><dt><span class="section"><a href="media.html#CA_RESET">CA_RESET</a></span></dt><dt><span class="section"><a href="media.html#CA_GET_CAP">CA_GET_CAP</a></span></dt><dt><span class="section"><a href="media.html#CA_GET_SLOT_INFO">CA_GET_SLOT_INFO</a></span></dt><dt><span class="section"><a href="media.html#CA_GET_DESCR_INFO">CA_GET_DESCR_INFO</a></span></dt><dt><span class="section"><a href="media.html#CA_GET_MSG">CA_GET_MSG</a></span></dt><dt><span class="section"><a href="media.html#CA_SEND_MSG">CA_SEND_MSG</a></span></dt><dt><span class="section"><a href="media.html#CA_SET_DESCR">CA_SET_DESCR</a></span></dt><dt><span class="section"><a href="media.html#CA_SET_PID">CA_SET_PID</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="media.html#dvb_net">14. DVB Network API</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#dvb_net_types">DVB Net Data Types</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#dvb-net-if">struct dvb_net_if</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#net_fcalls">DVB net Function Calls</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#NET_ADD_IF">NET_ADD_IF</a></span></dt><dt><span class="section"><a href="media.html#NET_REMOVE_IF">NET_REMOVE_IF</a></span></dt><dt><span class="section"><a href="media.html#NET_GET_IF">NET_GET_IF</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="media.html#dvb_kdapi">15. Kernel Demux API</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#kernel_demux_data_types">Kernel Demux Data Types</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#dmx_success_t">dmx_success_t</a></span></dt><dt><span class="section"><a href="media.html#ts_filter_types">TS filter types</a></span></dt><dt><span class="section"><a href="media.html#dmx_ts_pes_t">dmx_ts_pes_t</a></span></dt><dt><span class="section"><a href="media.html#demux_demux_t">demux_demux_t</a></span></dt><dt><span class="section"><a href="media.html#demux_directory">Demux directory</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#demux_directory_api">Demux Directory API</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp110784096">dmx_register_demux()</a></span></dt><dt><span class="section"><a href="media.html#idp110801088">dmx_unregister_demux()</a></span></dt><dt><span class="section"><a href="media.html#idp110817936">dmx_get_demuxes()</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#demux_api">Demux API</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#kdapi_fopen">open()</a></span></dt><dt><span class="section"><a href="media.html#kdapi_fclose">close()</a></span></dt><dt><span class="section"><a href="media.html#kdapi_fwrite">write()</a></span></dt><dt><span class="section"><a href="media.html#idp110890656">allocate_ts_feed()</a></span></dt><dt><span class="section"><a href="media.html#idp110913216">release_ts_feed()</a></span></dt><dt><span class="section"><a href="media.html#idp110929088">allocate_section_feed()</a></span></dt><dt><span class="section"><a href="media.html#idp110951600">release_section_feed()</a></span></dt><dt><span class="section"><a href="media.html#idp110967536">descramble_mac_address()</a></span></dt><dt><span class="section"><a href="media.html#idp110994256">descramble_section_payload()</a></span></dt><dt><span class="section"><a href="media.html#idp111023728">add_frontend()</a></span></dt><dt><span class="section"><a href="media.html#idp111046176">remove_frontend()</a></span></dt><dt><span class="section"><a href="media.html#idp111064624">get_frontends()</a></span></dt><dt><span class="section"><a href="media.html#idp111078032">connect_frontend()</a></span></dt><dt><span class="section"><a href="media.html#idp111097408">disconnect_frontend()</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#demux_callback_api">Demux Callback API</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp111114592">dmx_ts_cb()</a></span></dt><dt><span class="section"><a href="media.html#idp111148960">dmx_section_cb()</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#ts_feed_api">TS Feed API</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp111176992">set()</a></span></dt><dt><span class="section"><a href="media.html#idp111205664">start_filtering()</a></span></dt><dt><span class="section"><a href="media.html#idp111219648">stop_filtering()</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#section_feed_api">Section Feed API</a></span></dt><dt><span class="section"><a href="media.html#kdapi_set">set()</a></span></dt><dt><span class="section"><a href="media.html#idp111263088">allocate_filter()</a></span></dt><dt><span class="section"><a href="media.html#idp111294528">release_filter()</a></span></dt><dt><span class="section"><a href="media.html#idp111312448">start_filtering()</a></span></dt><dt><span class="section"><a href="media.html#idp111326592">stop_filtering()</a></span></dt></dl></dd><dt><span class="chapter"><a href="media.html#dvb_examples">16. Examples</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#tuning">Tuning</a></span></dt><dt><span class="section"><a href="media.html#the_dvr_device">The DVR device</a></span></dt></dl></dd><dt><span class="appendix"><a href="media.html#audio_h">F. DVB Audio Header File</a></span></dt><dt><span class="appendix"><a href="media.html#ca_h">G. DVB Conditional Access Header File</a></span></dt><dt><span class="appendix"><a href="media.html#dmx_h">H. DVB Demux Header File</a></span></dt><dt><span class="appendix"><a href="media.html#frontend_h">I. DVB Frontend Header File</a></span></dt><dt><span class="appendix"><a href="media.html#net_h">J. DVB Network Header File</a></span></dt><dt><span class="appendix"><a href="media.html#video_h">K. DVB Video Header File</a></span></dt></dl></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="dvb_introdution"></a>Chapter 8. Introduction</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="media.html#requisites">What you need to know</a></span></dt><dt><span class="section"><a href="media.html#history">History</a></span></dt><dt><span class="section"><a href="media.html#overview">Overview</a></span></dt><dt><span class="section"><a href="media.html#dvb_devices">Linux DVB Devices</a></span></dt><dt><span class="section"><a href="media.html#include_files">API include files</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="requisites"></a>What you need to know</h2></div></div></div><p>The reader of this document is required to have some knowledge in
the area of digital video broadcasting (DVB) and should be familiar with
part I of the MPEG2 specification ISO/IEC 13818 (aka ITU-T H.222), i.e
you should know what a program/transport stream (PS/TS) is and what is
meant by a packetized elementary stream (PES) or an I-frame.</p><p>Various DVB standards documents are available from
<a class="ulink" href="http://www.dvb.org" target="_top">http://www.dvb.org</a> and/or
<a class="ulink" href="http://www.etsi.org" target="_top">http://www.etsi.org</a>.</p><p>It is also necessary to know how to access unix/linux devices and
how to use ioctl calls. This also includes the knowledge of C or C++.
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="history"></a>History</h2></div></div></div><p>The first API for DVB cards we used at Convergence in late 1999
was an extension of the Video4Linux API which was primarily developed
for frame grabber cards. As such it was not really well suited to be
used for DVB cards and their new features like recording MPEG streams
and filtering several section and PES data streams at the same time.
</p><p>In early 2000, we were approached by Nokia with a proposal for a
new standard Linux DVB API. As a commitment to the development of
terminals based on open standards, Nokia and Convergence made it
available to all Linux developers and published it on
<a class="ulink" href="http://www.linuxtv.org/" target="_top">http://www.linuxtv.org/</a> in September 2000.
Convergence is the maintainer of the Linux DVB API. Together with the
LinuxTV community (i.e. you, the reader of this document), the Linux DVB
API will be constantly reviewed and improved. With the Linux driver for
the Siemens/Hauppauge DVB PCI card Convergence provides a first
implementation of the Linux DVB API.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="overview"></a>Overview</h2></div></div></div><div class="figure"><a name="stb_components"></a><p class="title"><b>Figure 8.1. Components of a DVB card/STB</b></p><div class="figure-contents"><div class="mediaobject"><img src="dvbstb.png" alt="Components of a DVB card/STB"></div></div></div><br class="figure-break"><p>A DVB PCI card or DVB set-top-box (STB) usually consists of the
following main hardware components: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Frontend consisting of tuner and DVB demodulator</p><p>Here the raw signal reaches the DVB hardware from a satellite dish
or antenna or directly from cable. The frontend down-converts and
demodulates this signal into an MPEG transport stream (TS). In case of a
satellite frontend, this includes a facility for satellite equipment
control (SEC), which allows control of LNB polarization, multi feed
switches or dish rotors.</p></li><li class="listitem"><p>Conditional Access (CA) hardware like CI adapters and smartcard slots
</p><p>The complete TS is passed through the CA hardware. Programs to
which the user has access (controlled by the smart card) are decoded in
real time and re-inserted into the TS.</p></li><li class="listitem"><p>Demultiplexer which filters the incoming DVB stream</p><p>The demultiplexer splits the TS into its components like audio and
video streams. Besides usually several of such audio and video streams
it also contains data streams with information about the programs
offered in this or other streams of the same provider.</p></li><li class="listitem"><p>MPEG2 audio and video decoder</p><p>The main targets of the demultiplexer are the MPEG2 audio and
video decoders. After decoding they pass on the uncompressed audio and
video to the computer screen or (through a PAL/NTSC encoder) to a TV
set.</p></li></ul></div><p><a class="xref" href="media.html#stb_components" title="Figure 8.1. Components of a DVB card/STB">Figure 8.1, &#8220;Components of a DVB card/STB&#8221;</a> shows a crude schematic of the control and data flow
between those components.</p><p>On a DVB PCI card not all of these have to be present since some
functionality can be provided by the main CPU of the PC (e.g. MPEG
picture and sound decoding) or is not needed (e.g. for data-only uses
like &#8220;internet over satellite&#8221;). Also not every card or STB
provides conditional access hardware.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dvb_devices"></a>Linux DVB Devices</h2></div></div></div><p>The Linux DVB API lets you control these hardware components
through currently six Unix-style character devices for video, audio,
frontend, demux, CA and IP-over-DVB networking. The video and audio
devices control the MPEG2 decoder hardware, the frontend device the
tuner and the DVB demodulator. The demux device gives you control over
the PES and section filters of the hardware. If the hardware does not
support filtering these filters can be implemented in software. Finally,
the CA device controls all the conditional access capabilities of the
hardware. It can depend on the individual security requirements of the
platform, if and how many of the CA functions are made available to the
application through this device.</p><p>All devices can be found in the <span class="tt">/dev</span>
tree under <span class="tt">/dev/dvb</span>. The individual devices
are called:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="tt">/dev/dvb/adapterN/audioM</span>,</p></li><li class="listitem"><p><span class="tt">/dev/dvb/adapterN/videoM</span>,</p></li><li class="listitem"><p><span class="tt">/dev/dvb/adapterN/frontendM</span>,</p></li><li class="listitem"><p><span class="tt">/dev/dvb/adapterN/netM</span>,</p></li><li class="listitem"><p><span class="tt">/dev/dvb/adapterN/demuxM</span>,</p></li><li class="listitem"><p><span class="tt">/dev/dvb/adapterN/dvrM</span>,</p></li><li class="listitem"><p><span class="tt">/dev/dvb/adapterN/caM</span>,</p></li></ul></div><p>where N enumerates the DVB PCI cards in a system starting
from 0, and M enumerates the devices of each type within each
adapter, starting from 0, too. We will omit the &#8220;<span class="tt">/dev/dvb/adapterN/</span>&#8221; in the further dicussion
of these devices. The naming scheme for the devices is the same wheter
devfs is used or not.</p><p>More details about the data structures and function calls of all
the devices are described in the following chapters.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="include_files"></a>API include files</h2></div></div></div><p>For each of the DVB devices a corresponding include file exists.
The DVB API include files should be included in application sources with
a partial path like:</p><pre class="programlisting">
	#include &lt;linux/dvb/audio.h&gt;
</pre><pre class="programlisting">
	#include &lt;linux/dvb/ca.h&gt;
</pre><pre class="programlisting">
	#include &lt;linux/dvb/dmx.h&gt;
</pre><pre class="programlisting">
	#include &lt;linux/dvb/frontend.h&gt;
</pre><pre class="programlisting">
	#include &lt;linux/dvb/net.h&gt;
</pre><pre class="programlisting">
	#include &lt;linux/dvb/osd.h&gt;
</pre><pre class="programlisting">
	#include &lt;linux/dvb/video.h&gt;
</pre><p>To enable applications to support different API version, an
additional include file <span class="tt">linux/dvb/version.h</span> exists, which defines the
constant <span class="tt">DVB_API_VERSION</span>. This document
describes <span class="tt">DVB_API_VERSION 5.8</span>.
</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="dvb_frontend"></a>Chapter 9. DVB Frontend API</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="media.html#frontend_types">Frontend Data Types</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#fe-type-t">Frontend type</a></span></dt><dt><span class="section"><a href="media.html#fe-caps-t">frontend capabilities</a></span></dt><dt><span class="section"><a href="media.html#dvb-frontend-info">frontend information</a></span></dt><dt><span class="section"><a href="media.html#dvb-diseqc-master-cmd">diseqc master command</a></span></dt><dt><span class="section"><a href="media.html#dvb-diseqc-slave-reply">diseqc slave reply</a></span></dt><dt><span class="section"><a href="media.html#fe-sec-voltage-t">diseqc slave reply</a></span></dt><dt><span class="section"><a href="media.html#fe-sec-tone-mode-t">SEC continuous tone</a></span></dt><dt><span class="section"><a href="media.html#fe-sec-mini-cmd-t">SEC tone burst</a></span></dt><dt><span class="section"><a href="media.html#fe-status-t">frontend status</a></span></dt><dt><span class="section"><a href="media.html#dvb-frontend-parameters">frontend parameters</a></span></dt><dt><span class="section"><a href="media.html#dvb-frontend-event">frontend events</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#frontend_fcalls">Frontend Function Calls</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#frontend_f_open">open()</a></span></dt><dt><span class="section"><a href="media.html#frontend_f_close">close()</a></span></dt><dt><span class="section"><a href="media.html#FE_READ_STATUS">FE_READ_STATUS</a></span></dt><dt><span class="section"><a href="media.html#FE_READ_BER">FE_READ_BER</a></span></dt><dt><span class="section"><a href="media.html#FE_READ_SNR">FE_READ_SNR</a></span></dt><dt><span class="section"><a href="media.html#FE_READ_SIGNAL_STRENGTH">FE_READ_SIGNAL_STRENGTH</a></span></dt><dt><span class="section"><a href="media.html#FE_READ_UNCORRECTED_BLOCKS">FE_READ_UNCORRECTED_BLOCKS</a></span></dt><dt><span class="section"><a href="media.html#FE_SET_FRONTEND">FE_SET_FRONTEND</a></span></dt><dt><span class="section"><a href="media.html#FE_GET_FRONTEND">FE_GET_FRONTEND</a></span></dt><dt><span class="section"><a href="media.html#FE_GET_EVENT">FE_GET_EVENT</a></span></dt><dt><span class="section"><a href="media.html#FE_GET_INFO">FE_GET_INFO</a></span></dt><dt><span class="section"><a href="media.html#FE_DISEQC_RESET_OVERLOAD">FE_DISEQC_RESET_OVERLOAD</a></span></dt><dt><span class="section"><a href="media.html#FE_DISEQC_SEND_MASTER_CMD">FE_DISEQC_SEND_MASTER_CMD</a></span></dt><dt><span class="section"><a href="media.html#FE_DISEQC_RECV_SLAVE_REPLY">FE_DISEQC_RECV_SLAVE_REPLY</a></span></dt><dt><span class="section"><a href="media.html#FE_DISEQC_SEND_BURST">FE_DISEQC_SEND_BURST</a></span></dt><dt><span class="section"><a href="media.html#FE_SET_TONE">FE_SET_TONE</a></span></dt><dt><span class="section"><a href="media.html#FE_SET_VOLTAGE">FE_SET_VOLTAGE</a></span></dt><dt><span class="section"><a href="media.html#FE_ENABLE_HIGH_LNB_VOLTAGE">FE_ENABLE_HIGH_LNB_VOLTAGE</a></span></dt><dt><span class="section"><a href="media.html#FE_SET_FRONTEND_TUNE_MODE">FE_SET_FRONTEND_TUNE_MODE</a></span></dt><dt><span class="section"><a href="media.html#FE_DISHNETWORK_SEND_LEGACY_CMD">FE_DISHNETWORK_SEND_LEGACY_CMD</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#FE_GET_SET_PROPERTY"><code class="constant">FE_GET_PROPERTY/FE_SET_PROPERTY</code></a></span></dt><dd><dl><dt><span class="section"><a href="media.html#dtv-stats">DTV stats type</a></span></dt><dt><span class="section"><a href="media.html#dtv-fe-stats">DTV stats type</a></span></dt><dt><span class="section"><a href="media.html#dtv-property">DTV property type</a></span></dt><dt><span class="section"><a href="media.html#dtv-properties">DTV properties type</a></span></dt><dt><span class="section"><a href="media.html#FE_GET_PROPERTY">FE_GET_PROPERTY</a></span></dt><dt><span class="section"><a href="media.html#FE_SET_PROPERTY">FE_SET_PROPERTY</a></span></dt><dt><span class="section"><a href="media.html#idp105068368">Property types</a></span></dt><dt><span class="section"><a href="media.html#fe_property_parameters">Digital TV property parameters</a></span></dt><dt><span class="section"><a href="media.html#frontend-stat-properties">Frontend statistics indicators</a></span></dt><dt><span class="section"><a href="media.html#frontend-property-terrestrial-systems">Properties used on terrestrial delivery systems</a></span></dt><dt><span class="section"><a href="media.html#frontend-property-cable-systems">Properties used on cable delivery systems</a></span></dt><dt><span class="section"><a href="media.html#frontend-property-satellital-systems">Properties used on satellital delivery systems</a></span></dt></dl></dd></dl></div><p>The DVB frontend device controls the tuner and DVB demodulator
hardware. It can be accessed through <span class="tt">/dev/dvb/adapter0/frontend0</span>. Data types and and
ioctl definitions can be accessed by including <span class="tt">linux/dvb/frontend.h</span> in your application.</p><p>DVB frontends come in three varieties: DVB-S (satellite), DVB-C
(cable) and DVB-T (terrestrial). Transmission via the internet (DVB-IP)
is not yet handled by this API but a future extension is possible. For
DVB-S the frontend device also supports satellite equipment control
(SEC) via DiSEqC and V-SEC protocols. The DiSEqC (digital SEC)
specification is available from
<a class="ulink" href="http://www.eutelsat.com/satellites/4_5_5.html" target="_top">Eutelsat</a>.</p><p>Note that the DVB API may also be used for MPEG decoder-only PCI
cards, in which case there exists no frontend device.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="frontend_types"></a>Frontend Data Types</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#fe-type-t">Frontend type</a></span></dt><dt><span class="section"><a href="media.html#fe-caps-t">frontend capabilities</a></span></dt><dt><span class="section"><a href="media.html#dvb-frontend-info">frontend information</a></span></dt><dt><span class="section"><a href="media.html#dvb-diseqc-master-cmd">diseqc master command</a></span></dt><dt><span class="section"><a href="media.html#dvb-diseqc-slave-reply">diseqc slave reply</a></span></dt><dt><span class="section"><a href="media.html#fe-sec-voltage-t">diseqc slave reply</a></span></dt><dt><span class="section"><a href="media.html#fe-sec-tone-mode-t">SEC continuous tone</a></span></dt><dt><span class="section"><a href="media.html#fe-sec-mini-cmd-t">SEC tone burst</a></span></dt><dt><span class="section"><a href="media.html#fe-status-t">frontend status</a></span></dt><dt><span class="section"><a href="media.html#dvb-frontend-parameters">frontend parameters</a></span></dt><dt><span class="section"><a href="media.html#dvb-frontend-event">frontend events</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="fe-type-t"></a>Frontend type</h3></div></div></div><p>For historical reasons, frontend types are named by the type of modulation used in
transmission. The fontend types are given by fe_type_t type, defined as:</p><div class="table"><a name="fe-type"></a><p class="title"><b>Table 9.1. Frontend types</b></p><div class="table-contents"><table summary="Frontend types" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><thead><tr><th>fe_type</th><th>Description</th><th><a class="link" href="media.html#DTV-DELIVERY-SYSTEM" title="DTV_DELIVERY_SYSTEM">DTV_DELIVERY_SYSTEM</a> equivalent type</th></tr></thead><tbody valign="top"><tr><td valign="top"><a name="FE_QPSK"></a><code class="constant">FE_QPSK</code></td><td valign="top">For DVB-S standard</td><td valign="top"><code class="constant">SYS_DVBS</code></td></tr><tr><td valign="top"><a name="FE_QAM"></a><code class="constant">FE_QAM</code></td><td valign="top">For DVB-C annex A standard</td><td valign="top"><code class="constant">SYS_DVBC_ANNEX_A</code></td></tr><tr><td valign="top"><a name="FE_OFDM"></a><code class="constant">FE_OFDM</code></td><td valign="top">For DVB-T standard</td><td valign="top"><code class="constant">SYS_DVBT</code></td></tr><tr><td valign="top"><a name="FE_ATSC"></a><code class="constant">FE_ATSC</code></td><td valign="top">For ATSC standard (terrestrial) or for DVB-C Annex B (cable) used in US.</td><td valign="top"><code class="constant">SYS_ATSC</code> (terrestrial) or <code class="constant">SYS_DVBC_ANNEX_B</code> (cable)</td></tr></tbody></table></div></div><br class="table-break"><p>Newer formats like DVB-S2, ISDB-T, ISDB-S and DVB-T2 are not described at the above, as they're
supported via the new <a class="link" href="media.html#FE_GET_SET_PROPERTY" title="FE_GET_PROPERTY/FE_SET_PROPERTY">FE_GET_PROPERTY/FE_GET_SET_PROPERTY</a> ioctl's, using the <a class="link" href="media.html#DTV-DELIVERY-SYSTEM" title="DTV_DELIVERY_SYSTEM">DTV_DELIVERY_SYSTEM</a> parameter.
</p><p>The usage of this field is deprecated, as it doesn't report all supported standards, and
will provide an incomplete information for frontends that support multiple delivery systems.
Please use <a class="link" href="media.html#DTV-ENUM-DELSYS" title="DTV_ENUM_DELSYS">DTV_ENUM_DELSYS</a> instead.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="fe-caps-t"></a>frontend capabilities</h3></div></div></div><p>Capabilities describe what a frontend can do. Some capabilities can only be supported for
a specific frontend type.</p><pre class="programlisting">
	typedef enum fe_caps {
	FE_IS_STUPID                  = 0,
	FE_CAN_INVERSION_AUTO         = 0x1,
	FE_CAN_FEC_1_2                = 0x2,
	FE_CAN_FEC_2_3                = 0x4,
	FE_CAN_FEC_3_4                = 0x8,
	FE_CAN_FEC_4_5                = 0x10,
	FE_CAN_FEC_5_6                = 0x20,
	FE_CAN_FEC_6_7                = 0x40,
	FE_CAN_FEC_7_8                = 0x80,
	FE_CAN_FEC_8_9                = 0x100,
	FE_CAN_FEC_AUTO               = 0x200,
	FE_CAN_QPSK                   = 0x400,
	FE_CAN_QAM_16                 = 0x800,
	FE_CAN_QAM_32                 = 0x1000,
	FE_CAN_QAM_64                 = 0x2000,
	FE_CAN_QAM_128                = 0x4000,
	FE_CAN_QAM_256                = 0x8000,
	FE_CAN_QAM_AUTO               = 0x10000,
	FE_CAN_TRANSMISSION_MODE_AUTO = 0x20000,
	FE_CAN_BANDWIDTH_AUTO         = 0x40000,
	FE_CAN_GUARD_INTERVAL_AUTO    = 0x80000,
	FE_CAN_HIERARCHY_AUTO         = 0x100000,
	FE_CAN_8VSB                   = 0x200000,
	FE_CAN_16VSB                  = 0x400000,
	FE_HAS_EXTENDED_CAPS          = 0x800000,
	FE_CAN_MULTISTREAM            = 0x4000000,
	FE_CAN_TURBO_FEC              = 0x8000000,
	FE_CAN_2G_MODULATION          = 0x10000000,
	FE_NEEDS_BENDING              = 0x20000000,
	FE_CAN_RECOVER                = 0x40000000,
	FE_CAN_MUTE_TS                = 0x80000000
	} fe_caps_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dvb-frontend-info"></a>frontend information</h3></div></div></div><p>Information about the frontend ca be queried with
	<a class="link" href="media.html#FE_GET_INFO" title="FE_GET_INFO">FE_GET_INFO</a>.</p><pre class="programlisting">
	struct dvb_frontend_info {
	char       name[128];
	fe_type_t  type;
	uint32_t   frequency_min;
	uint32_t   frequency_max;
	uint32_t   frequency_stepsize;
	uint32_t   frequency_tolerance;
	uint32_t   symbol_rate_min;
	uint32_t   symbol_rate_max;
	uint32_t   symbol_rate_tolerance;     /&#8902; ppm &#8902;/
	uint32_t   notifier_delay;            /&#8902; ms &#8902;/
	fe_caps_t  caps;
	};
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dvb-diseqc-master-cmd"></a>diseqc master command</h3></div></div></div><p>A message sent from the frontend to DiSEqC capable equipment.</p><pre class="programlisting">
	struct dvb_diseqc_master_cmd {
	uint8_t msg [6]; /&#8902;  { framing, address, command, data[3] } &#8902;/
	uint8_t msg_len; /&#8902;  valid values are 3...6  &#8902;/
	};
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dvb-diseqc-slave-reply"></a>diseqc slave reply</h3></div></div></div><p>A reply to the frontend from DiSEqC 2.0 capable equipment.</p><pre class="programlisting">
	struct dvb_diseqc_slave_reply {
	uint8_t msg [4]; /&#8902;  { framing, data [3] } &#8902;/
	uint8_t msg_len; /&#8902;  valid values are 0...4, 0 means no msg  &#8902;/
	int     timeout; /&#8902;  return from ioctl after timeout ms with &#8902;/
	};                       /&#8902;  errorcode when no message was received  &#8902;/
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="fe-sec-voltage-t"></a>diseqc slave reply</h3></div></div></div><p>The voltage is usually used with non-DiSEqC capable LNBs to switch the polarzation
(horizontal/vertical). When using DiSEqC epuipment this voltage has to be switched
consistently to the DiSEqC commands as described in the DiSEqC spec.</p><pre class="programlisting">
	typedef enum fe_sec_voltage {
	SEC_VOLTAGE_13,
	SEC_VOLTAGE_18
	} fe_sec_voltage_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="fe-sec-tone-mode-t"></a>SEC continuous tone</h3></div></div></div><p>The continuous 22KHz tone is usually used with non-DiSEqC capable LNBs to switch the
high/low band of a dual-band LNB. When using DiSEqC epuipment this voltage has to
be switched consistently to the DiSEqC commands as described in the DiSEqC
spec.</p><pre class="programlisting">
	typedef enum fe_sec_tone_mode {
	SEC_TONE_ON,
	SEC_TONE_OFF
	} fe_sec_tone_mode_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="fe-sec-mini-cmd-t"></a>SEC tone burst</h3></div></div></div><p>The 22KHz tone burst is usually used with non-DiSEqC capable switches to select
between two connected LNBs/satellites. When using DiSEqC epuipment this voltage has to
be switched consistently to the DiSEqC commands as described in the DiSEqC
spec.</p><pre class="programlisting">
	typedef enum fe_sec_mini_cmd {
	SEC_MINI_A,
	SEC_MINI_B
	} fe_sec_mini_cmd_t;
</pre><p></p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="fe-status-t"></a>frontend status</h3></div></div></div><p>Several functions of the frontend device use the fe_status data type defined
by</p><pre class="programlisting">
typedef enum fe_status {
	FE_HAS_SIGNAL		= 0x01,
	FE_HAS_CARRIER		= 0x02,
	FE_HAS_VITERBI		= 0x04,
	FE_HAS_SYNC		= 0x08,
	FE_HAS_LOCK		= 0x10,
	FE_TIMEDOUT		= 0x20,
	FE_REINIT		= 0x40,
} fe_status_t;
</pre><p>to indicate the current state and/or state changes of the frontend hardware:
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">FE_HAS_SIGNAL</td><td align="char">The frontend has found something above the noise level</td></tr><tr><td align="char">FE_HAS_CARRIER</td><td align="char">The frontend has found a DVB signal</td></tr><tr><td align="char">FE_HAS_VITERBI</td><td align="char">The frontend FEC inner coding (Viterbi, LDPC or other inner code) is stable</td></tr><tr><td align="char">FE_HAS_SYNC</td><td align="char">Synchronization bytes was found</td></tr><tr><td align="char">FE_HAS_LOCK</td><td align="char">The DVB were locked and everything is working</td></tr><tr><td align="char">FE_TIMEDOUT</td><td align="char">no lock within the last about 2 seconds</td></tr><tr><td align="char">FE_REINIT</td><td align="char">The frontend was reinitialized, application is
recommended to reset DiSEqC, tone and parameters</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dvb-frontend-parameters"></a>frontend parameters</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#dvb-qpsk-parameters">QPSK parameters</a></span></dt><dt><span class="section"><a href="media.html#dvb-qam-parameters">QAM parameters</a></span></dt><dt><span class="section"><a href="media.html#dvb-vsb-parameters">VSB parameters</a></span></dt><dt><span class="section"><a href="media.html#dvb-ofdm-parameters">OFDM parameters</a></span></dt><dt><span class="section"><a href="media.html#fe-spectral-inversion-t">frontend spectral inversion</a></span></dt><dt><span class="section"><a href="media.html#fe-code-rate-t">frontend code rate</a></span></dt><dt><span class="section"><a href="media.html#fe-modulation-t">frontend modulation type for QAM, OFDM and VSB</a></span></dt><dt><span class="section"><a href="media.html#idp104565440">More OFDM parameters</a></span></dt></dl></div><p>The kind of parameters passed to the frontend device for tuning depend on
the kind of hardware you are using.</p><p>The struct <code class="constant">dvb_frontend_parameters</code> uses an
union with specific per-system parameters. However, as newer delivery systems
required more data, the structure size weren't enough to fit, and just
extending its size would break the existing applications. So, those parameters
were replaced by the usage of <a class="link" href="media.html#FE_GET_SET_PROPERTY" title="FE_GET_PROPERTY/FE_SET_PROPERTY">
<code class="constant">FE_GET_PROPERTY/FE_SET_PROPERTY</code></a> ioctl's. The
new API is flexible enough to add new parameters to existing delivery systems,
and to add newer delivery systems.</p><p>So, newer applications should use <a class="link" href="media.html#FE_GET_SET_PROPERTY" title="FE_GET_PROPERTY/FE_SET_PROPERTY">
<code class="constant">FE_GET_PROPERTY/FE_SET_PROPERTY</code></a> instead, in
order to be able to support the newer System Delivery like  DVB-S2, DVB-T2,
DVB-C2, ISDB, etc.</p><p>All kinds of parameters are combined as an union in the FrontendParameters structure:
</p><pre class="programlisting">
struct dvb_frontend_parameters {
	uint32_t frequency;     /&#8902; (absolute) frequency in Hz for QAM/OFDM &#8902;/
				/&#8902; intermediate frequency in kHz for QPSK &#8902;/
	fe_spectral_inversion_t inversion;
	union {
		struct dvb_qpsk_parameters qpsk;
		struct dvb_qam_parameters  qam;
		struct dvb_ofdm_parameters ofdm;
		struct dvb_vsb_parameters  vsb;
	} u;
};
</pre><p>In the case of QPSK frontends the <code class="constant">frequency</code> field specifies the intermediate
frequency, i.e. the offset which is effectively added to the local oscillator frequency (LOF) of
the LNB. The intermediate frequency has to be specified in units of kHz. For QAM and
OFDM frontends the <code class="constant">frequency</code> specifies the absolute frequency and is given in Hz.
</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="dvb-qpsk-parameters"></a>QPSK parameters</h4></div></div></div><p>For satellite QPSK frontends you have to use the <code class="constant">dvb_qpsk_parameters</code> structure:</p><pre class="programlisting">
 struct dvb_qpsk_parameters {
	 uint32_t        symbol_rate;  /&#8902; symbol rate in Symbols per second &#8902;/
	 fe_code_rate_t  fec_inner;    /&#8902; forward error correction (see above) &#8902;/
 };
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="dvb-qam-parameters"></a>QAM parameters</h4></div></div></div><p>for cable QAM frontend you use the <code class="constant">dvb_qam_parameters</code> structure:</p><pre class="programlisting">
 struct dvb_qam_parameters {
	 uint32_t         symbol_rate; /&#8902; symbol rate in Symbols per second &#8902;/
	 fe_code_rate_t   fec_inner;   /&#8902; forward error correction (see above) &#8902;/
	 fe_modulation_t  modulation;  /&#8902; modulation type (see above) &#8902;/
 };
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="dvb-vsb-parameters"></a>VSB parameters</h4></div></div></div><p>ATSC frontends are supported by the <code class="constant">dvb_vsb_parameters</code> structure:</p><pre class="programlisting">
struct dvb_vsb_parameters {
	fe_modulation_t modulation;	/&#8902; modulation type (see above) &#8902;/
};
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="dvb-ofdm-parameters"></a>OFDM parameters</h4></div></div></div><p>DVB-T frontends are supported by the <code class="constant">dvb_ofdm_parameters</code> structure:</p><pre class="programlisting">
 struct dvb_ofdm_parameters {
	 fe_bandwidth_t      bandwidth;
	 fe_code_rate_t      code_rate_HP;  /&#8902; high priority stream code rate &#8902;/
	 fe_code_rate_t      code_rate_LP;  /&#8902; low priority stream code rate &#8902;/
	 fe_modulation_t     constellation; /&#8902; modulation type (see above) &#8902;/
	 fe_transmit_mode_t  transmission_mode;
	 fe_guard_interval_t guard_interval;
	 fe_hierarchy_t      hierarchy_information;
 };
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="fe-spectral-inversion-t"></a>frontend spectral inversion</h4></div></div></div><p>The Inversion field can take one of these values:
</p><pre class="programlisting">
typedef enum fe_spectral_inversion {
	INVERSION_OFF,
	INVERSION_ON,
	INVERSION_AUTO
} fe_spectral_inversion_t;
</pre><p>It indicates if spectral inversion should be presumed or not. In the automatic setting
(<code class="constant">INVERSION_AUTO</code>) the hardware will try to figure out the correct setting by
itself.
</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="fe-code-rate-t"></a>frontend code rate</h4></div></div></div><p>The possible values for the <code class="constant">fec_inner</code> field used on
<a class="link" href="media.html#dvb-qpsk-parameters" title="QPSK parameters"><code class="constant">struct dvb_qpsk_parameters</code></a> and
<a class="link" href="media.html#dvb-qam-parameters" title="QAM parameters"><code class="constant">struct dvb_qam_parameters</code></a> are:
</p><pre class="programlisting">
typedef enum fe_code_rate {
	FEC_NONE = 0,
	FEC_1_2,
	FEC_2_3,
	FEC_3_4,
	FEC_4_5,
	FEC_5_6,
	FEC_6_7,
	FEC_7_8,
	FEC_8_9,
	FEC_AUTO,
	FEC_3_5,
	FEC_9_10,
} fe_code_rate_t;
</pre><p>which correspond to error correction rates of 1/2, 2/3, etc., no error correction or auto
detection.
</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="fe-modulation-t"></a>frontend modulation type for QAM, OFDM and VSB</h4></div></div></div><p>For cable and terrestrial frontends, e. g. for
<a class="link" href="media.html#dvb-qam-parameters" title="QAM parameters"><code class="constant">struct dvb_qpsk_parameters</code></a>,
<a class="link" href="media.html#dvb-ofdm-parameters" title="OFDM parameters"><code class="constant">struct dvb_qam_parameters</code></a> and
<a class="link" href="media.html#dvb-vsb-parameters" title="VSB parameters"><code class="constant">struct dvb_qam_parameters</code></a>,
it needs to specify the quadrature modulation mode which can be one of the following:
</p><pre class="programlisting">
 typedef enum fe_modulation {
	QPSK,
	QAM_16,
	QAM_32,
	QAM_64,
	QAM_128,
	QAM_256,
	QAM_AUTO,
	VSB_8,
	VSB_16,
	PSK_8,
	APSK_16,
	APSK_32,
	DQPSK,
 } fe_modulation_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp104565440"></a>More OFDM parameters</h4></div></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="fe-transmit-mode-t"></a>Number of carriers per channel</h5></div></div></div><pre class="programlisting">
typedef enum fe_transmit_mode {
	TRANSMISSION_MODE_2K,
	TRANSMISSION_MODE_8K,
	TRANSMISSION_MODE_AUTO,
	TRANSMISSION_MODE_4K,
	TRANSMISSION_MODE_1K,
	TRANSMISSION_MODE_16K,
	TRANSMISSION_MODE_32K,
 } fe_transmit_mode_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="fe-bandwidth-t"></a>frontend bandwidth</h5></div></div></div><pre class="programlisting">
typedef enum fe_bandwidth {
	BANDWIDTH_8_MHZ,
	BANDWIDTH_7_MHZ,
	BANDWIDTH_6_MHZ,
	BANDWIDTH_AUTO,
	BANDWIDTH_5_MHZ,
	BANDWIDTH_10_MHZ,
	BANDWIDTH_1_712_MHZ,
} fe_bandwidth_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="fe-guard-interval-t"></a>frontend guard inverval</h5></div></div></div><pre class="programlisting">
typedef enum fe_guard_interval {
	GUARD_INTERVAL_1_32,
	GUARD_INTERVAL_1_16,
	GUARD_INTERVAL_1_8,
	GUARD_INTERVAL_1_4,
	GUARD_INTERVAL_AUTO,
	GUARD_INTERVAL_1_128,
	GUARD_INTERVAL_19_128,
	GUARD_INTERVAL_19_256,
} fe_guard_interval_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="fe-hierarchy-t"></a>frontend hierarchy</h5></div></div></div><pre class="programlisting">
typedef enum fe_hierarchy {
	 HIERARCHY_NONE,
	 HIERARCHY_1,
	 HIERARCHY_2,
	 HIERARCHY_4,
	 HIERARCHY_AUTO
 } fe_hierarchy_t;
</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dvb-frontend-event"></a>frontend events</h3></div></div></div><pre class="programlisting">
 struct dvb_frontend_event {
	 fe_status_t status;
	 struct dvb_frontend_parameters parameters;
 };
</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="frontend_fcalls"></a>Frontend Function Calls</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#frontend_f_open">open()</a></span></dt><dt><span class="section"><a href="media.html#frontend_f_close">close()</a></span></dt><dt><span class="section"><a href="media.html#FE_READ_STATUS">FE_READ_STATUS</a></span></dt><dt><span class="section"><a href="media.html#FE_READ_BER">FE_READ_BER</a></span></dt><dt><span class="section"><a href="media.html#FE_READ_SNR">FE_READ_SNR</a></span></dt><dt><span class="section"><a href="media.html#FE_READ_SIGNAL_STRENGTH">FE_READ_SIGNAL_STRENGTH</a></span></dt><dt><span class="section"><a href="media.html#FE_READ_UNCORRECTED_BLOCKS">FE_READ_UNCORRECTED_BLOCKS</a></span></dt><dt><span class="section"><a href="media.html#FE_SET_FRONTEND">FE_SET_FRONTEND</a></span></dt><dt><span class="section"><a href="media.html#FE_GET_FRONTEND">FE_GET_FRONTEND</a></span></dt><dt><span class="section"><a href="media.html#FE_GET_EVENT">FE_GET_EVENT</a></span></dt><dt><span class="section"><a href="media.html#FE_GET_INFO">FE_GET_INFO</a></span></dt><dt><span class="section"><a href="media.html#FE_DISEQC_RESET_OVERLOAD">FE_DISEQC_RESET_OVERLOAD</a></span></dt><dt><span class="section"><a href="media.html#FE_DISEQC_SEND_MASTER_CMD">FE_DISEQC_SEND_MASTER_CMD</a></span></dt><dt><span class="section"><a href="media.html#FE_DISEQC_RECV_SLAVE_REPLY">FE_DISEQC_RECV_SLAVE_REPLY</a></span></dt><dt><span class="section"><a href="media.html#FE_DISEQC_SEND_BURST">FE_DISEQC_SEND_BURST</a></span></dt><dt><span class="section"><a href="media.html#FE_SET_TONE">FE_SET_TONE</a></span></dt><dt><span class="section"><a href="media.html#FE_SET_VOLTAGE">FE_SET_VOLTAGE</a></span></dt><dt><span class="section"><a href="media.html#FE_ENABLE_HIGH_LNB_VOLTAGE">FE_ENABLE_HIGH_LNB_VOLTAGE</a></span></dt><dt><span class="section"><a href="media.html#FE_SET_FRONTEND_TUNE_MODE">FE_SET_FRONTEND_TUNE_MODE</a></span></dt><dt><span class="section"><a href="media.html#FE_DISHNETWORK_SEND_LEGACY_CMD">FE_DISHNETWORK_SEND_LEGACY_CMD</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="frontend_f_open"></a>open()</h3></div></div></div><p>DESCRIPTION</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This system call opens a named frontend device (/dev/dvb/adapter0/frontend0)
 for subsequent use. Usually the first thing to do after a successful open is to
 find out the frontend type with <a class="link" href="media.html#FE_GET_INFO" title="FE_GET_INFO">FE_GET_INFO</a>.</p>
<p>The device can be opened in read-only mode, which only allows monitoring of
 device status and statistics, or read/write mode, which allows any kind of use
 (e.g. performing tuning operations.)
</p>
<p>In a system with multiple front-ends, it is usually the case that multiple devices
 cannot be open in read/write mode simultaneously. As long as a front-end
 device is opened in read/write mode, other open() calls in read/write mode will
 either fail or block, depending on whether non-blocking or blocking mode was
 specified. A front-end device opened in blocking mode can later be put into
 non-blocking mode (and vice versa) using the F_SETFL command of the fcntl
 system call. This is a standard system call, documented in the Linux manual
 page for fcntl. When an open() call has succeeded, the device will be ready
 for use in the specified mode. This implies that the corresponding hardware is
 powered up, and that other front-ends may have been powered down to make
 that possible.</p>
</td></tr></tbody></table></div><p>SYNOPSIS</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int open(const char &#8902;deviceName, int flags);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>const char
 *deviceName</p>
</td><td align="char">
<p>Name of specific video device.</p>
</td></tr><tr><td align="char">
<p>int flags</p>
</td><td align="char">
<p>A bit-wise OR of the following flags:</p>
</td></tr><tr><td align="char">
</td><td align="char">
<p>O_RDONLY read-only access</p>
</td></tr><tr><td align="char">
</td><td align="char">
<p>O_RDWR read/write access</p>
</td></tr><tr><td align="char">
</td><td align="char">
<p>O_NONBLOCK open in non-blocking mode</p>
</td></tr><tr><td align="char">
</td><td align="char">
<p>(blocking mode is the default)</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>ENODEV</p>
</td><td align="char">
<p>Device driver not loaded/available.</p>
</td></tr><tr><td align="char">
<p>EINTERNAL</p>
</td><td align="char">
<p>Internal error.</p>
</td></tr><tr><td align="char">
<p>EBUSY</p>
</td><td align="char">
<p>Device or resource busy.</p>
</td></tr><tr><td align="char">
<p>EINVAL</p>
</td><td align="char">
<p>Invalid argument.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="frontend_f_close"></a>close()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This system call closes a previously opened front-end device. After closing
 a front-end device, its corresponding hardware might be powered down
 automatically.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int close(int fd);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>EBADF</p>
</td><td align="char">
<p>fd is not a valid open file descriptor.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="FE_READ_STATUS"></a>FE_READ_STATUS</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call returns status information about the front-end. This call only
 requires read-only access to the device.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request = <a class="link" href="media.html#FE_READ_STATUS" title="FE_READ_STATUS">FE_READ_STATUS</a>,
 fe_status_t &#8902;status);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals <a class="link" href="media.html#FE_READ_STATUS" title="FE_READ_STATUS">FE_READ_STATUS</a> for this command.</p>
</td></tr><tr><td align="char">
<p>struct fe_status_t
 *status</p>
</td><td align="char">
<p>Points to the location where the front-end status word is
 to be stored.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>EBADF</p>
</td><td align="char">
<p>fd is not a valid open file descriptor.</p>
</td></tr><tr><td align="char">
<p>EFAULT</p>
</td><td align="char">
<p>status points to invalid address.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="FE_READ_BER"></a>FE_READ_BER</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call returns the bit error rate for the signal currently
 received/demodulated by the front-end. For this command, read-only access to
 the device is sufficient.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request = <a class="link" href="media.html#FE_READ_BER" title="FE_READ_BER">FE_READ_BER</a>,
 uint32_t &#8902;ber);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals <a class="link" href="media.html#FE_READ_BER" title="FE_READ_BER">FE_READ_BER</a> for this command.</p>
</td></tr><tr><td align="char">
<p>uint32_t *ber</p>
</td><td align="char">
<p>The bit error rate is stored into *ber.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="FE_READ_SNR"></a>FE_READ_SNR</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call returns the signal-to-noise ratio for the signal currently received
 by the front-end. For this command, read-only access to the device is sufficient.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request = <a class="link" href="media.html#FE_READ_SNR" title="FE_READ_SNR">FE_READ_SNR</a>, uint16_t
 &#8902;snr);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals <a class="link" href="media.html#FE_READ_SNR" title="FE_READ_SNR">FE_READ_SNR</a> for this command.</p>
</td></tr><tr><td align="char">
<p>uint16_t *snr</p>
</td><td align="char">
<p>The signal-to-noise ratio is stored into *snr.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="FE_READ_SIGNAL_STRENGTH"></a>FE_READ_SIGNAL_STRENGTH</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call returns the signal strength value for the signal currently received
 by the front-end. For this command, read-only access to the device is sufficient.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl( int fd, int request =
 <a class="link" href="media.html#FE_READ_SIGNAL_STRENGTH" title="FE_READ_SIGNAL_STRENGTH">FE_READ_SIGNAL_STRENGTH</a>, uint16_t &#8902;strength);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals <a class="link" href="media.html#FE_READ_SIGNAL_STRENGTH" title="FE_READ_SIGNAL_STRENGTH">FE_READ_SIGNAL_STRENGTH</a> for this
 command.</p>
</td></tr><tr><td align="char">
<p>uint16_t *strength</p>
</td><td align="char">
<p>The signal strength value is stored into *strength.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="FE_READ_UNCORRECTED_BLOCKS"></a>FE_READ_UNCORRECTED_BLOCKS</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call returns the number of uncorrected blocks detected by the device
 driver during its lifetime. For meaningful measurements, the increment in block
 count during a specific time interval should be calculated. For this command,
 read-only access to the device is sufficient.</p>
</td></tr><tr><td align="char">
<p>Note that the counter will wrap to zero after its maximum count has been
 reached.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl( int fd, int request =
 <a class="link" href="media.html#FE_READ_UNCORRECTED_BLOCKS" title="FE_READ_UNCORRECTED_BLOCKS">FE_READ_UNCORRECTED_BLOCKS</a>, uint32_t &#8902;ublocks);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals <a class="link" href="media.html#FE_READ_UNCORRECTED_BLOCKS" title="FE_READ_UNCORRECTED_BLOCKS">FE_READ_UNCORRECTED_BLOCKS</a> for this
 command.</p>
</td></tr><tr><td align="char">
<p>uint32_t *ublocks</p>
</td><td align="char">
<p>The total number of uncorrected blocks seen by the driver
 so far.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="FE_SET_FRONTEND"></a>FE_SET_FRONTEND</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call starts a tuning operation using specified parameters. The result
 of this call will be successful if the parameters were valid and the tuning could
 be initiated. The result of the tuning operation in itself, however, will arrive
 asynchronously as an event (see documentation for <a class="link" href="media.html#FE_GET_EVENT" title="FE_GET_EVENT">FE_GET_EVENT</a> and
 FrontendEvent.) If a new <a class="link" href="media.html#FE_SET_FRONTEND" title="FE_SET_FRONTEND">FE_SET_FRONTEND</a> operation is initiated before
 the previous one was completed, the previous operation will be aborted in favor
 of the new one. This command requires read/write access to the device.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request = <a class="link" href="media.html#FE_SET_FRONTEND" title="FE_SET_FRONTEND">FE_SET_FRONTEND</a>,
 struct dvb_frontend_parameters &#8902;p);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals <a class="link" href="media.html#FE_SET_FRONTEND" title="FE_SET_FRONTEND">FE_SET_FRONTEND</a> for this command.</p>
</td></tr><tr><td align="char">
<p>struct
 dvb_frontend_parameters
 *p</p>
</td><td align="char">
<p>Points to parameters for tuning operation.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>EINVAL</p>
</td><td align="char">
<p>Maximum supported symbol rate reached.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="FE_GET_FRONTEND"></a>FE_GET_FRONTEND</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call queries the currently effective frontend parameters. For this
 command, read-only access to the device is sufficient.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request = <a class="link" href="media.html#FE_GET_FRONTEND" title="FE_GET_FRONTEND">FE_GET_FRONTEND</a>,
 struct dvb_frontend_parameters &#8902;p);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals <a class="link" href="media.html#FE_SET_FRONTEND" title="FE_SET_FRONTEND">FE_SET_FRONTEND</a> for this command.</p>
</td></tr><tr><td align="char">
<p>struct
 dvb_frontend_parameters
 *p</p>
</td><td align="char">
<p>Points to parameters for tuning operation.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>EINVAL</p>
</td><td align="char">
<p>Maximum supported symbol rate reached.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="FE_GET_EVENT"></a>FE_GET_EVENT</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call returns a frontend event if available. If an event is not
 available, the behavior depends on whether the device is in blocking or
 non-blocking mode. In the latter case, the call fails immediately with errno
 set to EWOULDBLOCK. In the former case, the call blocks until an event
 becomes available.</p>
</td></tr><tr><td align="char">
<p>The standard Linux poll() and/or select() system calls can be used with the
 device file descriptor to watch for new events. For select(), the file descriptor
 should be included in the exceptfds argument, and for poll(), POLLPRI should
 be specified as the wake-up condition. Since the event queue allocated is
 rather small (room for 8 events), the queue must be serviced regularly to avoid
 overflow. If an overflow happens, the oldest event is discarded from the queue,
 and an error (EOVERFLOW) occurs the next time the queue is read. After
 reporting the error condition in this fashion, subsequent
 <a class="link" href="media.html#FE_GET_EVENT" title="FE_GET_EVENT">FE_GET_EVENT</a>
 calls will return events from the queue as usual.</p>
</td></tr><tr><td align="char">
<p>For the sake of implementation simplicity, this command requires read/write
 access to the device.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request = QPSK_GET_EVENT,
 struct dvb_frontend_event &#8902;ev);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals <a class="link" href="media.html#FE_GET_EVENT" title="FE_GET_EVENT">FE_GET_EVENT</a> for this command.</p>
</td></tr><tr><td align="char">
<p>struct
 dvb_frontend_event
 *ev</p>
</td><td align="char">
<p>Points to the location where the event,</p>
</td></tr><tr><td align="char">
</td><td align="char">
<p>if any, is to be stored.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>EWOULDBLOCK</p>
</td><td align="char">
<p>There is no event pending, and the device is in
 non-blocking mode.</p>
</td></tr><tr><td align="char">
<p>EOVERFLOW</p>
</td><td align="char">
<p>Overflow in event queue - one or more events were lost.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="FE_GET_INFO"></a>FE_GET_INFO</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call returns information about the front-end. This call only requires
 read-only access to the device.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p> int ioctl(int fd, int request = <a class="link" href="media.html#FE_GET_INFO" title="FE_GET_INFO">FE_GET_INFO</a>, struct
 dvb_frontend_info &#8902;info);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals <a class="link" href="media.html#FE_GET_INFO" title="FE_GET_INFO">FE_GET_INFO</a> for this command.</p>
</td></tr><tr><td align="char">
<p>struct
 dvb_frontend_info
 *info</p>
</td><td align="char">
<p>Points to the location where the front-end information is
 to be stored.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="FE_DISEQC_RESET_OVERLOAD"></a>FE_DISEQC_RESET_OVERLOAD</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>If the bus has been automatically powered off due to power overload, this ioctl
 call restores the power to the bus. The call requires read/write access to the
 device. This call has no effect if the device is manually powered off. Not all
 DVB adapters support this ioctl.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request =
 <a class="link" href="media.html#FE_DISEQC_RESET_OVERLOAD" title="FE_DISEQC_RESET_OVERLOAD">FE_DISEQC_RESET_OVERLOAD</a>);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals <a class="link" href="media.html#FE_DISEQC_RESET_OVERLOAD" title="FE_DISEQC_RESET_OVERLOAD">FE_DISEQC_RESET_OVERLOAD</a> for this
 command.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="FE_DISEQC_SEND_MASTER_CMD"></a>FE_DISEQC_SEND_MASTER_CMD</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call is used to send a a DiSEqC command.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request =
 <a class="link" href="media.html#FE_DISEQC_SEND_MASTER_CMD" title="FE_DISEQC_SEND_MASTER_CMD">FE_DISEQC_SEND_MASTER_CMD</a>, struct
 dvb_diseqc_master_cmd &#8902;cmd);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals <a class="link" href="media.html#FE_DISEQC_SEND_MASTER_CMD" title="FE_DISEQC_SEND_MASTER_CMD">FE_DISEQC_SEND_MASTER_CMD</a> for this
 command.</p>
</td></tr><tr><td align="char">
<p>struct
 dvb_diseqc_master_cmd
 *cmd</p>
</td><td align="char">
<p>Pointer to the command to be transmitted.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="FE_DISEQC_RECV_SLAVE_REPLY"></a>FE_DISEQC_RECV_SLAVE_REPLY</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call is used to receive reply to a DiSEqC 2.0 command.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request =
 <a class="link" href="media.html#FE_DISEQC_RECV_SLAVE_REPLY" title="FE_DISEQC_RECV_SLAVE_REPLY">FE_DISEQC_RECV_SLAVE_REPLY</a>, struct
 dvb_diseqc_slave_reply &#8902;reply);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals <a class="link" href="media.html#FE_DISEQC_RECV_SLAVE_REPLY" title="FE_DISEQC_RECV_SLAVE_REPLY">FE_DISEQC_RECV_SLAVE_REPLY</a> for this
 command.</p>
</td></tr><tr><td align="char">
<p>struct
 dvb_diseqc_slave_reply
 *reply</p>
</td><td align="char">
<p>Pointer to the command to be received.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="FE_DISEQC_SEND_BURST"></a>FE_DISEQC_SEND_BURST</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call is used to send a 22KHz tone burst.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request =
 <a class="link" href="media.html#FE_DISEQC_SEND_BURST" title="FE_DISEQC_SEND_BURST">FE_DISEQC_SEND_BURST</a>, fe_sec_mini_cmd_t burst);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals <a class="link" href="media.html#FE_DISEQC_SEND_BURST" title="FE_DISEQC_SEND_BURST">FE_DISEQC_SEND_BURST</a> for this command.</p>
</td></tr><tr><td align="char">
<p>fe_sec_mini_cmd_t
 burst</p>
</td><td align="char">
<p>burst A or B.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="FE_SET_TONE"></a>FE_SET_TONE</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This call is used to set the generation of the continuous 22kHz tone. This call
 requires read/write permissions.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request = <a class="link" href="media.html#FE_SET_TONE" title="FE_SET_TONE">FE_SET_TONE</a>,
 fe_sec_tone_mode_t tone);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals <a class="link" href="media.html#FE_SET_TONE" title="FE_SET_TONE">FE_SET_TONE</a> for this command.</p>
</td></tr><tr><td align="char">
<p>fe_sec_tone_mode_t
 tone</p>
</td><td align="char">
<p>The requested tone generation mode (on/off).</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="FE_SET_VOLTAGE"></a>FE_SET_VOLTAGE</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This call is used to set the bus voltage. This call requires read/write
 permissions.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request = <a class="link" href="media.html#FE_SET_VOLTAGE" title="FE_SET_VOLTAGE">FE_SET_VOLTAGE</a>,
 fe_sec_voltage_t voltage);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals <a class="link" href="media.html#FE_SET_VOLTAGE" title="FE_SET_VOLTAGE">FE_SET_VOLTAGE</a> for this command.</p>
</td></tr><tr><td align="char">
<p>fe_sec_voltage_t
 voltage</p>
</td><td align="char">
<p>The requested bus voltage.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="FE_ENABLE_HIGH_LNB_VOLTAGE"></a>FE_ENABLE_HIGH_LNB_VOLTAGE</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>If high != 0 enables slightly higher voltages instead of 13/18V (to compensate
 for long cables). This call requires read/write permissions. Not all DVB
 adapters support this ioctl.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request =
 <a class="link" href="media.html#FE_ENABLE_HIGH_LNB_VOLTAGE" title="FE_ENABLE_HIGH_LNB_VOLTAGE">FE_ENABLE_HIGH_LNB_VOLTAGE</a>, int high);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals <a class="link" href="media.html#FE_SET_VOLTAGE" title="FE_SET_VOLTAGE">FE_SET_VOLTAGE</a> for this command.</p>
</td></tr><tr><td align="char">
<p>int high</p>
</td><td align="char">
<p>The requested bus voltage.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="FE_SET_FRONTEND_TUNE_MODE"></a>FE_SET_FRONTEND_TUNE_MODE</h3></div></div></div><p>DESCRIPTION</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>Allow setting tuner mode flags to the frontend.</p>
</td></tr></tbody></table></div><p>SYNOPSIS</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request =
<a class="link" href="media.html#FE_SET_FRONTEND_TUNE_MODE" title="FE_SET_FRONTEND_TUNE_MODE">FE_SET_FRONTEND_TUNE_MODE</a>, unsigned int flags);</p>
</td></tr></tbody></table></div><p>PARAMETERS</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
	<p>unsigned int flags</p>
</td><td align="char">
<p>
FE_TUNE_MODE_ONESHOT When set, this flag will disable any zigzagging or other "normal" tuning behaviour. Additionally, there will be no automatic monitoring of the lock status, and hence no frontend events will be generated. If a frontend device is closed, this flag will be automatically turned off when the device is reopened read-write.
</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="FE_DISHNETWORK_SEND_LEGACY_CMD"></a>FE_DISHNETWORK_SEND_LEGACY_CMD</h3></div></div></div><p>DESCRIPTION</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>WARNING: This is a very obscure legacy command, used only at stv0299 driver. Should not be used on newer drivers.</p>
<p>It provides a non-standard method for selecting Diseqc voltage on the frontend, for Dish Network legacy switches.</p>
<p>As support for this ioctl were added in 2004, this means that such dishes were already legacy in 2004.</p>
</td></tr></tbody></table></div><p>SYNOPSIS</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request =
	<a class="link" href="media.html#FE_DISHNETWORK_SEND_LEGACY_CMD" title="FE_DISHNETWORK_SEND_LEGACY_CMD">FE_DISHNETWORK_SEND_LEGACY_CMD</a>, unsigned long cmd);</p>
</td></tr></tbody></table></div><p>PARAMETERS</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
	<p>unsigned long cmd</p>
</td><td align="char">
<p>
sends the specified raw cmd to the dish via DISEqC.
</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="FE_GET_SET_PROPERTY"></a><code class="constant">FE_GET_PROPERTY/FE_SET_PROPERTY</code></h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#dtv-stats">DTV stats type</a></span></dt><dt><span class="section"><a href="media.html#dtv-fe-stats">DTV stats type</a></span></dt><dt><span class="section"><a href="media.html#dtv-property">DTV property type</a></span></dt><dt><span class="section"><a href="media.html#dtv-properties">DTV properties type</a></span></dt><dt><span class="section"><a href="media.html#FE_GET_PROPERTY">FE_GET_PROPERTY</a></span></dt><dt><span class="section"><a href="media.html#FE_SET_PROPERTY">FE_SET_PROPERTY</a></span></dt><dt><span class="section"><a href="media.html#idp105068368">Property types</a></span></dt><dt><span class="section"><a href="media.html#fe_property_parameters">Digital TV property parameters</a></span></dt><dt><span class="section"><a href="media.html#frontend-stat-properties">Frontend statistics indicators</a></span></dt><dt><span class="section"><a href="media.html#frontend-property-terrestrial-systems">Properties used on terrestrial delivery systems</a></span></dt><dt><span class="section"><a href="media.html#frontend-property-cable-systems">Properties used on cable delivery systems</a></span></dt><dt><span class="section"><a href="media.html#frontend-property-satellital-systems">Properties used on satellital delivery systems</a></span></dt></dl></div><p>This section describes the DVB version 5 extension of the DVB-API, also
called "S2API", as this API were added to provide support for DVB-S2. It was
designed to be able to replace the old frontend API. Yet, the DISEQC and
the capability ioctls weren't implemented yet via the new way.</p><p>The typical usage for the <code class="constant">FE_GET_PROPERTY/FE_SET_PROPERTY</code>
API is to replace the ioctl's were the <a class="link" href="media.html#dvb-frontend-parameters" title="frontend parameters">
struct <code class="constant">dvb_frontend_parameters</code></a> were used.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dtv-stats"></a>DTV stats type</h3></div></div></div><pre class="programlisting">
struct dtv_stats {
	__u8 scale;	/* enum fecap_scale_params type */
	union {
		__u64 uvalue;	/* for counters and relative scales */
		__s64 svalue;	/* for 1/1000 dB measures */
	};
} __packed;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dtv-fe-stats"></a>DTV stats type</h3></div></div></div><pre class="programlisting">
#define MAX_DTV_STATS   4

struct dtv_fe_stats {
	__u8 len;
	struct dtv_stats stat[MAX_DTV_STATS];
} __packed;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dtv-property"></a>DTV property type</h3></div></div></div><pre class="programlisting">
/* Reserved fields should be set to 0 */

struct dtv_property {
	__u32 cmd;
	__u32 reserved[3];
	union {
		__u32 data;
		struct dtv_fe_stats st;
		struct {
			__u8 data[32];
			__u32 len;
			__u32 reserved1[3];
			void *reserved2;
		} buffer;
	} u;
	int result;
} __attribute__ ((packed));

/* num of properties cannot exceed DTV_IOCTL_MAX_MSGS per ioctl */
#define DTV_IOCTL_MAX_MSGS 64
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dtv-properties"></a>DTV properties type</h3></div></div></div><pre class="programlisting">
struct dtv_properties {
	__u32 num;
	struct dtv_property *props;
};
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="FE_GET_PROPERTY"></a>FE_GET_PROPERTY</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call returns one or more frontend properties. This call only
 requires read-only access to the device.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request = <a class="link" href="media.html#FE_GET_PROPERTY" title="FE_GET_PROPERTY">FE_GET_PROPERTY</a>,
 dtv_properties &#8902;props);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int num</p>
</td><td align="char">
<p>Equals <a class="link" href="media.html#FE_GET_PROPERTY" title="FE_GET_PROPERTY">FE_GET_PROPERTY</a> for this command.</p>
</td></tr><tr><td align="char">
<p>struct dtv_property *props</p>
</td><td align="char">
<p>Points to the location where the front-end property commands are stored.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char"><p>EOPNOTSUPP</p></td><td align="char"><p>Property type not supported.</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="FE_SET_PROPERTY"></a>FE_SET_PROPERTY</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call sets one or more frontend properties. This call
 requires read/write access to the device.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request = <a class="link" href="media.html#FE_SET_PROPERTY" title="FE_SET_PROPERTY">FE_SET_PROPERTY</a>,
 dtv_properties &#8902;props);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int num</p>
</td><td align="char">
<p>Equals <a class="link" href="media.html#FE_SET_PROPERTY" title="FE_SET_PROPERTY">FE_SET_PROPERTY</a> for this command.</p>
</td></tr><tr><td align="char">
<p>struct dtv_property *props</p>
</td><td align="char">
<p>Points to the location where the front-end property commands are stored.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char"><p>EOPNOTSUPP</p></td><td align="char"><p>Property type not supported.</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp105068368"></a>Property types</h3></div></div></div><p>
On <a class="link" href="media.html#FE_GET_PROPERTY" title="FE_GET_PROPERTY">FE_GET_PROPERTY</a>/<a class="link" href="media.html#FE_SET_PROPERTY" title="FE_SET_PROPERTY">FE_SET_PROPERTY</a>,
the actual action is determined by the dtv_property cmd/data pairs. With one single ioctl, is possible to
get/set up to 64 properties. The actual meaning of each property is described on the next sections.
</p><p>The available frontend property types are shown on the next section.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="fe_property_parameters"></a>Digital TV property parameters</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#DTV-UNDEFINED"><code class="constant">DTV_UNDEFINED</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-TUNE"><code class="constant">DTV_TUNE</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-CLEAR"><code class="constant">DTV_CLEAR</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-FREQUENCY"><code class="constant">DTV_FREQUENCY</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-MODULATION"><code class="constant">DTV_MODULATION</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-BANDWIDTH-HZ"><code class="constant">DTV_BANDWIDTH_HZ</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-INVERSION"><code class="constant">DTV_INVERSION</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-DISEQC-MASTER"><code class="constant">DTV_DISEQC_MASTER</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-SYMBOL-RATE"><code class="constant">DTV_SYMBOL_RATE</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-INNER-FEC"><code class="constant">DTV_INNER_FEC</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-VOLTAGE"><code class="constant">DTV_VOLTAGE</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-TONE"><code class="constant">DTV_TONE</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-PILOT"><code class="constant">DTV_PILOT</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-ROLLOFF"><code class="constant">DTV_ROLLOFF</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-DISEQC-SLAVE-REPLY"><code class="constant">DTV_DISEQC_SLAVE_REPLY</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-FE-CAPABILITY-COUNT"><code class="constant">DTV_FE_CAPABILITY_COUNT</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-FE-CAPABILITY"><code class="constant">DTV_FE_CAPABILITY</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-DELIVERY-SYSTEM"><code class="constant">DTV_DELIVERY_SYSTEM</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-ISDBT-PARTIAL-RECEPTION"><code class="constant">DTV_ISDBT_PARTIAL_RECEPTION</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-ISDBT-SOUND-BROADCASTING"><code class="constant">DTV_ISDBT_SOUND_BROADCASTING</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-ISDBT-SB-SUBCHANNEL-ID"><code class="constant">DTV_ISDBT_SB_SUBCHANNEL_ID</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-ISDBT-SB-SEGMENT-IDX"><code class="constant">DTV_ISDBT_SB_SEGMENT_IDX</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-ISDBT-SB-SEGMENT-COUNT"><code class="constant">DTV_ISDBT_SB_SEGMENT_COUNT</code></a></span></dt><dt><span class="section"><a href="media.html#isdb-hierq-layers"><code class="constant">DTV-ISDBT-LAYER*</code> parameters</a></span></dt><dt><span class="section"><a href="media.html#DTV-API-VERSION"><code class="constant">DTV_API_VERSION</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-CODE-RATE-HP"><code class="constant">DTV_CODE_RATE_HP</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-CODE-RATE-LP"><code class="constant">DTV_CODE_RATE_LP</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-GUARD-INTERVAL"><code class="constant">DTV_GUARD_INTERVAL</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-TRANSMISSION-MODE"><code class="constant">DTV_TRANSMISSION_MODE</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-HIERARCHY"><code class="constant">DTV_HIERARCHY</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-STREAM-ID"><code class="constant">DTV_STREAM_ID</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-DVBT2-PLP-ID-LEGACY"><code class="constant">DTV_DVBT2_PLP_ID_LEGACY</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-ENUM-DELSYS"><code class="constant">DTV_ENUM_DELSYS</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-INTERLEAVING"><code class="constant">DTV_INTERLEAVING</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-LNA"><code class="constant">DTV_LNA</code></a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-UNDEFINED"></a><code class="constant">DTV_UNDEFINED</code></h4></div></div></div><p>Used internally. A GET/SET operation for it won't change or return anything.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-TUNE"></a><code class="constant">DTV_TUNE</code></h4></div></div></div><p>Interpret the cache of data, build either a traditional frontend tunerequest so we can pass validation in the <code class="constant">FE_SET_FRONTEND</code> ioctl.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-CLEAR"></a><code class="constant">DTV_CLEAR</code></h4></div></div></div><p>Reset a cache of data specific to the frontend here. This does not effect hardware.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-FREQUENCY"></a><code class="constant">DTV_FREQUENCY</code></h4></div></div></div><p>Central frequency of the channel.</p><p>Notes:</p><p>1)For satellital delivery systems, it is measured in kHz.
			For the other ones, it is measured in Hz.</p><p>2)For ISDB-T, the channels are usually transmitted with an offset of 143kHz.
			E.g. a valid frequency could be 474143 kHz. The stepping is bound to the bandwidth of
			the channel which is 6MHz.</p><p>3)As in ISDB-Tsb the channel consists of only one or three segments the
			frequency step is 429kHz, 3*429 respectively. As for ISDB-T the
			central frequency of the channel is expected.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-MODULATION"></a><code class="constant">DTV_MODULATION</code></h4></div></div></div><p>Specifies the frontend modulation type for cable and satellite types. The modulation can be one of the types bellow:</p><pre class="programlisting">
 typedef enum fe_modulation {
	QPSK,
	QAM_16,
	QAM_32,
	QAM_64,
	QAM_128,
	QAM_256,
	QAM_AUTO,
	VSB_8,
	VSB_16,
	PSK_8,
	APSK_16,
	APSK_32,
	DQPSK,
	QAM_4_NR,
 } fe_modulation_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-BANDWIDTH-HZ"></a><code class="constant">DTV_BANDWIDTH_HZ</code></h4></div></div></div><p>Bandwidth for the channel, in HZ.</p><p>Possible values:
			<code class="constant">1712000</code>,
			<code class="constant">5000000</code>,
			<code class="constant">6000000</code>,
			<code class="constant">7000000</code>,
			<code class="constant">8000000</code>,
			<code class="constant">10000000</code>.
		</p><p>Notes:</p><p>1) For ISDB-T it should be always 6000000Hz (6MHz)</p><p>2) For ISDB-Tsb it can vary depending on the number of connected segments</p><p>3) Bandwidth doesn't apply for DVB-C transmissions, as the bandwidth
			 for DVB-C depends on the symbol rate</p><p>4) Bandwidth in ISDB-T is fixed (6MHz) or can be easily derived from
			other parameters (DTV_ISDBT_SB_SEGMENT_IDX,
			DTV_ISDBT_SB_SEGMENT_COUNT).</p><p>5) DVB-T supports 6, 7 and 8MHz.</p><p>6) In addition, DVB-T2 supports 1.172, 5 and 10MHz.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-INVERSION"></a><code class="constant">DTV_INVERSION</code></h4></div></div></div><p>The Inversion field can take one of these values:
	</p><pre class="programlisting">
	typedef enum fe_spectral_inversion {
		INVERSION_OFF,
		INVERSION_ON,
		INVERSION_AUTO
	} fe_spectral_inversion_t;
	</pre><p>It indicates if spectral inversion should be presumed or not. In the automatic setting
	(<code class="constant">INVERSION_AUTO</code>) the hardware will try to figure out the correct setting by
	itself.
	</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-DISEQC-MASTER"></a><code class="constant">DTV_DISEQC_MASTER</code></h4></div></div></div><p>Currently not implemented.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-SYMBOL-RATE"></a><code class="constant">DTV_SYMBOL_RATE</code></h4></div></div></div><p>Digital TV symbol rate, in bauds (symbols/second). Used on cable standards.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-INNER-FEC"></a><code class="constant">DTV_INNER_FEC</code></h4></div></div></div><p>Used cable/satellite transmissions. The acceptable values are:
	</p><pre class="programlisting">
typedef enum fe_code_rate {
	FEC_NONE = 0,
	FEC_1_2,
	FEC_2_3,
	FEC_3_4,
	FEC_4_5,
	FEC_5_6,
	FEC_6_7,
	FEC_7_8,
	FEC_8_9,
	FEC_AUTO,
	FEC_3_5,
	FEC_9_10,
	FEC_2_5,
} fe_code_rate_t;
	</pre><p>which correspond to error correction rates of 1/2, 2/3, etc.,
	no error correction or auto detection.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-VOLTAGE"></a><code class="constant">DTV_VOLTAGE</code></h4></div></div></div><p>The voltage is usually used with non-DiSEqC capable LNBs to switch
	the polarzation (horizontal/vertical). When using DiSEqC epuipment this
	voltage has to be switched consistently to the DiSEqC commands as
	described in the DiSEqC spec.</p><pre class="programlisting">
		typedef enum fe_sec_voltage {
		SEC_VOLTAGE_13,
		SEC_VOLTAGE_18
		} fe_sec_voltage_t;
	</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-TONE"></a><code class="constant">DTV_TONE</code></h4></div></div></div><p>Currently not used.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-PILOT"></a><code class="constant">DTV_PILOT</code></h4></div></div></div><p>Sets DVB-S2 pilot</p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="fe-pilot-t"></a>fe_pilot type</h5></div></div></div><pre class="programlisting">
typedef enum fe_pilot {
	PILOT_ON,
	PILOT_OFF,
	PILOT_AUTO,
} fe_pilot_t;
		</pre></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-ROLLOFF"></a><code class="constant">DTV_ROLLOFF</code></h4></div></div></div><p>Sets DVB-S2 rolloff</p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="fe-rolloff-t"></a>fe_rolloff type</h5></div></div></div><pre class="programlisting">
typedef enum fe_rolloff {
	ROLLOFF_35, /* Implied value in DVB-S, default for DVB-S2 */
	ROLLOFF_20,
	ROLLOFF_25,
	ROLLOFF_AUTO,
} fe_rolloff_t;
		</pre></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-DISEQC-SLAVE-REPLY"></a><code class="constant">DTV_DISEQC_SLAVE_REPLY</code></h4></div></div></div><p>Currently not implemented.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-FE-CAPABILITY-COUNT"></a><code class="constant">DTV_FE_CAPABILITY_COUNT</code></h4></div></div></div><p>Currently not implemented.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-FE-CAPABILITY"></a><code class="constant">DTV_FE_CAPABILITY</code></h4></div></div></div><p>Currently not implemented.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-DELIVERY-SYSTEM"></a><code class="constant">DTV_DELIVERY_SYSTEM</code></h4></div></div></div><p>Specifies the type of Delivery system</p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="fe-delivery-system-t"></a>fe_delivery_system type</h5></div></div></div><p>Possible values: </p><pre class="programlisting">

typedef enum fe_delivery_system {
	SYS_UNDEFINED,
	SYS_DVBC_ANNEX_A,
	SYS_DVBC_ANNEX_B,
	SYS_DVBT,
	SYS_DSS,
	SYS_DVBS,
	SYS_DVBS2,
	SYS_DVBH,
	SYS_ISDBT,
	SYS_ISDBS,
	SYS_ISDBC,
	SYS_ATSC,
	SYS_ATSCMH,
	SYS_DTMB,
	SYS_CMMB,
	SYS_DAB,
	SYS_DVBT2,
	SYS_TURBO,
	SYS_DVBC_ANNEX_C,
} fe_delivery_system_t;
</pre></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-ISDBT-PARTIAL-RECEPTION"></a><code class="constant">DTV_ISDBT_PARTIAL_RECEPTION</code></h4></div></div></div><p>If <code class="constant">DTV_ISDBT_SOUND_BROADCASTING</code> is '0' this bit-field represents whether
			the channel is in partial reception mode or not.</p><p>If '1' <code class="constant">DTV_ISDBT_LAYERA_*</code> values are assigned to the center segment and
			<code class="constant">DTV_ISDBT_LAYERA_SEGMENT_COUNT</code> has to be '1'.</p><p>If in addition <code class="constant">DTV_ISDBT_SOUND_BROADCASTING</code> is '1'
			<code class="constant">DTV_ISDBT_PARTIAL_RECEPTION</code> represents whether this ISDB-Tsb channel
			is consisting of one segment and layer or three segments and two layers.</p><p>Possible values: 0, 1, -1 (AUTO)</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-ISDBT-SOUND-BROADCASTING"></a><code class="constant">DTV_ISDBT_SOUND_BROADCASTING</code></h4></div></div></div><p>This field represents whether the other DTV_ISDBT_*-parameters are
			referring to an ISDB-T and an ISDB-Tsb channel. (See also
			<code class="constant">DTV_ISDBT_PARTIAL_RECEPTION</code>).</p><p>Possible values: 0, 1, -1 (AUTO)</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-ISDBT-SB-SUBCHANNEL-ID"></a><code class="constant">DTV_ISDBT_SB_SUBCHANNEL_ID</code></h4></div></div></div><p>This field only applies if <code class="constant">DTV_ISDBT_SOUND_BROADCASTING</code> is '1'.</p><p>(Note of the author: This might not be the correct description of the
			<code class="constant">SUBCHANNEL-ID</code> in all details, but it is my understanding of the technical
			background needed to program a device)</p><p>An ISDB-Tsb channel (1 or 3 segments) can be broadcasted alone or in a
			set of connected ISDB-Tsb channels. In this set of channels every
			channel can be received independently. The number of connected
			ISDB-Tsb segment can vary, e.g. depending on the frequency spectrum
			bandwidth available.</p><p>Example: Assume 8 ISDB-Tsb connected segments are broadcasted. The
			broadcaster has several possibilities to put those channels in the
			air: Assuming a normal 13-segment ISDB-T spectrum he can align the 8
			segments from position 1-8 to 5-13 or anything in between.</p><p>The underlying layer of segments are subchannels: each segment is
			consisting of several subchannels with a predefined IDs. A sub-channel
			is used to help the demodulator to synchronize on the channel.</p><p>An ISDB-T channel is always centered over all sub-channels. As for
			the example above, in ISDB-Tsb it is no longer as simple as that.</p><p><code class="constant">The DTV_ISDBT_SB_SUBCHANNEL_ID</code> parameter is used to give the
			sub-channel ID of the segment to be demodulated.</p><p>Possible values: 0 .. 41, -1 (AUTO)</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-ISDBT-SB-SEGMENT-IDX"></a><code class="constant">DTV_ISDBT_SB_SEGMENT_IDX</code></h4></div></div></div><p>This field only applies if <code class="constant">DTV_ISDBT_SOUND_BROADCASTING</code> is '1'.</p><p><code class="constant">DTV_ISDBT_SB_SEGMENT_IDX</code> gives the index of the segment to be
			demodulated for an ISDB-Tsb channel where several of them are
			transmitted in the connected manner.</p><p>Possible values: 0 .. <code class="constant">DTV_ISDBT_SB_SEGMENT_COUNT</code> - 1</p><p>Note: This value cannot be determined by an automatic channel search.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-ISDBT-SB-SEGMENT-COUNT"></a><code class="constant">DTV_ISDBT_SB_SEGMENT_COUNT</code></h4></div></div></div><p>This field only applies if <code class="constant">DTV_ISDBT_SOUND_BROADCASTING</code> is '1'.</p><p><code class="constant">DTV_ISDBT_SB_SEGMENT_COUNT</code> gives the total count of connected ISDB-Tsb
			channels.</p><p>Possible values: 1 .. 13</p><p>Note: This value cannot be determined by an automatic channel search.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="isdb-hierq-layers"></a><code class="constant">DTV-ISDBT-LAYER*</code> parameters</h4></div></div></div><p>ISDB-T channels can be coded hierarchically. As opposed to DVB-T in
			ISDB-T hierarchical layers can be decoded simultaneously. For that
			reason a ISDB-T demodulator has 3 Viterbi and 3 Reed-Solomon decoders.</p><p>ISDB-T has 3 hierarchical layers which each can use a part of the
			available segments. The total number of segments over all layers has
			to 13 in ISDB-T.</p><p>There are 3 parameter sets, for Layers A, B and C.</p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="DTV-ISDBT-LAYER-ENABLED"></a><code class="constant">DTV_ISDBT_LAYER_ENABLED</code></h5></div></div></div><p>Hierarchical reception in ISDB-T is achieved by enabling or disabling
				layers in the decoding process. Setting all bits of
				<code class="constant">DTV_ISDBT_LAYER_ENABLED</code> to '1' forces all layers (if applicable) to be
				demodulated. This is the default.</p><p>If the channel is in the partial reception mode
				(<code class="constant">DTV_ISDBT_PARTIAL_RECEPTION</code> = 1) the central segment can be decoded
				independently of the other 12 segments. In that mode layer A has to
				have a <code class="constant">SEGMENT_COUNT</code> of 1.</p><p>In ISDB-Tsb only layer A is used, it can be 1 or 3 in ISDB-Tsb
				according to <code class="constant">DTV_ISDBT_PARTIAL_RECEPTION</code>. <code class="constant">SEGMENT_COUNT</code> must be filled
				accordingly.</p><p>Possible values: 0x1, 0x2, 0x4 (|-able)</p><p><code class="constant">DTV_ISDBT_LAYER_ENABLED[0:0]</code> - layer A</p><p><code class="constant">DTV_ISDBT_LAYER_ENABLED[1:1]</code> - layer B</p><p><code class="constant">DTV_ISDBT_LAYER_ENABLED[2:2]</code> - layer C</p><p><code class="constant">DTV_ISDBT_LAYER_ENABLED[31:3]</code> unused</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="DTV-ISDBT-LAYER-FEC"></a><code class="constant">DTV_ISDBT_LAYER*_FEC</code></h5></div></div></div><p>Possible values: <code class="constant">FEC_AUTO</code>, <code class="constant">FEC_1_2</code>, <code class="constant">FEC_2_3</code>, <code class="constant">FEC_3_4</code>, <code class="constant">FEC_5_6</code>, <code class="constant">FEC_7_8</code></p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="DTV-ISDBT-LAYER-MODULATION"></a><code class="constant">DTV_ISDBT_LAYER*_MODULATION</code></h5></div></div></div><p>Possible values: <code class="constant">QAM_AUTO</code>, QP<code class="constant">SK, QAM_16</code>, <code class="constant">QAM_64</code>, <code class="constant">DQPSK</code></p><p>Note: If layer C is <code class="constant">DQPSK</code> layer B has to be <code class="constant">DQPSK</code>. If layer B is <code class="constant">DQPSK</code>
				and <code class="constant">DTV_ISDBT_PARTIAL_RECEPTION</code>=0 layer has to be <code class="constant">DQPSK</code>.</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="DTV-ISDBT-LAYER-SEGMENT-COUNT"></a><code class="constant">DTV_ISDBT_LAYER*_SEGMENT_COUNT</code></h5></div></div></div><p>Possible values: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, -1 (AUTO)</p><p>Note: Truth table for <code class="constant">DTV_ISDBT_SOUND_BROADCASTING</code> and
				<code class="constant">DTV_ISDBT_PARTIAL_RECEPTION</code> and <code class="constant">LAYER</code>*_SEGMENT_COUNT</p><div class="informaltable"><a name="isdbt-layer_seg-cnt-table"></a><table border="1"><colgroup><col><col><col><col><col><col></colgroup><tbody><tr><td>PR</td><td>SB</td><td>Layer A width</td><td>Layer B width</td><td>Layer C width</td><td>total width</td></tr><tr><td>0</td><td>0</td><td>1 .. 13</td><td>1 .. 13</td><td>1 .. 13</td><td>13</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1 .. 13</td><td>1 .. 13</td><td>13</td></tr><tr><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>2</td><td>0</td><td>13</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="DTV-ISDBT-LAYER-TIME-INTERLEAVING"></a><code class="constant">DTV_ISDBT_LAYER*_TIME_INTERLEAVING</code></h5></div></div></div><p>Valid values: 0, 1, 2, 4, -1 (AUTO)</p><p>when DTV_ISDBT_SOUND_BROADCASTING is active, value 8 is also valid.</p><p>Note: The real time interleaving length depends on the mode (fft-size). The values
				here are referring to what can be found in the TMCC-structure, as shown in the table below.</p><div class="informaltable"><a name="isdbt-layer-interleaving-table"></a><table border="1"><colgroup><col><col><col><col></colgroup><tbody><tr><td align="center">DTV_ISDBT_LAYER*_TIME_INTERLEAVING</td><td align="center">Mode 1 (2K FFT)</td><td align="center">Mode 2 (4K FFT)</td><td align="center">Mode 3 (8K FFT)</td></tr><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">4</td><td align="center">2</td><td align="center">1</td></tr><tr><td align="center">2</td><td align="center">8</td><td align="center">4</td><td align="center">2</td></tr><tr><td align="center">4</td><td align="center">16</td><td align="center">8</td><td align="center">4</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="DTV-ATSCMH-FIC-VER"></a><code class="constant">DTV_ATSCMH_FIC_VER</code></h5></div></div></div><p>Version number of the FIC (Fast Information Channel) signaling data.</p><p>FIC is used for relaying information to allow rapid service acquisition by the receiver.</p><p>Possible values: 0, 1, 2, 3, ..., 30, 31</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="DTV-ATSCMH-PARADE-ID"></a><code class="constant">DTV_ATSCMH_PARADE_ID</code></h5></div></div></div><p>Parade identification number</p><p>A parade is a collection of up to eight MH groups, conveying one or two ensembles.</p><p>Possible values: 0, 1, 2, 3, ..., 126, 127</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="DTV-ATSCMH-NOG"></a><code class="constant">DTV_ATSCMH_NOG</code></h5></div></div></div><p>Number of MH groups per MH subframe for a designated parade.</p><p>Possible values: 1, 2, 3, 4, 5, 6, 7, 8</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="DTV-ATSCMH-TNOG"></a><code class="constant">DTV_ATSCMH_TNOG</code></h5></div></div></div><p>Total number of MH groups including all MH groups belonging to all MH parades in one MH subframe.</p><p>Possible values: 0, 1, 2, 3, ..., 30, 31</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="DTV-ATSCMH-SGN"></a><code class="constant">DTV_ATSCMH_SGN</code></h5></div></div></div><p>Start group number.</p><p>Possible values: 0, 1, 2, 3, ..., 14, 15</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="DTV-ATSCMH-PRC"></a><code class="constant">DTV_ATSCMH_PRC</code></h5></div></div></div><p>Parade repetition cycle.</p><p>Possible values: 1, 2, 3, 4, 5, 6, 7, 8</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="DTV-ATSCMH-RS-FRAME-MODE"></a><code class="constant">DTV_ATSCMH_RS_FRAME_MODE</code></h5></div></div></div><p>RS frame mode.</p><p>Possible values are:</p><p><a name="atscmh-rs-frame-mode"></a>
</p><pre class="programlisting">
typedef enum atscmh_rs_frame_mode {
	ATSCMH_RSFRAME_PRI_ONLY  = 0,
	ATSCMH_RSFRAME_PRI_SEC   = 1,
} atscmh_rs_frame_mode_t;
</pre><p>
		  </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="DTV-ATSCMH-RS-FRAME-ENSEMBLE"></a><code class="constant">DTV_ATSCMH_RS_FRAME_ENSEMBLE</code></h5></div></div></div><p>RS frame ensemble.</p><p>Possible values are:</p><p><a name="atscmh-rs-frame-ensemble"></a>
</p><pre class="programlisting">
typedef enum atscmh_rs_frame_ensemble {
	ATSCMH_RSFRAME_ENS_PRI   = 0,
	ATSCMH_RSFRAME_ENS_SEC   = 1,
} atscmh_rs_frame_ensemble_t;
</pre><p>
		  </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="DTV-ATSCMH-RS-CODE-MODE-PRI"></a><code class="constant">DTV_ATSCMH_RS_CODE_MODE_PRI</code></h5></div></div></div><p>RS code mode (primary).</p><p>Possible values are:</p><p><a name="atscmh-rs-code-mode"></a>
</p><pre class="programlisting">
typedef enum atscmh_rs_code_mode {
	ATSCMH_RSCODE_211_187    = 0,
	ATSCMH_RSCODE_223_187    = 1,
	ATSCMH_RSCODE_235_187    = 2,
} atscmh_rs_code_mode_t;
</pre><p>
		  </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="DTV-ATSCMH-RS-CODE-MODE-SEC"></a><code class="constant">DTV_ATSCMH_RS_CODE_MODE_SEC</code></h5></div></div></div><p>RS code mode (secondary).</p><p>Possible values are:</p><pre class="programlisting">
typedef enum atscmh_rs_code_mode {
	ATSCMH_RSCODE_211_187    = 0,
	ATSCMH_RSCODE_223_187    = 1,
	ATSCMH_RSCODE_235_187    = 2,
} atscmh_rs_code_mode_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="DTV-ATSCMH-SCCC-BLOCK-MODE"></a><code class="constant">DTV_ATSCMH_SCCC_BLOCK_MODE</code></h5></div></div></div><p>Series Concatenated Convolutional Code Block Mode.</p><p>Possible values are:</p><p><a name="atscmh-sccc-block-mode"></a>
</p><pre class="programlisting">
typedef enum atscmh_sccc_block_mode {
	ATSCMH_SCCC_BLK_SEP      = 0,
	ATSCMH_SCCC_BLK_COMB     = 1,
} atscmh_sccc_block_mode_t;
</pre><p>
		  </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="DTV-ATSCMH-SCCC-CODE-MODE-A"></a><code class="constant">DTV_ATSCMH_SCCC_CODE_MODE_A</code></h5></div></div></div><p>Series Concatenated Convolutional Code Rate.</p><p>Possible values are:</p><p><a name="atscmh-sccc-code-mode"></a>
</p><pre class="programlisting">
typedef enum atscmh_sccc_code_mode {
	ATSCMH_SCCC_CODE_HLF     = 0,
	ATSCMH_SCCC_CODE_QTR     = 1,
} atscmh_sccc_code_mode_t;
</pre><p>
		  </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="DTV-ATSCMH-SCCC-CODE-MODE-B"></a><code class="constant">DTV_ATSCMH_SCCC_CODE_MODE_B</code></h5></div></div></div><p>Series Concatenated Convolutional Code Rate.</p><p>Possible values are:</p><pre class="programlisting">
typedef enum atscmh_sccc_code_mode {
	ATSCMH_SCCC_CODE_HLF     = 0,
	ATSCMH_SCCC_CODE_QTR     = 1,
} atscmh_sccc_code_mode_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="DTV-ATSCMH-SCCC-CODE-MODE-C"></a><code class="constant">DTV_ATSCMH_SCCC_CODE_MODE_C</code></h5></div></div></div><p>Series Concatenated Convolutional Code Rate.</p><p>Possible values are:</p><pre class="programlisting">
typedef enum atscmh_sccc_code_mode {
	ATSCMH_SCCC_CODE_HLF     = 0,
	ATSCMH_SCCC_CODE_QTR     = 1,
} atscmh_sccc_code_mode_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="DTV-ATSCMH-SCCC-CODE-MODE-D"></a><code class="constant">DTV_ATSCMH_SCCC_CODE_MODE_D</code></h5></div></div></div><p>Series Concatenated Convolutional Code Rate.</p><p>Possible values are:</p><pre class="programlisting">
typedef enum atscmh_sccc_code_mode {
	ATSCMH_SCCC_CODE_HLF     = 0,
	ATSCMH_SCCC_CODE_QTR     = 1,
} atscmh_sccc_code_mode_t;
</pre></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-API-VERSION"></a><code class="constant">DTV_API_VERSION</code></h4></div></div></div><p>Returns the major/minor version of the DVB API</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-CODE-RATE-HP"></a><code class="constant">DTV_CODE_RATE_HP</code></h4></div></div></div><p>Used on terrestrial transmissions. The acceptable values are:
	</p><pre class="programlisting">
typedef enum fe_code_rate {
	FEC_NONE = 0,
	FEC_1_2,
	FEC_2_3,
	FEC_3_4,
	FEC_4_5,
	FEC_5_6,
	FEC_6_7,
	FEC_7_8,
	FEC_8_9,
	FEC_AUTO,
	FEC_3_5,
	FEC_9_10,
} fe_code_rate_t;
	</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-CODE-RATE-LP"></a><code class="constant">DTV_CODE_RATE_LP</code></h4></div></div></div><p>Used on terrestrial transmissions. The acceptable values are:
	</p><pre class="programlisting">
typedef enum fe_code_rate {
	FEC_NONE = 0,
	FEC_1_2,
	FEC_2_3,
	FEC_3_4,
	FEC_4_5,
	FEC_5_6,
	FEC_6_7,
	FEC_7_8,
	FEC_8_9,
	FEC_AUTO,
	FEC_3_5,
	FEC_9_10,
} fe_code_rate_t;
	</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-GUARD-INTERVAL"></a><code class="constant">DTV_GUARD_INTERVAL</code></h4></div></div></div><p>Possible values are:</p><pre class="programlisting">
typedef enum fe_guard_interval {
	GUARD_INTERVAL_1_32,
	GUARD_INTERVAL_1_16,
	GUARD_INTERVAL_1_8,
	GUARD_INTERVAL_1_4,
	GUARD_INTERVAL_AUTO,
	GUARD_INTERVAL_1_128,
	GUARD_INTERVAL_19_128,
	GUARD_INTERVAL_19_256,
	GUARD_INTERVAL_PN420,
	GUARD_INTERVAL_PN595,
	GUARD_INTERVAL_PN945,
} fe_guard_interval_t;
</pre><p>Notes:</p><p>1) If <code class="constant">DTV_GUARD_INTERVAL</code> is set the <code class="constant">GUARD_INTERVAL_AUTO</code> the hardware will
			try to find the correct guard interval (if capable) and will use TMCC to fill
			in the missing parameters.</p><p>2) Intervals 1/128, 19/128 and 19/256 are used only for DVB-T2 at present</p><p>3) DTMB specifies PN420, PN595 and PN945.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-TRANSMISSION-MODE"></a><code class="constant">DTV_TRANSMISSION_MODE</code></h4></div></div></div><p>Specifies the number of carriers used by the standard</p><p>Possible values are:</p><pre class="programlisting">
typedef enum fe_transmit_mode {
	TRANSMISSION_MODE_2K,
	TRANSMISSION_MODE_8K,
	TRANSMISSION_MODE_AUTO,
	TRANSMISSION_MODE_4K,
	TRANSMISSION_MODE_1K,
	TRANSMISSION_MODE_16K,
	TRANSMISSION_MODE_32K,
	TRANSMISSION_MODE_C1,
	TRANSMISSION_MODE_C3780,
} fe_transmit_mode_t;
</pre><p>Notes:</p><p>1) ISDB-T supports three carrier/symbol-size: 8K, 4K, 2K. It is called
			'mode' in the standard: Mode 1 is 2K, mode 2 is 4K, mode 3 is 8K</p><p>2) If <code class="constant">DTV_TRANSMISSION_MODE</code> is set the <code class="constant">TRANSMISSION_MODE_AUTO</code> the
			hardware will try to find the correct FFT-size (if capable) and will
			use TMCC to fill in the missing parameters.</p><p>3) DVB-T specifies 2K and 8K as valid sizes.</p><p>4) DVB-T2 specifies 1K, 2K, 4K, 8K, 16K and 32K.</p><p>5) DTMB specifies C1 and C3780.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-HIERARCHY"></a><code class="constant">DTV_HIERARCHY</code></h4></div></div></div><p>Frontend hierarchy</p><pre class="programlisting">
typedef enum fe_hierarchy {
	 HIERARCHY_NONE,
	 HIERARCHY_1,
	 HIERARCHY_2,
	 HIERARCHY_4,
	 HIERARCHY_AUTO
 } fe_hierarchy_t;
	</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-STREAM-ID"></a><code class="constant">DTV_STREAM_ID</code></h4></div></div></div><p>DVB-S2, DVB-T2 and ISDB-S support the transmission of several
	      streams on a single transport stream.
	      This property enables the DVB driver to handle substream filtering,
	      when supported by the hardware.
	      By default, substream filtering is disabled.
	</p><p>
	      For DVB-S2 and DVB-T2, the valid substream id range is from 0 to 255.
	</p><p>
	      For ISDB, the valid substream id range is from 1 to 65535.
	</p><p>
	      To disable it, you should use the special macro NO_STREAM_ID_FILTER.
	</p><p>
	      Note: any value outside the id range also disables filtering.
	</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-DVBT2-PLP-ID-LEGACY"></a><code class="constant">DTV_DVBT2_PLP_ID_LEGACY</code></h4></div></div></div><p>Obsolete, replaced with DTV_STREAM_ID.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-ENUM-DELSYS"></a><code class="constant">DTV_ENUM_DELSYS</code></h4></div></div></div><p>A Multi standard frontend needs to advertise the delivery systems provided.
			Applications need to enumerate the provided delivery systems, before using
			any other operation with the frontend. Prior to it's introduction,
			FE_GET_INFO was used to determine a frontend type. A frontend which
			provides more than a single delivery system, FE_GET_INFO doesn't help much.
			Applications which intends to use a multistandard frontend must enumerate
			the delivery systems associated with it, rather than trying to use
			FE_GET_INFO. In the case of a legacy frontend, the result is just the same
			as with FE_GET_INFO, but in a more structured format </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-INTERLEAVING"></a><code class="constant">DTV_INTERLEAVING</code></h4></div></div></div><p><a name="fe-interleaving"></a>Interleaving mode</p><pre class="programlisting">
enum fe_interleaving {
	INTERLEAVING_NONE,
	INTERLEAVING_AUTO,
	INTERLEAVING_240,
	INTERLEAVING_720,
};
	</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-LNA"></a><code class="constant">DTV_LNA</code></h4></div></div></div><p>Low-noise amplifier.</p><p>Hardware might offer controllable LNA which can be set manually
		using that parameter. Usually LNA could be found only from
		terrestrial devices if at all.</p><p>Possible values: 0, 1, LNA_AUTO</p><p>0, LNA off</p><p>1, LNA on</p><p>use the special macro LNA_AUTO to set LNA auto</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="frontend-stat-properties"></a>Frontend statistics indicators</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#DTV-STAT-SIGNAL-STRENGTH"><code class="constant">DTV_STAT_SIGNAL_STRENGTH</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-STAT-CNR"><code class="constant">DTV_STAT_CNR</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-STAT-PRE-ERROR-BIT-COUNT"><code class="constant">DTV_STAT_PRE_ERROR_BIT_COUNT</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-STAT-PRE-TOTAL-BIT-COUNT"><code class="constant">DTV_STAT_PRE_TOTAL_BIT_COUNT</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-STAT-POST-ERROR-BIT-COUNT"><code class="constant">DTV_STAT_POST_ERROR_BIT_COUNT</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-STAT-POST-TOTAL-BIT-COUNT"><code class="constant">DTV_STAT_POST_TOTAL_BIT_COUNT</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-STAT-ERROR-BLOCK-COUNT"><code class="constant">DTV_STAT_ERROR_BLOCK_COUNT</code></a></span></dt><dt><span class="section"><a href="media.html#DTV-STAT-TOTAL-BLOCK-COUNT"><code class="constant">DTV-STAT_TOTAL_BLOCK_COUNT</code></a></span></dt></dl></div><p>The values are returned via <code class="constant">dtv_property.stat</code>.
	      If the property is supported, <code class="constant">dtv_property.stat.len</code> is bigger than zero.</p><p>For most delivery systems, <code class="constant">dtv_property.stat.len</code>
	      will be 1 if the stats is supported, and the properties will
	      return a single value for each parameter.</p><p>It should be noticed, however, that new OFDM delivery systems
	      like ISDB can use different modulation types for each group of
	      carriers. On such standards, up to 3 groups of statistics can be
	      provided, and <code class="constant">dtv_property.stat.len</code> is updated
	      to reflect the "global" metrics, plus one metric per each carrier
	      group (called "layer" on ISDB).</p><p>So, in order to be consistent with other delivery systems, the first
	      value at <a class="link" href="media.html#dtv-stats" title="DTV stats type"><code class="constant">dtv_property.stat.dtv_stats</code></a>
	      array refers to the global metric. The other elements of the array
	      represent each layer, starting from layer A(index 1),
	      layer B (index 2) and so on.</p><p>The number of filled elements are stored at <code class="constant">dtv_property.stat.len</code>.</p><p>Each element of the <code class="constant">dtv_property.stat.dtv_stats</code> array consists on two elements:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: opencircle; "><li class="listitem" style="list-style-type: circle"><p><code class="constant">svalue</code> or <code class="constant">uvalue</code>, where
			<code class="constant">svalue</code> is for signed values of the measure (dB measures)
			and <code class="constant">uvalue</code> is for unsigned values (counters, relative scale)</p></li><li class="listitem" style="list-style-type: circle"><p><code class="constant">scale</code> - Scale for the value. It can be:</p><div class="itemizedlist"><a name="fecap-scale-params"></a><ul class="itemizedlist" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p><code class="constant">FE_SCALE_NOT_AVAILABLE</code> - The parameter is supported by the frontend, but it was not possible to collect it (could be a transitory or permanent condition)</p></li><li class="listitem" style="list-style-type: disc"><p><code class="constant">FE_SCALE_DECIBEL</code> - parameter is a signed value, measured in 1/1000 dB</p></li><li class="listitem" style="list-style-type: disc"><p><code class="constant">FE_SCALE_RELATIVE</code> - parameter is a unsigned value, where 0 means 0% and 65535 means 100%.</p></li><li class="listitem" style="list-style-type: disc"><p><code class="constant">FE_SCALE_COUNTER</code> - parameter is a unsigned value that counts the occurrence of an event, like bit error, block error, or lapsed time.</p></li></ul></div></li></ul></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-STAT-SIGNAL-STRENGTH"></a><code class="constant">DTV_STAT_SIGNAL_STRENGTH</code></h4></div></div></div><p>Indicates the signal strength level at the analog part of the tuner or of the demod.</p><p>Possible scales for this metric are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p><code class="constant">FE_SCALE_NOT_AVAILABLE</code> - it failed to measure it, or the measurement was not complete yet.</p></li><li class="listitem" style="list-style-type: disc"><p><code class="constant">FE_SCALE_DECIBEL</code> - signal strength is in 0.0001 dBm units, power measured in miliwatts. This value is generally negative.</p></li><li class="listitem" style="list-style-type: disc"><p><code class="constant">FE_SCALE_RELATIVE</code> - The frontend provides a 0% to 100% measurement for power (actually, 0 to 65535).</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-STAT-CNR"></a><code class="constant">DTV_STAT_CNR</code></h4></div></div></div><p>Indicates the Signal to Noise ratio for the main carrier.</p><p>Possible scales for this metric are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p><code class="constant">FE_SCALE_NOT_AVAILABLE</code> - it failed to measure it, or the measurement was not complete yet.</p></li><li class="listitem" style="list-style-type: disc"><p><code class="constant">FE_SCALE_DECIBEL</code> - Signal/Noise ratio is in 0.0001 dB units.</p></li><li class="listitem" style="list-style-type: disc"><p><code class="constant">FE_SCALE_RELATIVE</code> - The frontend provides a 0% to 100% measurement for Signal/Noise (actually, 0 to 65535).</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-STAT-PRE-ERROR-BIT-COUNT"></a><code class="constant">DTV_STAT_PRE_ERROR_BIT_COUNT</code></h4></div></div></div><p>Measures the number of bit errors before the forward error correction (FEC) on the inner coding block (before Viterbi, LDPC or other inner code).</p><p>This measure is taken during the same interval as <code class="constant">DTV_STAT_PRE_TOTAL_BIT_COUNT</code>.</p><p>In order to get the BER (Bit Error Rate) measurement, it should be divided by
		<a class="link" href="media.html#DTV-STAT-PRE-TOTAL-BIT-COUNT" title="DTV_STAT_PRE_TOTAL_BIT_COUNT"><code class="constant">DTV_STAT_PRE_TOTAL_BIT_COUNT</code></a>.</p><p>This measurement is monotonically increased, as the frontend gets more bit count measurements.
		      The frontend may reset it when a channel/transponder is tuned.</p><p>Possible scales for this metric are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p><code class="constant">FE_SCALE_NOT_AVAILABLE</code> - it failed to measure it, or the measurement was not complete yet.</p></li><li class="listitem" style="list-style-type: disc"><p><code class="constant">FE_SCALE_COUNTER</code> - Number of error bits counted before the inner coding.</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-STAT-PRE-TOTAL-BIT-COUNT"></a><code class="constant">DTV_STAT_PRE_TOTAL_BIT_COUNT</code></h4></div></div></div><p>Measures the amount of bits received before the inner code block, during the same period as
		<a class="link" href="media.html#DTV-STAT-PRE-ERROR-BIT-COUNT" title="DTV_STAT_PRE_ERROR_BIT_COUNT"><code class="constant">DTV_STAT_PRE_ERROR_BIT_COUNT</code></a> measurement was taken.</p><p>It should be noticed that this measurement can be smaller than the total amount of bits on the transport stream,
		      as the frontend may need to manually restart the measurement, losing some data between each measurement interval.</p><p>This measurement is monotonically increased, as the frontend gets more bit count measurements.
		      The frontend may reset it when a channel/transponder is tuned.</p><p>Possible scales for this metric are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p><code class="constant">FE_SCALE_NOT_AVAILABLE</code> - it failed to measure it, or the measurement was not complete yet.</p></li><li class="listitem" style="list-style-type: disc"><p><code class="constant">FE_SCALE_COUNTER</code> - Number of bits counted while measuring
				 <a class="link" href="media.html#DTV-STAT-PRE-ERROR-BIT-COUNT" title="DTV_STAT_PRE_ERROR_BIT_COUNT"><code class="constant">DTV_STAT_PRE_ERROR_BIT_COUNT</code></a>.</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-STAT-POST-ERROR-BIT-COUNT"></a><code class="constant">DTV_STAT_POST_ERROR_BIT_COUNT</code></h4></div></div></div><p>Measures the number of bit errors after the forward error correction (FEC) done by inner code block (after Viterbi, LDPC or other inner code).</p><p>This measure is taken during the same interval as <code class="constant">DTV_STAT_POST_TOTAL_BIT_COUNT</code>.</p><p>In order to get the BER (Bit Error Rate) measurement, it should be divided by
		<a class="link" href="media.html#DTV-STAT-POST-TOTAL-BIT-COUNT" title="DTV_STAT_POST_TOTAL_BIT_COUNT"><code class="constant">DTV_STAT_POST_TOTAL_BIT_COUNT</code></a>.</p><p>This measurement is monotonically increased, as the frontend gets more bit count measurements.
		      The frontend may reset it when a channel/transponder is tuned.</p><p>Possible scales for this metric are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p><code class="constant">FE_SCALE_NOT_AVAILABLE</code> - it failed to measure it, or the measurement was not complete yet.</p></li><li class="listitem" style="list-style-type: disc"><p><code class="constant">FE_SCALE_COUNTER</code> - Number of error bits counted after the inner coding.</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-STAT-POST-TOTAL-BIT-COUNT"></a><code class="constant">DTV_STAT_POST_TOTAL_BIT_COUNT</code></h4></div></div></div><p>Measures the amount of bits received after the inner coding, during the same period as
		<a class="link" href="media.html#DTV-STAT-POST-ERROR-BIT-COUNT" title="DTV_STAT_POST_ERROR_BIT_COUNT"><code class="constant">DTV_STAT_POST_ERROR_BIT_COUNT</code></a> measurement was taken.</p><p>It should be noticed that this measurement can be smaller than the total amount of bits on the transport stream,
		      as the frontend may need to manually restart the measurement, losing some data between each measurement interval.</p><p>This measurement is monotonically increased, as the frontend gets more bit count measurements.
		      The frontend may reset it when a channel/transponder is tuned.</p><p>Possible scales for this metric are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p><code class="constant">FE_SCALE_NOT_AVAILABLE</code> - it failed to measure it, or the measurement was not complete yet.</p></li><li class="listitem" style="list-style-type: disc"><p><code class="constant">FE_SCALE_COUNTER</code> - Number of bits counted while measuring
				 <a class="link" href="media.html#DTV-STAT-POST-ERROR-BIT-COUNT" title="DTV_STAT_POST_ERROR_BIT_COUNT"><code class="constant">DTV_STAT_POST_ERROR_BIT_COUNT</code></a>.</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-STAT-ERROR-BLOCK-COUNT"></a><code class="constant">DTV_STAT_ERROR_BLOCK_COUNT</code></h4></div></div></div><p>Measures the number of block errors after the outer forward error correction coding (after Reed-Solomon or other outer code).</p><p>This measurement is monotonically increased, as the frontend gets more bit count measurements.
		      The frontend may reset it when a channel/transponder is tuned.</p><p>Possible scales for this metric are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p><code class="constant">FE_SCALE_NOT_AVAILABLE</code> - it failed to measure it, or the measurement was not complete yet.</p></li><li class="listitem" style="list-style-type: disc"><p><code class="constant">FE_SCALE_COUNTER</code> - Number of error blocks counted after the outer coding.</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="DTV-STAT-TOTAL-BLOCK-COUNT"></a><code class="constant">DTV-STAT_TOTAL_BLOCK_COUNT</code></h4></div></div></div><p>Measures the total number of blocks received during the same period as
		<a class="link" href="media.html#DTV-STAT-ERROR-BLOCK-COUNT" title="DTV_STAT_ERROR_BLOCK_COUNT"><code class="constant">DTV_STAT_ERROR_BLOCK_COUNT</code></a> measurement was taken.</p><p>It can be used to calculate the PER indicator, by dividing
		<a class="link" href="media.html#DTV-STAT-ERROR-BLOCK-COUNT" title="DTV_STAT_ERROR_BLOCK_COUNT"><code class="constant">DTV_STAT_ERROR_BLOCK_COUNT</code></a>
		by <a class="link" href="media.html#DTV-STAT-TOTAL-BLOCK-COUNT" title="DTV-STAT_TOTAL_BLOCK_COUNT"><code class="constant">DTV-STAT-TOTAL-BLOCK-COUNT</code></a>.</p><p>Possible scales for this metric are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p><code class="constant">FE_SCALE_NOT_AVAILABLE</code> - it failed to measure it, or the measurement was not complete yet.</p></li><li class="listitem" style="list-style-type: disc"><p><code class="constant">FE_SCALE_COUNTER</code> - Number of blocks counted while measuring
			<a class="link" href="media.html#DTV-STAT-ERROR-BLOCK-COUNT" title="DTV_STAT_ERROR_BLOCK_COUNT"><code class="constant">DTV_STAT_ERROR_BLOCK_COUNT</code></a>.</p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="frontend-property-terrestrial-systems"></a>Properties used on terrestrial delivery systems</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#dvbt-params">DVB-T delivery system</a></span></dt><dt><span class="section"><a href="media.html#dvbt2-params">DVB-T2 delivery system</a></span></dt><dt><span class="section"><a href="media.html#isdbt">ISDB-T delivery system</a></span></dt><dt><span class="section"><a href="media.html#atsc-params">ATSC delivery system</a></span></dt><dt><span class="section"><a href="media.html#atscmh-params">ATSC-MH delivery system</a></span></dt><dt><span class="section"><a href="media.html#dtmb-params">DTMB delivery system</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="dvbt-params"></a>DVB-T delivery system</h4></div></div></div><p>The following parameters are valid for DVB-T:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: opencircle; "><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-API-VERSION" title="DTV_API_VERSION"><code class="constant">DTV_API_VERSION</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-DELIVERY-SYSTEM" title="DTV_DELIVERY_SYSTEM"><code class="constant">DTV_DELIVERY_SYSTEM</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-TUNE" title="DTV_TUNE"><code class="constant">DTV_TUNE</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-CLEAR" title="DTV_CLEAR"><code class="constant">DTV_CLEAR</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-FREQUENCY" title="DTV_FREQUENCY"><code class="constant">DTV_FREQUENCY</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-MODULATION" title="DTV_MODULATION"><code class="constant">DTV_MODULATION</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-BANDWIDTH-HZ" title="DTV_BANDWIDTH_HZ"><code class="constant">DTV_BANDWIDTH_HZ</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-INVERSION" title="DTV_INVERSION"><code class="constant">DTV_INVERSION</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-CODE-RATE-HP" title="DTV_CODE_RATE_HP"><code class="constant">DTV_CODE_RATE_HP</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-CODE-RATE-LP" title="DTV_CODE_RATE_LP"><code class="constant">DTV_CODE_RATE_LP</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-GUARD-INTERVAL" title="DTV_GUARD_INTERVAL"><code class="constant">DTV_GUARD_INTERVAL</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-TRANSMISSION-MODE" title="DTV_TRANSMISSION_MODE"><code class="constant">DTV_TRANSMISSION_MODE</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-HIERARCHY" title="DTV_HIERARCHY"><code class="constant">DTV_HIERARCHY</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-LNA" title="DTV_LNA"><code class="constant">DTV_LNA</code></a></p></li></ul></div><p>In addition, the <a class="link" href="media.html#frontend-stat-properties" title="Frontend statistics indicators">DTV QoS statistics</a> are also valid.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="dvbt2-params"></a>DVB-T2 delivery system</h4></div></div></div><p>DVB-T2 support is currently in the early stages
			of development, so expect that this section maygrow and become
			more detailed with time.</p><p>The following parameters are valid for DVB-T2:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: opencircle; "><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-API-VERSION" title="DTV_API_VERSION"><code class="constant">DTV_API_VERSION</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-DELIVERY-SYSTEM" title="DTV_DELIVERY_SYSTEM"><code class="constant">DTV_DELIVERY_SYSTEM</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-TUNE" title="DTV_TUNE"><code class="constant">DTV_TUNE</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-CLEAR" title="DTV_CLEAR"><code class="constant">DTV_CLEAR</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-FREQUENCY" title="DTV_FREQUENCY"><code class="constant">DTV_FREQUENCY</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-MODULATION" title="DTV_MODULATION"><code class="constant">DTV_MODULATION</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-BANDWIDTH-HZ" title="DTV_BANDWIDTH_HZ"><code class="constant">DTV_BANDWIDTH_HZ</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-INVERSION" title="DTV_INVERSION"><code class="constant">DTV_INVERSION</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-CODE-RATE-HP" title="DTV_CODE_RATE_HP"><code class="constant">DTV_CODE_RATE_HP</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-CODE-RATE-LP" title="DTV_CODE_RATE_LP"><code class="constant">DTV_CODE_RATE_LP</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-GUARD-INTERVAL" title="DTV_GUARD_INTERVAL"><code class="constant">DTV_GUARD_INTERVAL</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-TRANSMISSION-MODE" title="DTV_TRANSMISSION_MODE"><code class="constant">DTV_TRANSMISSION_MODE</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-HIERARCHY" title="DTV_HIERARCHY"><code class="constant">DTV_HIERARCHY</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-STREAM-ID" title="DTV_STREAM_ID"><code class="constant">DTV_STREAM_ID</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-LNA" title="DTV_LNA"><code class="constant">DTV_LNA</code></a></p></li></ul></div><p>In addition, the <a class="link" href="media.html#frontend-stat-properties" title="Frontend statistics indicators">DTV QoS statistics</a> are also valid.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="isdbt"></a>ISDB-T delivery system</h4></div></div></div><p>This ISDB-T/ISDB-Tsb API extension should reflect all information
			needed to tune any ISDB-T/ISDB-Tsb hardware. Of course it is possible
			that some very sophisticated devices won't need certain parameters to
			tune.</p><p>The information given here should help application writers to know how
			to handle ISDB-T and ISDB-Tsb hardware using the Linux DVB-API.</p><p>The details given here about ISDB-T and ISDB-Tsb are just enough to
			basically show the dependencies between the needed parameter values,
			but surely some information is left out. For more detailed information
			see the following documents:</p><p>ARIB STD-B31 - "Transmission System for Digital Terrestrial
			Television Broadcasting" and</p><p>ARIB TR-B14 - "Operational Guidelines for Digital Terrestrial
			Television Broadcasting".</p><p>In order to understand the ISDB specific parameters,
			one has to have some knowledge the channel structure in
			ISDB-T and ISDB-Tsb. I.e. it has to be known to
			the reader that an ISDB-T channel consists of 13 segments,
			that it can have up to 3 layer sharing those segments,
			and things like that.</p><p>The following parameters are valid for ISDB-T:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: opencircle; "><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-API-VERSION" title="DTV_API_VERSION"><code class="constant">DTV_API_VERSION</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-DELIVERY-SYSTEM" title="DTV_DELIVERY_SYSTEM"><code class="constant">DTV_DELIVERY_SYSTEM</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-TUNE" title="DTV_TUNE"><code class="constant">DTV_TUNE</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-CLEAR" title="DTV_CLEAR"><code class="constant">DTV_CLEAR</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-FREQUENCY" title="DTV_FREQUENCY"><code class="constant">DTV_FREQUENCY</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-BANDWIDTH-HZ" title="DTV_BANDWIDTH_HZ"><code class="constant">DTV_BANDWIDTH_HZ</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-INVERSION" title="DTV_INVERSION"><code class="constant">DTV_INVERSION</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-GUARD-INTERVAL" title="DTV_GUARD_INTERVAL"><code class="constant">DTV_GUARD_INTERVAL</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-TRANSMISSION-MODE" title="DTV_TRANSMISSION_MODE"><code class="constant">DTV_TRANSMISSION_MODE</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-ISDBT-LAYER-ENABLED" title="DTV_ISDBT_LAYER_ENABLED"><code class="constant">DTV_ISDBT_LAYER_ENABLED</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-ISDBT-PARTIAL-RECEPTION" title="DTV_ISDBT_PARTIAL_RECEPTION"><code class="constant">DTV_ISDBT_PARTIAL_RECEPTION</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-ISDBT-SOUND-BROADCASTING" title="DTV_ISDBT_SOUND_BROADCASTING"><code class="constant">DTV_ISDBT_SOUND_BROADCASTING</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-ISDBT-SB-SUBCHANNEL-ID" title="DTV_ISDBT_SB_SUBCHANNEL_ID"><code class="constant">DTV_ISDBT_SB_SUBCHANNEL_ID</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-ISDBT-SB-SEGMENT-IDX" title="DTV_ISDBT_SB_SEGMENT_IDX"><code class="constant">DTV_ISDBT_SB_SEGMENT_IDX</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-ISDBT-SB-SEGMENT-COUNT" title="DTV_ISDBT_SB_SEGMENT_COUNT"><code class="constant">DTV_ISDBT_SB_SEGMENT_COUNT</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-ISDBT-LAYER-FEC" title="DTV_ISDBT_LAYER*_FEC"><code class="constant">DTV_ISDBT_LAYERA_FEC</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-ISDBT-LAYER-MODULATION" title="DTV_ISDBT_LAYER*_MODULATION"><code class="constant">DTV_ISDBT_LAYERA_MODULATION</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-ISDBT-LAYER-SEGMENT-COUNT" title="DTV_ISDBT_LAYER*_SEGMENT_COUNT"><code class="constant">DTV_ISDBT_LAYERA_SEGMENT_COUNT</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-ISDBT-LAYER-TIME-INTERLEAVING" title="DTV_ISDBT_LAYER*_TIME_INTERLEAVING"><code class="constant">DTV_ISDBT_LAYERA_TIME_INTERLEAVING</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-ISDBT-LAYER-FEC" title="DTV_ISDBT_LAYER*_FEC"><code class="constant">DTV_ISDBT_LAYERB_FEC</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-ISDBT-LAYER-MODULATION" title="DTV_ISDBT_LAYER*_MODULATION"><code class="constant">DTV_ISDBT_LAYERB_MODULATION</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-ISDBT-LAYER-SEGMENT-COUNT" title="DTV_ISDBT_LAYER*_SEGMENT_COUNT"><code class="constant">DTV_ISDBT_LAYERB_SEGMENT_COUNT</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-ISDBT-LAYER-TIME-INTERLEAVING" title="DTV_ISDBT_LAYER*_TIME_INTERLEAVING"><code class="constant">DTV_ISDBT_LAYERB_TIME_INTERLEAVING</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-ISDBT-LAYER-FEC" title="DTV_ISDBT_LAYER*_FEC"><code class="constant">DTV_ISDBT_LAYERC_FEC</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-ISDBT-LAYER-MODULATION" title="DTV_ISDBT_LAYER*_MODULATION"><code class="constant">DTV_ISDBT_LAYERC_MODULATION</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-ISDBT-LAYER-SEGMENT-COUNT" title="DTV_ISDBT_LAYER*_SEGMENT_COUNT"><code class="constant">DTV_ISDBT_LAYERC_SEGMENT_COUNT</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-ISDBT-LAYER-TIME-INTERLEAVING" title="DTV_ISDBT_LAYER*_TIME_INTERLEAVING"><code class="constant">DTV_ISDBT_LAYERC_TIME_INTERLEAVING</code></a></p></li></ul></div><p>In addition, the <a class="link" href="media.html#frontend-stat-properties" title="Frontend statistics indicators">DTV QoS statistics</a> are also valid.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="atsc-params"></a>ATSC delivery system</h4></div></div></div><p>The following parameters are valid for ATSC:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: opencircle; "><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-API-VERSION" title="DTV_API_VERSION"><code class="constant">DTV_API_VERSION</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-DELIVERY-SYSTEM" title="DTV_DELIVERY_SYSTEM"><code class="constant">DTV_DELIVERY_SYSTEM</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-TUNE" title="DTV_TUNE"><code class="constant">DTV_TUNE</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-CLEAR" title="DTV_CLEAR"><code class="constant">DTV_CLEAR</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-FREQUENCY" title="DTV_FREQUENCY"><code class="constant">DTV_FREQUENCY</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-MODULATION" title="DTV_MODULATION"><code class="constant">DTV_MODULATION</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-BANDWIDTH-HZ" title="DTV_BANDWIDTH_HZ"><code class="constant">DTV_BANDWIDTH_HZ</code></a></p></li></ul></div><p>In addition, the <a class="link" href="media.html#frontend-stat-properties" title="Frontend statistics indicators">DTV QoS statistics</a> are also valid.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="atscmh-params"></a>ATSC-MH delivery system</h4></div></div></div><p>The following parameters are valid for ATSC-MH:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: opencircle; "><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-API-VERSION" title="DTV_API_VERSION"><code class="constant">DTV_API_VERSION</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-DELIVERY-SYSTEM" title="DTV_DELIVERY_SYSTEM"><code class="constant">DTV_DELIVERY_SYSTEM</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-TUNE" title="DTV_TUNE"><code class="constant">DTV_TUNE</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-CLEAR" title="DTV_CLEAR"><code class="constant">DTV_CLEAR</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-FREQUENCY" title="DTV_FREQUENCY"><code class="constant">DTV_FREQUENCY</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-BANDWIDTH-HZ" title="DTV_BANDWIDTH_HZ"><code class="constant">DTV_BANDWIDTH_HZ</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-ATSCMH-FIC-VER" title="DTV_ATSCMH_FIC_VER"><code class="constant">DTV_ATSCMH_FIC_VER</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-ATSCMH-PARADE-ID" title="DTV_ATSCMH_PARADE_ID"><code class="constant">DTV_ATSCMH_PARADE_ID</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-ATSCMH-NOG" title="DTV_ATSCMH_NOG"><code class="constant">DTV_ATSCMH_NOG</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-ATSCMH-TNOG" title="DTV_ATSCMH_TNOG"><code class="constant">DTV_ATSCMH_TNOG</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-ATSCMH-SGN" title="DTV_ATSCMH_SGN"><code class="constant">DTV_ATSCMH_SGN</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-ATSCMH-PRC" title="DTV_ATSCMH_PRC"><code class="constant">DTV_ATSCMH_PRC</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-ATSCMH-RS-FRAME-MODE" title="DTV_ATSCMH_RS_FRAME_MODE"><code class="constant">DTV_ATSCMH_RS_FRAME_MODE</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-ATSCMH-RS-FRAME-ENSEMBLE" title="DTV_ATSCMH_RS_FRAME_ENSEMBLE"><code class="constant">DTV_ATSCMH_RS_FRAME_ENSEMBLE</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-ATSCMH-RS-CODE-MODE-PRI" title="DTV_ATSCMH_RS_CODE_MODE_PRI"><code class="constant">DTV_ATSCMH_RS_CODE_MODE_PRI</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-ATSCMH-RS-CODE-MODE-SEC" title="DTV_ATSCMH_RS_CODE_MODE_SEC"><code class="constant">DTV_ATSCMH_RS_CODE_MODE_SEC</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-ATSCMH-SCCC-BLOCK-MODE" title="DTV_ATSCMH_SCCC_BLOCK_MODE"><code class="constant">DTV_ATSCMH_SCCC_BLOCK_MODE</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-ATSCMH-SCCC-CODE-MODE-A" title="DTV_ATSCMH_SCCC_CODE_MODE_A"><code class="constant">DTV_ATSCMH_SCCC_CODE_MODE_A</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-ATSCMH-SCCC-CODE-MODE-B" title="DTV_ATSCMH_SCCC_CODE_MODE_B"><code class="constant">DTV_ATSCMH_SCCC_CODE_MODE_B</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-ATSCMH-SCCC-CODE-MODE-C" title="DTV_ATSCMH_SCCC_CODE_MODE_C"><code class="constant">DTV_ATSCMH_SCCC_CODE_MODE_C</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-ATSCMH-SCCC-CODE-MODE-D" title="DTV_ATSCMH_SCCC_CODE_MODE_D"><code class="constant">DTV_ATSCMH_SCCC_CODE_MODE_D</code></a></p></li></ul></div><p>In addition, the <a class="link" href="media.html#frontend-stat-properties" title="Frontend statistics indicators">DTV QoS statistics</a> are also valid.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="dtmb-params"></a>DTMB delivery system</h4></div></div></div><p>The following parameters are valid for DTMB:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: opencircle; "><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-API-VERSION" title="DTV_API_VERSION"><code class="constant">DTV_API_VERSION</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-DELIVERY-SYSTEM" title="DTV_DELIVERY_SYSTEM"><code class="constant">DTV_DELIVERY_SYSTEM</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-TUNE" title="DTV_TUNE"><code class="constant">DTV_TUNE</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-CLEAR" title="DTV_CLEAR"><code class="constant">DTV_CLEAR</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-FREQUENCY" title="DTV_FREQUENCY"><code class="constant">DTV_FREQUENCY</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-MODULATION" title="DTV_MODULATION"><code class="constant">DTV_MODULATION</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-BANDWIDTH-HZ" title="DTV_BANDWIDTH_HZ"><code class="constant">DTV_BANDWIDTH_HZ</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-INVERSION" title="DTV_INVERSION"><code class="constant">DTV_INVERSION</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-INNER-FEC" title="DTV_INNER_FEC"><code class="constant">DTV_INNER_FEC</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-GUARD-INTERVAL" title="DTV_GUARD_INTERVAL"><code class="constant">DTV_GUARD_INTERVAL</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-TRANSMISSION-MODE" title="DTV_TRANSMISSION_MODE"><code class="constant">DTV_TRANSMISSION_MODE</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-INTERLEAVING" title="DTV_INTERLEAVING"><code class="constant">DTV_INTERLEAVING</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-LNA" title="DTV_LNA"><code class="constant">DTV_LNA</code></a></p></li></ul></div><p>In addition, the <a class="link" href="media.html#frontend-stat-properties" title="Frontend statistics indicators">DTV QoS statistics</a> are also valid.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="frontend-property-cable-systems"></a>Properties used on cable delivery systems</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#dvbc-params">DVB-C delivery system</a></span></dt><dt><span class="section"><a href="media.html#dvbc-annex-b-params">DVB-C Annex B delivery system</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="dvbc-params"></a>DVB-C delivery system</h4></div></div></div><p>The DVB-C Annex-A is the widely used cable standard. Transmission uses QAM modulation.</p><p>The DVB-C Annex-C is optimized for 6MHz, and is used in Japan. It supports a subset of the Annex A modulation types, and a roll-off of 0.13, instead of 0.15</p><p>The following parameters are valid for DVB-C Annex A/C:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: opencircle; "><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-API-VERSION" title="DTV_API_VERSION"><code class="constant">DTV_API_VERSION</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-DELIVERY-SYSTEM" title="DTV_DELIVERY_SYSTEM"><code class="constant">DTV_DELIVERY_SYSTEM</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-TUNE" title="DTV_TUNE"><code class="constant">DTV_TUNE</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-CLEAR" title="DTV_CLEAR"><code class="constant">DTV_CLEAR</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-FREQUENCY" title="DTV_FREQUENCY"><code class="constant">DTV_FREQUENCY</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-MODULATION" title="DTV_MODULATION"><code class="constant">DTV_MODULATION</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-INVERSION" title="DTV_INVERSION"><code class="constant">DTV_INVERSION</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-SYMBOL-RATE" title="DTV_SYMBOL_RATE"><code class="constant">DTV_SYMBOL_RATE</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-INNER-FEC" title="DTV_INNER_FEC"><code class="constant">DTV_INNER_FEC</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-LNA" title="DTV_LNA"><code class="constant">DTV_LNA</code></a></p></li></ul></div><p>In addition, the <a class="link" href="media.html#frontend-stat-properties" title="Frontend statistics indicators">DTV QoS statistics</a> are also valid.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="dvbc-annex-b-params"></a>DVB-C Annex B delivery system</h4></div></div></div><p>The DVB-C Annex-B is only used on a few Countries like the United States.</p><p>The following parameters are valid for DVB-C Annex B:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: opencircle; "><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-API-VERSION" title="DTV_API_VERSION"><code class="constant">DTV_API_VERSION</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-DELIVERY-SYSTEM" title="DTV_DELIVERY_SYSTEM"><code class="constant">DTV_DELIVERY_SYSTEM</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-TUNE" title="DTV_TUNE"><code class="constant">DTV_TUNE</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-CLEAR" title="DTV_CLEAR"><code class="constant">DTV_CLEAR</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-FREQUENCY" title="DTV_FREQUENCY"><code class="constant">DTV_FREQUENCY</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-MODULATION" title="DTV_MODULATION"><code class="constant">DTV_MODULATION</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-INVERSION" title="DTV_INVERSION"><code class="constant">DTV_INVERSION</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-LNA" title="DTV_LNA"><code class="constant">DTV_LNA</code></a></p></li></ul></div><p>In addition, the <a class="link" href="media.html#frontend-stat-properties" title="Frontend statistics indicators">DTV QoS statistics</a> are also valid.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="frontend-property-satellital-systems"></a>Properties used on satellital delivery systems</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#dvbs-params">DVB-S delivery system</a></span></dt><dt><span class="section"><a href="media.html#dvbs2-params">DVB-S2 delivery system</a></span></dt><dt><span class="section"><a href="media.html#turbo-params">Turbo code delivery system</a></span></dt><dt><span class="section"><a href="media.html#isdbs-params">ISDB-S delivery system</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="dvbs-params"></a>DVB-S delivery system</h4></div></div></div><p>The following parameters are valid for DVB-S:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: opencircle; "><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-API-VERSION" title="DTV_API_VERSION"><code class="constant">DTV_API_VERSION</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-DELIVERY-SYSTEM" title="DTV_DELIVERY_SYSTEM"><code class="constant">DTV_DELIVERY_SYSTEM</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-TUNE" title="DTV_TUNE"><code class="constant">DTV_TUNE</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-CLEAR" title="DTV_CLEAR"><code class="constant">DTV_CLEAR</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-FREQUENCY" title="DTV_FREQUENCY"><code class="constant">DTV_FREQUENCY</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-INVERSION" title="DTV_INVERSION"><code class="constant">DTV_INVERSION</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-SYMBOL-RATE" title="DTV_SYMBOL_RATE"><code class="constant">DTV_SYMBOL_RATE</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-INNER-FEC" title="DTV_INNER_FEC"><code class="constant">DTV_INNER_FEC</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-VOLTAGE" title="DTV_VOLTAGE"><code class="constant">DTV_VOLTAGE</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-TONE" title="DTV_TONE"><code class="constant">DTV_TONE</code></a></p></li></ul></div><p>In addition, the <a class="link" href="media.html#frontend-stat-properties" title="Frontend statistics indicators">DTV QoS statistics</a> are also valid.</p><p>Future implementations might add those two missing parameters:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: opencircle; "><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-DISEQC-MASTER" title="DTV_DISEQC_MASTER"><code class="constant">DTV_DISEQC_MASTER</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-DISEQC-SLAVE-REPLY" title="DTV_DISEQC_SLAVE_REPLY"><code class="constant">DTV_DISEQC_SLAVE_REPLY</code></a></p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="dvbs2-params"></a>DVB-S2 delivery system</h4></div></div></div><p>In addition to all parameters valid for DVB-S, DVB-S2 supports the following parameters:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: opencircle; "><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-MODULATION" title="DTV_MODULATION"><code class="constant">DTV_MODULATION</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-PILOT" title="DTV_PILOT"><code class="constant">DTV_PILOT</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-ROLLOFF" title="DTV_ROLLOFF"><code class="constant">DTV_ROLLOFF</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-STREAM-ID" title="DTV_STREAM_ID"><code class="constant">DTV_STREAM_ID</code></a></p></li></ul></div><p>In addition, the <a class="link" href="media.html#frontend-stat-properties" title="Frontend statistics indicators">DTV QoS statistics</a> are also valid.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="turbo-params"></a>Turbo code delivery system</h4></div></div></div><p>In addition to all parameters valid for DVB-S, turbo code supports the following parameters:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: opencircle; "><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-MODULATION" title="DTV_MODULATION"><code class="constant">DTV_MODULATION</code></a></p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="isdbs-params"></a>ISDB-S delivery system</h4></div></div></div><p>The following parameters are valid for ISDB-S:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: opencircle; "><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-API-VERSION" title="DTV_API_VERSION"><code class="constant">DTV_API_VERSION</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-DELIVERY-SYSTEM" title="DTV_DELIVERY_SYSTEM"><code class="constant">DTV_DELIVERY_SYSTEM</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-TUNE" title="DTV_TUNE"><code class="constant">DTV_TUNE</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-CLEAR" title="DTV_CLEAR"><code class="constant">DTV_CLEAR</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-FREQUENCY" title="DTV_FREQUENCY"><code class="constant">DTV_FREQUENCY</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-INVERSION" title="DTV_INVERSION"><code class="constant">DTV_INVERSION</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-SYMBOL-RATE" title="DTV_SYMBOL_RATE"><code class="constant">DTV_SYMBOL_RATE</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-INNER-FEC" title="DTV_INNER_FEC"><code class="constant">DTV_INNER_FEC</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-VOLTAGE" title="DTV_VOLTAGE"><code class="constant">DTV_VOLTAGE</code></a></p></li><li class="listitem" style="list-style-type: circle"><p><a class="link" href="media.html#DTV-STREAM-ID" title="DTV_STREAM_ID"><code class="constant">DTV_STREAM_ID</code></a></p></li></ul></div></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="dvb_demux"></a>Chapter 10. DVB Demux Device</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="media.html#dmx_types">Demux Data Types</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#dmx-output-t">dmx_output_t</a></span></dt><dt><span class="section"><a href="media.html#dmx-input-t">dmx_input_t</a></span></dt><dt><span class="section"><a href="media.html#dmx-pes-type-t">dmx_pes_type_t</a></span></dt><dt><span class="section"><a href="media.html#dmx-filter">struct dmx_filter</a></span></dt><dt><span class="section"><a href="media.html#dmx-sct-filter-params">struct dmx_sct_filter_params</a></span></dt><dt><span class="section"><a href="media.html#dmx-pes-filter-params">struct dmx_pes_filter_params</a></span></dt><dt><span class="section"><a href="media.html#dmx-event">struct dmx_event</a></span></dt><dt><span class="section"><a href="media.html#dmx-stc">struct dmx_stc</a></span></dt><dt><span class="section"><a href="media.html#dmx-caps">struct dmx_caps</a></span></dt><dt><span class="section"><a href="media.html#dmx-source-t">enum dmx_source_t</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#dmx_fcalls">Demux Function Calls</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#dmx_fopen">open()</a></span></dt><dt><span class="section"><a href="media.html#dmx_fclose">close()</a></span></dt><dt><span class="section"><a href="media.html#dmx_fread">read()</a></span></dt><dt><span class="section"><a href="media.html#dmx_fwrite">write()</a></span></dt><dt><span class="section"><a href="media.html#DMX_START">DMX_START</a></span></dt><dt><span class="section"><a href="media.html#DMX_STOP">DMX_STOP</a></span></dt><dt><span class="section"><a href="media.html#DMX_SET_FILTER">DMX_SET_FILTER</a></span></dt><dt><span class="section"><a href="media.html#DMX_SET_PES_FILTER">DMX_SET_PES_FILTER</a></span></dt><dt><span class="section"><a href="media.html#DMX_SET_BUFFER_SIZE">DMX_SET_BUFFER_SIZE</a></span></dt><dt><span class="section"><a href="media.html#DMX_GET_EVENT">DMX_GET_EVENT</a></span></dt><dt><span class="section"><a href="media.html#DMX_GET_STC">DMX_GET_STC</a></span></dt><dt><span class="section"><a href="media.html#DMX_GET_PES_PIDS">DMX_GET_PES_PIDS</a></span></dt><dt><span class="section"><a href="media.html#DMX_GET_CAPS">DMX_GET_CAPS</a></span></dt><dt><span class="section"><a href="media.html#DMX_SET_SOURCE">DMX_SET_SOURCE</a></span></dt><dt><span class="section"><a href="media.html#DMX_ADD_PID">DMX_ADD_PID</a></span></dt><dt><span class="section"><a href="media.html#DMX_REMOVE_PID">DMX_REMOVE_PID</a></span></dt></dl></dd></dl></div><p>The DVB demux device controls the filters of the DVB hardware/software. It can be
accessed through <span class="tt">/dev/adapter0/demux0</span>. Data types and and ioctl definitions can be
accessed by including <span class="tt">linux/dvb/dmx.h</span> in your application.
</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dmx_types"></a>Demux Data Types</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#dmx-output-t">dmx_output_t</a></span></dt><dt><span class="section"><a href="media.html#dmx-input-t">dmx_input_t</a></span></dt><dt><span class="section"><a href="media.html#dmx-pes-type-t">dmx_pes_type_t</a></span></dt><dt><span class="section"><a href="media.html#dmx-filter">struct dmx_filter</a></span></dt><dt><span class="section"><a href="media.html#dmx-sct-filter-params">struct dmx_sct_filter_params</a></span></dt><dt><span class="section"><a href="media.html#dmx-pes-filter-params">struct dmx_pes_filter_params</a></span></dt><dt><span class="section"><a href="media.html#dmx-event">struct dmx_event</a></span></dt><dt><span class="section"><a href="media.html#dmx-stc">struct dmx_stc</a></span></dt><dt><span class="section"><a href="media.html#dmx-caps">struct dmx_caps</a></span></dt><dt><span class="section"><a href="media.html#dmx-source-t">enum dmx_source_t</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dmx-output-t"></a>dmx_output_t</h3></div></div></div><pre class="programlisting">
typedef enum
{
	DMX_OUT_DECODER, /&#8902; Streaming directly to decoder. &#8902;/
	DMX_OUT_TAP,     /&#8902; Output going to a memory buffer &#8902;/
			 /&#8902; (to be retrieved via the read command).&#8902;/
	DMX_OUT_TS_TAP,  /&#8902; Output multiplexed into a new TS  &#8902;/
			 /&#8902; (to be retrieved by reading from the &#8902;/
			 /&#8902; logical DVR device).                 &#8902;/
	DMX_OUT_TSDEMUX_TAP /&#8902; Like TS_TAP but retrieved from the DMX device &#8902;/
} dmx_output_t;
</pre><p><span class="tt">DMX_OUT_TAP</span> delivers the stream output to the demux device on which the ioctl is
called.
</p><p><span class="tt">DMX_OUT_TS_TAP</span> routes output to the logical DVR device <span class="tt">/dev/dvb/adapter0/dvr0</span>,
which delivers a TS multiplexed from all filters for which <span class="tt">DMX_OUT_TS_TAP</span> was
specified.
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dmx-input-t"></a>dmx_input_t</h3></div></div></div><pre class="programlisting">
typedef enum
{
	DMX_IN_FRONTEND, /&#8902; Input from a front-end device.  &#8902;/
	DMX_IN_DVR       /&#8902; Input from the logical DVR device.  &#8902;/
} dmx_input_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dmx-pes-type-t"></a>dmx_pes_type_t</h3></div></div></div><pre class="programlisting">
typedef enum
{
	DMX_PES_AUDIO0,
	DMX_PES_VIDEO0,
	DMX_PES_TELETEXT0,
	DMX_PES_SUBTITLE0,
	DMX_PES_PCR0,

	DMX_PES_AUDIO1,
	DMX_PES_VIDEO1,
	DMX_PES_TELETEXT1,
	DMX_PES_SUBTITLE1,
	DMX_PES_PCR1,

	DMX_PES_AUDIO2,
	DMX_PES_VIDEO2,
	DMX_PES_TELETEXT2,
	DMX_PES_SUBTITLE2,
	DMX_PES_PCR2,

	DMX_PES_AUDIO3,
	DMX_PES_VIDEO3,
	DMX_PES_TELETEXT3,
	DMX_PES_SUBTITLE3,
	DMX_PES_PCR3,

	DMX_PES_OTHER
} dmx_pes_type_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dmx-filter"></a>struct dmx_filter</h3></div></div></div><pre class="programlisting">
 typedef struct dmx_filter
{
	__u8  filter[DMX_FILTER_SIZE];
	__u8  mask[DMX_FILTER_SIZE];
	__u8  mode[DMX_FILTER_SIZE];
} dmx_filter_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dmx-sct-filter-params"></a>struct dmx_sct_filter_params</h3></div></div></div><pre class="programlisting">
struct dmx_sct_filter_params
{
	__u16          pid;
	dmx_filter_t   filter;
	__u32          timeout;
	__u32          flags;
#define DMX_CHECK_CRC       1
#define DMX_ONESHOT         2
#define DMX_IMMEDIATE_START 4
#define DMX_KERNEL_CLIENT   0x8000
};
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dmx-pes-filter-params"></a>struct dmx_pes_filter_params</h3></div></div></div><pre class="programlisting">
struct dmx_pes_filter_params
{
	__u16          pid;
	dmx_input_t    input;
	dmx_output_t   output;
	dmx_pes_type_t pes_type;
	__u32          flags;
};
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dmx-event"></a>struct dmx_event</h3></div></div></div><pre class="programlisting">
 struct dmx_event
 {
	 dmx_event_t          event;
	 time_t               timeStamp;
	 union
	 {
		 dmx_scrambling_status_t scrambling;
	 } u;
 };
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dmx-stc"></a>struct dmx_stc</h3></div></div></div><pre class="programlisting">
struct dmx_stc {
	unsigned int num;	/&#8902; input : which STC? 0..N &#8902;/
	unsigned int base;	/&#8902; output: divisor for stc to get 90 kHz clock &#8902;/
	__u64 stc;		/&#8902; output: stc in 'base'&#8902;90 kHz units &#8902;/
};
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dmx-caps"></a>struct dmx_caps</h3></div></div></div><pre class="programlisting">
 typedef struct dmx_caps {
	__u32 caps;
	int num_decoders;
} dmx_caps_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dmx-source-t"></a>enum dmx_source_t</h3></div></div></div><pre class="programlisting">
typedef enum {
	DMX_SOURCE_FRONT0 = 0,
	DMX_SOURCE_FRONT1,
	DMX_SOURCE_FRONT2,
	DMX_SOURCE_FRONT3,
	DMX_SOURCE_DVR0   = 16,
	DMX_SOURCE_DVR1,
	DMX_SOURCE_DVR2,
	DMX_SOURCE_DVR3
} dmx_source_t;
</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dmx_fcalls"></a>Demux Function Calls</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#dmx_fopen">open()</a></span></dt><dt><span class="section"><a href="media.html#dmx_fclose">close()</a></span></dt><dt><span class="section"><a href="media.html#dmx_fread">read()</a></span></dt><dt><span class="section"><a href="media.html#dmx_fwrite">write()</a></span></dt><dt><span class="section"><a href="media.html#DMX_START">DMX_START</a></span></dt><dt><span class="section"><a href="media.html#DMX_STOP">DMX_STOP</a></span></dt><dt><span class="section"><a href="media.html#DMX_SET_FILTER">DMX_SET_FILTER</a></span></dt><dt><span class="section"><a href="media.html#DMX_SET_PES_FILTER">DMX_SET_PES_FILTER</a></span></dt><dt><span class="section"><a href="media.html#DMX_SET_BUFFER_SIZE">DMX_SET_BUFFER_SIZE</a></span></dt><dt><span class="section"><a href="media.html#DMX_GET_EVENT">DMX_GET_EVENT</a></span></dt><dt><span class="section"><a href="media.html#DMX_GET_STC">DMX_GET_STC</a></span></dt><dt><span class="section"><a href="media.html#DMX_GET_PES_PIDS">DMX_GET_PES_PIDS</a></span></dt><dt><span class="section"><a href="media.html#DMX_GET_CAPS">DMX_GET_CAPS</a></span></dt><dt><span class="section"><a href="media.html#DMX_SET_SOURCE">DMX_SET_SOURCE</a></span></dt><dt><span class="section"><a href="media.html#DMX_ADD_PID">DMX_ADD_PID</a></span></dt><dt><span class="section"><a href="media.html#DMX_REMOVE_PID">DMX_REMOVE_PID</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dmx_fopen"></a>open()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This system call, used with a device name of /dev/dvb/adapter0/demux0,
 allocates a new filter and returns a handle which can be used for subsequent
 control of that filter. This call has to be made for each filter to be used, i.e. every
 returned file descriptor is a reference to a single filter. /dev/dvb/adapter0/dvr0
 is a logical device to be used for retrieving Transport Streams for digital
 video recording. When reading from this device a transport stream containing
 the packets from all PES filters set in the corresponding demux device
 (/dev/dvb/adapter0/demux0) having the output set to DMX_OUT_TS_TAP. A
 recorded Transport Stream is replayed by writing to this device. </p>
<p>The significance of blocking or non-blocking mode is described in the
 documentation for functions where there is a difference. It does not affect the
 semantics of the open() call itself. A device opened in blocking mode can later
 be put into non-blocking mode (and vice versa) using the F_SETFL command
 of the fcntl system call.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int open(const char &#8902;deviceName, int flags);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>const char
 *deviceName</p>
</td><td align="char">
<p>Name of demux device.</p>
</td></tr><tr><td align="char">
<p>int flags</p>
</td><td align="char">
<p>A bit-wise OR of the following flags:</p>
</td></tr><tr><td align="char">
</td><td align="char">
<p>O_RDWR read/write access</p>
</td></tr><tr><td align="char">
</td><td align="char">
<p>O_NONBLOCK open in non-blocking mode</p>
</td></tr><tr><td align="char">
</td><td align="char">
<p>(blocking mode is the default)</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>ENODEV</p>
</td><td align="char">
<p>Device driver not loaded/available.</p>
</td></tr><tr><td align="char">
<p>EINVAL</p>
</td><td align="char">
<p>Invalid argument.</p>
</td></tr><tr><td align="char">
<p>EMFILE</p>
</td><td align="char">
<p>&#8220;Too many open files&#8221;, i.e. no more filters available.</p>
</td></tr><tr><td align="char">
<p>ENOMEM</p>
</td><td align="char">
<p>The driver failed to allocate enough memory.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dmx_fclose"></a>close()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This system call deactivates and deallocates a filter that was previously
 allocated via the open() call.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int close(int fd);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>EBADF</p>
</td><td align="char">
<p>fd is not a valid open file descriptor.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dmx_fread"></a>read()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This system call returns filtered data, which might be section or PES data. The
 filtered data is transferred from the driver&#8217;s internal circular buffer to buf. The
 maximum amount of data to be transferred is implied by count.</p>
</td></tr><tr><td align="char">
<p>When returning section data the driver always tries to return a complete single
 section (even though buf would provide buffer space for more data). If the size
 of the buffer is smaller than the section as much as possible will be returned,
 and the remaining data will be provided in subsequent calls.</p>
</td></tr><tr><td align="char">
<p>The size of the internal buffer is 2 * 4096 bytes (the size of two maximum
 sized sections) by default. The size of this buffer may be changed by using the
 DMX_SET_BUFFER_SIZE function. If the buffer is not large enough, or if
 the read operations are not performed fast enough, this may result in a buffer
 overflow error. In this case EOVERFLOW will be returned, and the circular
 buffer will be emptied. This call is blocking if there is no data to return, i.e. the
 process will be put to sleep waiting for data, unless the O_NONBLOCK flag
 is specified.</p>
</td></tr><tr><td align="char">
<p>Note that in order to be able to read, the filtering process has to be started
 by defining either a section or a PES filter by means of the ioctl functions,
 and then starting the filtering process via the DMX_START ioctl function
 or by setting the DMX_IMMEDIATE_START flag. If the reading is done
 from a logical DVR demux device, the data will constitute a Transport Stream
 including the packets from all PES filters in the corresponding demux device
 /dev/dvb/adapter0/demux0 having the output set to DMX_OUT_TS_TAP.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>size_t read(int fd, void &#8902;buf, size_t count);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>void *buf</p>
</td><td align="char">
<p>Pointer to the buffer to be used for returned filtered data.</p>
</td></tr><tr><td align="char">
<p>size_t count</p>
</td><td align="char">
<p>Size of buf.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>EWOULDBLOCK</p>
</td><td align="char">
<p>No data to return and O_NONBLOCK was specified.</p>
</td></tr><tr><td align="char">
<p>EBADF</p>
</td><td align="char">
<p>fd is not a valid open file descriptor.</p>
</td></tr><tr><td align="char">
<p>ECRC</p>
</td><td align="char">
<p>Last section had a CRC error - no data returned. The
 buffer is flushed.</p>
</td></tr><tr><td align="char">
<p>EOVERFLOW</p>
</td><td align="char">
</td></tr><tr><td align="char">
</td><td align="char">
<p>The filtered data was not read from the buffer in due
 time, resulting in non-read data being lost. The buffer is
 flushed.</p>
</td></tr><tr><td align="char">
<p>ETIMEDOUT</p>
</td><td align="char">
<p>The section was not loaded within the stated timeout
 period. See ioctl DMX_SET_FILTER for how to set a
 timeout.</p>
</td></tr><tr><td align="char">
<p>EFAULT</p>
</td><td align="char">
<p>The driver failed to write to the callers buffer due to an
 invalid *buf pointer.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dmx_fwrite"></a>write()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This system call is only provided by the logical device /dev/dvb/adapter0/dvr0,
 associated with the physical demux device that provides the actual DVR
 functionality. It is used for replay of a digitally recorded Transport Stream.
 Matching filters have to be defined in the corresponding physical demux
 device, /dev/dvb/adapter0/demux0. The amount of data to be transferred is
 implied by count.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>ssize_t write(int fd, const void &#8902;buf, size_t
 count);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>void *buf</p>
</td><td align="char">
<p>Pointer to the buffer containing the Transport Stream.</p>
</td></tr><tr><td align="char">
<p>size_t count</p>
</td><td align="char">
<p>Size of buf.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>EWOULDBLOCK</p>
</td><td align="char">
<p>No data was written. This
 might happen if O_NONBLOCK was specified and there
 is no more buffer space available (if O_NONBLOCK is
 not specified the function will block until buffer space is
 available).</p>
</td></tr><tr><td align="char">
<p>EBUSY</p>
</td><td align="char">
<p>This error code indicates that there are conflicting
 requests. The corresponding demux device is setup to
 receive data from the front- end. Make sure that these
 filters are stopped and that the filters with input set to
 DMX_IN_DVR are started.</p>
</td></tr><tr><td align="char">
<p>EBADF</p>
</td><td align="char">
<p>fd is not a valid open file descriptor.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="DMX_START"></a>DMX_START</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call is used to start the actual filtering operation defined via the ioctl
 calls DMX_SET_FILTER or DMX_SET_PES_FILTER.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl( int fd, int request = DMX_START);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals DMX_START for this command.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>EINVAL</p>
</td><td align="char">
<p>Invalid argument, i.e. no filtering parameters provided via
 the DMX_SET_FILTER or DMX_SET_PES_FILTER
 functions.</p>
</td></tr><tr><td align="char">
<p>EBUSY</p>
</td><td align="char">
<p>This error code indicates that there are conflicting
 requests. There are active filters filtering data from
 another input source. Make sure that these filters are
 stopped before starting this filter.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="DMX_STOP"></a>DMX_STOP</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call is used to stop the actual filtering operation defined via the
 ioctl calls DMX_SET_FILTER or DMX_SET_PES_FILTER and started via
 the DMX_START command.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl( int fd, int request = DMX_STOP);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals DMX_STOP for this command.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="DMX_SET_FILTER"></a>DMX_SET_FILTER</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call sets up a filter according to the filter and mask parameters
 provided. A timeout may be defined stating number of seconds to wait for a
 section to be loaded. A value of 0 means that no timeout should be applied.
 Finally there is a flag field where it is possible to state whether a section should
 be CRC-checked, whether the filter should be a &#8221;one-shot&#8221; filter, i.e. if the
 filtering operation should be stopped after the first section is received, and
 whether the filtering operation should be started immediately (without waiting
 for a DMX_START ioctl call). If a filter was previously set-up, this filter will
 be canceled, and the receive buffer will be flushed.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl( int fd, int request = DMX_SET_FILTER,
 struct dmx_sct_filter_params &#8902;params);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals DMX_SET_FILTER for this command.</p>
</td></tr><tr><td align="char">
<p>struct
 dmx_sct_filter_params
 *params</p>
</td><td align="char">
<p>Pointer to structure containing filter parameters.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="DMX_SET_PES_FILTER"></a>DMX_SET_PES_FILTER</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call sets up a PES filter according to the parameters provided. By a
 PES filter is meant a filter that is based just on the packet identifier (PID), i.e.
 no PES header or payload filtering capability is supported.</p>
</td></tr><tr><td align="char">
<p>The transport stream destination for the filtered output may be set. Also the
 PES type may be stated in order to be able to e.g. direct a video stream directly
 to the video decoder. Finally there is a flag field where it is possible to state
 whether the filtering operation should be started immediately (without waiting
 for a DMX_START ioctl call). If a filter was previously set-up, this filter will
 be cancelled, and the receive buffer will be flushed.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl( int fd, int request = DMX_SET_PES_FILTER,
 struct dmx_pes_filter_params &#8902;params);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals DMX_SET_PES_FILTER for this command.</p>
</td></tr><tr><td align="char">
<p>struct
 dmx_pes_filter_params
 *params</p>
</td><td align="char">
<p>Pointer to structure containing filter parameters.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>EBUSY</p>
</td><td align="char">
<p>This error code indicates that there are conflicting
 requests. There are active filters filtering data from
 another input source. Make sure that these filters are
 stopped before starting this filter.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="DMX_SET_BUFFER_SIZE"></a>DMX_SET_BUFFER_SIZE</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call is used to set the size of the circular buffer used for filtered data.
 The default size is two maximum sized sections, i.e. if this function is not called
 a buffer size of 2 * 4096 bytes will be used.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl( int fd, int request =
 DMX_SET_BUFFER_SIZE, unsigned long size);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals DMX_SET_BUFFER_SIZE for this command.</p>
</td></tr><tr><td align="char">
<p>unsigned long size</p>
</td><td align="char">
<p>Size of circular buffer.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="DMX_GET_EVENT"></a>DMX_GET_EVENT</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call returns an event if available. If an event is not available,
 the behavior depends on whether the device is in blocking or non-blocking
 mode. In the latter case, the call fails immediately with errno set to
 EWOULDBLOCK. In the former case, the call blocks until an event becomes
 available.</p>
</td></tr><tr><td align="char">
<p>The standard Linux poll() and/or select() system calls can be used with the
 device file descriptor to watch for new events. For select(), the file descriptor
 should be included in the exceptfds argument, and for poll(), POLLPRI should
 be specified as the wake-up condition. Only the latest event for each filter is
 saved.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl( int fd, int request = DMX_GET_EVENT,
 struct dmx_event &#8902;ev);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals DMX_GET_EVENT for this command.</p>
</td></tr><tr><td align="char">
<p>struct dmx_event *ev</p>
</td><td align="char">
<p>Pointer to the location where the event is to be stored.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>EWOULDBLOCK</p>
</td><td align="char">
<p>There is no event pending, and the device is in
 non-blocking mode.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="DMX_GET_STC"></a>DMX_GET_STC</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call returns the current value of the system time counter (which is driven
 by a PES filter of type DMX_PES_PCR). Some hardware supports more than one
 STC, so you must specify which one by setting the num field of stc before the ioctl
 (range 0...n). The result is returned in form of a ratio with a 64 bit numerator
 and a 32 bit denominator, so the real 90kHz STC value is stc-&gt;stc /
 stc-&gt;base
 .</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl( int fd, int request = DMX_GET_STC, struct
 dmx_stc &#8902;stc);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals DMX_GET_STC for this command.</p>
</td></tr><tr><td align="char">
<p>struct dmx_stc *stc</p>
</td><td align="char">
<p>Pointer to the location where the stc is to be stored.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>EINVAL</p>
</td><td align="char">
<p>Invalid stc number.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="DMX_GET_PES_PIDS"></a>DMX_GET_PES_PIDS</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl is undocumented. Documentation is welcome.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(fd, int request = DMX_GET_PES_PIDS,
 __u16[5]);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals DMX_GET_PES_PIDS for this command.</p>
</td></tr><tr><td align="char">
<p>__u16[5]
</p>
</td><td align="char">
<p>Undocumented.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="DMX_GET_CAPS"></a>DMX_GET_CAPS</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl is undocumented. Documentation is welcome.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(fd, int request = DMX_GET_CAPS,
 dmx_caps_t *);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals DMX_GET_CAPS for this command.</p>
</td></tr><tr><td align="char">
<p>dmx_caps_t *
</p>
</td><td align="char">
<p>Undocumented.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="DMX_SET_SOURCE"></a>DMX_SET_SOURCE</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl is undocumented. Documentation is welcome.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(fd, int request = DMX_SET_SOURCE,
 dmx_source_t *);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals DMX_SET_SOURCE for this command.</p>
</td></tr><tr><td align="char">
<p>dmx_source_t *
</p>
</td><td align="char">
<p>Undocumented.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="DMX_ADD_PID"></a>DMX_ADD_PID</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call allows to add multiple PIDs to a transport stream filter
previously set up with DMX_SET_PES_FILTER and output equal to DMX_OUT_TSDEMUX_TAP.
</p></td></tr><tr><td align="char"><p>
It is used by readers of /dev/dvb/adapterX/demuxY.
</p></td></tr><tr><td align="char"><p>
It may be called at any time, i.e. before or after the first filter on the
shared file descriptor was started. It makes it possible to record multiple
services without the need to de-multiplex or re-multiplex TS packets.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(fd, int request = DMX_ADD_PID,
 __u16 *);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals DMX_ADD_PID for this command.</p>
</td></tr><tr><td align="char">
<p>__u16 *
</p>
</td><td align="char">
<p>PID number to be filtered.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="DMX_REMOVE_PID"></a>DMX_REMOVE_PID</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call allows to remove a PID when multiple PIDs are set on a
transport stream filter, e. g. a filter previously set up with output equal to
DMX_OUT_TSDEMUX_TAP, created via either DMX_SET_PES_FILTER or DMX_ADD_PID.
</p></td></tr><tr><td align="char"><p>
It is used by readers of /dev/dvb/adapterX/demuxY.
</p></td></tr><tr><td align="char"><p>
It may be called at any time, i.e. before or after the first filter on the
shared file descriptor was started. It makes it possible to record multiple
services without the need to de-multiplex or re-multiplex TS packets.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(fd, int request = DMX_REMOVE_PID,
 __u16 *);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals DMX_REMOVE_PID for this command.</p>
</td></tr><tr><td align="char">
<p>__u16 *
</p>
</td><td align="char">
<p>PID of the PES filter to be removed.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="dvb_video"></a>Chapter 11. DVB Video Device</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="media.html#video_types">Video Data Types</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#video-format-t">video_format_t</a></span></dt><dt><span class="section"><a href="media.html#video-displayformat-t">video_displayformat_t</a></span></dt><dt><span class="section"><a href="media.html#video-stream-source-t">video_stream_source_t</a></span></dt><dt><span class="section"><a href="media.html#video-play-state-t">video_play_state_t</a></span></dt><dt><span class="section"><a href="media.html#video-command">struct video_command</a></span></dt><dt><span class="section"><a href="media.html#video-size-t">video_size_t</a></span></dt><dt><span class="section"><a href="media.html#video-event">struct video_event</a></span></dt><dt><span class="section"><a href="media.html#video-status">struct video_status</a></span></dt><dt><span class="section"><a href="media.html#video-still-picture">struct video_still_picture</a></span></dt><dt><span class="section"><a href="media.html#video_caps">video capabilities</a></span></dt><dt><span class="section"><a href="media.html#video-system">video_system_t</a></span></dt><dt><span class="section"><a href="media.html#video-highlight">struct video_highlight</a></span></dt><dt><span class="section"><a href="media.html#video-spu">struct video_spu</a></span></dt><dt><span class="section"><a href="media.html#video-spu-palette">struct video_spu_palette</a></span></dt><dt><span class="section"><a href="media.html#video-navi-pack">struct video_navi_pack</a></span></dt><dt><span class="section"><a href="media.html#video-attributes-t">video_attributes_t</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#video_function_calls">Video Function Calls</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#video_fopen">open()</a></span></dt><dt><span class="section"><a href="media.html#video_fclose">close()</a></span></dt><dt><span class="section"><a href="media.html#video_fwrite">write()</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_STOP">VIDEO_STOP</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_PLAY">VIDEO_PLAY</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_FREEZE">VIDEO_FREEZE</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_CONTINUE">VIDEO_CONTINUE</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SELECT_SOURCE">VIDEO_SELECT_SOURCE</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_BLANK">VIDEO_SET_BLANK</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_GET_STATUS">VIDEO_GET_STATUS</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_GET_FRAME_COUNT">VIDEO_GET_FRAME_COUNT</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_GET_PTS">VIDEO_GET_PTS</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_GET_FRAME_RATE">VIDEO_GET_FRAME_RATE</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_GET_EVENT">VIDEO_GET_EVENT</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_COMMAND">VIDEO_COMMAND</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_TRY_COMMAND">VIDEO_TRY_COMMAND</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_GET_SIZE">VIDEO_GET_SIZE</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_DISPLAY_FORMAT">VIDEO_SET_DISPLAY_FORMAT</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_STILLPICTURE">VIDEO_STILLPICTURE</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_FAST_FORWARD">VIDEO_FAST_FORWARD</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SLOWMOTION">VIDEO_SLOWMOTION</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_GET_CAPABILITIES">VIDEO_GET_CAPABILITIES</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_ID">VIDEO_SET_ID</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_CLEAR_BUFFER">VIDEO_CLEAR_BUFFER</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_STREAMTYPE">VIDEO_SET_STREAMTYPE</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_FORMAT">VIDEO_SET_FORMAT</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_SYSTEM">VIDEO_SET_SYSTEM</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_HIGHLIGHT">VIDEO_SET_HIGHLIGHT</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_SPU">VIDEO_SET_SPU</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_SPU_PALETTE">VIDEO_SET_SPU_PALETTE</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_GET_NAVI">VIDEO_GET_NAVI</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_ATTRIBUTES">VIDEO_SET_ATTRIBUTES</a></span></dt></dl></dd></dl></div><p>The DVB video device controls the MPEG2 video decoder of the DVB hardware. It
can be accessed through <span class="tt">/dev/dvb/adapter0/video0</span>. Data types and and
ioctl definitions can be accessed by including <span class="tt">linux/dvb/video.h</span> in your
application.
</p><p>Note that the DVB video device only controls decoding of the MPEG video stream, not
its presentation on the TV or computer screen. On PCs this is typically handled by an
associated video4linux device, e.g. <span class="tt">/dev/video</span>, which allows scaling and defining output
windows.
</p><p>Some DVB cards don&#8217;t have their own MPEG decoder, which results in the omission of
the audio and video device as well as the video4linux device.
</p><p>The ioctls that deal with SPUs (sub picture units) and navigation packets are only
supported on some MPEG decoders made for DVD playback.
</p><p>
These ioctls were also used by V4L2 to control MPEG decoders implemented in V4L2. The use
of these ioctls for that purpose has been made obsolete and proper V4L2 ioctls or controls
have been created to replace that functionality.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="video_types"></a>Video Data Types</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#video-format-t">video_format_t</a></span></dt><dt><span class="section"><a href="media.html#video-displayformat-t">video_displayformat_t</a></span></dt><dt><span class="section"><a href="media.html#video-stream-source-t">video_stream_source_t</a></span></dt><dt><span class="section"><a href="media.html#video-play-state-t">video_play_state_t</a></span></dt><dt><span class="section"><a href="media.html#video-command">struct video_command</a></span></dt><dt><span class="section"><a href="media.html#video-size-t">video_size_t</a></span></dt><dt><span class="section"><a href="media.html#video-event">struct video_event</a></span></dt><dt><span class="section"><a href="media.html#video-status">struct video_status</a></span></dt><dt><span class="section"><a href="media.html#video-still-picture">struct video_still_picture</a></span></dt><dt><span class="section"><a href="media.html#video_caps">video capabilities</a></span></dt><dt><span class="section"><a href="media.html#video-system">video_system_t</a></span></dt><dt><span class="section"><a href="media.html#video-highlight">struct video_highlight</a></span></dt><dt><span class="section"><a href="media.html#video-spu">struct video_spu</a></span></dt><dt><span class="section"><a href="media.html#video-spu-palette">struct video_spu_palette</a></span></dt><dt><span class="section"><a href="media.html#video-navi-pack">struct video_navi_pack</a></span></dt><dt><span class="section"><a href="media.html#video-attributes-t">video_attributes_t</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="video-format-t"></a>video_format_t</h3></div></div></div><p>The <span class="tt">video_format_t</span> data type defined by
</p><pre class="programlisting">
typedef enum {
	VIDEO_FORMAT_4_3,     /&#8902; Select 4:3 format &#8902;/
	VIDEO_FORMAT_16_9,    /&#8902; Select 16:9 format. &#8902;/
	VIDEO_FORMAT_221_1    /&#8902; 2.21:1 &#8902;/
} video_format_t;
</pre><p>is used in the VIDEO_SET_FORMAT function (??) to tell the driver which aspect ratio
the output hardware (e.g. TV) has. It is also used in the data structures video_status
(??) returned by VIDEO_GET_STATUS (??) and video_event (??) returned by
VIDEO_GET_EVENT (??) which report about the display format of the current video
stream.
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="video-displayformat-t"></a>video_displayformat_t</h3></div></div></div><p>In case the display format of the video stream and of the display hardware differ the
application has to specify how to handle the cropping of the picture. This can be done using
the VIDEO_SET_DISPLAY_FORMAT call (??) which accepts
</p><pre class="programlisting">
typedef enum {
	VIDEO_PAN_SCAN,       /&#8902; use pan and scan format &#8902;/
	VIDEO_LETTER_BOX,     /&#8902; use letterbox format &#8902;/
	VIDEO_CENTER_CUT_OUT  /&#8902; use center cut out format &#8902;/
} video_displayformat_t;
</pre><p>as argument.
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="video-stream-source-t"></a>video_stream_source_t</h3></div></div></div><p>The video stream source is set through the VIDEO_SELECT_SOURCE call and can take
the following values, depending on whether we are replaying from an internal (demuxer) or
external (user write) source.
</p><pre class="programlisting">
typedef enum {
	VIDEO_SOURCE_DEMUX, /&#8902; Select the demux as the main source &#8902;/
	VIDEO_SOURCE_MEMORY /&#8902; If this source is selected, the stream
			       comes from the user through the write
			       system call &#8902;/
} video_stream_source_t;
</pre><p>VIDEO_SOURCE_DEMUX selects the demultiplexer (fed either by the frontend or the
DVR device) as the source of the video stream. If VIDEO_SOURCE_MEMORY
is selected the stream comes from the application through the <span class="tt">write()</span> system
call.
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="video-play-state-t"></a>video_play_state_t</h3></div></div></div><p>The following values can be returned by the VIDEO_GET_STATUS call representing the
state of video playback.
</p><pre class="programlisting">
typedef enum {
	VIDEO_STOPPED, /&#8902; Video is stopped &#8902;/
	VIDEO_PLAYING, /&#8902; Video is currently playing &#8902;/
	VIDEO_FREEZED  /&#8902; Video is freezed &#8902;/
} video_play_state_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="video-command"></a>struct video_command</h3></div></div></div><p>The structure must be zeroed before use by the application
This ensures it can be extended safely in the future.</p><pre class="programlisting">
struct video_command {
	__u32 cmd;
	__u32 flags;
	union {
		struct {
			__u64 pts;
		} stop;

		struct {
			/&#8902; 0 or 1000 specifies normal speed,
			   1 specifies forward single stepping,
			   -1 specifies backward single stepping,
			   &gt;&gt;1: playback at speed/1000 of the normal speed,
			   &lt;-1: reverse playback at (-speed/1000) of the normal speed. &#8902;/
			__s32 speed;
			__u32 format;
		} play;

		struct {
			__u32 data[16];
		} raw;
	};
};
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="video-size-t"></a>video_size_t</h3></div></div></div><pre class="programlisting">
typedef struct {
	int w;
	int h;
	video_format_t aspect_ratio;
} video_size_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="video-event"></a>struct video_event</h3></div></div></div><p>The following is the structure of a video event as it is returned by the VIDEO_GET_EVENT
call.
</p><pre class="programlisting">
struct video_event {
	__s32 type;
#define VIDEO_EVENT_SIZE_CHANGED	1
#define VIDEO_EVENT_FRAME_RATE_CHANGED	2
#define VIDEO_EVENT_DECODER_STOPPED 	3
#define VIDEO_EVENT_VSYNC 		4
	__kernel_time_t timestamp;
	union {
		video_size_t size;
		unsigned int frame_rate;	/&#8902; in frames per 1000sec &#8902;/
		unsigned char vsync_field;	/&#8902; unknown/odd/even/progressive &#8902;/
	} u;
};
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="video-status"></a>struct video_status</h3></div></div></div><p>The VIDEO_GET_STATUS call returns the following structure informing about various
states of the playback operation.
</p><pre class="programlisting">
struct video_status {
	int                   video_blank;   /&#8902; blank video on freeze? &#8902;/
	video_play_state_t    play_state;    /&#8902; current state of playback &#8902;/
	video_stream_source_t stream_source; /&#8902; current source (demux/memory) &#8902;/
	video_format_t        video_format;  /&#8902; current aspect ratio of stream &#8902;/
	video_displayformat_t display_format;/&#8902; selected cropping mode &#8902;/
};
</pre><p>If video_blank is set video will be blanked out if the channel is changed or if playback is
stopped. Otherwise, the last picture will be displayed. play_state indicates if the video is
currently frozen, stopped, or being played back. The stream_source corresponds to the seleted
source for the video stream. It can come either from the demultiplexer or from memory.
The video_format indicates the aspect ratio (one of 4:3 or 16:9) of the currently
played video stream. Finally, display_format corresponds to the selected cropping
mode in case the source video format is not the same as the format of the output
device.
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="video-still-picture"></a>struct video_still_picture</h3></div></div></div><p>An I-frame displayed via the VIDEO_STILLPICTURE call is passed on within the
following structure.
</p><pre class="programlisting">
/&#8902; pointer to and size of a single iframe in memory &#8902;/
struct video_still_picture {
	char &#8902;iFrame;        /&#8902; pointer to a single iframe in memory &#8902;/
	int32_t size;
};
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="video_caps"></a>video capabilities</h3></div></div></div><p>A call to VIDEO_GET_CAPABILITIES returns an unsigned integer with the following
bits set according to the hardwares capabilities.
</p><pre class="programlisting">
 /&#8902; bit definitions for capabilities: &#8902;/
 /&#8902; can the hardware decode MPEG1 and/or MPEG2? &#8902;/
 #define VIDEO_CAP_MPEG1   1
 #define VIDEO_CAP_MPEG2   2
 /&#8902; can you send a system and/or program stream to video device?
    (you still have to open the video and the audio device but only
     send the stream to the video device) &#8902;/
 #define VIDEO_CAP_SYS     4
 #define VIDEO_CAP_PROG    8
 /&#8902; can the driver also handle SPU, NAVI and CSS encoded data?
    (CSS API is not present yet) &#8902;/
 #define VIDEO_CAP_SPU    16
 #define VIDEO_CAP_NAVI   32
 #define VIDEO_CAP_CSS    64
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="video-system"></a>video_system_t</h3></div></div></div><p>A call to VIDEO_SET_SYSTEM sets the desired video system for TV output. The
following system types can be set:
</p><pre class="programlisting">
typedef enum {
	 VIDEO_SYSTEM_PAL,
	 VIDEO_SYSTEM_NTSC,
	 VIDEO_SYSTEM_PALN,
	 VIDEO_SYSTEM_PALNc,
	 VIDEO_SYSTEM_PALM,
	 VIDEO_SYSTEM_NTSC60,
	 VIDEO_SYSTEM_PAL60,
	 VIDEO_SYSTEM_PALM60
} video_system_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="video-highlight"></a>struct video_highlight</h3></div></div></div><p>Calling the ioctl VIDEO_SET_HIGHLIGHTS posts the SPU highlight information. The
call expects the following format for that information:
</p><pre class="programlisting">
 typedef
 struct video_highlight {
	 boolean active;      /&#8902;    1=show highlight, 0=hide highlight &#8902;/
	 uint8_t contrast1;   /&#8902;    7- 4  Pattern pixel contrast &#8902;/
			      /&#8902;    3- 0  Background pixel contrast &#8902;/
	 uint8_t contrast2;   /&#8902;    7- 4  Emphasis pixel-2 contrast &#8902;/
			      /&#8902;    3- 0  Emphasis pixel-1 contrast &#8902;/
	 uint8_t color1;      /&#8902;    7- 4  Pattern pixel color &#8902;/
			      /&#8902;    3- 0  Background pixel color &#8902;/
	 uint8_t color2;      /&#8902;    7- 4  Emphasis pixel-2 color &#8902;/
			      /&#8902;    3- 0  Emphasis pixel-1 color &#8902;/
	 uint32_t ypos;       /&#8902;   23-22  auto action mode &#8902;/
			      /&#8902;   21-12  start y &#8902;/
			      /&#8902;    9- 0  end y &#8902;/
	 uint32_t xpos;       /&#8902;   23-22  button color number &#8902;/
			      /&#8902;   21-12  start x &#8902;/
			      /&#8902;    9- 0  end x &#8902;/
 } video_highlight_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="video-spu"></a>struct video_spu</h3></div></div></div><p>Calling VIDEO_SET_SPU deactivates or activates SPU decoding, according to the
following format:
</p><pre class="programlisting">
 typedef
 struct video_spu {
	 boolean active;
	 int stream_id;
 } video_spu_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="video-spu-palette"></a>struct video_spu_palette</h3></div></div></div><p>The following structure is used to set the SPU palette by calling VIDEO_SPU_PALETTE:
</p><pre class="programlisting">
 typedef
 struct video_spu_palette {
	 int length;
	 uint8_t &#8902;palette;
 } video_spu_palette_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="video-navi-pack"></a>struct video_navi_pack</h3></div></div></div><p>In order to get the navigational data the following structure has to be passed to the ioctl
VIDEO_GET_NAVI:
</p><pre class="programlisting">
 typedef
 struct video_navi_pack {
	 int length;         /&#8902; 0 ... 1024 &#8902;/
	 uint8_t data[1024];
 } video_navi_pack_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="video-attributes-t"></a>video_attributes_t</h3></div></div></div><p>The following attributes can be set by a call to VIDEO_SET_ATTRIBUTES:
</p><pre class="programlisting">
 typedef uint16_t video_attributes_t;
 /&#8902;   bits: descr. &#8902;/
 /&#8902;   15-14 Video compression mode (0=MPEG-1, 1=MPEG-2) &#8902;/
 /&#8902;   13-12 TV system (0=525/60, 1=625/50) &#8902;/
 /&#8902;   11-10 Aspect ratio (0=4:3, 3=16:9) &#8902;/
 /&#8902;    9- 8 permitted display mode on 4:3 monitor (0=both, 1=only pan-sca &#8902;/
 /&#8902;    7    line 21-1 data present in GOP (1=yes, 0=no) &#8902;/
 /&#8902;    6    line 21-2 data present in GOP (1=yes, 0=no) &#8902;/
 /&#8902;    5- 3 source resolution (0=720x480/576, 1=704x480/576, 2=352x480/57 &#8902;/
 /&#8902;    2    source letterboxed (1=yes, 0=no) &#8902;/
 /&#8902;    0    film/camera mode (0=camera, 1=film (625/50 only)) &#8902;/
</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="video_function_calls"></a>Video Function Calls</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#video_fopen">open()</a></span></dt><dt><span class="section"><a href="media.html#video_fclose">close()</a></span></dt><dt><span class="section"><a href="media.html#video_fwrite">write()</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_STOP">VIDEO_STOP</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_PLAY">VIDEO_PLAY</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_FREEZE">VIDEO_FREEZE</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_CONTINUE">VIDEO_CONTINUE</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SELECT_SOURCE">VIDEO_SELECT_SOURCE</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_BLANK">VIDEO_SET_BLANK</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_GET_STATUS">VIDEO_GET_STATUS</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_GET_FRAME_COUNT">VIDEO_GET_FRAME_COUNT</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_GET_PTS">VIDEO_GET_PTS</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_GET_FRAME_RATE">VIDEO_GET_FRAME_RATE</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_GET_EVENT">VIDEO_GET_EVENT</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_COMMAND">VIDEO_COMMAND</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_TRY_COMMAND">VIDEO_TRY_COMMAND</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_GET_SIZE">VIDEO_GET_SIZE</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_DISPLAY_FORMAT">VIDEO_SET_DISPLAY_FORMAT</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_STILLPICTURE">VIDEO_STILLPICTURE</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_FAST_FORWARD">VIDEO_FAST_FORWARD</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SLOWMOTION">VIDEO_SLOWMOTION</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_GET_CAPABILITIES">VIDEO_GET_CAPABILITIES</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_ID">VIDEO_SET_ID</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_CLEAR_BUFFER">VIDEO_CLEAR_BUFFER</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_STREAMTYPE">VIDEO_SET_STREAMTYPE</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_FORMAT">VIDEO_SET_FORMAT</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_SYSTEM">VIDEO_SET_SYSTEM</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_HIGHLIGHT">VIDEO_SET_HIGHLIGHT</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_SPU">VIDEO_SET_SPU</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_SPU_PALETTE">VIDEO_SET_SPU_PALETTE</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_GET_NAVI">VIDEO_GET_NAVI</a></span></dt><dt><span class="section"><a href="media.html#VIDEO_SET_ATTRIBUTES">VIDEO_SET_ATTRIBUTES</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="video_fopen"></a>open()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This system call opens a named video device (e.g. /dev/dvb/adapter0/video0)
 for subsequent use.</p>
<p>When an open() call has succeeded, the device will be ready for use.
 The significance of blocking or non-blocking mode is described in the
 documentation for functions where there is a difference. It does not affect the
 semantics of the open() call itself. A device opened in blocking mode can later
 be put into non-blocking mode (and vice versa) using the F_SETFL command
 of the fcntl system call. This is a standard system call, documented in the Linux
 manual page for fcntl. Only one user can open the Video Device in O_RDWR
 mode. All other attempts to open the device in this mode will fail, and an
 error-code will be returned. If the Video Device is opened in O_RDONLY
 mode, the only ioctl call that can be used is VIDEO_GET_STATUS. All other
 call will return an error code.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int open(const char &#8902;deviceName, int flags);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>const char
 *deviceName</p>
</td><td align="char">
<p>Name of specific video device.</p>
</td></tr><tr><td align="char">
<p>int flags</p>
</td><td align="char">
<p>A bit-wise OR of the following flags:</p>
</td></tr><tr><td align="char">
</td><td align="char">
<p>O_RDONLY read-only access</p>
</td></tr><tr><td align="char">
</td><td align="char">
<p>O_RDWR read/write access</p>
</td></tr><tr><td align="char">
</td><td align="char">
<p>O_NONBLOCK open in non-blocking mode</p>
</td></tr><tr><td align="char">
</td><td align="char">
<p>(blocking mode is the default)</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>ENODEV</p>
</td><td align="char">
<p>Device driver not loaded/available.</p>
</td></tr><tr><td align="char">
<p>EINTERNAL</p>
</td><td align="char">
<p>Internal error.</p>
</td></tr><tr><td align="char">
<p>EBUSY</p>
</td><td align="char">
<p>Device or resource busy.</p>
</td></tr><tr><td align="char">
<p>EINVAL</p>
</td><td align="char">
<p>Invalid argument.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="video_fclose"></a>close()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This system call closes a previously opened video device.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int close(int fd);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>EBADF</p>
</td><td align="char">
<p>fd is not a valid open file descriptor.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="video_fwrite"></a>write()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This system call can only be used if VIDEO_SOURCE_MEMORY is selected
 in the ioctl call VIDEO_SELECT_SOURCE. The data provided shall be in
 PES format, unless the capability allows other formats. If O_NONBLOCK is
 not specified the function will block until buffer space is available. The amount
 of data to be transferred is implied by count.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>size_t write(int fd, const void &#8902;buf, size_t count);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>void *buf</p>
</td><td align="char">
<p>Pointer to the buffer containing the PES data.</p>
</td></tr><tr><td align="char">
<p>size_t count</p>
</td><td align="char">
<p>Size of buf.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>EPERM</p>
</td><td align="char">
<p>Mode VIDEO_SOURCE_MEMORY not selected.</p>
</td></tr><tr><td align="char">
<p>ENOMEM</p>
</td><td align="char">
<p>Attempted to write more data than the internal buffer can
 hold.</p>
</td></tr><tr><td align="char">
<p>EBADF</p>
</td><td align="char">
<p>fd is not a valid open file descriptor.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="VIDEO_STOP"></a>VIDEO_STOP</h3></div></div></div><p>DESCRIPTION
</p><p>This ioctl is for DVB devices only. To control a V4L2 decoder use the V4L2
<a class="link" href="media.html#vidioc-decoder-cmd" title="ioctl VIDIOC_DECODER_CMD, VIDIOC_TRY_DECODER_CMD"><code class="constant">VIDIOC_DECODER_CMD</code></a> instead.</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call asks the Video Device to stop playing the current stream.
 Depending on the input parameter, the screen can be blanked out or displaying
 the last decoded frame.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(fd, int request = VIDEO_STOP, boolean
 mode);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals VIDEO_STOP for this command.</p>
</td></tr><tr><td align="char">
<p>Boolean mode</p>
</td><td align="char">
<p>Indicates how the screen shall be handled.</p>
</td></tr><tr><td align="char">
</td><td align="char">
<p>TRUE: Blank screen when stop.</p>
</td></tr><tr><td align="char">
</td><td align="char">
<p>FALSE: Show last decoded frame.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="VIDEO_PLAY"></a>VIDEO_PLAY</h3></div></div></div><p>DESCRIPTION
</p><p>This ioctl is for DVB devices only. To control a V4L2 decoder use the V4L2
<a class="link" href="media.html#vidioc-decoder-cmd" title="ioctl VIDIOC_DECODER_CMD, VIDIOC_TRY_DECODER_CMD"><code class="constant">VIDIOC_DECODER_CMD</code></a> instead.</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call asks the Video Device to start playing a video stream from the
 selected source.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(fd, int request = VIDEO_PLAY);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals VIDEO_PLAY for this command.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="VIDEO_FREEZE"></a>VIDEO_FREEZE</h3></div></div></div><p>DESCRIPTION
</p><p>This ioctl is for DVB devices only. To control a V4L2 decoder use the V4L2
<a class="link" href="media.html#vidioc-decoder-cmd" title="ioctl VIDIOC_DECODER_CMD, VIDIOC_TRY_DECODER_CMD"><code class="constant">VIDIOC_DECODER_CMD</code></a> instead.</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call suspends the live video stream being played. Decoding
 and playing are frozen. It is then possible to restart the decoding
 and playing process of the video stream using the VIDEO_CONTINUE
 command. If VIDEO_SOURCE_MEMORY is selected in the ioctl call
 VIDEO_SELECT_SOURCE, the DVB subsystem will not decode any more
 data until the ioctl call VIDEO_CONTINUE or VIDEO_PLAY is performed.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(fd, int request = VIDEO_FREEZE);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals VIDEO_FREEZE for this command.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="VIDEO_CONTINUE"></a>VIDEO_CONTINUE</h3></div></div></div><p>DESCRIPTION
</p><p>This ioctl is for DVB devices only. To control a V4L2 decoder use the V4L2
<a class="link" href="media.html#vidioc-decoder-cmd" title="ioctl VIDIOC_DECODER_CMD, VIDIOC_TRY_DECODER_CMD"><code class="constant">VIDIOC_DECODER_CMD</code></a> instead.</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call restarts decoding and playing processes of the video stream
 which was played before a call to VIDEO_FREEZE was made.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(fd, int request = VIDEO_CONTINUE);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals VIDEO_CONTINUE for this command.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="VIDEO_SELECT_SOURCE"></a>VIDEO_SELECT_SOURCE</h3></div></div></div><p>DESCRIPTION
</p><p>This ioctl is for DVB devices only. This ioctl was also supported by the
V4L2 ivtv driver, but that has been replaced by the ivtv-specific
<code class="constant">IVTV_IOC_PASSTHROUGH_MODE</code> ioctl.</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call informs the video device which source shall be used for the input
 data. The possible sources are demux or memory. If memory is selected, the
 data is fed to the video device through the write command.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(fd, int request = VIDEO_SELECT_SOURCE,
 video_stream_source_t source);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals VIDEO_SELECT_SOURCE for this command.</p>
</td></tr><tr><td align="char">
<p>video_stream_source_t
 source</p>
</td><td align="char">
<p>Indicates which source shall be used for the Video stream.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="VIDEO_SET_BLANK"></a>VIDEO_SET_BLANK</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call asks the Video Device to blank out the picture.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(fd, int request = VIDEO_SET_BLANK, boolean
 mode);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals VIDEO_SET_BLANK for this command.</p>
</td></tr><tr><td align="char">
<p>boolean mode</p>
</td><td align="char">
<p>TRUE: Blank screen when stop.</p>
</td></tr><tr><td align="char">
</td><td align="char">
<p>FALSE: Show last decoded frame.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="VIDEO_GET_STATUS"></a>VIDEO_GET_STATUS</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call asks the Video Device to return the current status of the device.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p> int ioctl(fd, int request = VIDEO_GET_STATUS, struct
 video_status &#8902;status);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals VIDEO_GET_STATUS for this command.</p>
</td></tr><tr><td align="char">
<p>struct video_status
 *status</p>
</td><td align="char">
<p>Returns the current status of the Video Device.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="VIDEO_GET_FRAME_COUNT"></a>VIDEO_GET_FRAME_COUNT</h3></div></div></div><p>DESCRIPTION
</p><p>This ioctl is obsolete. Do not use in new drivers. For V4L2 decoders this
ioctl has been replaced by the <code class="constant">V4L2_CID_MPEG_VIDEO_DEC_FRAME</code> control.</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call asks the Video Device to return the number of displayed frames
since the decoder was started.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request =
 VIDEO_GET_FRAME_COUNT, __u64 *pts);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals VIDEO_GET_FRAME_COUNT for this
 command.</p>
</td></tr><tr><td align="char">
<p>__u64 *pts
</p>
</td><td align="char">
<p>Returns the number of frames displayed since the decoder was started.
</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="VIDEO_GET_PTS"></a>VIDEO_GET_PTS</h3></div></div></div><p>DESCRIPTION
</p><p>This ioctl is obsolete. Do not use in new drivers. For V4L2 decoders this
ioctl has been replaced by the <code class="constant">V4L2_CID_MPEG_VIDEO_DEC_PTS</code> control.</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call asks the Video Device to return the current PTS timestamp.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request =
 VIDEO_GET_PTS, __u64 *pts);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals VIDEO_GET_PTS for this
 command.</p>
</td></tr><tr><td align="char">
<p>__u64 *pts
</p>
</td><td align="char">
<p>Returns the 33-bit timestamp as defined in ITU T-REC-H.222.0 / ISO/IEC 13818-1.
</p>
<p>
The PTS should belong to the currently played
frame if possible, but may also be a value close to it
like the PTS of the last decoded frame or the last PTS
extracted by the PES parser.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="VIDEO_GET_FRAME_RATE"></a>VIDEO_GET_FRAME_RATE</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call asks the Video Device to return the current framerate.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request =
 VIDEO_GET_FRAME_RATE, unsigned int *rate);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals VIDEO_GET_FRAME_RATE for this
 command.</p>
</td></tr><tr><td align="char">
<p>unsigned int *rate
</p>
</td><td align="char">
<p>Returns the framerate in number of frames per 1000 seconds.
</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="VIDEO_GET_EVENT"></a>VIDEO_GET_EVENT</h3></div></div></div><p>DESCRIPTION
</p><p>This ioctl is for DVB devices only. To get events from a V4L2 decoder use the V4L2
<a class="link" href="media.html#vidioc-dqevent" title="ioctl VIDIOC_DQEVENT"><code class="constant">VIDIOC_DQEVENT</code></a> ioctl instead.</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call returns an event of type video_event if available. If an event is
 not available, the behavior depends on whether the device is in blocking or
 non-blocking mode. In the latter case, the call fails immediately with errno
 set to EWOULDBLOCK. In the former case, the call blocks until an event
 becomes available. The standard Linux poll() and/or select() system calls can
 be used with the device file descriptor to watch for new events. For select(),
 the file descriptor should be included in the exceptfds argument, and for
 poll(), POLLPRI should be specified as the wake-up condition. Read-only
 permissions are sufficient for this ioctl call.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p> int ioctl(fd, int request = VIDEO_GET_EVENT, struct
 video_event &#8902;ev);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals VIDEO_GET_EVENT for this command.</p>
</td></tr><tr><td align="char">
<p>struct video_event
 *ev</p>
</td><td align="char">
<p>Points to the location where the event, if any, is to be
 stored.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>EWOULDBLOCK</p>
</td><td align="char">
<p>There is no event pending, and the device is in
 non-blocking mode.</p>
</td></tr><tr><td align="char">
<p>EOVERFLOW</p>
</td><td align="char">
<p>Overflow in event queue - one or more events were lost.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="VIDEO_COMMAND"></a>VIDEO_COMMAND</h3></div></div></div><p>DESCRIPTION
</p><p>This ioctl is obsolete. Do not use in new drivers. For V4L2 decoders this
ioctl has been replaced by the <a class="link" href="media.html#vidioc-decoder-cmd" title="ioctl VIDIOC_DECODER_CMD, VIDIOC_TRY_DECODER_CMD"><code class="constant">VIDIOC_DECODER_CMD</code></a> ioctl.</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl commands the decoder. The <code class="constant">video_command</code> struct
is a subset of the <code class="constant">v4l2_decoder_cmd</code> struct, so refer to the
<a class="link" href="media.html#vidioc-decoder-cmd" title="ioctl VIDIOC_DECODER_CMD, VIDIOC_TRY_DECODER_CMD"><code class="constant">VIDIOC_DECODER_CMD</code></a> documentation for more information.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request =
 VIDEO_COMMAND, struct video_command *cmd);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals VIDEO_COMMAND for this
 command.</p>
</td></tr><tr><td align="char">
<p>struct video_command *cmd
</p>
</td><td align="char">
<p>Commands the decoder.
</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="VIDEO_TRY_COMMAND"></a>VIDEO_TRY_COMMAND</h3></div></div></div><p>DESCRIPTION
</p><p>This ioctl is obsolete. Do not use in new drivers. For V4L2 decoders this
ioctl has been replaced by the <a class="link" href="media.html#vidioc-decoder-cmd" title="ioctl VIDIOC_DECODER_CMD, VIDIOC_TRY_DECODER_CMD"><code class="constant">VIDIOC_TRY_DECODER_CMD</code></a> ioctl.</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl tries a decoder command. The <code class="constant">video_command</code> struct
is a subset of the <code class="constant">v4l2_decoder_cmd</code> struct, so refer to the
<a class="link" href="media.html#vidioc-decoder-cmd" title="ioctl VIDIOC_DECODER_CMD, VIDIOC_TRY_DECODER_CMD"><code class="constant">VIDIOC_TRY_DECODER_CMD</code></a> documentation for more information.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request =
 VIDEO_TRY_COMMAND, struct video_command *cmd);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals VIDEO_TRY_COMMAND for this
 command.</p>
</td></tr><tr><td align="char">
<p>struct video_command *cmd
</p>
</td><td align="char">
<p>Try a decoder command.
</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="VIDEO_GET_SIZE"></a>VIDEO_GET_SIZE</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl returns the size and aspect ratio.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request =
 VIDEO_GET_SIZE, video_size_t *size);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals VIDEO_GET_SIZE for this
 command.</p>
</td></tr><tr><td align="char">
<p>video_size_t *size
</p>
</td><td align="char">
<p>Returns the size and aspect ratio.
</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="VIDEO_SET_DISPLAY_FORMAT"></a>VIDEO_SET_DISPLAY_FORMAT</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call asks the Video Device to select the video format to be applied
 by the MPEG chip on the video.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p> int ioctl(fd, int request =
 VIDEO_SET_DISPLAY_FORMAT, video_display_format_t
 format);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals VIDEO_SET_DISPLAY_FORMAT for this
 command.</p>
</td></tr><tr><td align="char">
<p>video_display_format_t
 format</p>
</td><td align="char">
<p>Selects the video format to be used.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="VIDEO_STILLPICTURE"></a>VIDEO_STILLPICTURE</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call asks the Video Device to display a still picture (I-frame). The
 input data shall contain an I-frame. If the pointer is NULL, then the current
 displayed still picture is blanked.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(fd, int request = VIDEO_STILLPICTURE,
 struct video_still_picture &#8902;sp);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals VIDEO_STILLPICTURE for this command.</p>
</td></tr><tr><td align="char">
<p>struct
 video_still_picture
 *sp</p>
</td><td align="char">
<p>Pointer to a location where an I-frame and size is stored.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="VIDEO_FAST_FORWARD"></a>VIDEO_FAST_FORWARD</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call asks the Video Device to skip decoding of N number of I-frames.
 This call can only be used if VIDEO_SOURCE_MEMORY is selected.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(fd, int request = VIDEO_FAST_FORWARD, int
 nFrames);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals VIDEO_FAST_FORWARD for this command.</p>
</td></tr><tr><td align="char">
<p>int nFrames</p>
</td><td align="char">
<p>The number of frames to skip.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>EPERM</p>
</td><td align="char">
<p>Mode VIDEO_SOURCE_MEMORY not selected.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="VIDEO_SLOWMOTION"></a>VIDEO_SLOWMOTION</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call asks the video device to repeat decoding frames N number of
 times. This call can only be used if VIDEO_SOURCE_MEMORY is selected.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(fd, int request = VIDEO_SLOWMOTION, int
 nFrames);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals VIDEO_SLOWMOTION for this command.</p>
</td></tr><tr><td align="char">
<p>int nFrames</p>
</td><td align="char">
<p>The number of times to repeat each frame.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>EPERM</p>
</td><td align="char">
<p>Mode VIDEO_SOURCE_MEMORY not selected.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="VIDEO_GET_CAPABILITIES"></a>VIDEO_GET_CAPABILITIES</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call asks the video device about its decoding capabilities. On success
 it returns and integer which has bits set according to the defines in section ??.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(fd, int request = VIDEO_GET_CAPABILITIES,
 unsigned int &#8902;cap);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals VIDEO_GET_CAPABILITIES for this
 command.</p>
</td></tr><tr><td align="char">
<p>unsigned int *cap</p>
</td><td align="char">
<p>Pointer to a location where to store the capability
 information.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="VIDEO_SET_ID"></a>VIDEO_SET_ID</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl selects which sub-stream is to be decoded if a program or system
 stream is sent to the video device.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request = VIDEO_SET_ID, int
 id);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals VIDEO_SET_ID for this command.</p>
</td></tr><tr><td align="char">
<p>int id</p>
</td><td align="char">
<p>video sub-stream id</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>EINVAL</p>
</td><td align="char">
<p>Invalid sub-stream id.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="VIDEO_CLEAR_BUFFER"></a>VIDEO_CLEAR_BUFFER</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call clears all video buffers in the driver and in the decoder hardware.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(fd, int request = VIDEO_CLEAR_BUFFER);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals VIDEO_CLEAR_BUFFER for this command.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="VIDEO_SET_STREAMTYPE"></a>VIDEO_SET_STREAMTYPE</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl tells the driver which kind of stream to expect being written to it. If
 this call is not used the default of video PES is used. Some drivers might not
 support this call and always expect PES.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(fd, int request = VIDEO_SET_STREAMTYPE,
 int type);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals VIDEO_SET_STREAMTYPE for this command.</p>
</td></tr><tr><td align="char">
<p>int type</p>
</td><td align="char">
<p>stream type</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="VIDEO_SET_FORMAT"></a>VIDEO_SET_FORMAT</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl sets the screen format (aspect ratio) of the connected output device
 (TV) so that the output of the decoder can be adjusted accordingly.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p> int ioctl(fd, int request = VIDEO_SET_FORMAT,
 video_format_t format);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals VIDEO_SET_FORMAT for this command.</p>
</td></tr><tr><td align="char">
<p>video_format_t
 format</p>
</td><td align="char">
<p>video format of TV as defined in section ??.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>EINVAL</p>
</td><td align="char">
<p>format is not a valid video format.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="VIDEO_SET_SYSTEM"></a>VIDEO_SET_SYSTEM</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl sets the television output format. The format (see section ??) may
 vary from the color format of the displayed MPEG stream. If the hardware is
 not able to display the requested format the call will return an error.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p> int ioctl(fd, int request = VIDEO_SET_SYSTEM ,
 video_system_t system);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals VIDEO_SET_FORMAT for this command.</p>
</td></tr><tr><td align="char">
<p>video_system_t
 system</p>
</td><td align="char">
<p>video system of TV output.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>EINVAL</p>
</td><td align="char">
<p>system is not a valid or supported video system.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="VIDEO_SET_HIGHLIGHT"></a>VIDEO_SET_HIGHLIGHT</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl sets the SPU highlight information for the menu access of a DVD.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p> int ioctl(fd, int request = VIDEO_SET_HIGHLIGHT
 ,video_highlight_t &#8902;vhilite)</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals VIDEO_SET_HIGHLIGHT for this command.</p>
</td></tr><tr><td align="char">
<p>video_highlight_t
 *vhilite</p>
</td><td align="char">
<p>SPU Highlight information according to section ??.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="VIDEO_SET_SPU"></a>VIDEO_SET_SPU</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl activates or deactivates SPU decoding in a DVD input stream. It can
 only be used, if the driver is able to handle a DVD stream.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p> int ioctl(fd, int request = VIDEO_SET_SPU ,
 video_spu_t &#8902;spu)</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals VIDEO_SET_SPU for this command.</p>
</td></tr><tr><td align="char">
<p>video_spu_t *spu</p>
</td><td align="char">
<p>SPU decoding (de)activation and subid setting according
 to section ??.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>EINVAL</p>
</td><td align="char">
<p>input is not a valid spu setting or driver cannot handle
 SPU.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="VIDEO_SET_SPU_PALETTE"></a>VIDEO_SET_SPU_PALETTE</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl sets the SPU color palette.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p> int ioctl(fd, int request = VIDEO_SET_SPU_PALETTE
 ,video_spu_palette_t &#8902;palette )</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals VIDEO_SET_SPU_PALETTE for this command.</p>
</td></tr><tr><td align="char">
<p>video_spu_palette_t
 *palette</p>
</td><td align="char">
<p>SPU palette according to section ??.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>EINVAL</p>
</td><td align="char">
<p>input is not a valid palette or driver doesn&#8217;t handle SPU.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="VIDEO_GET_NAVI"></a>VIDEO_GET_NAVI</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl returns navigational information from the DVD stream. This is
 especially needed if an encoded stream has to be decoded by the hardware.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p> int ioctl(fd, int request = VIDEO_GET_NAVI ,
 video_navi_pack_t &#8902;navipack)</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals VIDEO_GET_NAVI for this command.</p>
</td></tr><tr><td align="char">
<p>video_navi_pack_t
 *navipack</p>
</td><td align="char">
<p>PCI or DSI pack (private stream 2) according to section
 ??.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>EFAULT</p>
</td><td align="char">
<p>driver is not able to return navigational information</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="VIDEO_SET_ATTRIBUTES"></a>VIDEO_SET_ATTRIBUTES</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl is intended for DVD playback and allows you to set certain
 information about the stream. Some hardware may not need this information,
 but the call also tells the hardware to prepare for DVD playback.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p> int ioctl(fd, int request = VIDEO_SET_ATTRIBUTE
 ,video_attributes_t vattr)</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals VIDEO_SET_ATTRIBUTE for this command.</p>
</td></tr><tr><td align="char">
<p>video_attributes_t
 vattr</p>
</td><td align="char">
<p>video attributes according to section ??.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>EINVAL</p>
</td><td align="char">
<p>input is not a valid attribute setting.</p>
</td></tr></tbody></table></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="dvb_audio"></a>Chapter 12. DVB Audio Device</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="media.html#audio_data_types">Audio Data Types</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#audio-stream-source-t">audio_stream_source_t</a></span></dt><dt><span class="section"><a href="media.html#audio-play-state-t">audio_play_state_t</a></span></dt><dt><span class="section"><a href="media.html#audio-channel-select-t">audio_channel_select_t</a></span></dt><dt><span class="section"><a href="media.html#audio-status">struct audio_status</a></span></dt><dt><span class="section"><a href="media.html#audio-mixer">struct audio_mixer</a></span></dt><dt><span class="section"><a href="media.html#audio_encodings">audio encodings</a></span></dt><dt><span class="section"><a href="media.html#audio-karaoke">struct audio_karaoke</a></span></dt><dt><span class="section"><a href="media.html#audio-attributes-t">audio attributes</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#audio_function_calls">Audio Function Calls</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#audio_fopen">open()</a></span></dt><dt><span class="section"><a href="media.html#audio_fclose">close()</a></span></dt><dt><span class="section"><a href="media.html#audio_fwrite">write()</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_STOP">AUDIO_STOP</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_PLAY">AUDIO_PLAY</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_PAUSE">AUDIO_PAUSE</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_CONTINUE">AUDIO_CONTINUE</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SELECT_SOURCE">AUDIO_SELECT_SOURCE</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_MUTE">AUDIO_SET_MUTE</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_AV_SYNC">AUDIO_SET_AV_SYNC</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_BYPASS_MODE">AUDIO_SET_BYPASS_MODE</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_CHANNEL_SELECT">AUDIO_CHANNEL_SELECT</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_BILINGUAL_CHANNEL_SELECT">AUDIO_BILINGUAL_CHANNEL_SELECT</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_GET_PTS">AUDIO_GET_PTS</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_GET_STATUS">AUDIO_GET_STATUS</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_GET_CAPABILITIES">AUDIO_GET_CAPABILITIES</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_CLEAR_BUFFER">AUDIO_CLEAR_BUFFER</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_ID">AUDIO_SET_ID</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_MIXER">AUDIO_SET_MIXER</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_STREAMTYPE">AUDIO_SET_STREAMTYPE</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_EXT_ID">AUDIO_SET_EXT_ID</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_ATTRIBUTES">AUDIO_SET_ATTRIBUTES</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_KARAOKE">AUDIO_SET_KARAOKE</a></span></dt></dl></dd></dl></div><p>The DVB audio device controls the MPEG2 audio decoder of the DVB hardware. It
can be accessed through <span class="tt">/dev/dvb/adapter0/audio0</span>. Data types and and
ioctl definitions can be accessed by including <span class="tt">linux/dvb/audio.h</span> in your
application.
</p><p>Please note that some DVB cards don&#8217;t have their own MPEG decoder, which results in
the omission of the audio and video device.
</p><p>
These ioctls were also used by V4L2 to control MPEG decoders implemented in V4L2. The use
of these ioctls for that purpose has been made obsolete and proper V4L2 ioctls or controls
have been created to replace that functionality.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="audio_data_types"></a>Audio Data Types</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#audio-stream-source-t">audio_stream_source_t</a></span></dt><dt><span class="section"><a href="media.html#audio-play-state-t">audio_play_state_t</a></span></dt><dt><span class="section"><a href="media.html#audio-channel-select-t">audio_channel_select_t</a></span></dt><dt><span class="section"><a href="media.html#audio-status">struct audio_status</a></span></dt><dt><span class="section"><a href="media.html#audio-mixer">struct audio_mixer</a></span></dt><dt><span class="section"><a href="media.html#audio_encodings">audio encodings</a></span></dt><dt><span class="section"><a href="media.html#audio-karaoke">struct audio_karaoke</a></span></dt><dt><span class="section"><a href="media.html#audio-attributes-t">audio attributes</a></span></dt></dl></div><p>This section describes the structures, data types and defines used when talking to the
audio device.
</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="audio-stream-source-t"></a>audio_stream_source_t</h3></div></div></div><p>The audio stream source is set through the AUDIO_SELECT_SOURCE call and can take
the following values, depending on whether we are replaying from an internal (demux) or
external (user write) source.
</p><pre class="programlisting">
typedef enum {
	AUDIO_SOURCE_DEMUX,
	AUDIO_SOURCE_MEMORY
} audio_stream_source_t;
</pre><p>AUDIO_SOURCE_DEMUX selects the demultiplexer (fed either by the frontend or the
DVR device) as the source of the video stream. If AUDIO_SOURCE_MEMORY
is selected the stream comes from the application through the <span class="tt">write()</span> system
call.
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="audio-play-state-t"></a>audio_play_state_t</h3></div></div></div><p>The following values can be returned by the AUDIO_GET_STATUS call representing the
state of audio playback.
</p><pre class="programlisting">
typedef enum {
	AUDIO_STOPPED,
	AUDIO_PLAYING,
	AUDIO_PAUSED
} audio_play_state_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="audio-channel-select-t"></a>audio_channel_select_t</h3></div></div></div><p>The audio channel selected via AUDIO_CHANNEL_SELECT is determined by the
following values.
</p><pre class="programlisting">
typedef enum {
	AUDIO_STEREO,
	AUDIO_MONO_LEFT,
	AUDIO_MONO_RIGHT,
	AUDIO_MONO,
	AUDIO_STEREO_SWAPPED
} audio_channel_select_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="audio-status"></a>struct audio_status</h3></div></div></div><p>The AUDIO_GET_STATUS call returns the following structure informing about various
states of the playback operation.
</p><pre class="programlisting">
typedef struct audio_status {
	boolean AV_sync_state;
	boolean mute_state;
	audio_play_state_t play_state;
	audio_stream_source_t stream_source;
	audio_channel_select_t channel_select;
	boolean bypass_mode;
	audio_mixer_t mixer_state;
} audio_status_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="audio-mixer"></a>struct audio_mixer</h3></div></div></div><p>The following structure is used by the AUDIO_SET_MIXER call to set the audio
volume.
</p><pre class="programlisting">
typedef struct audio_mixer {
	unsigned int volume_left;
	unsigned int volume_right;
} audio_mixer_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="audio_encodings"></a>audio encodings</h3></div></div></div><p>A call to AUDIO_GET_CAPABILITIES returns an unsigned integer with the following
bits set according to the hardwares capabilities.
</p><pre class="programlisting">
 #define AUDIO_CAP_DTS    1
 #define AUDIO_CAP_LPCM   2
 #define AUDIO_CAP_MP1    4
 #define AUDIO_CAP_MP2    8
 #define AUDIO_CAP_MP3   16
 #define AUDIO_CAP_AAC   32
 #define AUDIO_CAP_OGG   64
 #define AUDIO_CAP_SDDS 128
 #define AUDIO_CAP_AC3  256
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="audio-karaoke"></a>struct audio_karaoke</h3></div></div></div><p>The ioctl AUDIO_SET_KARAOKE uses the following format:
</p><pre class="programlisting">
typedef
struct audio_karaoke {
	int vocal1;
	int vocal2;
	int melody;
} audio_karaoke_t;
</pre><p>If Vocal1 or Vocal2 are non-zero, they get mixed into left and right t at 70% each. If both,
Vocal1 and Vocal2 are non-zero, Vocal1 gets mixed into the left channel and Vocal2 into the
right channel at 100% each. Ff Melody is non-zero, the melody channel gets mixed into left
and right.
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="audio-attributes-t"></a>audio attributes</h3></div></div></div><p>The following attributes can be set by a call to AUDIO_SET_ATTRIBUTES:
</p><pre class="programlisting">
 typedef uint16_t audio_attributes_t;
 /&#8902;   bits: descr. &#8902;/
 /&#8902;   15-13 audio coding mode (0=ac3, 2=mpeg1, 3=mpeg2ext, 4=LPCM, 6=DTS, &#8902;/
 /&#8902;   12    multichannel extension &#8902;/
 /&#8902;   11-10 audio type (0=not spec, 1=language included) &#8902;/
 /&#8902;    9- 8 audio application mode (0=not spec, 1=karaoke, 2=surround) &#8902;/
 /&#8902;    7- 6 Quantization / DRC (mpeg audio: 1=DRC exists)(lpcm: 0=16bit,  &#8902;/
 /&#8902;    5- 4 Sample frequency fs (0=48kHz, 1=96kHz) &#8902;/
 /&#8902;    2- 0 number of audio channels (n+1 channels) &#8902;/
</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="audio_function_calls"></a>Audio Function Calls</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#audio_fopen">open()</a></span></dt><dt><span class="section"><a href="media.html#audio_fclose">close()</a></span></dt><dt><span class="section"><a href="media.html#audio_fwrite">write()</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_STOP">AUDIO_STOP</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_PLAY">AUDIO_PLAY</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_PAUSE">AUDIO_PAUSE</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_CONTINUE">AUDIO_CONTINUE</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SELECT_SOURCE">AUDIO_SELECT_SOURCE</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_MUTE">AUDIO_SET_MUTE</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_AV_SYNC">AUDIO_SET_AV_SYNC</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_BYPASS_MODE">AUDIO_SET_BYPASS_MODE</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_CHANNEL_SELECT">AUDIO_CHANNEL_SELECT</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_BILINGUAL_CHANNEL_SELECT">AUDIO_BILINGUAL_CHANNEL_SELECT</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_GET_PTS">AUDIO_GET_PTS</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_GET_STATUS">AUDIO_GET_STATUS</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_GET_CAPABILITIES">AUDIO_GET_CAPABILITIES</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_CLEAR_BUFFER">AUDIO_CLEAR_BUFFER</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_ID">AUDIO_SET_ID</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_MIXER">AUDIO_SET_MIXER</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_STREAMTYPE">AUDIO_SET_STREAMTYPE</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_EXT_ID">AUDIO_SET_EXT_ID</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_ATTRIBUTES">AUDIO_SET_ATTRIBUTES</a></span></dt><dt><span class="section"><a href="media.html#AUDIO_SET_KARAOKE">AUDIO_SET_KARAOKE</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="audio_fopen"></a>open()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This system call opens a named audio device (e.g. /dev/dvb/adapter0/audio0)
 for subsequent use. When an open() call has succeeded, the device will be ready
 for use. The significance of blocking or non-blocking mode is described in the
 documentation for functions where there is a difference. It does not affect the
 semantics of the open() call itself. A device opened in blocking mode can later
 be put into non-blocking mode (and vice versa) using the F_SETFL command
 of the fcntl system call. This is a standard system call, documented in the Linux
 manual page for fcntl. Only one user can open the Audio Device in O_RDWR
 mode. All other attempts to open the device in this mode will fail, and an error
 code will be returned. If the Audio Device is opened in O_RDONLY mode, the
 only ioctl call that can be used is AUDIO_GET_STATUS. All other call will
 return with an error code.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int open(const char &#8902;deviceName, int flags);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>const char
 *deviceName</p>
</td><td align="char">
<p>Name of specific audio device.</p>
</td></tr><tr><td align="char">
<p>int flags</p>
</td><td align="char">
<p>A bit-wise OR of the following flags:</p>
</td></tr><tr><td align="char">
</td><td align="char">
<p>O_RDONLY read-only access</p>
</td></tr><tr><td align="char">
</td><td align="char">
<p>O_RDWR read/write access</p>
</td></tr><tr><td align="char">
</td><td align="char">
<p>O_NONBLOCK open in non-blocking mode</p>
</td></tr><tr><td align="char">
</td><td align="char">
<p>(blocking mode is the default)</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>ENODEV</p>
</td><td align="char">
<p>Device driver not loaded/available.</p>
</td></tr><tr><td align="char">
<p>EBUSY</p>
</td><td align="char">
<p>Device or resource busy.</p>
</td></tr><tr><td align="char">
<p>EINVAL</p>
</td><td align="char">
<p>Invalid argument.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="audio_fclose"></a>close()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This system call closes a previously opened audio device.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int close(int fd);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>EBADF</p>
</td><td align="char">
<p>fd is not a valid open file descriptor.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="audio_fwrite"></a>write()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This system call can only be used if AUDIO_SOURCE_MEMORY is selected
 in the ioctl call AUDIO_SELECT_SOURCE. The data provided shall be in
 PES format. If O_NONBLOCK is not specified the function will block until
 buffer space is available. The amount of data to be transferred is implied by
 count.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>size_t write(int fd, const void &#8902;buf, size_t count);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>void *buf</p>
</td><td align="char">
<p>Pointer to the buffer containing the PES data.</p>
</td></tr><tr><td align="char">
<p>size_t count</p>
</td><td align="char">
<p>Size of buf.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>EPERM</p>
</td><td align="char">
<p>Mode AUDIO_SOURCE_MEMORY not selected.</p>
</td></tr><tr><td align="char">
<p>ENOMEM</p>
</td><td align="char">
<p>Attempted to write more data than the internal buffer can
 hold.</p>
</td></tr><tr><td align="char">
<p>EBADF</p>
</td><td align="char">
<p>fd is not a valid open file descriptor.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="AUDIO_STOP"></a>AUDIO_STOP</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call asks the Audio Device to stop playing the current stream.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request = AUDIO_STOP);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals AUDIO_STOP for this command.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="AUDIO_PLAY"></a>AUDIO_PLAY</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call asks the Audio Device to start playing an audio stream from the
 selected source.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request = AUDIO_PLAY);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals AUDIO_PLAY for this command.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="AUDIO_PAUSE"></a>AUDIO_PAUSE</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call suspends the audio stream being played. Decoding and playing
 are paused. It is then possible to restart again decoding and playing process of
 the audio stream using AUDIO_CONTINUE command.</p>
</td></tr><tr><td align="char">
<p>If AUDIO_SOURCE_MEMORY is selected in the ioctl call
 AUDIO_SELECT_SOURCE, the DVB-subsystem will not decode (consume)
 any more data until the ioctl call AUDIO_CONTINUE or AUDIO_PLAY is
 performed.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request = AUDIO_PAUSE);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals AUDIO_PAUSE for this command.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="AUDIO_CONTINUE"></a>AUDIO_CONTINUE</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl restarts the decoding and playing process previously paused
with AUDIO_PAUSE command.</p>
</td></tr><tr><td align="char">
<p>It only works if the stream were previously stopped with AUDIO_PAUSE</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request = AUDIO_CONTINUE);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals AUDIO_CONTINUE for this command.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="AUDIO_SELECT_SOURCE"></a>AUDIO_SELECT_SOURCE</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call informs the audio device which source shall be used
 for the input data. The possible sources are demux or memory. If
 AUDIO_SOURCE_MEMORY is selected, the data is fed to the Audio Device
 through the write command.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request = AUDIO_SELECT_SOURCE,
 audio_stream_source_t source);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals AUDIO_SELECT_SOURCE for this command.</p>
</td></tr><tr><td align="char">
<p>audio_stream_source_t
 source</p>
</td><td align="char">
<p>Indicates the source that shall be used for the Audio
 stream.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="AUDIO_SET_MUTE"></a>AUDIO_SET_MUTE</h3></div></div></div><p>DESCRIPTION
</p><p>This ioctl is for DVB devices only. To control a V4L2 decoder use the V4L2
<a class="link" href="media.html#vidioc-decoder-cmd" title="ioctl VIDIOC_DECODER_CMD, VIDIOC_TRY_DECODER_CMD"><code class="constant">VIDIOC_DECODER_CMD</code></a> with the <code class="constant">V4L2_DEC_CMD_START_MUTE_AUDIO</code> flag instead.</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call asks the audio device to mute the stream that is currently being
 played.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request = AUDIO_SET_MUTE,
 boolean state);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals AUDIO_SET_MUTE for this command.</p>
</td></tr><tr><td align="char">
<p>boolean state</p>
</td><td align="char">
<p>Indicates if audio device shall mute or not.</p>
</td></tr><tr><td align="char">
</td><td align="char">
<p>TRUE Audio Mute</p>
</td></tr><tr><td align="char">
</td><td align="char">
<p>FALSE Audio Un-mute</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="AUDIO_SET_AV_SYNC"></a>AUDIO_SET_AV_SYNC</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call asks the Audio Device to turn ON or OFF A/V synchronization.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request = AUDIO_SET_AV_SYNC,
 boolean state);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals AUDIO_AV_SYNC for this command.</p>
</td></tr><tr><td align="char">
<p>boolean state</p>
</td><td align="char">
<p>Tells the DVB subsystem if A/V synchronization shall be
 ON or OFF.</p>
</td></tr><tr><td align="char">
</td><td align="char">
<p>TRUE AV-sync ON</p>
</td></tr><tr><td align="char">
</td><td align="char">
<p>FALSE AV-sync OFF</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="AUDIO_SET_BYPASS_MODE"></a>AUDIO_SET_BYPASS_MODE</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call asks the Audio Device to bypass the Audio decoder and forward
 the stream without decoding. This mode shall be used if streams that can&#8217;t be
 handled by the DVB system shall be decoded. Dolby DigitalTM streams are
 automatically forwarded by the DVB subsystem if the hardware can handle it.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request =
 AUDIO_SET_BYPASS_MODE, boolean mode);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals AUDIO_SET_BYPASS_MODE for this
 command.</p>
</td></tr><tr><td align="char">
<p>boolean mode</p>
</td><td align="char">
<p>Enables or disables the decoding of the current Audio
 stream in the DVB subsystem.</p>
</td></tr><tr><td align="char">
</td><td align="char">
<p>TRUE Bypass is disabled</p>
</td></tr><tr><td align="char">
</td><td align="char">
<p>FALSE Bypass is enabled</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="AUDIO_CHANNEL_SELECT"></a>AUDIO_CHANNEL_SELECT</h3></div></div></div><p>DESCRIPTION
</p><p>This ioctl is for DVB devices only. To control a V4L2 decoder use the V4L2
<code class="constant">V4L2_CID_MPEG_AUDIO_DEC_PLAYBACK</code> control instead.</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call asks the Audio Device to select the requested channel if possible.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request =
 AUDIO_CHANNEL_SELECT, audio_channel_select_t);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals AUDIO_CHANNEL_SELECT for this
 command.</p>
</td></tr><tr><td align="char">
<p>audio_channel_select_t
 ch</p>
</td><td align="char">
<p>Select the output format of the audio (mono left/right,
 stereo).</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="AUDIO_BILINGUAL_CHANNEL_SELECT"></a>AUDIO_BILINGUAL_CHANNEL_SELECT</h3></div></div></div><p>DESCRIPTION
</p><p>This ioctl is obsolete. Do not use in new drivers. It has been replaced by
the V4L2 <code class="constant">V4L2_CID_MPEG_AUDIO_DEC_MULTILINGUAL_PLAYBACK</code> control
for MPEG decoders controlled through V4L2.</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call asks the Audio Device to select the requested channel for bilingual streams if possible.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request =
 AUDIO_BILINGUAL_CHANNEL_SELECT, audio_channel_select_t);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals AUDIO_BILINGUAL_CHANNEL_SELECT for this
 command.</p>
</td></tr><tr><td align="char">
<p>audio_channel_select_t
ch</p>
</td><td align="char">
<p>Select the output format of the audio (mono left/right,
 stereo).</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="AUDIO_GET_PTS"></a>AUDIO_GET_PTS</h3></div></div></div><p>DESCRIPTION
</p><p>This ioctl is obsolete. Do not use in new drivers. If you need this functionality,
then please contact the linux-media mailing list (<a class="ulink" href="http://www.linuxtv.org/lists.php" target="_top">http://www.linuxtv.org/lists.php</a>).</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call asks the Audio Device to return the current PTS timestamp.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request =
 AUDIO_GET_PTS, __u64 *pts);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals AUDIO_GET_PTS for this
 command.</p>
</td></tr><tr><td align="char">
<p>__u64 *pts
</p>
</td><td align="char">
<p>Returns the 33-bit timestamp as defined in ITU T-REC-H.222.0 / ISO/IEC 13818-1.
</p>
<p>
The PTS should belong to the currently played
frame if possible, but may also be a value close to it
like the PTS of the last decoded frame or the last PTS
extracted by the PES parser.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="AUDIO_GET_STATUS"></a>AUDIO_GET_STATUS</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call asks the Audio Device to return the current state of the Audio
 Device.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request = AUDIO_GET_STATUS,
 struct audio_status &#8902;status);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals AUDIO_GET_STATUS for this command.</p>
</td></tr><tr><td align="char">
<p>struct audio_status
 *status</p>
</td><td align="char">
<p>Returns the current state of Audio Device.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="AUDIO_GET_CAPABILITIES"></a>AUDIO_GET_CAPABILITIES</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call asks the Audio Device to tell us about the decoding capabilities
 of the audio hardware.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request =
 AUDIO_GET_CAPABILITIES, unsigned int &#8902;cap);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals AUDIO_GET_CAPABILITIES for this
 command.</p>
</td></tr><tr><td align="char">
<p>unsigned int *cap</p>
</td><td align="char">
<p>Returns a bit array of supported sound formats.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="AUDIO_CLEAR_BUFFER"></a>AUDIO_CLEAR_BUFFER</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl call asks the Audio Device to clear all software and hardware buffers
 of the audio decoder device.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request = AUDIO_CLEAR_BUFFER);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals AUDIO_CLEAR_BUFFER for this command.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="AUDIO_SET_ID"></a>AUDIO_SET_ID</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl selects which sub-stream is to be decoded if a program or system
 stream is sent to the video device. If no audio stream type is set the id has to be
 in [0xC0,0xDF] for MPEG sound, in [0x80,0x87] for AC3 and in [0xA0,0xA7]
 for LPCM. More specifications may follow for other stream types. If the stream
 type is set the id just specifies the substream id of the audio stream and only
 the first 5 bits are recognized.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request = AUDIO_SET_ID, int
 id);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals AUDIO_SET_ID for this command.</p>
</td></tr><tr><td align="char">
<p>int id</p>
</td><td align="char">
<p>audio sub-stream id</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="AUDIO_SET_MIXER"></a>AUDIO_SET_MIXER</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl lets you adjust the mixer settings of the audio decoder.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(int fd, int request = AUDIO_SET_MIXER,
 audio_mixer_t &#8902;mix);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals AUDIO_SET_ID for this command.</p>
</td></tr><tr><td align="char">
<p>audio_mixer_t *mix</p>
</td><td align="char">
<p>mixer settings.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="AUDIO_SET_STREAMTYPE"></a>AUDIO_SET_STREAMTYPE</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl tells the driver which kind of audio stream to expect. This is useful
 if the stream offers several audio sub-streams like LPCM and AC3.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(fd, int request = AUDIO_SET_STREAMTYPE,
 int type);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals AUDIO_SET_STREAMTYPE for this
 command.</p>
</td></tr><tr><td align="char">
<p>int type</p>
</td><td align="char">
<p>stream type</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>EINVAL</p>
</td><td align="char">
<p>type is not a valid or supported stream type.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="AUDIO_SET_EXT_ID"></a>AUDIO_SET_EXT_ID</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl can be used to set the extension id for MPEG streams in DVD
 playback. Only the first 3 bits are recognized.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(fd, int request = AUDIO_SET_EXT_ID, int
 id);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals AUDIO_SET_EXT_ID for this command.</p>
</td></tr><tr><td align="char">
<p>int id</p>
</td><td align="char">
<p>audio sub_stream_id</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>EINVAL</p>
</td><td align="char">
<p>id is not a valid id.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="AUDIO_SET_ATTRIBUTES"></a>AUDIO_SET_ATTRIBUTES</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl is intended for DVD playback and allows you to set certain
 information about the audio stream.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(fd, int request = AUDIO_SET_ATTRIBUTES,
 audio_attributes_t attr );</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals AUDIO_SET_ATTRIBUTES for this command.</p>
</td></tr><tr><td align="char">
<p>audio_attributes_t
 attr</p>
</td><td align="char">
<p>audio attributes according to section ??</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>EINVAL</p>
</td><td align="char">
<p>attr is not a valid or supported attribute setting.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="AUDIO_SET_KARAOKE"></a>AUDIO_SET_KARAOKE</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl allows one to set the mixer settings for a karaoke DVD.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(fd, int request = AUDIO_SET_KARAOKE,
 audio_karaoke_t &#8902;karaoke);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals AUDIO_SET_KARAOKE for this
 command.</p>
</td></tr><tr><td align="char">
<p>audio_karaoke_t
 *karaoke</p>
</td><td align="char">
<p>karaoke settings according to section ??.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>EINVAL</p>
</td><td align="char">
<p>karaoke is not a valid or supported karaoke setting.</p>
</td></tr></tbody></table></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="dvb_ca"></a>Chapter 13. DVB CA Device</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="media.html#ca_data_types">CA Data Types</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#ca-slot-info">ca_slot_info_t</a></span></dt><dt><span class="section"><a href="media.html#ca-descr-info">ca_descr_info_t</a></span></dt><dt><span class="section"><a href="media.html#ca-caps">ca_caps_t</a></span></dt><dt><span class="section"><a href="media.html#ca-msg">ca_msg_t</a></span></dt><dt><span class="section"><a href="media.html#ca-descr">ca_descr_t</a></span></dt><dt><span class="section"><a href="media.html#ca-pid">ca-pid</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#ca_function_calls">CA Function Calls</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#ca_fopen">open()</a></span></dt><dt><span class="section"><a href="media.html#ca_fclose">close()</a></span></dt><dt><span class="section"><a href="media.html#CA_RESET">CA_RESET</a></span></dt><dt><span class="section"><a href="media.html#CA_GET_CAP">CA_GET_CAP</a></span></dt><dt><span class="section"><a href="media.html#CA_GET_SLOT_INFO">CA_GET_SLOT_INFO</a></span></dt><dt><span class="section"><a href="media.html#CA_GET_DESCR_INFO">CA_GET_DESCR_INFO</a></span></dt><dt><span class="section"><a href="media.html#CA_GET_MSG">CA_GET_MSG</a></span></dt><dt><span class="section"><a href="media.html#CA_SEND_MSG">CA_SEND_MSG</a></span></dt><dt><span class="section"><a href="media.html#CA_SET_DESCR">CA_SET_DESCR</a></span></dt><dt><span class="section"><a href="media.html#CA_SET_PID">CA_SET_PID</a></span></dt></dl></dd></dl></div><p>The DVB CA device controls the conditional access hardware. It can be accessed through
<span class="tt">/dev/dvb/adapter0/ca0</span>. Data types and and ioctl definitions can be accessed by
including <span class="tt">linux/dvb/ca.h</span> in your application.
</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ca_data_types"></a>CA Data Types</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#ca-slot-info">ca_slot_info_t</a></span></dt><dt><span class="section"><a href="media.html#ca-descr-info">ca_descr_info_t</a></span></dt><dt><span class="section"><a href="media.html#ca-caps">ca_caps_t</a></span></dt><dt><span class="section"><a href="media.html#ca-msg">ca_msg_t</a></span></dt><dt><span class="section"><a href="media.html#ca-descr">ca_descr_t</a></span></dt><dt><span class="section"><a href="media.html#ca-pid">ca-pid</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="ca-slot-info"></a>ca_slot_info_t</h3></div></div></div><pre class="programlisting">
typedef struct ca_slot_info {
	int num;               /&#8902; slot number &#8902;/

	int type;              /&#8902; CA interface this slot supports &#8902;/
#define CA_CI            1     /&#8902; CI high level interface &#8902;/
#define CA_CI_LINK       2     /&#8902; CI link layer level interface &#8902;/
#define CA_CI_PHYS       4     /&#8902; CI physical layer level interface &#8902;/
#define CA_DESCR         8     /&#8902; built-in descrambler &#8902;/
#define CA_SC          128     /&#8902; simple smart card interface &#8902;/

	unsigned int flags;
#define CA_CI_MODULE_PRESENT 1 /&#8902; module (or card) inserted &#8902;/
#define CA_CI_MODULE_READY   2
} ca_slot_info_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="ca-descr-info"></a>ca_descr_info_t</h3></div></div></div><pre class="programlisting">
typedef struct ca_descr_info {
	unsigned int num;  /&#8902; number of available descramblers (keys) &#8902;/
	unsigned int type; /&#8902; type of supported scrambling system &#8902;/
#define CA_ECD           1
#define CA_NDS           2
#define CA_DSS           4
} ca_descr_info_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="ca-caps"></a>ca_caps_t</h3></div></div></div><pre class="programlisting">
typedef struct ca_caps {
	unsigned int slot_num;  /&#8902; total number of CA card and module slots &#8902;/
	unsigned int slot_type; /&#8902; OR of all supported types &#8902;/
	unsigned int descr_num; /&#8902; total number of descrambler slots (keys) &#8902;/
	unsigned int descr_type;/&#8902; OR of all supported types &#8902;/
 } ca_cap_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="ca-msg"></a>ca_msg_t</h3></div></div></div><pre class="programlisting">
/&#8902; a message to/from a CI-CAM &#8902;/
typedef struct ca_msg {
	unsigned int index;
	unsigned int type;
	unsigned int length;
	unsigned char msg[256];
} ca_msg_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="ca-descr"></a>ca_descr_t</h3></div></div></div><pre class="programlisting">
typedef struct ca_descr {
	unsigned int index;
	unsigned int parity;
	unsigned char cw[8];
} ca_descr_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="ca-pid"></a>ca-pid</h3></div></div></div><pre class="programlisting">
typedef struct ca_pid {
	unsigned int pid;
	int index;		/&#8902; -1 == disable&#8902;/
} ca_pid_t;
</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ca_function_calls"></a>CA Function Calls</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#ca_fopen">open()</a></span></dt><dt><span class="section"><a href="media.html#ca_fclose">close()</a></span></dt><dt><span class="section"><a href="media.html#CA_RESET">CA_RESET</a></span></dt><dt><span class="section"><a href="media.html#CA_GET_CAP">CA_GET_CAP</a></span></dt><dt><span class="section"><a href="media.html#CA_GET_SLOT_INFO">CA_GET_SLOT_INFO</a></span></dt><dt><span class="section"><a href="media.html#CA_GET_DESCR_INFO">CA_GET_DESCR_INFO</a></span></dt><dt><span class="section"><a href="media.html#CA_GET_MSG">CA_GET_MSG</a></span></dt><dt><span class="section"><a href="media.html#CA_SEND_MSG">CA_SEND_MSG</a></span></dt><dt><span class="section"><a href="media.html#CA_SET_DESCR">CA_SET_DESCR</a></span></dt><dt><span class="section"><a href="media.html#CA_SET_PID">CA_SET_PID</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="ca_fopen"></a>open()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This system call opens a named ca device (e.g. /dev/ost/ca) for subsequent use.</p>
<p>When an open() call has succeeded, the device will be ready for use.
 The significance of blocking or non-blocking mode is described in the
 documentation for functions where there is a difference. It does not affect the
 semantics of the open() call itself. A device opened in blocking mode can later
 be put into non-blocking mode (and vice versa) using the F_SETFL command
 of the fcntl system call. This is a standard system call, documented in the Linux
 manual page for fcntl. Only one user can open the CA Device in O_RDWR
 mode. All other attempts to open the device in this mode will fail, and an error
 code will be returned.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int open(const char &#8902;deviceName, int flags);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>const char
 *deviceName</p>
</td><td align="char">
<p>Name of specific video device.</p>
</td></tr><tr><td align="char">
<p>int flags</p>
</td><td align="char">
<p>A bit-wise OR of the following flags:</p>
</td></tr><tr><td align="char">
</td><td align="char">
<p>O_RDONLY read-only access</p>
</td></tr><tr><td align="char">
</td><td align="char">
<p>O_RDWR read/write access</p>
</td></tr><tr><td align="char">
</td><td align="char">
<p>O_NONBLOCK open in non-blocking mode</p>
</td></tr><tr><td align="char">
</td><td align="char">
<p>(blocking mode is the default)</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>ENODEV</p>
</td><td align="char">
<p>Device driver not loaded/available.</p>
</td></tr><tr><td align="char">
<p>EINTERNAL</p>
</td><td align="char">
<p>Internal error.</p>
</td></tr><tr><td align="char">
<p>EBUSY</p>
</td><td align="char">
<p>Device or resource busy.</p>
</td></tr><tr><td align="char">
<p>EINVAL</p>
</td><td align="char">
<p>Invalid argument.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="ca_fclose"></a>close()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This system call closes a previously opened audio device.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int close(int fd);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>EBADF</p>
</td><td align="char">
<p>fd is not a valid open file descriptor.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="CA_RESET"></a>CA_RESET</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl is undocumented. Documentation is welcome.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(fd, int request = CA_RESET);
</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals CA_RESET for this command.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="CA_GET_CAP"></a>CA_GET_CAP</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl is undocumented. Documentation is welcome.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(fd, int request = CA_GET_CAP,
 ca_caps_t *);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals CA_GET_CAP for this command.</p>
</td></tr><tr><td align="char">
<p>ca_caps_t *
</p>
</td><td align="char">
<p>Undocumented.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="CA_GET_SLOT_INFO"></a>CA_GET_SLOT_INFO</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl is undocumented. Documentation is welcome.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(fd, int request = CA_GET_SLOT_INFO,
 ca_slot_info_t *);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals CA_GET_SLOT_INFO for this command.</p>
</td></tr><tr><td align="char">
<p>ca_slot_info_t *
</p>
</td><td align="char">
<p>Undocumented.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="CA_GET_DESCR_INFO"></a>CA_GET_DESCR_INFO</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl is undocumented. Documentation is welcome.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(fd, int request = CA_GET_DESCR_INFO,
 ca_descr_info_t *);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals CA_GET_DESCR_INFO for this command.</p>
</td></tr><tr><td align="char">
<p>ca_descr_info_t *
</p>
</td><td align="char">
<p>Undocumented.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="CA_GET_MSG"></a>CA_GET_MSG</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl is undocumented. Documentation is welcome.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(fd, int request = CA_GET_MSG,
 ca_msg_t *);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals CA_GET_MSG for this command.</p>
</td></tr><tr><td align="char">
<p>ca_msg_t *
</p>
</td><td align="char">
<p>Undocumented.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="CA_SEND_MSG"></a>CA_SEND_MSG</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl is undocumented. Documentation is welcome.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(fd, int request = CA_SEND_MSG,
 ca_msg_t *);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals CA_SEND_MSG for this command.</p>
</td></tr><tr><td align="char">
<p>ca_msg_t *
</p>
</td><td align="char">
<p>Undocumented.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="CA_SET_DESCR"></a>CA_SET_DESCR</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl is undocumented. Documentation is welcome.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(fd, int request = CA_SET_DESCR,
 ca_descr_t *);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals CA_SET_DESCR for this command.</p>
</td></tr><tr><td align="char">
<p>ca_descr_t *
</p>
</td><td align="char">
<p>Undocumented.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="CA_SET_PID"></a>CA_SET_PID</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl is undocumented. Documentation is welcome.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(fd, int request = CA_SET_PID,
 ca_pid_t *);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals CA_SET_PID for this command.</p>
</td></tr><tr><td align="char">
<p>ca_pid_t *
</p>
</td><td align="char">
<p>Undocumented.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="dvb_net"></a>Chapter 14. DVB Network API</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="media.html#dvb_net_types">DVB Net Data Types</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#dvb-net-if">struct dvb_net_if</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#net_fcalls">DVB net Function Calls</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#NET_ADD_IF">NET_ADD_IF</a></span></dt><dt><span class="section"><a href="media.html#NET_REMOVE_IF">NET_REMOVE_IF</a></span></dt><dt><span class="section"><a href="media.html#NET_GET_IF">NET_GET_IF</a></span></dt></dl></dd></dl></div><p>The DVB net device enables feeding of MPE (multi protocol encapsulation) packets
received via DVB into the Linux network protocol stack, e.g. for internet via satellite
applications. It can be accessed through <span class="tt">/dev/dvb/adapter0/net0</span>. Data types and
and ioctl definitions can be accessed by including <span class="tt">linux/dvb/net.h</span> in your
application.
</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dvb_net_types"></a>DVB Net Data Types</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#dvb-net-if">struct dvb_net_if</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dvb-net-if"></a>struct dvb_net_if</h3></div></div></div><pre class="programlisting">
struct dvb_net_if {
	__u16 pid;
	__u16 if_num;
	__u8  feedtype;
#define DVB_NET_FEEDTYPE_MPE 0	/&#8902; multi protocol encapsulation &#8902;/
#define DVB_NET_FEEDTYPE_ULE 1	/&#8902; ultra lightweight encapsulation &#8902;/
};
</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="net_fcalls"></a>DVB net Function Calls</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#NET_ADD_IF">NET_ADD_IF</a></span></dt><dt><span class="section"><a href="media.html#NET_REMOVE_IF">NET_REMOVE_IF</a></span></dt><dt><span class="section"><a href="media.html#NET_GET_IF">NET_GET_IF</a></span></dt></dl></div><p>To be written&#8230;
</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="NET_ADD_IF"></a>NET_ADD_IF</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl is undocumented. Documentation is welcome.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(fd, int request = NET_ADD_IF,
 struct dvb_net_if *if);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals NET_ADD_IF for this command.</p>
</td></tr><tr><td align="char">
<p>struct dvb_net_if *if
</p>
</td><td align="char">
<p>Undocumented.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="NET_REMOVE_IF"></a>NET_REMOVE_IF</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl is undocumented. Documentation is welcome.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(fd, int request = NET_REMOVE_IF);
</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals NET_REMOVE_IF for this command.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="NET_GET_IF"></a>NET_GET_IF</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This ioctl is undocumented. Documentation is welcome.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int ioctl(fd, int request = NET_GET_IF,
 struct dvb_net_if *if);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>int fd</p>
</td><td align="char">
<p>File descriptor returned by a previous call to open().</p>
</td></tr><tr><td align="char">
<p>int request</p>
</td><td align="char">
<p>Equals NET_GET_IF for this command.</p>
</td></tr><tr><td align="char">
<p>struct dvb_net_if *if
</p>
</td><td align="char">
<p>Undocumented.</p>
</td></tr></tbody></table></div><p>RETURN VALUE</p><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="dvb_kdapi"></a>Chapter 15. Kernel Demux API</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="media.html#kernel_demux_data_types">Kernel Demux Data Types</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#dmx_success_t">dmx_success_t</a></span></dt><dt><span class="section"><a href="media.html#ts_filter_types">TS filter types</a></span></dt><dt><span class="section"><a href="media.html#dmx_ts_pes_t">dmx_ts_pes_t</a></span></dt><dt><span class="section"><a href="media.html#demux_demux_t">demux_demux_t</a></span></dt><dt><span class="section"><a href="media.html#demux_directory">Demux directory</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#demux_directory_api">Demux Directory API</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp110784096">dmx_register_demux()</a></span></dt><dt><span class="section"><a href="media.html#idp110801088">dmx_unregister_demux()</a></span></dt><dt><span class="section"><a href="media.html#idp110817936">dmx_get_demuxes()</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#demux_api">Demux API</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#kdapi_fopen">open()</a></span></dt><dt><span class="section"><a href="media.html#kdapi_fclose">close()</a></span></dt><dt><span class="section"><a href="media.html#kdapi_fwrite">write()</a></span></dt><dt><span class="section"><a href="media.html#idp110890656">allocate_ts_feed()</a></span></dt><dt><span class="section"><a href="media.html#idp110913216">release_ts_feed()</a></span></dt><dt><span class="section"><a href="media.html#idp110929088">allocate_section_feed()</a></span></dt><dt><span class="section"><a href="media.html#idp110951600">release_section_feed()</a></span></dt><dt><span class="section"><a href="media.html#idp110967536">descramble_mac_address()</a></span></dt><dt><span class="section"><a href="media.html#idp110994256">descramble_section_payload()</a></span></dt><dt><span class="section"><a href="media.html#idp111023728">add_frontend()</a></span></dt><dt><span class="section"><a href="media.html#idp111046176">remove_frontend()</a></span></dt><dt><span class="section"><a href="media.html#idp111064624">get_frontends()</a></span></dt><dt><span class="section"><a href="media.html#idp111078032">connect_frontend()</a></span></dt><dt><span class="section"><a href="media.html#idp111097408">disconnect_frontend()</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#demux_callback_api">Demux Callback API</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp111114592">dmx_ts_cb()</a></span></dt><dt><span class="section"><a href="media.html#idp111148960">dmx_section_cb()</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#ts_feed_api">TS Feed API</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#idp111176992">set()</a></span></dt><dt><span class="section"><a href="media.html#idp111205664">start_filtering()</a></span></dt><dt><span class="section"><a href="media.html#idp111219648">stop_filtering()</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#section_feed_api">Section Feed API</a></span></dt><dt><span class="section"><a href="media.html#kdapi_set">set()</a></span></dt><dt><span class="section"><a href="media.html#idp111263088">allocate_filter()</a></span></dt><dt><span class="section"><a href="media.html#idp111294528">release_filter()</a></span></dt><dt><span class="section"><a href="media.html#idp111312448">start_filtering()</a></span></dt><dt><span class="section"><a href="media.html#idp111326592">stop_filtering()</a></span></dt></dl></div><p>The kernel demux API defines a driver-internal interface for registering low-level,
hardware specific driver to a hardware independent demux layer. It is only of interest for
DVB device driver writers. The header file for this API is named <span class="tt">demux.h</span> and located in
<span class="tt">drivers/media/dvb-core</span>.
</p><p>Maintainer note: This section must be reviewed. It is probably out of date.
</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="kernel_demux_data_types"></a>Kernel Demux Data Types</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#dmx_success_t">dmx_success_t</a></span></dt><dt><span class="section"><a href="media.html#ts_filter_types">TS filter types</a></span></dt><dt><span class="section"><a href="media.html#dmx_ts_pes_t">dmx_ts_pes_t</a></span></dt><dt><span class="section"><a href="media.html#demux_demux_t">demux_demux_t</a></span></dt><dt><span class="section"><a href="media.html#demux_directory">Demux directory</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dmx_success_t"></a>dmx_success_t</h3></div></div></div><pre class="programlisting">
 typedef enum {
   DMX_OK = 0, /&#8902; Received Ok &#8902;/
   DMX_LENGTH_ERROR, /&#8902; Incorrect length &#8902;/
   DMX_OVERRUN_ERROR, /&#8902; Receiver ring buffer overrun &#8902;/
   DMX_CRC_ERROR, /&#8902; Incorrect CRC &#8902;/
   DMX_FRAME_ERROR, /&#8902; Frame alignment error &#8902;/
   DMX_FIFO_ERROR, /&#8902; Receiver FIFO overrun &#8902;/
   DMX_MISSED_ERROR /&#8902; Receiver missed packet &#8902;/
 } dmx_success_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="ts_filter_types"></a>TS filter types</h3></div></div></div><pre class="programlisting">
 /&#8902;--------------------------------------------------------------------------&#8902;/
 /&#8902; TS packet reception &#8902;/
 /&#8902;--------------------------------------------------------------------------&#8902;/

 /&#8902; TS filter type for set_type() &#8902;/

 #define TS_PACKET       1   /&#8902; send TS packets (188 bytes) to callback (default) &#8902;/
 #define TS_PAYLOAD_ONLY 2   /&#8902; in case TS_PACKET is set, only send the TS
				payload (&lt;=184 bytes per packet) to callback &#8902;/
 #define TS_DECODER      4   /&#8902; send stream to built-in decoder (if present) &#8902;/
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dmx_ts_pes_t"></a>dmx_ts_pes_t</h3></div></div></div><p>The structure
</p><pre class="programlisting">
 typedef enum
 {
	 DMX_TS_PES_AUDIO,   /&#8902; also send packets to audio decoder (if it exists) &#8902;/
	 DMX_TS_PES_VIDEO,   /&#8902; ... &#8902;/
	 DMX_TS_PES_TELETEXT,
	 DMX_TS_PES_SUBTITLE,
	 DMX_TS_PES_PCR,
	 DMX_TS_PES_OTHER,
 } dmx_ts_pes_t;
</pre><p>describes the PES type for filters which write to a built-in decoder. The correspond (and
should be kept identical) to the types in the demux device.
</p><pre class="programlisting">
 struct dmx_ts_feed_s {
	 int is_filtering; /&#8902; Set to non-zero when filtering in progress &#8902;/
	 struct dmx_demux_s&#8902; parent; /&#8902; Back-pointer &#8902;/
	 void&#8902; priv; /&#8902; Pointer to private data of the API client &#8902;/
	 int (&#8902;set) (struct dmx_ts_feed_s&#8902; feed,
		     __u16 pid,
		     size_t callback_length,
		     size_t circular_buffer_size,
		     int descramble,
		     struct timespec timeout);
	 int (&#8902;start_filtering) (struct dmx_ts_feed_s&#8902; feed);
	 int (&#8902;stop_filtering) (struct dmx_ts_feed_s&#8902; feed);
	 int (&#8902;set_type) (struct dmx_ts_feed_s&#8902; feed,
			  int type,
			  dmx_ts_pes_t pes_type);
 };

 typedef struct dmx_ts_feed_s dmx_ts_feed_t;
</pre><pre class="programlisting">
 /&#8902;--------------------------------------------------------------------------&#8902;/
 /&#8902; PES packet reception (not supported yet) &#8902;/
 /&#8902;--------------------------------------------------------------------------&#8902;/

 typedef struct dmx_pes_filter_s {
	 struct dmx_pes_s&#8902; parent; /&#8902; Back-pointer &#8902;/
	 void&#8902; priv; /&#8902; Pointer to private data of the API client &#8902;/
 } dmx_pes_filter_t;
</pre><pre class="programlisting">
 typedef struct dmx_pes_feed_s {
	 int is_filtering; /&#8902; Set to non-zero when filtering in progress &#8902;/
	 struct dmx_demux_s&#8902; parent; /&#8902; Back-pointer &#8902;/
	 void&#8902; priv; /&#8902; Pointer to private data of the API client &#8902;/
	 int (&#8902;set) (struct dmx_pes_feed_s&#8902; feed,
		     __u16 pid,
		     size_t circular_buffer_size,
		     int descramble,
		     struct timespec timeout);
	 int (&#8902;start_filtering) (struct dmx_pes_feed_s&#8902; feed);
	 int (&#8902;stop_filtering) (struct dmx_pes_feed_s&#8902; feed);
	 int (&#8902;allocate_filter) (struct dmx_pes_feed_s&#8902; feed,
				 dmx_pes_filter_t&#8902;&#8902; filter);
	 int (&#8902;release_filter) (struct dmx_pes_feed_s&#8902; feed,
				dmx_pes_filter_t&#8902; filter);
 } dmx_pes_feed_t;
</pre><pre class="programlisting">
 typedef struct {
	 __u8 filter_value [DMX_MAX_FILTER_SIZE];
	 __u8 filter_mask [DMX_MAX_FILTER_SIZE];
	 struct dmx_section_feed_s&#8902; parent; /&#8902; Back-pointer &#8902;/
	 void&#8902; priv; /&#8902; Pointer to private data of the API client &#8902;/
 } dmx_section_filter_t;
</pre><pre class="programlisting">
 struct dmx_section_feed_s {
	 int is_filtering; /&#8902; Set to non-zero when filtering in progress &#8902;/
	 struct dmx_demux_s&#8902; parent; /&#8902; Back-pointer &#8902;/
	 void&#8902; priv; /&#8902; Pointer to private data of the API client &#8902;/
	 int (&#8902;set) (struct dmx_section_feed_s&#8902; feed,
		     __u16 pid,
		     size_t circular_buffer_size,
		     int descramble,
		     int check_crc);
	 int (&#8902;allocate_filter) (struct dmx_section_feed_s&#8902; feed,
				 dmx_section_filter_t&#8902;&#8902; filter);
	 int (&#8902;release_filter) (struct dmx_section_feed_s&#8902; feed,
				dmx_section_filter_t&#8902; filter);
	 int (&#8902;start_filtering) (struct dmx_section_feed_s&#8902; feed);
	 int (&#8902;stop_filtering) (struct dmx_section_feed_s&#8902; feed);
 };
 typedef struct dmx_section_feed_s dmx_section_feed_t;

 /&#8902;--------------------------------------------------------------------------&#8902;/
 /&#8902; Callback functions &#8902;/
 /&#8902;--------------------------------------------------------------------------&#8902;/

 typedef int (&#8902;dmx_ts_cb) ( __u8 &#8902; buffer1,
			    size_t buffer1_length,
			    __u8 &#8902; buffer2,
			    size_t buffer2_length,
			    dmx_ts_feed_t&#8902; source,
			    dmx_success_t success);

 typedef int (&#8902;dmx_section_cb) ( __u8 &#8902; buffer1,
				 size_t buffer1_len,
				 __u8 &#8902; buffer2,
				 size_t buffer2_len,
				 dmx_section_filter_t &#8902; source,
				 dmx_success_t success);

 typedef int (&#8902;dmx_pes_cb) ( __u8 &#8902; buffer1,
			     size_t buffer1_len,
			     __u8 &#8902; buffer2,
			     size_t buffer2_len,
			     dmx_pes_filter_t&#8902; source,
			     dmx_success_t success);

 /&#8902;--------------------------------------------------------------------------&#8902;/
 /&#8902; DVB Front-End &#8902;/
 /&#8902;--------------------------------------------------------------------------&#8902;/

 typedef enum {
	 DMX_OTHER_FE = 0,
	 DMX_SATELLITE_FE,
	 DMX_CABLE_FE,
	 DMX_TERRESTRIAL_FE,
	 DMX_LVDS_FE,
	 DMX_ASI_FE, /&#8902; DVB-ASI interface &#8902;/
	 DMX_MEMORY_FE
 } dmx_frontend_source_t;

 typedef struct {
	 /&#8902; The following char&#8902; fields point to NULL terminated strings &#8902;/
	 char&#8902; id;                    /&#8902; Unique front-end identifier &#8902;/
	 char&#8902; vendor;                /&#8902; Name of the front-end vendor &#8902;/
	 char&#8902; model;                 /&#8902; Name of the front-end model &#8902;/
	 struct list_head connectivity_list; /&#8902; List of front-ends that can
						be connected to a particular
						demux &#8902;/
	 void&#8902; priv;     /&#8902; Pointer to private data of the API client &#8902;/
	 dmx_frontend_source_t source;
 } dmx_frontend_t;

 /&#8902;--------------------------------------------------------------------------&#8902;/
 /&#8902; MPEG-2 TS Demux &#8902;/
 /&#8902;--------------------------------------------------------------------------&#8902;/

 /&#8902;
  &#8902; Flags OR'ed in the capabilites field of struct dmx_demux_s.
  &#8902;/

 #define DMX_TS_FILTERING                        1
 #define DMX_PES_FILTERING                       2
 #define DMX_SECTION_FILTERING                   4
 #define DMX_MEMORY_BASED_FILTERING              8    /&#8902; write() available &#8902;/
 #define DMX_CRC_CHECKING                        16
 #define DMX_TS_DESCRAMBLING                     32
 #define DMX_SECTION_PAYLOAD_DESCRAMBLING        64
 #define DMX_MAC_ADDRESS_DESCRAMBLING            128
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="demux_demux_t"></a>demux_demux_t</h3></div></div></div><pre class="programlisting">
 /&#8902;
  &#8902; DMX_FE_ENTRY(): Casts elements in the list of registered
  &#8902; front-ends from the generic type struct list_head
  &#8902; to the type &#8902; dmx_frontend_t
  &#8902;.
 &#8902;/

 #define DMX_FE_ENTRY(list) list_entry(list, dmx_frontend_t, connectivity_list)

 struct dmx_demux_s {
	 /&#8902; The following char&#8902; fields point to NULL terminated strings &#8902;/
	 char&#8902; id;                    /&#8902; Unique demux identifier &#8902;/
	 char&#8902; vendor;                /&#8902; Name of the demux vendor &#8902;/
	 char&#8902; model;                 /&#8902; Name of the demux model &#8902;/
	 __u32 capabilities;          /&#8902; Bitfield of capability flags &#8902;/
	 dmx_frontend_t&#8902; frontend;    /&#8902; Front-end connected to the demux &#8902;/
	 struct list_head reg_list;   /&#8902; List of registered demuxes &#8902;/
	 void&#8902; priv;                  /&#8902; Pointer to private data of the API client &#8902;/
	 int users;                   /&#8902; Number of users &#8902;/
	 int (&#8902;open) (struct dmx_demux_s&#8902; demux);
	 int (&#8902;close) (struct dmx_demux_s&#8902; demux);
	 int (&#8902;write) (struct dmx_demux_s&#8902; demux, const char&#8902; buf, size_t count);
	 int (&#8902;allocate_ts_feed) (struct dmx_demux_s&#8902; demux,
				  dmx_ts_feed_t&#8902;&#8902; feed,
				  dmx_ts_cb callback);
	 int (&#8902;release_ts_feed) (struct dmx_demux_s&#8902; demux,
				 dmx_ts_feed_t&#8902; feed);
	 int (&#8902;allocate_pes_feed) (struct dmx_demux_s&#8902; demux,
				   dmx_pes_feed_t&#8902;&#8902; feed,
				   dmx_pes_cb callback);
	 int (&#8902;release_pes_feed) (struct dmx_demux_s&#8902; demux,
				  dmx_pes_feed_t&#8902; feed);
	 int (&#8902;allocate_section_feed) (struct dmx_demux_s&#8902; demux,
				       dmx_section_feed_t&#8902;&#8902; feed,
				       dmx_section_cb callback);
	 int (&#8902;release_section_feed) (struct dmx_demux_s&#8902; demux,
				      dmx_section_feed_t&#8902; feed);
	 int (&#8902;descramble_mac_address) (struct dmx_demux_s&#8902; demux,
					__u8&#8902; buffer1,
					size_t buffer1_length,
					__u8&#8902; buffer2,
					size_t buffer2_length,
					__u16 pid);
	 int (&#8902;descramble_section_payload) (struct dmx_demux_s&#8902; demux,
					    __u8&#8902; buffer1,
					    size_t buffer1_length,
					    __u8&#8902; buffer2, size_t buffer2_length,
					    __u16 pid);
	 int (&#8902;add_frontend) (struct dmx_demux_s&#8902; demux,
			      dmx_frontend_t&#8902; frontend);
	 int (&#8902;remove_frontend) (struct dmx_demux_s&#8902; demux,
				 dmx_frontend_t&#8902; frontend);
	 struct list_head&#8902; (&#8902;get_frontends) (struct dmx_demux_s&#8902; demux);
	 int (&#8902;connect_frontend) (struct dmx_demux_s&#8902; demux,
				  dmx_frontend_t&#8902; frontend);
	 int (&#8902;disconnect_frontend) (struct dmx_demux_s&#8902; demux);


	 /&#8902; added because js cannot keep track of these himself &#8902;/
	 int (&#8902;get_pes_pids) (struct dmx_demux_s&#8902; demux, __u16 &#8902;pids);
 };
 typedef struct dmx_demux_s dmx_demux_t;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="demux_directory"></a>Demux directory</h3></div></div></div><pre class="programlisting">
 /&#8902;
  &#8902; DMX_DIR_ENTRY(): Casts elements in the list of registered
  &#8902; demuxes from the generic type struct list_head&#8902; to the type dmx_demux_t
  &#8902;.
  &#8902;/

 #define DMX_DIR_ENTRY(list) list_entry(list, dmx_demux_t, reg_list)

 int dmx_register_demux (dmx_demux_t&#8902; demux);
 int dmx_unregister_demux (dmx_demux_t&#8902; demux);
 struct list_head&#8902; dmx_get_demuxes (void);
</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="demux_directory_api"></a>Demux Directory API</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#idp110784096">dmx_register_demux()</a></span></dt><dt><span class="section"><a href="media.html#idp110801088">dmx_unregister_demux()</a></span></dt><dt><span class="section"><a href="media.html#idp110817936">dmx_get_demuxes()</a></span></dt></dl></div><p>The demux directory is a Linux kernel-wide facility for registering and accessing the
MPEG-2 TS demuxes in the system. Run-time registering and unregistering of demux drivers
is possible using this API.
</p><p>All demux drivers in the directory implement the abstract interface dmx_demux_t.
</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp110784096"></a>dmx_register_demux()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This function makes a demux driver interface available to the Linux kernel. It is
 usually called by the init_module() function of the kernel module that contains
 the demux driver. The caller of this function is responsible for allocating
 dynamic or static memory for the demux structure and for initializing its fields
 before calling this function. The memory allocated for the demux structure
 must not be freed before calling dmx_unregister_demux(),</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int dmx_register_demux ( dmx_demux_t &#8902;demux )</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>dmx_demux_t*
 demux</p>
</td><td align="char">
<p>Pointer to the demux structure.</p>
</td></tr></tbody></table></div><p>RETURNS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>0</p>
</td><td align="char">
<p>The function was completed without errors.</p>
</td></tr><tr><td align="char">
<p>-EEXIST</p>
</td><td align="char">
<p>A demux with the same value of the id field already stored
 in the directory.</p>
</td></tr><tr><td align="char">
<p>-ENOSPC</p>
</td><td align="char">
<p>No space left in the directory.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp110801088"></a>dmx_unregister_demux()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This function is called to indicate that the given demux interface is no
 longer available. The caller of this function is responsible for freeing the
 memory of the demux structure, if it was dynamically allocated before calling
 dmx_register_demux(). The cleanup_module() function of the kernel module
 that contains the demux driver should call this function. Note that this function
 fails if the demux is currently in use, i.e., release_demux() has not been called
 for the interface.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int dmx_unregister_demux ( dmx_demux_t &#8902;demux )</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>dmx_demux_t*
 demux</p>
</td><td align="char">
<p>Pointer to the demux structure which is to be
 unregistered.</p>
</td></tr></tbody></table></div><p>RETURNS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>0</p>
</td><td align="char">
<p>The function was completed without errors.</p>
</td></tr><tr><td align="char">
<p>ENODEV</p>
</td><td align="char">
<p>The specified demux is not registered in the demux
 directory.</p>
</td></tr><tr><td align="char">
<p>EBUSY</p>
</td><td align="char">
<p>The specified demux is currently in use.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp110817936"></a>dmx_get_demuxes()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>Provides the caller with the list of registered demux interfaces, using the
 standard list structure defined in the include file linux/list.h. The include file
 demux.h defines the macro DMX_DIR_ENTRY() for converting an element of
 the generic type struct list_head* to the type dmx_demux_t*. The caller must
 not free the memory of any of the elements obtained via this function call.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>struct list_head &#8902;dmx_get_demuxes ()</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>none</p>
</td><td class="auto-generated"> </td></tr></tbody></table></div><p>RETURNS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>struct list_head *</p>
</td><td align="char">
<p>A list of demux interfaces, or NULL in the case of an
 empty list.</p>
</td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="demux_api"></a>Demux API</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#kdapi_fopen">open()</a></span></dt><dt><span class="section"><a href="media.html#kdapi_fclose">close()</a></span></dt><dt><span class="section"><a href="media.html#kdapi_fwrite">write()</a></span></dt><dt><span class="section"><a href="media.html#idp110890656">allocate_ts_feed()</a></span></dt><dt><span class="section"><a href="media.html#idp110913216">release_ts_feed()</a></span></dt><dt><span class="section"><a href="media.html#idp110929088">allocate_section_feed()</a></span></dt><dt><span class="section"><a href="media.html#idp110951600">release_section_feed()</a></span></dt><dt><span class="section"><a href="media.html#idp110967536">descramble_mac_address()</a></span></dt><dt><span class="section"><a href="media.html#idp110994256">descramble_section_payload()</a></span></dt><dt><span class="section"><a href="media.html#idp111023728">add_frontend()</a></span></dt><dt><span class="section"><a href="media.html#idp111046176">remove_frontend()</a></span></dt><dt><span class="section"><a href="media.html#idp111064624">get_frontends()</a></span></dt><dt><span class="section"><a href="media.html#idp111078032">connect_frontend()</a></span></dt><dt><span class="section"><a href="media.html#idp111097408">disconnect_frontend()</a></span></dt></dl></div><p>The demux API should be implemented for each demux in the system. It is used to select
the TS source of a demux and to manage the demux resources. When the demux
client allocates a resource via the demux API, it receives a pointer to the API of that
resource.
</p><p>Each demux receives its TS input from a DVB front-end or from memory, as set via the
demux API. In a system with more than one front-end, the API can be used to select one of
the DVB front-ends as a TS source for a demux, unless this is fixed in the HW platform. The
demux API only controls front-ends regarding their connections with demuxes; the APIs
used to set the other front-end parameters, such as tuning, are not defined in this
document.
</p><p>The functions that implement the abstract interface demux should be defined static or
module private and registered to the Demux Directory for external access. It is not necessary
to implement every function in the demux_t struct, however (for example, a demux interface
might support Section filtering, but not TS or PES filtering). The API client is expected to
check the value of any function pointer before calling the function: the value of NULL means
&#8220;function not available&#8221;.
</p><p>Whenever the functions of the demux API modify shared data, the possibilities of lost
update and race condition problems should be addressed, e.g. by protecting parts of code with
mutexes. This is especially important on multi-processor hosts.
</p><p>Note that functions called from a bottom half context must not sleep, at least in the 2.2.x
kernels. Even a simple memory allocation can result in a kernel thread being put to sleep if
swapping is needed. For example, the Linux kernel calls the functions of a network device
interface from a bottom half context. Thus, if a demux API function is called from network
device code, the function must not sleep.
</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="kdapi_fopen"></a>open()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This function reserves the demux for use by the caller and, if necessary,
 initializes the demux. When the demux is no longer needed, the function close()
 should be called. It should be possible for multiple clients to access the demux
 at the same time. Thus, the function implementation should increment the
 demux usage count when open() is called and decrement it when close() is
 called.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int open ( demux_t&#8902; demux );</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>demux_t* demux</p>
</td><td align="char">
<p>Pointer to the demux API and instance data.</p>
</td></tr></tbody></table></div><p>RETURNS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>0</p>
</td><td align="char">
<p>The function was completed without errors.</p>
</td></tr><tr><td align="char">
<p>-EUSERS</p>
</td><td align="char">
<p>Maximum usage count reached.</p>
</td></tr><tr><td align="char">
<p>-EINVAL</p>
</td><td align="char">
<p>Bad parameter.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="kdapi_fclose"></a>close()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This function reserves the demux for use by the caller and, if necessary,
 initializes the demux. When the demux is no longer needed, the function close()
 should be called. It should be possible for multiple clients to access the demux
 at the same time. Thus, the function implementation should increment the
 demux usage count when open() is called and decrement it when close() is
 called.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int close(demux_t&#8902; demux);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>demux_t* demux</p>
</td><td align="char">
<p>Pointer to the demux API and instance data.</p>
</td></tr></tbody></table></div><p>RETURNS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>0</p>
</td><td align="char">
<p>The function was completed without errors.</p>
</td></tr><tr><td align="char">
<p>-ENODEV</p>
</td><td align="char">
<p>The demux was not in use.</p>
</td></tr><tr><td align="char">
<p>-EINVAL</p>
</td><td align="char">
<p>Bad parameter.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="kdapi_fwrite"></a>write()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This function provides the demux driver with a memory buffer containing TS
 packets. Instead of receiving TS packets from the DVB front-end, the demux
 driver software will read packets from memory. Any clients of this demux
 with active TS, PES or Section filters will receive filtered data via the Demux
 callback API (see 0). The function returns when all the data in the buffer has
 been consumed by the demux. Demux hardware typically cannot read TS from
 memory. If this is the case, memory-based filtering has to be implemented
 entirely in software.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int write(demux_t&#8902; demux, const char&#8902; buf, size_t
 count);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>demux_t* demux</p>
</td><td align="char">
<p>Pointer to the demux API and instance data.</p>
</td></tr><tr><td align="char">
<p>const char* buf</p>
</td><td align="char">
<p>Pointer to the TS data in kernel-space memory.</p>
</td></tr><tr><td align="char">
<p>size_t length</p>
</td><td align="char">
<p>Length of the TS data.</p>
</td></tr></tbody></table></div><p>RETURNS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>0</p>
</td><td align="char">
<p>The function was completed without errors.</p>
</td></tr><tr><td align="char">
<p>-ENOSYS</p>
</td><td align="char">
<p>The command is not implemented.</p>
</td></tr><tr><td align="char">
<p>-EINVAL</p>
</td><td align="char">
<p>Bad parameter.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp110890656"></a>allocate_ts_feed()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>Allocates a new TS feed, which is used to filter the TS packets carrying a
 certain PID. The TS feed normally corresponds to a hardware PID filter on the
 demux chip.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int allocate_ts_feed(dmx_demux_t&#8902; demux,
 dmx_ts_feed_t&#8902;&#8902; feed, dmx_ts_cb callback);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>demux_t* demux</p>
</td><td align="char">
<p>Pointer to the demux API and instance data.</p>
</td></tr><tr><td align="char">
<p>dmx_ts_feed_t**
 feed</p>
</td><td align="char">
<p>Pointer to the TS feed API and instance data.</p>
</td></tr><tr><td align="char">
<p>dmx_ts_cb callback</p>
</td><td align="char">
<p>Pointer to the callback function for passing received TS
 packet</p>
</td></tr></tbody></table></div><p>RETURNS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>0</p>
</td><td align="char">
<p>The function was completed without errors.</p>
</td></tr><tr><td align="char">
<p>-EBUSY</p>
</td><td align="char">
<p>No more TS feeds available.</p>
</td></tr><tr><td align="char">
<p>-ENOSYS</p>
</td><td align="char">
<p>The command is not implemented.</p>
</td></tr><tr><td align="char">
<p>-EINVAL</p>
</td><td align="char">
<p>Bad parameter.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp110913216"></a>release_ts_feed()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>Releases the resources allocated with allocate_ts_feed(). Any filtering in
 progress on the TS feed should be stopped before calling this function.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int release_ts_feed(dmx_demux_t&#8902; demux,
 dmx_ts_feed_t&#8902; feed);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>demux_t* demux</p>
</td><td align="char">
<p>Pointer to the demux API and instance data.</p>
</td></tr><tr><td align="char">
<p>dmx_ts_feed_t* feed</p>
</td><td align="char">
<p>Pointer to the TS feed API and instance data.</p>
</td></tr></tbody></table></div><p>RETURNS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>0</p>
</td><td align="char">
<p>The function was completed without errors.</p>
</td></tr><tr><td align="char">
<p>-EINVAL</p>
</td><td align="char">
<p>Bad parameter.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp110929088"></a>allocate_section_feed()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>Allocates a new section feed, i.e. a demux resource for filtering and receiving
 sections. On platforms with hardware support for section filtering, a section
 feed is directly mapped to the demux HW. On other platforms, TS packets are
 first PID filtered in hardware and a hardware section filter then emulated in
 software. The caller obtains an API pointer of type dmx_section_feed_t as an
 out parameter. Using this API the caller can set filtering parameters and start
 receiving sections.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int allocate_section_feed(dmx_demux_t&#8902; demux,
 dmx_section_feed_t &#8902;&#8902;feed, dmx_section_cb callback);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>demux_t *demux</p>
</td><td align="char">
<p>Pointer to the demux API and instance data.</p>
</td></tr><tr><td align="char">
<p>dmx_section_feed_t
 **feed</p>
</td><td align="char">
<p>Pointer to the section feed API and instance data.</p>
</td></tr><tr><td align="char">
<p>dmx_section_cb
 callback</p>
</td><td align="char">
<p>Pointer to the callback function for passing received
 sections.</p>
</td></tr></tbody></table></div><p>RETURNS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>0</p>
</td><td align="char">
<p>The function was completed without errors.</p>
</td></tr><tr><td align="char">
<p>-EBUSY</p>
</td><td align="char">
<p>No more section feeds available.</p>
</td></tr><tr><td align="char">
<p>-ENOSYS</p>
</td><td align="char">
<p>The command is not implemented.</p>
</td></tr><tr><td align="char">
<p>-EINVAL</p>
</td><td align="char">
<p>Bad parameter.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp110951600"></a>release_section_feed()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>Releases the resources allocated with allocate_section_feed(), including
 allocated filters. Any filtering in progress on the section feed should be stopped
 before calling this function.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int release_section_feed(dmx_demux_t&#8902; demux,
 dmx_section_feed_t &#8902;feed);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>demux_t *demux</p>
</td><td align="char">
<p>Pointer to the demux API and instance data.</p>
</td></tr><tr><td align="char">
<p>dmx_section_feed_t
 *feed</p>
</td><td align="char">
<p>Pointer to the section feed API and instance data.</p>
</td></tr></tbody></table></div><p>RETURNS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>0</p>
</td><td align="char">
<p>The function was completed without errors.</p>
</td></tr><tr><td align="char">
<p>-EINVAL</p>
</td><td align="char">
<p>Bad parameter.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp110967536"></a>descramble_mac_address()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This function runs a descrambling algorithm on the destination MAC
 address field of a DVB Datagram Section, replacing the original address
 with its un-encrypted version. Otherwise, the description on the function
 descramble_section_payload() applies also to this function.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int descramble_mac_address(dmx_demux_t&#8902; demux, __u8
 &#8902;buffer1, size_t buffer1_length, __u8 &#8902;buffer2,
 size_t buffer2_length, __u16 pid);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>dmx_demux_t
 *demux</p>
</td><td align="char">
<p>Pointer to the demux API and instance data.</p>
</td></tr><tr><td align="char">
<p>__u8 *buffer1</p>
</td><td align="char">
<p>Pointer to the first byte of the section.</p>
</td></tr><tr><td align="char">
<p>size_t buffer1_length</p>
</td><td align="char">
<p>Length of the section data, including headers and CRC,
 in buffer1.</p>
</td></tr><tr><td align="char">
<p>__u8* buffer2</p>
</td><td align="char">
<p>Pointer to the tail of the section data, or NULL. The
 pointer has a non-NULL value if the section wraps past
 the end of a circular buffer.</p>
</td></tr><tr><td align="char">
<p>size_t buffer2_length</p>
</td><td align="char">
<p>Length of the section data, including headers and CRC,
 in buffer2.</p>
</td></tr><tr><td align="char">
<p>__u16 pid</p>
</td><td align="char">
<p>The PID on which the section was received. Useful
 for obtaining the descrambling key, e.g. from a DVB
 Common Access facility.</p>
</td></tr></tbody></table></div><p>RETURNS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>0</p>
</td><td align="char">
<p>The function was completed without errors.</p>
</td></tr><tr><td align="char">
<p>-ENOSYS</p>
</td><td align="char">
<p>No descrambling facility available.</p>
</td></tr><tr><td align="char">
<p>-EINVAL</p>
</td><td align="char">
<p>Bad parameter.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp110994256"></a>descramble_section_payload()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This function runs a descrambling algorithm on the payload of a DVB
 Datagram Section, replacing the original payload with its un-encrypted
 version. The function will be called from the demux API implementation;
 the API client need not call this function directly. Section-level scrambling
 algorithms are currently standardized only for DVB-RCC (return channel
 over 2-directional cable TV network) systems. For all other DVB networks,
 encryption schemes are likely to be proprietary to each data broadcaster. Thus,
 it is expected that this function pointer will have the value of NULL (i.e.,
 function not available) in most demux API implementations. Nevertheless, it
 should be possible to use the function pointer as a hook for dynamically adding
 a &#8220;plug-in&#8221; descrambling facility to a demux driver.</p>
</td></tr><tr><td align="char">
<p>While this function is not needed with hardware-based section descrambling,
 the descramble_section_payload function pointer can be used to override the
 default hardware-based descrambling algorithm: if the function pointer has a
 non-NULL value, the corresponding function should be used instead of any
 descrambling hardware.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int descramble_section_payload(dmx_demux_t&#8902; demux,
 __u8 &#8902;buffer1, size_t buffer1_length, __u8 &#8902;buffer2,
 size_t buffer2_length, __u16 pid);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>dmx_demux_t
 *demux</p>
</td><td align="char">
<p>Pointer to the demux API and instance data.</p>
</td></tr><tr><td align="char">
<p>__u8 *buffer1</p>
</td><td align="char">
<p>Pointer to the first byte of the section.</p>
</td></tr><tr><td align="char">
<p>size_t buffer1_length</p>
</td><td align="char">
<p>Length of the section data, including headers and CRC,
 in buffer1.</p>
</td></tr><tr><td align="char">
<p>__u8 *buffer2</p>
</td><td align="char">
<p>Pointer to the tail of the section data, or NULL. The
 pointer has a non-NULL value if the section wraps past
 the end of a circular buffer.</p>
</td></tr><tr><td align="char">
<p>size_t buffer2_length</p>
</td><td align="char">
<p>Length of the section data, including headers and CRC,
 in buffer2.</p>
</td></tr><tr><td align="char">
<p>__u16 pid</p>
</td><td align="char">
<p>The PID on which the section was received. Useful
 for obtaining the descrambling key, e.g. from a DVB
 Common Access facility.</p>
</td></tr></tbody></table></div><p>RETURNS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>0</p>
</td><td align="char">
<p>The function was completed without errors.</p>
</td></tr><tr><td align="char">
<p>-ENOSYS</p>
</td><td align="char">
<p>No descrambling facility available.</p>
</td></tr><tr><td align="char">
<p>-EINVAL</p>
</td><td align="char">
<p>Bad parameter.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp111023728"></a>add_frontend()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>Registers a connectivity between a demux and a front-end, i.e., indicates that
 the demux can be connected via a call to connect_frontend() to use the given
 front-end as a TS source. The client of this function has to allocate dynamic or
 static memory for the frontend structure and initialize its fields before calling
 this function. This function is normally called during the driver initialization.
 The caller must not free the memory of the frontend struct before successfully
 calling remove_frontend().</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int add_frontend(dmx_demux_t &#8902;demux, dmx_frontend_t
 &#8902;frontend);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>dmx_demux_t*
 demux</p>
</td><td align="char">
<p>Pointer to the demux API and instance data.</p>
</td></tr><tr><td align="char">
<p>dmx_frontend_t*
 frontend</p>
</td><td align="char">
<p>Pointer to the front-end instance data.</p>
</td></tr></tbody></table></div><p>RETURNS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>0</p>
</td><td align="char">
<p>The function was completed without errors.</p>
</td></tr><tr><td align="char">
<p>-EEXIST</p>
</td><td align="char">
<p>A front-end with the same value of the id field already
 registered.</p>
</td></tr><tr><td align="char">
<p>-EINUSE</p>
</td><td align="char">
<p>The demux is in use.</p>
</td></tr><tr><td align="char">
<p>-ENOMEM</p>
</td><td align="char">
<p>No more front-ends can be added.</p>
</td></tr><tr><td align="char">
<p>-EINVAL</p>
</td><td align="char">
<p>Bad parameter.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp111046176"></a>remove_frontend()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>Indicates that the given front-end, registered by a call to add_frontend(), can
 no longer be connected as a TS source by this demux. The function should be
 called when a front-end driver or a demux driver is removed from the system.
 If the front-end is in use, the function fails with the return value of -EBUSY.
 After successfully calling this function, the caller can free the memory of
 the frontend struct if it was dynamically allocated before the add_frontend()
 operation.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int remove_frontend(dmx_demux_t&#8902; demux,
 dmx_frontend_t&#8902; frontend);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>dmx_demux_t*
 demux</p>
</td><td align="char">
<p>Pointer to the demux API and instance data.</p>
</td></tr><tr><td align="char">
<p>dmx_frontend_t*
 frontend</p>
</td><td align="char">
<p>Pointer to the front-end instance data.</p>
</td></tr></tbody></table></div><p>RETURNS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>0</p>
</td><td align="char">
<p>The function was completed without errors.</p>
</td></tr><tr><td align="char">
<p>-EINVAL</p>
</td><td align="char">
<p>Bad parameter.</p>
</td></tr><tr><td align="char">
<p>-EBUSY</p>
</td><td align="char">
<p>The front-end is in use, i.e. a call to connect_frontend()
 has not been followed by a call to disconnect_frontend().</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp111064624"></a>get_frontends()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>Provides the APIs of the front-ends that have been registered for this demux.
 Any of the front-ends obtained with this call can be used as a parameter for
 connect_frontend().</p>
</td></tr><tr><td align="char">
<p>The include file demux.h contains the macro DMX_FE_ENTRY() for
 converting an element of the generic type struct list_head* to the type
 dmx_frontend_t*. The caller must not free the memory of any of the elements
 obtained via this function call.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>struct list_head&#8902; get_frontends(dmx_demux_t&#8902; demux);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>dmx_demux_t*
 demux</p>
</td><td align="char">
<p>Pointer to the demux API and instance data.</p>
</td></tr></tbody></table></div><p>RETURNS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>dmx_demux_t*</p>
</td><td align="char">
<p>A list of front-end interfaces, or NULL in the case of an
 empty list.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp111078032"></a>connect_frontend()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>Connects the TS output of the front-end to the input of the demux. A demux
 can only be connected to a front-end registered to the demux with the function
 add_frontend().</p>
</td></tr><tr><td align="char">
<p>It may or may not be possible to connect multiple demuxes to the same
 front-end, depending on the capabilities of the HW platform. When not used,
 the front-end should be released by calling disconnect_frontend().</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int connect_frontend(dmx_demux_t&#8902; demux,
 dmx_frontend_t&#8902; frontend);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>dmx_demux_t*
 demux</p>
</td><td align="char">
<p>Pointer to the demux API and instance data.</p>
</td></tr><tr><td align="char">
<p>dmx_frontend_t*
 frontend</p>
</td><td align="char">
<p>Pointer to the front-end instance data.</p>
</td></tr></tbody></table></div><p>RETURNS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>0</p>
</td><td align="char">
<p>The function was completed without errors.</p>
</td></tr><tr><td align="char">
<p>-EINVAL</p>
</td><td align="char">
<p>Bad parameter.</p>
</td></tr><tr><td align="char">
<p>-EBUSY</p>
</td><td align="char">
<p>The front-end is in use.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp111097408"></a>disconnect_frontend()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>Disconnects the demux and a front-end previously connected by a
 connect_frontend() call.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int disconnect_frontend(dmx_demux_t&#8902; demux);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>dmx_demux_t*
 demux</p>
</td><td align="char">
<p>Pointer to the demux API and instance data.</p>
</td></tr></tbody></table></div><p>RETURNS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>0</p>
</td><td align="char">
<p>The function was completed without errors.</p>
</td></tr><tr><td align="char">
<p>-EINVAL</p>
</td><td align="char">
<p>Bad parameter.</p>
</td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="demux_callback_api"></a>Demux Callback API</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#idp111114592">dmx_ts_cb()</a></span></dt><dt><span class="section"><a href="media.html#idp111148960">dmx_section_cb()</a></span></dt></dl></div><p>This kernel-space API comprises the callback functions that deliver filtered data to the
demux client. Unlike the other APIs, these API functions are provided by the client and called
from the demux code.
</p><p>The function pointers of this abstract interface are not packed into a structure as in the
other demux APIs, because the callback functions are registered and used independent
of each other. As an example, it is possible for the API client to provide several
callback functions for receiving TS packets and no callbacks for PES packets or
sections.
</p><p>The functions that implement the callback API need not be re-entrant: when a demux
driver calls one of these functions, the driver is not allowed to call the function again before
the original call returns. If a callback is triggered by a hardware interrupt, it is recommended
to use the Linux &#8220;bottom half&#8221; mechanism or start a tasklet instead of making the callback
function call directly from a hardware interrupt.
</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp111114592"></a>dmx_ts_cb()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This function, provided by the client of the demux API, is called from the
 demux code. The function is only called when filtering on this TS feed has
 been enabled using the start_filtering() function.</p>
</td></tr><tr><td align="char">
<p>Any TS packets that match the filter settings are copied to a circular buffer. The
 filtered TS packets are delivered to the client using this callback function. The
 size of the circular buffer is controlled by the circular_buffer_size parameter
 of the set() function in the TS Feed API. It is expected that the buffer1 and
 buffer2 callback parameters point to addresses within the circular buffer, but
 other implementations are also possible. Note that the called party should not
 try to free the memory the buffer1 and buffer2 parameters point to.</p>
</td></tr><tr><td align="char">
<p>When this function is called, the buffer1 parameter typically points to the
 start of the first undelivered TS packet within a circular buffer. The buffer2
 buffer parameter is normally NULL, except when the received TS packets have
 crossed the last address of the circular buffer and &#8221;wrapped&#8221; to the beginning
 of the buffer. In the latter case the buffer1 parameter would contain an address
 within the circular buffer, while the buffer2 parameter would contain the first
 address of the circular buffer.</p>
</td></tr><tr><td align="char">
<p>The number of bytes delivered with this function (i.e. buffer1_length +
 buffer2_length) is usually equal to the value of callback_length parameter
 given in the set() function, with one exception: if a timeout occurs before
 receiving callback_length bytes of TS data, any undelivered packets are
 immediately delivered to the client by calling this function. The timeout
 duration is controlled by the set() function in the TS Feed API.</p>
</td></tr><tr><td align="char">
<p>If a TS packet is received with errors that could not be fixed by the TS-level
 forward error correction (FEC), the Transport_error_indicator flag of the TS
 packet header should be set. The TS packet should not be discarded, as
 the error can possibly be corrected by a higher layer protocol. If the called
 party is slow in processing the callback, it is possible that the circular buffer
 eventually fills up. If this happens, the demux driver should discard any TS
 packets received while the buffer is full. The error should be indicated to the
 client on the next callback by setting the success parameter to the value of
 DMX_OVERRUN_ERROR.</p>
</td></tr><tr><td align="char">
<p>The type of data returned to the callback can be selected by the new
 function int (*set_type) (struct dmx_ts_feed_s* feed, int type, dmx_ts_pes_t
 pes_type) which is part of the dmx_ts_feed_s struct (also cf. to the
 include file ost/demux.h) The type parameter decides if the raw TS packet
 (TS_PACKET) or just the payload (TS_PACKET&#8212;TS_PAYLOAD_ONLY)
 should be returned. If additionally the TS_DECODER bit is set the stream
 will also be sent to the hardware MPEG decoder. In this case, the second
 flag decides as what kind of data the stream should be interpreted. The
 possible choices are one of DMX_TS_PES_AUDIO, DMX_TS_PES_VIDEO,
 DMX_TS_PES_TELETEXT, DMX_TS_PES_SUBTITLE,
 DMX_TS_PES_PCR, or DMX_TS_PES_OTHER.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int dmx_ts_cb(__u8&#8902; buffer1, size_t buffer1_length,
 __u8&#8902; buffer2, size_t buffer2_length, dmx_ts_feed_t&#8902;
 source, dmx_success_t success);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>__u8* buffer1</p>
</td><td align="char">
<p>Pointer to the start of the filtered TS packets.</p>
</td></tr><tr><td align="char">
<p>size_t buffer1_length</p>
</td><td align="char">
<p>Length of the TS data in buffer1.</p>
</td></tr><tr><td align="char">
<p>__u8* buffer2</p>
</td><td align="char">
<p>Pointer to the tail of the filtered TS packets, or NULL.</p>
</td></tr><tr><td align="char">
<p>size_t buffer2_length</p>
</td><td align="char">
<p>Length of the TS data in buffer2.</p>
</td></tr><tr><td align="char">
<p>dmx_ts_feed_t*
 source</p>
</td><td align="char">
<p>Indicates which TS feed is the source of the callback.</p>
</td></tr><tr><td align="char">
<p>dmx_success_t
 success</p>
</td><td align="char">
<p>Indicates if there was an error in TS reception.</p>
</td></tr></tbody></table></div><p>RETURNS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>0</p>
</td><td align="char">
<p>Continue filtering.</p>
</td></tr><tr><td align="char">
<p>-1</p>
</td><td align="char">
<p>Stop filtering - has the same effect as a call to
 stop_filtering() on the TS Feed API.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp111148960"></a>dmx_section_cb()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This function, provided by the client of the demux API, is called from the
 demux code. The function is only called when filtering of sections has been
 enabled using the function start_filtering() of the section feed API. When the
 demux driver has received a complete section that matches at least one section
 filter, the client is notified via this callback function. Normally this function is
 called for each received section; however, it is also possible to deliver multiple
 sections with one callback, for example when the system load is high. If an
 error occurs while receiving a section, this function should be called with
 the corresponding error type set in the success field, whether or not there is
 data to deliver. The Section Feed implementation should maintain a circular
 buffer for received sections. However, this is not necessary if the Section Feed
 API is implemented as a client of the TS Feed API, because the TS Feed
 implementation then buffers the received data. The size of the circular buffer
 can be configured using the set() function in the Section Feed API. If there
 is no room in the circular buffer when a new section is received, the section
 must be discarded. If this happens, the value of the success parameter should
 be DMX_OVERRUN_ERROR on the next callback.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int dmx_section_cb(__u8&#8902; buffer1, size_t
 buffer1_length, __u8&#8902; buffer2, size_t
 buffer2_length, dmx_section_filter_t&#8902; source,
 dmx_success_t success);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>__u8* buffer1</p>
</td><td align="char">
<p>Pointer to the start of the filtered section, e.g. within the
 circular buffer of the demux driver.</p>
</td></tr><tr><td align="char">
<p>size_t buffer1_length</p>
</td><td align="char">
<p>Length of the filtered section data in buffer1, including
 headers and CRC.</p>
</td></tr><tr><td align="char">
<p>__u8* buffer2</p>
</td><td align="char">
<p>Pointer to the tail of the filtered section data, or NULL.
 Useful to handle the wrapping of a circular buffer.</p>
</td></tr><tr><td align="char">
<p>size_t buffer2_length</p>
</td><td align="char">
<p>Length of the filtered section data in buffer2, including
 headers and CRC.</p>
</td></tr><tr><td align="char">
<p>dmx_section_filter_t*
 filter</p>
</td><td align="char">
<p>Indicates the filter that triggered the callback.</p>
</td></tr><tr><td align="char">
<p>dmx_success_t
 success</p>
</td><td align="char">
<p>Indicates if there was an error in section reception.</p>
</td></tr></tbody></table></div><p>RETURNS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>0</p>
</td><td align="char">
<p>Continue filtering.</p>
</td></tr><tr><td align="char">
<p>-1</p>
</td><td align="char">
<p>Stop filtering - has the same effect as a call to
 stop_filtering() on the Section Feed API.</p>
</td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ts_feed_api"></a>TS Feed API</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#idp111176992">set()</a></span></dt><dt><span class="section"><a href="media.html#idp111205664">start_filtering()</a></span></dt><dt><span class="section"><a href="media.html#idp111219648">stop_filtering()</a></span></dt></dl></div><p>A TS feed is typically mapped to a hardware PID filter on the demux chip.
Using this API, the client can set the filtering properties to start/stop filtering TS
packets on a particular TS feed. The API is defined as an abstract interface of the type
dmx_ts_feed_t.
</p><p>The functions that implement the interface should be defined static or module private. The
client can get the handle of a TS feed API by calling the function allocate_ts_feed() in the
demux API.
</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp111176992"></a>set()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This function sets the parameters of a TS feed. Any filtering in progress on the
 TS feed must be stopped before calling this function.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int set ( dmx_ts_feed_t&#8902; feed, __u16 pid, size_t
 callback_length, size_t circular_buffer_size, int
 descramble, struct timespec timeout);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>dmx_ts_feed_t* feed</p>
</td><td align="char">
<p>Pointer to the TS feed API and instance data.</p>
</td></tr><tr><td align="char">
<p>__u16 pid</p>
</td><td align="char">
<p>PID value to filter. Only the TS packets carrying the
 specified PID will be passed to the API client.</p>
</td></tr><tr><td align="char">
<p>size_t
 callback_length</p>
</td><td align="char">
<p>Number of bytes to deliver with each call to the
 dmx_ts_cb() callback function. The value of this
 parameter should be a multiple of 188.</p>
</td></tr><tr><td align="char">
<p>size_t
 circular_buffer_size</p>
</td><td align="char">
<p>Size of the circular buffer for the filtered TS packets.</p>
</td></tr><tr><td align="char">
<p>int descramble</p>
</td><td align="char">
<p>If non-zero, descramble the filtered TS packets.</p>
</td></tr><tr><td align="char">
<p>struct timespec
 timeout</p>
</td><td align="char">
<p>Maximum time to wait before delivering received TS
 packets to the client.</p>
</td></tr></tbody></table></div><p>RETURNS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>0</p>
</td><td align="char">
<p>The function was completed without errors.</p>
</td></tr><tr><td align="char">
<p>-ENOMEM</p>
</td><td align="char">
<p>Not enough memory for the requested buffer size.</p>
</td></tr><tr><td align="char">
<p>-ENOSYS</p>
</td><td align="char">
<p>No descrambling facility available for TS.</p>
</td></tr><tr><td align="char">
<p>-EINVAL</p>
</td><td align="char">
<p>Bad parameter.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp111205664"></a>start_filtering()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>Starts filtering TS packets on this TS feed, according to its settings. The PID
 value to filter can be set by the API client. All matching TS packets are
 delivered asynchronously to the client, using the callback function registered
 with allocate_ts_feed().</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int start_filtering(dmx_ts_feed_t&#8902; feed);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>dmx_ts_feed_t* feed</p>
</td><td align="char">
<p>Pointer to the TS feed API and instance data.</p>
</td></tr></tbody></table></div><p>RETURNS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>0</p>
</td><td align="char">
<p>The function was completed without errors.</p>
</td></tr><tr><td align="char">
<p>-EINVAL</p>
</td><td align="char">
<p>Bad parameter.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp111219648"></a>stop_filtering()</h3></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>Stops filtering TS packets on this TS feed.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int stop_filtering(dmx_ts_feed_t&#8902; feed);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>dmx_ts_feed_t* feed</p>
</td><td align="char">
<p>Pointer to the TS feed API and instance data.</p>
</td></tr></tbody></table></div><p>RETURNS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>0</p>
</td><td align="char">
<p>The function was completed without errors.</p>
</td></tr><tr><td align="char">
<p>-EINVAL</p>
</td><td align="char">
<p>Bad parameter.</p>
</td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="section_feed_api"></a>Section Feed API</h2></div></div></div><p>A section feed is a resource consisting of a PID filter and a set of section filters. Using this
API, the client can set the properties of a section feed and to start/stop filtering. The API is
defined as an abstract interface of the type dmx_section_feed_t. The functions that implement
the interface should be defined static or module private. The client can get the handle of
a section feed API by calling the function allocate_section_feed() in the demux
API.
</p><p>On demux platforms that provide section filtering in hardware, the Section Feed API
implementation provides a software wrapper for the demux hardware. Other platforms may
support only PID filtering in hardware, requiring that TS packets are converted to sections in
software. In the latter case the Section Feed API implementation can be a client of the TS
Feed API.
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="kdapi_set"></a>set()</h2></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This function sets the parameters of a section feed. Any filtering in progress on
 the section feed must be stopped before calling this function. If descrambling
 is enabled, the payload_scrambling_control and address_scrambling_control
 fields of received DVB datagram sections should be observed. If either one is
 non-zero, the section should be descrambled either in hardware or using the
 functions descramble_mac_address() and descramble_section_payload() of the
 demux API. Note that according to the MPEG-2 Systems specification, only
 the payloads of private sections can be scrambled while the rest of the section
 data must be sent in the clear.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int set(dmx_section_feed_t&#8902; feed, __u16 pid, size_t
 circular_buffer_size, int descramble, int
 check_crc);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>dmx_section_feed_t*
 feed</p>
</td><td align="char">
<p>Pointer to the section feed API and instance data.</p>
</td></tr><tr><td align="char">
<p>__u16 pid</p>
</td><td align="char">
<p>PID value to filter; only the TS packets carrying the
 specified PID will be accepted.</p>
</td></tr><tr><td align="char">
<p>size_t
 circular_buffer_size</p>
</td><td align="char">
<p>Size of the circular buffer for filtered sections.</p>
</td></tr><tr><td align="char">
<p>int descramble</p>
</td><td align="char">
<p>If non-zero, descramble any sections that are scrambled.</p>
</td></tr><tr><td align="char">
<p>int check_crc</p>
</td><td align="char">
<p>If non-zero, check the CRC values of filtered sections.</p>
</td></tr></tbody></table></div><p>RETURNS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>0</p>
</td><td align="char">
<p>The function was completed without errors.</p>
</td></tr><tr><td align="char">
<p>-ENOMEM</p>
</td><td align="char">
<p>Not enough memory for the requested buffer size.</p>
</td></tr><tr><td align="char">
<p>-ENOSYS</p>
</td><td align="char">
<p>No descrambling facility available for sections.</p>
</td></tr><tr><td align="char">
<p>-EINVAL</p>
</td><td align="char">
<p>Bad parameters.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp111263088"></a>allocate_filter()</h2></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This function is used to allocate a section filter on the demux. It should only be
 called when no filtering is in progress on this section feed. If a filter cannot be
 allocated, the function fails with -ENOSPC. See in section ?? for the format of
 the section filter.</p>
</td></tr><tr><td align="char">
<p>The bitfields filter_mask and filter_value should only be modified when no
 filtering is in progress on this section feed. filter_mask controls which bits of
 filter_value are compared with the section headers/payload. On a binary value
 of 1 in filter_mask, the corresponding bits are compared. The filter only accepts
 sections that are equal to filter_value in all the tested bit positions. Any changes
 to the values of filter_mask and filter_value are guaranteed to take effect only
 when the start_filtering() function is called next time. The parent pointer in
 the struct is initialized by the API implementation to the value of the feed
 parameter. The priv pointer is not used by the API implementation, and can
 thus be freely utilized by the caller of this function. Any data pointed to by the
 priv pointer is available to the recipient of the dmx_section_cb() function call.</p>
</td></tr><tr><td align="char">
<p>While the maximum section filter length (DMX_MAX_FILTER_SIZE) is
 currently set at 16 bytes, hardware filters of that size are not available on all
 platforms. Therefore, section filtering will often take place first in hardware,
 followed by filtering in software for the header bytes that were not covered
 by a hardware filter. The filter_mask field can be checked to determine how
 many bytes of the section filter are actually used, and if the hardware filter will
 suffice. Additionally, software-only section filters can optionally be allocated
 to clients when all hardware section filters are in use. Note that on most demux
 hardware it is not possible to filter on the section_length field of the section
 header &#8211; thus this field is ignored, even though it is included in filter_value and
 filter_mask fields.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int allocate_filter(dmx_section_feed_t&#8902; feed,
 dmx_section_filter_t&#8902;&#8902; filter);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>dmx_section_feed_t*
 feed</p>
</td><td align="char">
<p>Pointer to the section feed API and instance data.</p>
</td></tr><tr><td align="char">
<p>dmx_section_filter_t**
 filter</p>
</td><td align="char">
<p>Pointer to the allocated filter.</p>
</td></tr></tbody></table></div><p>RETURNS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>0</p>
</td><td align="char">
<p>The function was completed without errors.</p>
</td></tr><tr><td align="char">
<p>-ENOSPC</p>
</td><td align="char">
<p>No filters of given type and length available.</p>
</td></tr><tr><td align="char">
<p>-EINVAL</p>
</td><td align="char">
<p>Bad parameters.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp111294528"></a>release_filter()</h2></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>This function releases all the resources of a previously allocated section filter.
 The function should not be called while filtering is in progress on this section
 feed. After calling this function, the caller should not try to dereference the
 filter pointer.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int release_filter ( dmx_section_feed_t&#8902; feed,
 dmx_section_filter_t&#8902; filter);</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>dmx_section_feed_t*
 feed</p>
</td><td align="char">
<p>Pointer to the section feed API and instance data.</p>
</td></tr><tr><td align="char">
<p>dmx_section_filter_t*
 filter</p>
</td><td align="char">
<p>I/O Pointer to the instance data of a section filter.</p>
</td></tr></tbody></table></div><p>RETURNS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>0</p>
</td><td align="char">
<p>The function was completed without errors.</p>
</td></tr><tr><td align="char">
<p>-ENODEV</p>
</td><td align="char">
<p>No such filter allocated.</p>
</td></tr><tr><td align="char">
<p>-EINVAL</p>
</td><td align="char">
<p>Bad parameter.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp111312448"></a>start_filtering()</h2></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>Starts filtering sections on this section feed, according to its settings. Sections
 are first filtered based on their PID and then matched with the section
 filters allocated for this feed. If the section matches the PID filter and
 at least one section filter, it is delivered to the API client. The section
 is delivered asynchronously using the callback function registered with
 allocate_section_feed().</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int start_filtering ( dmx_section_feed_t&#8902; feed );</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>dmx_section_feed_t*
 feed</p>
</td><td align="char">
<p>Pointer to the section feed API and instance data.</p>
</td></tr></tbody></table></div><p>RETURNS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>0</p>
</td><td align="char">
<p>The function was completed without errors.</p>
</td></tr><tr><td align="char">
<p>-EINVAL</p>
</td><td align="char">
<p>Bad parameter.</p>
</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp111326592"></a>stop_filtering()</h2></div></div></div><p>DESCRIPTION
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>Stops filtering sections on this section feed. Note that any changes to the
 filtering parameters (filter_value, filter_mask, etc.) should only be made when
 filtering is stopped.</p>
</td></tr></tbody></table></div><p>SYNOPSIS
</p><div class="informaltable"><table border="1"><colgroup><col></colgroup><tbody><tr><td align="char">
<p>int stop_filtering ( dmx_section_feed_t&#8902; feed );</p>
</td></tr></tbody></table></div><p>PARAMETERS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>dmx_section_feed_t*
 feed</p>
</td><td align="char">
<p>Pointer to the section feed API and instance data.</p>
</td></tr></tbody></table></div><p>RETURNS
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td align="char">
<p>0</p>
</td><td align="char">
<p>The function was completed without errors.</p>
</td></tr><tr><td align="char">
<p>-EINVAL</p>
</td><td align="char">
<p>Bad parameter.</p>
</td></tr></tbody></table></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="dvb_examples"></a>Chapter 16. Examples</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="media.html#tuning">Tuning</a></span></dt><dt><span class="section"><a href="media.html#the_dvr_device">The DVR device</a></span></dt></dl></div><p>In this section we would like to present some examples for using the DVB API.
</p><p>Maintainer note: This section is out of date. Please refer to the sample programs packaged
with the driver distribution from <a class="ulink" href="http://linuxtv.org/hg/dvb-apps" target="_top">http://linuxtv.org/hg/dvb-apps</a>.
</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tuning"></a>Tuning</h2></div></div></div><p>We will start with a generic tuning subroutine that uses the frontend and SEC, as well as
the demux devices. The example is given for QPSK tuners, but can easily be adjusted for
QAM.
</p><pre class="programlisting">
 #include &lt;sys/ioctl.h&gt;
 #include &lt;stdio.h&gt;
 #include &lt;stdint.h&gt;
 #include &lt;sys/types.h&gt;
 #include &lt;sys/stat.h&gt;
 #include &lt;fcntl.h&gt;
 #include &lt;time.h&gt;
 #include &lt;unistd.h&gt;

 #include &lt;linux/dvb/dmx.h&gt;
 #include &lt;linux/dvb/frontend.h&gt;
 #include &lt;linux/dvb/sec.h&gt;
 #include &lt;sys/poll.h&gt;

 #define DMX "/dev/dvb/adapter0/demux1"
 #define FRONT "/dev/dvb/adapter0/frontend1"
 #define SEC "/dev/dvb/adapter0/sec1"

 /&#8902; routine for checking if we have a signal and other status information&#8902;/
 int FEReadStatus(int fd, fe_status_t &#8902;stat)
 {
	 int ans;

	 if ( (ans = ioctl(fd,FE_READ_STATUS,stat) &lt; 0)){
		 perror("FE READ STATUS: ");
		 return -1;
	 }

	 if (&#8902;stat &amp; FE_HAS_POWER)
		 printf("FE HAS POWER\n");

	 if (&#8902;stat &amp; FE_HAS_SIGNAL)
		 printf("FE HAS SIGNAL\n");

	 if (&#8902;stat &amp; FE_SPECTRUM_INV)
		 printf("SPEKTRUM INV\n");

	 return 0;
 }


 /&#8902; tune qpsk &#8902;/
 /&#8902; freq:             frequency of transponder                      &#8902;/
 /&#8902; vpid, apid, tpid: PIDs of video, audio and teletext TS packets  &#8902;/
 /&#8902; diseqc:           DiSEqC address of the used LNB                &#8902;/
 /&#8902; pol:              Polarisation                                  &#8902;/
 /&#8902; srate:            Symbol Rate                                   &#8902;/
 /&#8902; fec.              FEC                                           &#8902;/
 /&#8902; lnb_lof1:         local frequency of lower LNB band             &#8902;/
 /&#8902; lnb_lof2:         local frequency of upper LNB band             &#8902;/
 /&#8902; lnb_slof:         switch frequency of LNB                       &#8902;/

 int set_qpsk_channel(int freq, int vpid, int apid, int tpid,
		 int diseqc, int pol, int srate, int fec, int lnb_lof1,
		 int lnb_lof2, int lnb_slof)
 {
	 struct secCommand scmd;
	 struct secCmdSequence scmds;
	 struct dmx_pes_filter_params pesFilterParams;
	 FrontendParameters frp;
	 struct pollfd pfd[1];
	 FrontendEvent event;
	 int demux1, demux2, demux3, front;

	 frequency = (uint32_t) freq;
	 symbolrate = (uint32_t) srate;

	 if((front = open(FRONT,O_RDWR)) &lt; 0){
		 perror("FRONTEND DEVICE: ");
		 return -1;
	 }

	 if((sec = open(SEC,O_RDWR)) &lt; 0){
		 perror("SEC DEVICE: ");
		 return -1;
	 }

	 if (demux1 &lt; 0){
		 if ((demux1=open(DMX, O_RDWR|O_NONBLOCK))
		     &lt; 0){
			 perror("DEMUX DEVICE: ");
			 return -1;
		 }
	 }

	 if (demux2 &lt; 0){
		 if ((demux2=open(DMX, O_RDWR|O_NONBLOCK))
		     &lt; 0){
			 perror("DEMUX DEVICE: ");
			 return -1;
		 }
	 }

	 if (demux3 &lt; 0){
		 if ((demux3=open(DMX, O_RDWR|O_NONBLOCK))
		     &lt; 0){
			 perror("DEMUX DEVICE: ");
			 return -1;
		 }
	 }

	 if (freq &lt; lnb_slof) {
		 frp.Frequency = (freq - lnb_lof1);
		 scmds.continuousTone = SEC_TONE_OFF;
	 } else {
		 frp.Frequency = (freq - lnb_lof2);
		 scmds.continuousTone = SEC_TONE_ON;
	 }
	 frp.Inversion = INVERSION_AUTO;
	 if (pol) scmds.voltage = SEC_VOLTAGE_18;
	 else scmds.voltage = SEC_VOLTAGE_13;

	 scmd.type=0;
	 scmd.u.diseqc.addr=0x10;
	 scmd.u.diseqc.cmd=0x38;
	 scmd.u.diseqc.numParams=1;
	 scmd.u.diseqc.params[0] = 0xF0 | ((diseqc &#8902; 4) &amp; 0x0F) |
		 (scmds.continuousTone == SEC_TONE_ON ? 1 : 0) |
		 (scmds.voltage==SEC_VOLTAGE_18 ? 2 : 0);

	 scmds.miniCommand=SEC_MINI_NONE;
	 scmds.numCommands=1;
	 scmds.commands=&amp;scmd;
	 if (ioctl(sec, SEC_SEND_SEQUENCE, &amp;scmds) &lt; 0){
		 perror("SEC SEND: ");
		 return -1;
	 }

	 if (ioctl(sec, SEC_SEND_SEQUENCE, &amp;scmds) &lt; 0){
		 perror("SEC SEND: ");
		 return -1;
	 }

	 frp.u.qpsk.SymbolRate = srate;
	 frp.u.qpsk.FEC_inner = fec;

	 if (ioctl(front, FE_SET_FRONTEND, &amp;frp) &lt; 0){
		 perror("QPSK TUNE: ");
		 return -1;
	 }

	 pfd[0].fd = front;
	 pfd[0].events = POLLIN;

	 if (poll(pfd,1,3000)){
		 if (pfd[0].revents &amp; POLLIN){
			 printf("Getting QPSK event\n");
			 if ( ioctl(front, FE_GET_EVENT, &amp;event)

			      == -EOVERFLOW){
				 perror("qpsk get event");
				 return -1;
			 }
			 printf("Received ");
			 switch(event.type){
			 case FE_UNEXPECTED_EV:
				 printf("unexpected event\n");
				 return -1;
			 case FE_FAILURE_EV:
				 printf("failure event\n");
				 return -1;

			 case FE_COMPLETION_EV:
				 printf("completion event\n");
			 }
		 }
	 }


	 pesFilterParams.pid     = vpid;
	 pesFilterParams.input   = DMX_IN_FRONTEND;
	 pesFilterParams.output  = DMX_OUT_DECODER;
	 pesFilterParams.pes_type = DMX_PES_VIDEO;
	 pesFilterParams.flags   = DMX_IMMEDIATE_START;
	 if (ioctl(demux1, DMX_SET_PES_FILTER, &amp;pesFilterParams) &lt; 0){
		 perror("set_vpid");
		 return -1;
	 }

	 pesFilterParams.pid     = apid;
	 pesFilterParams.input   = DMX_IN_FRONTEND;
	 pesFilterParams.output  = DMX_OUT_DECODER;
	 pesFilterParams.pes_type = DMX_PES_AUDIO;
	 pesFilterParams.flags   = DMX_IMMEDIATE_START;
	 if (ioctl(demux2, DMX_SET_PES_FILTER, &amp;pesFilterParams) &lt; 0){
		 perror("set_apid");
		 return -1;
	 }

	 pesFilterParams.pid     = tpid;
	 pesFilterParams.input   = DMX_IN_FRONTEND;
	 pesFilterParams.output  = DMX_OUT_DECODER;
	 pesFilterParams.pes_type = DMX_PES_TELETEXT;
	 pesFilterParams.flags   = DMX_IMMEDIATE_START;
	 if (ioctl(demux3, DMX_SET_PES_FILTER, &amp;pesFilterParams) &lt; 0){
		 perror("set_tpid");
		 return -1;
	 }

	 return has_signal(fds);
 }

</pre><p>The program assumes that you are using a universal LNB and a standard DiSEqC
switch with up to 4 addresses. Of course, you could build in some more checking if
tuning was successful and maybe try to repeat the tuning process. Depending on the
external hardware, i.e. LNB and DiSEqC switch, and weather conditions this may be
necessary.
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="the_dvr_device"></a>The DVR device</h2></div></div></div><p>The following program code shows how to use the DVR device for recording.
</p><pre class="programlisting">
 #include &lt;sys/ioctl.h&gt;
 #include &lt;stdio.h&gt;
 #include &lt;stdint.h&gt;
 #include &lt;sys/types.h&gt;
 #include &lt;sys/stat.h&gt;
 #include &lt;fcntl.h&gt;
 #include &lt;time.h&gt;
 #include &lt;unistd.h&gt;

 #include &lt;linux/dvb/dmx.h&gt;
 #include &lt;linux/dvb/video.h&gt;
 #include &lt;sys/poll.h&gt;
 #define DVR "/dev/dvb/adapter0/dvr1"
 #define AUDIO "/dev/dvb/adapter0/audio1"
 #define VIDEO "/dev/dvb/adapter0/video1"

 #define BUFFY (188&#8902;20)
 #define MAX_LENGTH (1024&#8902;1024&#8902;5) /&#8902; record 5MB &#8902;/


 /&#8902; switch the demuxes to recording, assuming the transponder is tuned &#8902;/

 /&#8902; demux1, demux2: file descriptor of video and audio filters &#8902;/
 /&#8902; vpid, apid:     PIDs of video and audio channels           &#8902;/

 int switch_to_record(int demux1, int demux2, uint16_t vpid, uint16_t apid)
 {
	 struct dmx_pes_filter_params pesFilterParams;

	 if (demux1 &lt; 0){
		 if ((demux1=open(DMX, O_RDWR|O_NONBLOCK))
		     &lt; 0){
			 perror("DEMUX DEVICE: ");
			 return -1;
		 }
	 }

	 if (demux2 &lt; 0){
		 if ((demux2=open(DMX, O_RDWR|O_NONBLOCK))
		     &lt; 0){
			 perror("DEMUX DEVICE: ");
			 return -1;
		 }
	 }

	 pesFilterParams.pid = vpid;
	 pesFilterParams.input = DMX_IN_FRONTEND;
	 pesFilterParams.output = DMX_OUT_TS_TAP;
	 pesFilterParams.pes_type = DMX_PES_VIDEO;
	 pesFilterParams.flags = DMX_IMMEDIATE_START;
	 if (ioctl(demux1, DMX_SET_PES_FILTER, &amp;pesFilterParams) &lt; 0){
		 perror("DEMUX DEVICE");
		 return -1;
	 }
	 pesFilterParams.pid = apid;
	 pesFilterParams.input = DMX_IN_FRONTEND;
	 pesFilterParams.output = DMX_OUT_TS_TAP;
	 pesFilterParams.pes_type = DMX_PES_AUDIO;
	 pesFilterParams.flags = DMX_IMMEDIATE_START;
	 if (ioctl(demux2, DMX_SET_PES_FILTER, &amp;pesFilterParams) &lt; 0){
		 perror("DEMUX DEVICE");
		 return -1;
	 }
	 return 0;
 }

 /&#8902; start recording MAX_LENGTH , assuming the transponder is tuned &#8902;/

 /&#8902; demux1, demux2: file descriptor of video and audio filters &#8902;/
 /&#8902; vpid, apid:     PIDs of video and audio channels           &#8902;/
 int record_dvr(int demux1, int demux2, uint16_t vpid, uint16_t apid)
 {
	 int i;
	 int len;
	 int written;
	 uint8_t buf[BUFFY];
	 uint64_t length;
	 struct pollfd pfd[1];
	 int dvr, dvr_out;

	 /&#8902; open dvr device &#8902;/
	 if ((dvr = open(DVR, O_RDONLY|O_NONBLOCK)) &lt; 0){
			 perror("DVR DEVICE");
			 return -1;
	 }

	 /&#8902; switch video and audio demuxes to dvr &#8902;/
	 printf ("Switching dvr on\n");
	 i = switch_to_record(demux1, demux2, vpid, apid);
	 printf("finished: ");

	 printf("Recording %2.0f MB of test file in TS format\n",
		MAX_LENGTH/(1024.0&#8902;1024.0));
	 length = 0;

	 /&#8902; open output file &#8902;/
	 if ((dvr_out = open(DVR_FILE,O_WRONLY|O_CREAT
				  |O_TRUNC, S_IRUSR|S_IWUSR
				  |S_IRGRP|S_IWGRP|S_IROTH|
				  S_IWOTH)) &lt; 0){
		 perror("Can't open file for dvr test");
		 return -1;
	 }

	 pfd[0].fd = dvr;
	 pfd[0].events = POLLIN;

	 /&#8902; poll for dvr data and write to file &#8902;/
	 while (length &lt; MAX_LENGTH ) {
		 if (poll(pfd,1,1)){
			 if (pfd[0].revents &amp; POLLIN){
				 len = read(dvr, buf, BUFFY);
				 if (len &lt; 0){
					 perror("recording");
					 return -1;
				 }
				 if (len &gt; 0){
					 written = 0;
					 while (written &lt; len)
						 written +=
							 write (dvr_out,
								buf, len);
					 length += len;
					 printf("written %2.0f MB\r",
						length/1024./1024.);
				 }
			 }
		 }
	 }
	 return 0;
 }

</pre></div></div><div class="appendix"><div class="titlepage"><div><div><h2 class="title"><a name="audio_h"></a>Appendix F. DVB Audio Header File</h2></div></div></div><pre class="programlisting">
/*
 * audio.h
 *
 * Copyright (C) 2000 Ralph  Metzler &lt;ralph@convergence.de&gt;
 *                  &amp; Marcus Metzler &lt;marcus@convergence.de&gt;
 *                    for convergence integrated media GmbH
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Lesser Public License
 * as published by the Free Software Foundation; either version 2.1
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 */

#ifndef _DVBAUDIO_H_
#define _DVBAUDIO_H_

#include &lt;linux/types.h&gt;

typedef enum {
        AUDIO_SOURCE_DEMUX, /* Select the demux as the main source */
        AUDIO_SOURCE_MEMORY /* Select internal memory as the main source */
} <a class="link" href="media.html#audio-stream-source-t" title="audio_stream_source_t">audio_stream_source_t</a>;


typedef enum {
        AUDIO_STOPPED,      /* Device is stopped */
        AUDIO_PLAYING,      /* Device is currently playing */
        AUDIO_PAUSED        /* Device is paused */
} <a class="link" href="media.html#audio-play-state-t" title="audio_play_state_t">audio_play_state_t</a>;


typedef enum {
        AUDIO_STEREO,
        AUDIO_MONO_LEFT,
        AUDIO_MONO_RIGHT,
        AUDIO_MONO,
        AUDIO_STEREO_SWAPPED
} <a class="link" href="media.html#audio-channel-select-t" title="audio_channel_select_t">audio_channel_select_t</a>;


typedef struct <a class="link" href="media.html#audio-mixer" title="struct audio_mixer">audio_mixer</a> {
        unsigned int volume_left;
        unsigned int volume_right;
  // what else do we need? bass, pass-through, ...
} <a class="link" href="media.html#audio-mixer" title="struct audio_mixer">audio_mixer_t</a>;


typedef struct <a class="link" href="media.html#audio-status" title="struct audio_status">audio_status</a> {
        int                    AV_sync_state;  /* sync audio and video? */
        int                    mute_state;     /* audio is muted */
        audio_play_state_t     play_state;     /* current playback state */
        audio_stream_source_t  stream_source;  /* current stream source */
        audio_channel_select_t channel_select; /* currently selected channel */
        int                    bypass_mode;    /* pass on audio data to */
        audio_mixer_t          mixer_state;    /* current mixer state */
} <a class="link" href="media.html#audio-status" title="struct audio_status">audio_status_t</a>;                              /* separate decoder hardware */


typedef
struct <a class="link" href="media.html#audio-karaoke" title="struct audio_karaoke">audio_karaoke</a> {  /* if Vocal1 or Vocal2 are non-zero, they get mixed  */
        int vocal1;    /* into left and right t at 70% each */
        int vocal2;    /* if both, Vocal1 and Vocal2 are non-zero, Vocal1 gets*/
        int melody;    /* mixed into the left channel and */
                       /* Vocal2 into the right channel at 100% each. */
                       /* if Melody is non-zero, the melody channel gets mixed*/
} <a class="link" href="media.html#audio-karaoke" title="struct audio_karaoke">audio_karaoke_t</a>;     /* into left and right  */


typedef __u16 audio_attributes_t;
/*   bits: descr. */
/*   15-13 audio coding mode (0=ac3, 2=mpeg1, 3=mpeg2ext, 4=LPCM, 6=DTS, */
/*   12    multichannel extension */
/*   11-10 audio type (0=not spec, 1=language included) */
/*    9- 8 audio application mode (0=not spec, 1=karaoke, 2=surround) */
/*    7- 6 Quantization / DRC (mpeg audio: 1=DRC exists)(lpcm: 0=16bit,  */
/*    5- 4 Sample frequency fs (0=48kHz, 1=96kHz) */
/*    2- 0 number of audio channels (n+1 channels) */


/* for GET_CAPABILITIES and SET_FORMAT, the latter should only set one bit */
#define AUDIO_CAP_DTS    1
#define AUDIO_CAP_LPCM   2
#define AUDIO_CAP_MP1    4
#define AUDIO_CAP_MP2    8
#define AUDIO_CAP_MP3   16
#define AUDIO_CAP_AAC   32
#define AUDIO_CAP_OGG   64
#define AUDIO_CAP_SDDS 128
#define AUDIO_CAP_AC3  256

#define <a class="link" href="media.html#AUDIO_STOP" title="AUDIO_STOP">AUDIO_STOP</a>                 _IO('o', 1)
#define <a class="link" href="media.html#AUDIO_PLAY" title="AUDIO_PLAY">AUDIO_PLAY</a>                 _IO('o', 2)
#define <a class="link" href="media.html#AUDIO_PAUSE" title="AUDIO_PAUSE">AUDIO_PAUSE</a>                _IO('o', 3)
#define <a class="link" href="media.html#AUDIO_CONTINUE" title="AUDIO_CONTINUE">AUDIO_CONTINUE</a>             _IO('o', 4)
#define <a class="link" href="media.html#AUDIO_SELECT_SOURCE" title="AUDIO_SELECT_SOURCE">AUDIO_SELECT_SOURCE</a>        _IO('o', 5)
#define <a class="link" href="media.html#AUDIO_SET_MUTE" title="AUDIO_SET_MUTE">AUDIO_SET_MUTE</a>             _IO('o', 6)
#define <a class="link" href="media.html#AUDIO_SET_AV_SYNC" title="AUDIO_SET_AV_SYNC">AUDIO_SET_AV_SYNC</a>          _IO('o', 7)
#define <a class="link" href="media.html#AUDIO_SET_BYPASS_MODE" title="AUDIO_SET_BYPASS_MODE">AUDIO_SET_BYPASS_MODE</a>      _IO('o', 8)
#define <a class="link" href="media.html#AUDIO_CHANNEL_SELECT" title="AUDIO_CHANNEL_SELECT">AUDIO_CHANNEL_SELECT</a>       _IO('o', 9)
#define <a class="link" href="media.html#AUDIO_GET_STATUS" title="AUDIO_GET_STATUS">AUDIO_GET_STATUS</a>           _IOR('o', 10, audio_status_t)

#define <a class="link" href="media.html#AUDIO_GET_CAPABILITIES" title="AUDIO_GET_CAPABILITIES">AUDIO_GET_CAPABILITIES</a>     _IOR('o', 11, unsigned int)
#define <a class="link" href="media.html#AUDIO_CLEAR_BUFFER" title="AUDIO_CLEAR_BUFFER">AUDIO_CLEAR_BUFFER</a>         _IO('o',  12)
#define <a class="link" href="media.html#AUDIO_SET_ID" title="AUDIO_SET_ID">AUDIO_SET_ID</a>               _IO('o', 13)
#define <a class="link" href="media.html#AUDIO_SET_MIXER" title="AUDIO_SET_MIXER">AUDIO_SET_MIXER</a>            _IOW('o', 14, audio_mixer_t)
#define <a class="link" href="media.html#AUDIO_SET_STREAMTYPE" title="AUDIO_SET_STREAMTYPE">AUDIO_SET_STREAMTYPE</a>       _IO('o', 15)
#define <a class="link" href="media.html#AUDIO_SET_EXT_ID" title="AUDIO_SET_EXT_ID">AUDIO_SET_EXT_ID</a>           _IO('o', 16)
#define <a class="link" href="media.html#AUDIO_SET_ATTRIBUTES" title="AUDIO_SET_ATTRIBUTES">AUDIO_SET_ATTRIBUTES</a>       _IOW('o', 17, audio_attributes_t)
#define <a class="link" href="media.html#AUDIO_SET_KARAOKE" title="AUDIO_SET_KARAOKE">AUDIO_SET_KARAOKE</a>          _IOW('o', 18, audio_karaoke_t)

/**
 * AUDIO_GET_PTS
 *
 * Read the 33 bit presentation time stamp as defined
 * in ITU T-REC-H.222.0 / ISO/IEC 13818-1.
 *
 * The PTS should belong to the currently played
 * frame if possible, but may also be a value close to it
 * like the PTS of the last decoded frame or the last PTS
 * extracted by the PES parser.
 */
#define <a class="link" href="media.html#AUDIO_GET_PTS" title="AUDIO_GET_PTS">AUDIO_GET_PTS</a>              _IOR('o', 19, __u64)
#define <a class="link" href="media.html#AUDIO_BILINGUAL_CHANNEL_SELECT" title="AUDIO_BILINGUAL_CHANNEL_SELECT">AUDIO_BILINGUAL_CHANNEL_SELECT</a> _IO('o', 20)

#endif /* _DVBAUDIO_H_ */
</pre></div><div class="appendix"><div class="titlepage"><div><div><h2 class="title"><a name="ca_h"></a>Appendix G. DVB Conditional Access Header File</h2></div></div></div><pre class="programlisting">
/*
 * ca.h
 *
 * Copyright (C) 2000 Ralph  Metzler &lt;ralph@convergence.de&gt;
 *                  &amp; Marcus Metzler &lt;marcus@convergence.de&gt;
 *                    for convergence integrated media GmbH
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Lesser Public License
 * as published by the Free Software Foundation; either version 2.1
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 */

#ifndef _DVBCA_H_
#define _DVBCA_H_

/* slot interface types and info */

typedef struct <a class="link" href="media.html#ca-slot-info" title="ca_slot_info_t">ca_slot_info</a> {
        int num;               /* slot number */

        int type;              /* CA interface this slot supports */
#define CA_CI            1     /* CI high level interface */
#define CA_CI_LINK       2     /* CI link layer level interface */
#define CA_CI_PHYS       4     /* CI physical layer level interface */
#define CA_DESCR         8     /* built-in descrambler */
#define CA_SC          128     /* simple smart card interface */

        unsigned int flags;
#define CA_CI_MODULE_PRESENT 1 /* module (or card) inserted */
#define CA_CI_MODULE_READY   2
} <a class="link" href="media.html#ca-slot-info" title="ca_slot_info_t">ca_slot_info_t</a>;


/* descrambler types and info */

typedef struct <a class="link" href="media.html#ca-descr-info" title="ca_descr_info_t">ca_descr_info</a> {
        unsigned int num;          /* number of available descramblers (keys) */
        unsigned int type;         /* type of supported scrambling system */
#define CA_ECD           1
#define CA_NDS           2
#define CA_DSS           4
} <a class="link" href="media.html#ca-descr-info" title="ca_descr_info_t">ca_descr_info_t</a>;

typedef struct <a class="link" href="media.html#ca-caps" title="ca_caps_t">ca_caps</a> {
        unsigned int slot_num;     /* total number of CA card and module slots */
        unsigned int slot_type;    /* OR of all supported types */
        unsigned int descr_num;    /* total number of descrambler slots (keys) */
        unsigned int descr_type;   /* OR of all supported types */
} <a class="link" href="media.html#ca-caps" title="ca_caps_t">ca_caps_t</a>;

/* a message to/from a CI-CAM */
typedef struct <a class="link" href="media.html#ca-msg" title="ca_msg_t">ca_msg</a> {
        unsigned int index;
        unsigned int type;
        unsigned int length;
        unsigned char msg[256];
} <a class="link" href="media.html#ca-msg" title="ca_msg_t">ca_msg_t</a>;

typedef struct <a class="link" href="media.html#ca-descr" title="ca_descr_t">ca_descr</a> {
        unsigned int index;
        unsigned int parity;    /* 0 == even, 1 == odd */
        unsigned char cw[8];
} <a class="link" href="media.html#ca-descr" title="ca_descr_t">ca_descr_t</a>;

typedef struct <a class="link" href="media.html#ca-pid" title="ca-pid">ca_pid</a> {
        unsigned int pid;
        int index;              /* -1 == disable*/
} <a class="link" href="media.html#ca-pid" title="ca-pid">ca_pid_t</a>;

#define <a class="link" href="media.html#CA_RESET" title="CA_RESET">CA_RESET</a>          _IO('o', 128)
#define <a class="link" href="media.html#CA_GET_CAP" title="CA_GET_CAP">CA_GET_CAP</a>        _IOR('o', 129, ca_caps_t)
#define <a class="link" href="media.html#CA_GET_SLOT_INFO" title="CA_GET_SLOT_INFO">CA_GET_SLOT_INFO</a>  _IOR('o', 130, ca_slot_info_t)
#define <a class="link" href="media.html#CA_GET_DESCR_INFO" title="CA_GET_DESCR_INFO">CA_GET_DESCR_INFO</a> _IOR('o', 131, ca_descr_info_t)
#define <a class="link" href="media.html#CA_GET_MSG" title="CA_GET_MSG">CA_GET_MSG</a>        _IOR('o', 132, ca_msg_t)
#define <a class="link" href="media.html#CA_SEND_MSG" title="CA_SEND_MSG">CA_SEND_MSG</a>       _IOW('o', 133, ca_msg_t)
#define <a class="link" href="media.html#CA_SET_DESCR" title="CA_SET_DESCR">CA_SET_DESCR</a>      _IOW('o', 134, ca_descr_t)
#define <a class="link" href="media.html#CA_SET_PID" title="CA_SET_PID">CA_SET_PID</a>        _IOW('o', 135, ca_pid_t)

#endif
</pre></div><div class="appendix"><div class="titlepage"><div><div><h2 class="title"><a name="dmx_h"></a>Appendix H. DVB Demux Header File</h2></div></div></div><pre class="programlisting">
/*
 * dmx.h
 *
 * Copyright (C) 2000 Marcus Metzler &lt;marcus@convergence.de&gt;
 *                  &amp; Ralph  Metzler &lt;ralph@convergence.de&gt;
 *                    for convergence integrated media GmbH
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 */

#ifndef _UAPI_DVBDMX_H_
#define _UAPI_DVBDMX_H_

#include &lt;linux/types.h&gt;
#ifndef __KERNEL__
#include &lt;time.h&gt;
#endif


#define DMX_FILTER_SIZE 16

typedef enum
{
        DMX_OUT_DECODER, /* Streaming directly to decoder. */
        DMX_OUT_TAP,     /* Output going to a memory buffer */
                         /* (to be retrieved via the read command).*/
        DMX_OUT_TS_TAP,  /* Output multiplexed into a new TS  */
                         /* (to be retrieved by reading from the */
                         /* logical DVR device).                 */
        DMX_OUT_TSDEMUX_TAP /* Like TS_TAP but retrieved from the DMX device */
} <a class="link" href="media.html#dmx-output-t" title="dmx_output_t">dmx_output_t</a>;


typedef enum
{
        DMX_IN_FRONTEND, /* Input from a front-end device.  */
        DMX_IN_DVR       /* Input from the logical DVR device.  */
} <a class="link" href="media.html#dmx-input-t" title="dmx_input_t">dmx_input_t</a>;


typedef enum dmx_ts_pes
{
        DMX_PES_AUDIO0,
        DMX_PES_VIDEO0,
        DMX_PES_TELETEXT0,
        DMX_PES_SUBTITLE0,
        DMX_PES_PCR0,

        DMX_PES_AUDIO1,
        DMX_PES_VIDEO1,
        DMX_PES_TELETEXT1,
        DMX_PES_SUBTITLE1,
        DMX_PES_PCR1,

        DMX_PES_AUDIO2,
        DMX_PES_VIDEO2,
        DMX_PES_TELETEXT2,
        DMX_PES_SUBTITLE2,
        DMX_PES_PCR2,

        DMX_PES_AUDIO3,
        DMX_PES_VIDEO3,
        DMX_PES_TELETEXT3,
        DMX_PES_SUBTITLE3,
        DMX_PES_PCR3,

        DMX_PES_OTHER
} <a class="link" href="media.html#dmx-pes-type-t" title="dmx_pes_type_t">dmx_pes_type_t</a>;

#define DMX_PES_AUDIO    DMX_PES_AUDIO0
#define DMX_PES_VIDEO    DMX_PES_VIDEO0
#define DMX_PES_TELETEXT DMX_PES_TELETEXT0
#define DMX_PES_SUBTITLE DMX_PES_SUBTITLE0
#define DMX_PES_PCR      DMX_PES_PCR0


typedef struct dmx_filter
{
        __u8  filter[DMX_FILTER_SIZE];
        __u8  mask[DMX_FILTER_SIZE];
        __u8  mode[DMX_FILTER_SIZE];
} <a class="link" href="media.html#dmx-filter" title="struct dmx_filter">dmx_filter_t</a>;


struct dmx_sct_filter_params
{
        __u16          pid;
        dmx_filter_t   filter;
        __u32          timeout;
        __u32          flags;
#define DMX_CHECK_CRC       1
#define DMX_ONESHOT         2
#define DMX_IMMEDIATE_START 4
#define DMX_KERNEL_CLIENT   0x8000
};


struct dmx_pes_filter_params
{
        __u16          pid;
        dmx_input_t    input;
        dmx_output_t   output;
        dmx_pes_type_t pes_type;
        __u32          flags;
};

typedef struct <a class="link" href="media.html#dmx-caps" title="struct dmx_caps">dmx_caps</a> {
        __u32 caps;
        int num_decoders;
} <a class="link" href="media.html#dmx-caps" title="struct dmx_caps">dmx_caps_t</a>;

typedef enum {
        DMX_SOURCE_FRONT0 = 0,
        DMX_SOURCE_FRONT1,
        DMX_SOURCE_FRONT2,
        DMX_SOURCE_FRONT3,
        DMX_SOURCE_DVR0   = 16,
        DMX_SOURCE_DVR1,
        DMX_SOURCE_DVR2,
        DMX_SOURCE_DVR3
} <a class="link" href="media.html#dmx-source-t" title="enum dmx_source_t">dmx_source_t</a>;

struct <a class="link" href="media.html#dmx-stc" title="struct dmx_stc">dmx_stc</a> {
        unsigned int num;       /* input : which STC? 0..N */
        unsigned int base;      /* output: divisor for stc to get 90 kHz clock */
        __u64 stc;              /* output: stc in 'base'*90 kHz units */
};


#define <a class="link" href="media.html#DMX_START" title="DMX_START">DMX_START</a>                _IO('o', 41)
#define <a class="link" href="media.html#DMX_STOP" title="DMX_STOP">DMX_STOP</a>                 _IO('o', 42)
#define <a class="link" href="media.html#DMX_SET_FILTER" title="DMX_SET_FILTER">DMX_SET_FILTER</a>           _IOW('o', 43, struct dmx_sct_filter_params)
#define <a class="link" href="media.html#DMX_SET_PES_FILTER" title="DMX_SET_PES_FILTER">DMX_SET_PES_FILTER</a>       _IOW('o', 44, struct dmx_pes_filter_params)
#define <a class="link" href="media.html#DMX_SET_BUFFER_SIZE" title="DMX_SET_BUFFER_SIZE">DMX_SET_BUFFER_SIZE</a>      _IO('o', 45)
#define <a class="link" href="media.html#DMX_GET_PES_PIDS" title="DMX_GET_PES_PIDS">DMX_GET_PES_PIDS</a>         _IOR('o', 47, __u16[5])
#define <a class="link" href="media.html#DMX_GET_CAPS" title="DMX_GET_CAPS">DMX_GET_CAPS</a>             _IOR('o', 48, dmx_caps_t)
#define <a class="link" href="media.html#DMX_SET_SOURCE" title="DMX_SET_SOURCE">DMX_SET_SOURCE</a>           _IOW('o', 49, dmx_source_t)
#define <a class="link" href="media.html#DMX_GET_STC" title="DMX_GET_STC">DMX_GET_STC</a>              _IOWR('o', 50, struct dmx_stc)
#define <a class="link" href="media.html#DMX_ADD_PID" title="DMX_ADD_PID">DMX_ADD_PID</a>              _IOW('o', 51, __u16)
#define <a class="link" href="media.html#DMX_REMOVE_PID" title="DMX_REMOVE_PID">DMX_REMOVE_PID</a>           _IOW('o', 52, __u16)

#endif /* _UAPI_DVBDMX_H_ */
</pre></div><div class="appendix"><div class="titlepage"><div><div><h2 class="title"><a name="frontend_h"></a>Appendix I. DVB Frontend Header File</h2></div></div></div><pre class="programlisting">
/*
 * frontend.h
 *
 * Copyright (C) 2000 Marcus Metzler &lt;marcus@convergence.de&gt;
 *                  Ralph  Metzler &lt;ralph@convergence.de&gt;
 *                  Holger Waechtler &lt;holger@convergence.de&gt;
 *                  Andre Draszik &lt;ad@convergence.de&gt;
 *                  for convergence integrated media GmbH
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 */

#ifndef _DVBFRONTEND_H_
#define _DVBFRONTEND_H_

#include &lt;linux/types.h&gt;

typedef enum fe_type {
        FE_QPSK,
        FE_QAM,
        FE_OFDM,
        FE_ATSC
} <a class="link" href="media.html#fe-type-t" title="Frontend type">fe_type_t</a>;


typedef enum fe_caps {
        FE_IS_STUPID                    = 0,
        FE_CAN_INVERSION_AUTO           = 0x1,
        FE_CAN_FEC_1_2                  = 0x2,
        FE_CAN_FEC_2_3                  = 0x4,
        FE_CAN_FEC_3_4                  = 0x8,
        FE_CAN_FEC_4_5                  = 0x10,
        FE_CAN_FEC_5_6                  = 0x20,
        FE_CAN_FEC_6_7                  = 0x40,
        FE_CAN_FEC_7_8                  = 0x80,
        FE_CAN_FEC_8_9                  = 0x100,
        FE_CAN_FEC_AUTO                 = 0x200,
        FE_CAN_QPSK                     = 0x400,
        FE_CAN_QAM_16                   = 0x800,
        FE_CAN_QAM_32                   = 0x1000,
        FE_CAN_QAM_64                   = 0x2000,
        FE_CAN_QAM_128                  = 0x4000,
        FE_CAN_QAM_256                  = 0x8000,
        FE_CAN_QAM_AUTO                 = 0x10000,
        FE_CAN_TRANSMISSION_MODE_AUTO   = 0x20000,
        FE_CAN_BANDWIDTH_AUTO           = 0x40000,
        FE_CAN_GUARD_INTERVAL_AUTO      = 0x80000,
        FE_CAN_HIERARCHY_AUTO           = 0x100000,
        FE_CAN_8VSB                     = 0x200000,
        FE_CAN_16VSB                    = 0x400000,
        FE_HAS_EXTENDED_CAPS            = 0x800000,   /* We need more bitspace for newer APIs, indicate this. */
        FE_CAN_MULTISTREAM              = 0x4000000,  /* frontend supports multistream filtering */
        FE_CAN_TURBO_FEC                = 0x8000000,  /* frontend supports "turbo fec modulation" */
        FE_CAN_2G_MODULATION            = 0x10000000, /* frontend supports "2nd generation modulation" (DVB-S2) */
        FE_NEEDS_BENDING                = 0x20000000, /* not supported anymore, don't use (frontend requires frequency bending) */
        FE_CAN_RECOVER                  = 0x40000000, /* frontend can recover from a cable unplug automatically */
        FE_CAN_MUTE_TS                  = 0x80000000  /* frontend can stop spurious TS data output */
} <a class="link" href="media.html#fe-caps-t" title="frontend capabilities">fe_caps_t</a>;


struct <a class="link" href="media.html#dvb-frontend-info" title="frontend information">dvb_frontend_info</a> {
        char       name[128];
        fe_type_t  type;                        /* DEPRECATED. Use DTV_ENUM_DELSYS instead */
        __u32      frequency_min;
        __u32      frequency_max;
        __u32      frequency_stepsize;
        __u32      frequency_tolerance;
        __u32      symbol_rate_min;
        __u32      symbol_rate_max;
        __u32      symbol_rate_tolerance;       /* ppm */
        __u32      notifier_delay;              /* DEPRECATED */
        fe_caps_t  caps;
};


/**
 *  Check out the DiSEqC bus spec available on http://www.eutelsat.org/ for
 *  the meaning of this struct...
 */
struct <a class="link" href="media.html#dvb-diseqc-master-cmd" title="diseqc master command">dvb_diseqc_master_cmd</a> {
        __u8 msg [6];   /*  { framing, address, command, data [3] } */
        __u8 msg_len;   /*  valid values are 3...6  */
};


struct <a class="link" href="media.html#dvb-diseqc-slave-reply" title="diseqc slave reply">dvb_diseqc_slave_reply</a> {
        __u8 msg [4];   /*  { framing, data [3] } */
        __u8 msg_len;   /*  valid values are 0...4, 0 means no msg  */
        int  timeout;   /*  return from ioctl after timeout ms with */
};                      /*  errorcode when no message was received  */


typedef enum fe_sec_voltage {
        SEC_VOLTAGE_13,
        SEC_VOLTAGE_18,
        SEC_VOLTAGE_OFF
} <a class="link" href="media.html#fe-sec-voltage-t" title="diseqc slave reply">fe_sec_voltage_t</a>;


typedef enum fe_sec_tone_mode {
        SEC_TONE_ON,
        SEC_TONE_OFF
} <a class="link" href="media.html#fe-sec-tone-mode-t" title="SEC continuous tone">fe_sec_tone_mode_t</a>;


typedef enum fe_sec_mini_cmd {
        SEC_MINI_A,
        SEC_MINI_B
} <a class="link" href="media.html#fe-sec-mini-cmd-t" title="SEC tone burst">fe_sec_mini_cmd_t</a>;


/**
 * enum fe_status - enumerates the possible frontend status
 * @FE_HAS_SIGNAL:      found something above the noise level
 * @FE_HAS_CARRIER:     found a DVB signal
 * @FE_HAS_VITERBI:     FEC is stable
 * @FE_HAS_SYNC:        found sync bytes
 * @FE_HAS_LOCK:        everything's working
 * @FE_TIMEDOUT:        no lock within the last ~2 seconds
 * @FE_REINIT:          frontend was reinitialized, application is recommended
 *                      to reset DiSEqC, tone and parameters
 */

typedef enum fe_status {
        FE_HAS_SIGNAL           = 0x01,
        FE_HAS_CARRIER          = 0x02,
        FE_HAS_VITERBI          = 0x04,
        FE_HAS_SYNC             = 0x08,
        FE_HAS_LOCK             = 0x10,
        FE_TIMEDOUT             = 0x20,
        FE_REINIT               = 0x40,
} <a class="link" href="media.html#fe-status-t" title="frontend status">fe_status_t</a>;

typedef enum fe_spectral_inversion {
        INVERSION_OFF,
        INVERSION_ON,
        INVERSION_AUTO
} <a class="link" href="media.html#fe-spectral-inversion-t" title="frontend spectral inversion">fe_spectral_inversion_t</a>;


typedef enum fe_code_rate {
        FEC_NONE = 0,
        FEC_1_2,
        FEC_2_3,
        FEC_3_4,
        FEC_4_5,
        FEC_5_6,
        FEC_6_7,
        FEC_7_8,
        FEC_8_9,
        FEC_AUTO,
        FEC_3_5,
        FEC_9_10,
        FEC_2_5,
} <a class="link" href="media.html#fe-code-rate-t" title="frontend code rate">fe_code_rate_t</a>;


typedef enum fe_modulation {
        QPSK,
        QAM_16,
        QAM_32,
        QAM_64,
        QAM_128,
        QAM_256,
        QAM_AUTO,
        VSB_8,
        VSB_16,
        PSK_8,
        APSK_16,
        APSK_32,
        DQPSK,
        QAM_4_NR,
} <a class="link" href="media.html#fe-modulation-t" title="frontend modulation type for QAM, OFDM and VSB">fe_modulation_t</a>;

typedef enum fe_transmit_mode {
        TRANSMISSION_MODE_2K,
        TRANSMISSION_MODE_8K,
        TRANSMISSION_MODE_AUTO,
        TRANSMISSION_MODE_4K,
        TRANSMISSION_MODE_1K,
        TRANSMISSION_MODE_16K,
        TRANSMISSION_MODE_32K,
        TRANSMISSION_MODE_C1,
        TRANSMISSION_MODE_C3780,
} <a class="link" href="media.html#fe-transmit-mode-t" title="Number of carriers per channel">fe_transmit_mode_t</a>;

#if defined(__DVB_CORE__) || !defined (__KERNEL__)
typedef enum fe_bandwidth {
        BANDWIDTH_8_MHZ,
        BANDWIDTH_7_MHZ,
        BANDWIDTH_6_MHZ,
        BANDWIDTH_AUTO,
        BANDWIDTH_5_MHZ,
        BANDWIDTH_10_MHZ,
        BANDWIDTH_1_712_MHZ,
} <a class="link" href="media.html#fe-bandwidth-t" title="frontend bandwidth">fe_bandwidth_t</a>;
#endif

typedef enum fe_guard_interval {
        GUARD_INTERVAL_1_32,
        GUARD_INTERVAL_1_16,
        GUARD_INTERVAL_1_8,
        GUARD_INTERVAL_1_4,
        GUARD_INTERVAL_AUTO,
        GUARD_INTERVAL_1_128,
        GUARD_INTERVAL_19_128,
        GUARD_INTERVAL_19_256,
        GUARD_INTERVAL_PN420,
        GUARD_INTERVAL_PN595,
        GUARD_INTERVAL_PN945,
} <a class="link" href="media.html#fe-guard-interval-t" title="frontend guard inverval">fe_guard_interval_t</a>;


typedef enum fe_hierarchy {
        HIERARCHY_NONE,
        HIERARCHY_1,
        HIERARCHY_2,
        HIERARCHY_4,
        HIERARCHY_AUTO
} <a class="link" href="media.html#fe-hierarchy-t" title="frontend hierarchy">fe_hierarchy_t</a>;

enum fe_interleaving {
        INTERLEAVING_NONE,
        INTERLEAVING_AUTO,
        INTERLEAVING_240,
        INTERLEAVING_720,
};

#if defined(__DVB_CORE__) || !defined (__KERNEL__)
struct <a class="link" href="media.html#dvb-qpsk-parameters" title="QPSK parameters">dvb_qpsk_parameters</a> {
        __u32           symbol_rate;  /* symbol rate in Symbols per second */
        fe_code_rate_t  fec_inner;    /* forward error correction (see above) */
};

struct <a class="link" href="media.html#dvb-qam-parameters" title="QAM parameters">dvb_qam_parameters</a> {
        __u32           symbol_rate; /* symbol rate in Symbols per second */
        fe_code_rate_t  fec_inner;   /* forward error correction (see above) */
        fe_modulation_t modulation;  /* modulation type (see above) */
};

struct <a class="link" href="media.html#dvb-vsb-parameters" title="VSB parameters">dvb_vsb_parameters</a> {
        fe_modulation_t modulation;  /* modulation type (see above) */
};

struct <a class="link" href="media.html#dvb-ofdm-parameters" title="OFDM parameters">dvb_ofdm_parameters</a> {
        fe_bandwidth_t      bandwidth;
        fe_code_rate_t      code_rate_HP;  /* high priority stream code rate */
        fe_code_rate_t      code_rate_LP;  /* low priority stream code rate */
        fe_modulation_t     constellation; /* modulation type (see above) */
        fe_transmit_mode_t  transmission_mode;
        fe_guard_interval_t guard_interval;
        fe_hierarchy_t      hierarchy_information;
};


struct <a class="link" href="media.html#dvb-frontend-parameters" title="frontend parameters">dvb_frontend_parameters</a> {
        __u32 frequency;     /* (absolute) frequency in Hz for QAM/OFDM/ATSC */
                             /* intermediate frequency in kHz for QPSK */
        fe_spectral_inversion_t inversion;
        union {
                struct dvb_qpsk_parameters qpsk;
                struct dvb_qam_parameters  qam;
                struct dvb_ofdm_parameters ofdm;
                struct dvb_vsb_parameters vsb;
        } u;
};

struct <a class="link" href="media.html#dvb-frontend-event" title="frontend events">dvb_frontend_event</a> {
        fe_status_t status;
        struct dvb_frontend_parameters parameters;
};
#endif

/* S2API Commands */
#define <a class="link" href="media.html#DTV-UNDEFINED" title="DTV_UNDEFINED">DTV_UNDEFINED</a>           0
#define <a class="link" href="media.html#DTV-TUNE" title="DTV_TUNE">DTV_TUNE</a>                1
#define <a class="link" href="media.html#DTV-CLEAR" title="DTV_CLEAR">DTV_CLEAR</a>               2
#define <a class="link" href="media.html#DTV-FREQUENCY" title="DTV_FREQUENCY">DTV_FREQUENCY</a>           3
#define <a class="link" href="media.html#DTV-MODULATION" title="DTV_MODULATION">DTV_MODULATION</a>          4
#define <a class="link" href="media.html#DTV-BANDWIDTH-HZ" title="DTV_BANDWIDTH_HZ">DTV_BANDWIDTH_HZ</a>        5
#define <a class="link" href="media.html#DTV-INVERSION" title="DTV_INVERSION">DTV_INVERSION</a>           6
#define <a class="link" href="media.html#DTV-DISEQC-MASTER" title="DTV_DISEQC_MASTER">DTV_DISEQC_MASTER</a>       7
#define <a class="link" href="media.html#DTV-SYMBOL-RATE" title="DTV_SYMBOL_RATE">DTV_SYMBOL_RATE</a>         8
#define <a class="link" href="media.html#DTV-INNER-FEC" title="DTV_INNER_FEC">DTV_INNER_FEC</a>           9
#define <a class="link" href="media.html#DTV-VOLTAGE" title="DTV_VOLTAGE">DTV_VOLTAGE</a>             10
#define <a class="link" href="media.html#DTV-TONE" title="DTV_TONE">DTV_TONE</a>                11
#define <a class="link" href="media.html#DTV-PILOT" title="DTV_PILOT">DTV_PILOT</a>               12
#define <a class="link" href="media.html#DTV-ROLLOFF" title="DTV_ROLLOFF">DTV_ROLLOFF</a>             13
#define <a class="link" href="media.html#DTV-DISEQC-SLAVE-REPLY" title="DTV_DISEQC_SLAVE_REPLY">DTV_DISEQC_SLAVE_REPLY</a>  14

/* Basic enumeration set for querying unlimited capabilities */
#define <a class="link" href="media.html#DTV-FE-CAPABILITY-COUNT" title="DTV_FE_CAPABILITY_COUNT">DTV_FE_CAPABILITY_COUNT</a> 15
#define <a class="link" href="media.html#DTV-FE-CAPABILITY" title="DTV_FE_CAPABILITY">DTV_FE_CAPABILITY</a>       16
#define <a class="link" href="media.html#DTV-DELIVERY-SYSTEM" title="DTV_DELIVERY_SYSTEM">DTV_DELIVERY_SYSTEM</a>     17

/* ISDB-T and ISDB-Tsb */
#define <a class="link" href="media.html#DTV-ISDBT-PARTIAL-RECEPTION" title="DTV_ISDBT_PARTIAL_RECEPTION">DTV_ISDBT_PARTIAL_RECEPTION</a>     18
#define <a class="link" href="media.html#DTV-ISDBT-SOUND-BROADCASTING" title="DTV_ISDBT_SOUND_BROADCASTING">DTV_ISDBT_SOUND_BROADCASTING</a>    19

#define <a class="link" href="media.html#DTV-ISDBT-SB-SUBCHANNEL-ID" title="DTV_ISDBT_SB_SUBCHANNEL_ID">DTV_ISDBT_SB_SUBCHANNEL_ID</a>      20
#define <a class="link" href="media.html#DTV-ISDBT-SB-SEGMENT-IDX" title="DTV_ISDBT_SB_SEGMENT_IDX">DTV_ISDBT_SB_SEGMENT_IDX</a>        21
#define <a class="link" href="media.html#DTV-ISDBT-SB-SEGMENT-COUNT" title="DTV_ISDBT_SB_SEGMENT_COUNT">DTV_ISDBT_SB_SEGMENT_COUNT</a>      22

#define <a class="link" href="media.html#DTV-ISDBT-LAYER-FEC" title="DTV_ISDBT_LAYER*_FEC">DTV_ISDBT_LAYERA_FEC</a>                    23
#define <a class="link" href="media.html#DTV-ISDBT-LAYER-MODULATION" title="DTV_ISDBT_LAYER*_MODULATION">DTV_ISDBT_LAYERA_MODULATION</a>             24
#define <a class="link" href="media.html#DTV-ISDBT-LAYER-SEGMENT-COUNT" title="DTV_ISDBT_LAYER*_SEGMENT_COUNT">DTV_ISDBT_LAYERA_SEGMENT_COUNT</a>          25
#define <a class="link" href="media.html#DTV-ISDBT-LAYER-TIME-INTERLEAVING" title="DTV_ISDBT_LAYER*_TIME_INTERLEAVING">DTV_ISDBT_LAYERA_TIME_INTERLEAVING</a>      26

#define <a class="link" href="media.html#DTV-ISDBT-LAYER-FEC" title="DTV_ISDBT_LAYER*_FEC">DTV_ISDBT_LAYERB_FEC</a>                    27
#define <a class="link" href="media.html#DTV-ISDBT-LAYER-MODULATION" title="DTV_ISDBT_LAYER*_MODULATION">DTV_ISDBT_LAYERB_MODULATION</a>             28
#define <a class="link" href="media.html#DTV-ISDBT-LAYER-SEGMENT-COUNT" title="DTV_ISDBT_LAYER*_SEGMENT_COUNT">DTV_ISDBT_LAYERB_SEGMENT_COUNT</a>          29
#define <a class="link" href="media.html#DTV-ISDBT-LAYER-TIME-INTERLEAVING" title="DTV_ISDBT_LAYER*_TIME_INTERLEAVING">DTV_ISDBT_LAYERB_TIME_INTERLEAVING</a>      30

#define <a class="link" href="media.html#DTV-ISDBT-LAYER-FEC" title="DTV_ISDBT_LAYER*_FEC">DTV_ISDBT_LAYERC_FEC</a>                    31
#define <a class="link" href="media.html#DTV-ISDBT-LAYER-MODULATION" title="DTV_ISDBT_LAYER*_MODULATION">DTV_ISDBT_LAYERC_MODULATION</a>             32
#define <a class="link" href="media.html#DTV-ISDBT-LAYER-SEGMENT-COUNT" title="DTV_ISDBT_LAYER*_SEGMENT_COUNT">DTV_ISDBT_LAYERC_SEGMENT_COUNT</a>          33
#define <a class="link" href="media.html#DTV-ISDBT-LAYER-TIME-INTERLEAVING" title="DTV_ISDBT_LAYER*_TIME_INTERLEAVING">DTV_ISDBT_LAYERC_TIME_INTERLEAVING</a>      34

#define <a class="link" href="media.html#DTV-API-VERSION" title="DTV_API_VERSION">DTV_API_VERSION</a>         35

#define <a class="link" href="media.html#DTV-CODE-RATE-HP" title="DTV_CODE_RATE_HP">DTV_CODE_RATE_HP</a>        36
#define <a class="link" href="media.html#DTV-CODE-RATE-LP" title="DTV_CODE_RATE_LP">DTV_CODE_RATE_LP</a>        37
#define <a class="link" href="media.html#DTV-GUARD-INTERVAL" title="DTV_GUARD_INTERVAL">DTV_GUARD_INTERVAL</a>      38
#define <a class="link" href="media.html#DTV-TRANSMISSION-MODE" title="DTV_TRANSMISSION_MODE">DTV_TRANSMISSION_MODE</a>   39
#define <a class="link" href="media.html#DTV-HIERARCHY" title="DTV_HIERARCHY">DTV_HIERARCHY</a>           40

#define <a class="link" href="media.html#DTV-ISDBT-LAYER-ENABLED" title="DTV_ISDBT_LAYER_ENABLED">DTV_ISDBT_LAYER_ENABLED</a> 41

#define <a class="link" href="media.html#DTV-STREAM-ID" title="DTV_STREAM_ID">DTV_STREAM_ID</a>           42
#define DTV_ISDBS_TS_ID_LEGACY  DTV_STREAM_ID
#define <a class="link" href="media.html#DTV-DVBT2-PLP-ID-LEGACY" title="DTV_DVBT2_PLP_ID_LEGACY">DTV_DVBT2_PLP_ID_LEGACY</a> 43

#define <a class="link" href="media.html#DTV-ENUM-DELSYS" title="DTV_ENUM_DELSYS">DTV_ENUM_DELSYS</a>         44

/* ATSC-MH */
#define <a class="link" href="media.html#DTV-ATSCMH-FIC-VER" title="DTV_ATSCMH_FIC_VER">DTV_ATSCMH_FIC_VER</a>              45
#define <a class="link" href="media.html#DTV-ATSCMH-PARADE-ID" title="DTV_ATSCMH_PARADE_ID">DTV_ATSCMH_PARADE_ID</a>            46
#define <a class="link" href="media.html#DTV-ATSCMH-NOG" title="DTV_ATSCMH_NOG">DTV_ATSCMH_NOG</a>                  47
#define <a class="link" href="media.html#DTV-ATSCMH-TNOG" title="DTV_ATSCMH_TNOG">DTV_ATSCMH_TNOG</a>                 48
#define <a class="link" href="media.html#DTV-ATSCMH-SGN" title="DTV_ATSCMH_SGN">DTV_ATSCMH_SGN</a>                  49
#define <a class="link" href="media.html#DTV-ATSCMH-PRC" title="DTV_ATSCMH_PRC">DTV_ATSCMH_PRC</a>                  50
#define <a class="link" href="media.html#DTV-ATSCMH-RS-FRAME-MODE" title="DTV_ATSCMH_RS_FRAME_MODE">DTV_ATSCMH_RS_FRAME_MODE</a>        51
#define <a class="link" href="media.html#DTV-ATSCMH-RS-FRAME-ENSEMBLE" title="DTV_ATSCMH_RS_FRAME_ENSEMBLE">DTV_ATSCMH_RS_FRAME_ENSEMBLE</a>    52
#define <a class="link" href="media.html#DTV-ATSCMH-RS-CODE-MODE-PRI" title="DTV_ATSCMH_RS_CODE_MODE_PRI">DTV_ATSCMH_RS_CODE_MODE_PRI</a>     53
#define <a class="link" href="media.html#DTV-ATSCMH-RS-CODE-MODE-SEC" title="DTV_ATSCMH_RS_CODE_MODE_SEC">DTV_ATSCMH_RS_CODE_MODE_SEC</a>     54
#define <a class="link" href="media.html#DTV-ATSCMH-SCCC-BLOCK-MODE" title="DTV_ATSCMH_SCCC_BLOCK_MODE">DTV_ATSCMH_SCCC_BLOCK_MODE</a>      55
#define <a class="link" href="media.html#DTV-ATSCMH-SCCC-CODE-MODE-A" title="DTV_ATSCMH_SCCC_CODE_MODE_A">DTV_ATSCMH_SCCC_CODE_MODE_A</a>     56
#define <a class="link" href="media.html#DTV-ATSCMH-SCCC-CODE-MODE-B" title="DTV_ATSCMH_SCCC_CODE_MODE_B">DTV_ATSCMH_SCCC_CODE_MODE_B</a>     57
#define <a class="link" href="media.html#DTV-ATSCMH-SCCC-CODE-MODE-C" title="DTV_ATSCMH_SCCC_CODE_MODE_C">DTV_ATSCMH_SCCC_CODE_MODE_C</a>     58
#define <a class="link" href="media.html#DTV-ATSCMH-SCCC-CODE-MODE-D" title="DTV_ATSCMH_SCCC_CODE_MODE_D">DTV_ATSCMH_SCCC_CODE_MODE_D</a>     59

#define <a class="link" href="media.html#DTV-INTERLEAVING" title="DTV_INTERLEAVING">DTV_INTERLEAVING</a>                        60
#define <a class="link" href="media.html#DTV-LNA" title="DTV_LNA">DTV_LNA</a>                                 61

/* Quality parameters */
#define <a class="link" href="media.html#DTV-STAT-SIGNAL-STRENGTH" title="DTV_STAT_SIGNAL_STRENGTH">DTV_STAT_SIGNAL_STRENGTH</a>        62
#define <a class="link" href="media.html#DTV-STAT-CNR" title="DTV_STAT_CNR">DTV_STAT_CNR</a>                    63
#define <a class="link" href="media.html#DTV-STAT-PRE-ERROR-BIT-COUNT" title="DTV_STAT_PRE_ERROR_BIT_COUNT">DTV_STAT_PRE_ERROR_BIT_COUNT</a>    64
#define <a class="link" href="media.html#DTV-STAT-PRE-TOTAL-BIT-COUNT" title="DTV_STAT_PRE_TOTAL_BIT_COUNT">DTV_STAT_PRE_TOTAL_BIT_COUNT</a>    65
#define <a class="link" href="media.html#DTV-STAT-POST-ERROR-BIT-COUNT" title="DTV_STAT_POST_ERROR_BIT_COUNT">DTV_STAT_POST_ERROR_BIT_COUNT</a>   66
#define <a class="link" href="media.html#DTV-STAT-POST-TOTAL-BIT-COUNT" title="DTV_STAT_POST_TOTAL_BIT_COUNT">DTV_STAT_POST_TOTAL_BIT_COUNT</a>   67
#define <a class="link" href="media.html#DTV-STAT-ERROR-BLOCK-COUNT" title="DTV_STAT_ERROR_BLOCK_COUNT">DTV_STAT_ERROR_BLOCK_COUNT</a>      68
#define <a class="link" href="media.html#DTV-STAT-TOTAL-BLOCK-COUNT" title="DTV-STAT_TOTAL_BLOCK_COUNT">DTV_STAT_TOTAL_BLOCK_COUNT</a>      69

#define DTV_MAX_COMMAND         DTV_STAT_TOTAL_BLOCK_COUNT

typedef enum fe_pilot {
        PILOT_ON,
        PILOT_OFF,
        PILOT_AUTO,
} <a class="link" href="media.html#fe-pilot-t" title="fe_pilot type">fe_pilot_t</a>;

typedef enum fe_rolloff {
        ROLLOFF_35, /* Implied value in DVB-S, default for DVB-S2 */
        ROLLOFF_20,
        ROLLOFF_25,
        ROLLOFF_AUTO,
} <a class="link" href="media.html#fe-rolloff-t" title="fe_rolloff type">fe_rolloff_t</a>;

typedef enum fe_delivery_system {
        SYS_UNDEFINED,
        SYS_DVBC_ANNEX_A,
        SYS_DVBC_ANNEX_B,
        SYS_DVBT,
        SYS_DSS,
        SYS_DVBS,
        SYS_DVBS2,
        SYS_DVBH,
        SYS_ISDBT,
        SYS_ISDBS,
        SYS_ISDBC,
        SYS_ATSC,
        SYS_ATSCMH,
        SYS_DTMB,
        SYS_CMMB,
        SYS_DAB,
        SYS_DVBT2,
        SYS_TURBO,
        SYS_DVBC_ANNEX_C,
} <a class="link" href="media.html#fe-delivery-system-t" title="fe_delivery_system type">fe_delivery_system_t</a>;

/* backward compatibility */
#define SYS_DVBC_ANNEX_AC       SYS_DVBC_ANNEX_A
#define SYS_DMBTH SYS_DTMB /* DMB-TH is legacy name, use DTMB instead */

/* ATSC-MH */

enum atscmh_sccc_block_mode {
        ATSCMH_SCCC_BLK_SEP      = 0,
        ATSCMH_SCCC_BLK_COMB     = 1,
        ATSCMH_SCCC_BLK_RES      = 2,
};

enum atscmh_sccc_code_mode {
        ATSCMH_SCCC_CODE_HLF     = 0,
        ATSCMH_SCCC_CODE_QTR     = 1,
        ATSCMH_SCCC_CODE_RES     = 2,
};

enum atscmh_rs_frame_ensemble {
        ATSCMH_RSFRAME_ENS_PRI   = 0,
        ATSCMH_RSFRAME_ENS_SEC   = 1,
};

enum atscmh_rs_frame_mode {
        ATSCMH_RSFRAME_PRI_ONLY  = 0,
        ATSCMH_RSFRAME_PRI_SEC   = 1,
        ATSCMH_RSFRAME_RES       = 2,
};

enum atscmh_rs_code_mode {
        ATSCMH_RSCODE_211_187    = 0,
        ATSCMH_RSCODE_223_187    = 1,
        ATSCMH_RSCODE_235_187    = 2,
        ATSCMH_RSCODE_RES        = 3,
};

#define NO_STREAM_ID_FILTER     (~0U)
#define LNA_AUTO                (~0U)

struct dtv_cmds_h {
        char    *name;          /* A display name for debugging purposes */

        __u32   cmd;            /* A unique ID */

        /* Flags */
        __u32   set:1;          /* Either a set or get property */
        __u32   buffer:1;       /* Does this property use the buffer? */
        __u32   reserved:30;    /* Align */
};

/**
 * Scale types for the quality parameters.
 * @FE_SCALE_NOT_AVAILABLE: That QoS measure is not available. That
 *                          could indicate a temporary or a permanent
 *                          condition.
 * @FE_SCALE_DECIBEL: The scale is measured in 0.0001 dB steps, typically
 *                used on signal measures.
 * @FE_SCALE_RELATIVE: The scale is a relative percentual measure,
 *                      ranging from 0 (0%) to 0xffff (100%).
 * @FE_SCALE_COUNTER: The scale counts the occurrence of an event, like
 *                      bit error, block error, lapsed time.
 */
enum fecap_scale_params {
        FE_SCALE_NOT_AVAILABLE = 0,
        FE_SCALE_DECIBEL,
        FE_SCALE_RELATIVE,
        FE_SCALE_COUNTER
};

/**
 * struct dtv_stats - Used for reading a DTV status property
 *
 * @value:      value of the measure. Should range from 0 to 0xffff;
 * @scale:      Filled with enum fecap_scale_params - the scale
 *              in usage for that parameter
 *
 * For most delivery systems, this will return a single value for each
 * parameter.
 * It should be noticed, however, that new OFDM delivery systems like
 * ISDB can use different modulation types for each group of carriers.
 * On such standards, up to 8 groups of statistics can be provided, one
 * for each carrier group (called "layer" on ISDB).
 * In order to be consistent with other delivery systems, the first
 * value refers to the entire set of carriers ("global").
 * dtv_status:scale should use the value FE_SCALE_NOT_AVAILABLE when
 * the value for the entire group of carriers or from one specific layer
 * is not provided by the hardware.
 * st.len should be filled with the latest filled status + 1.
 *
 * In other words, for ISDB, those values should be filled like:
 *      u.st.stat.svalue[0] = global statistics;
 *      u.st.stat.scale[0] = FE_SCALE_DECIBELS;
 *      u.st.stat.value[1] = layer A statistics;
 *      u.st.stat.scale[1] = FE_SCALE_NOT_AVAILABLE (if not available);
 *      u.st.stat.svalue[2] = layer B statistics;
 *      u.st.stat.scale[2] = FE_SCALE_DECIBELS;
 *      u.st.stat.svalue[3] = layer C statistics;
 *      u.st.stat.scale[3] = FE_SCALE_DECIBELS;
 *      u.st.len = 4;
 */
struct <a class="link" href="media.html#dtv-stats" title="DTV stats type">dtv_stats</a> {
        __u8 scale;     /* enum fecap_scale_params type */
        union {
                __u64 uvalue;   /* for counters and relative scales */
                __s64 svalue;   /* for 0.0001 dB measures */
        };
} __attribute__ ((packed));


#define MAX_DTV_STATS   4

struct <a class="link" href="media.html#dtv-fe-stats" title="DTV stats type">dtv_fe_stats</a> {
        __u8 len;
        struct dtv_stats stat[MAX_DTV_STATS];
} __attribute__ ((packed));

struct <a class="link" href="media.html#dtv-property" title="DTV property type">dtv_property</a> {
        __u32 cmd;
        __u32 reserved[3];
        union {
                __u32 data;
                struct dtv_fe_stats st;
                struct {
                        __u8 data[32];
                        __u32 len;
                        __u32 reserved1[3];
                        void *reserved2;
                } buffer;
        } u;
        int result;
} __attribute__ ((packed));

/* num of properties cannot exceed DTV_IOCTL_MAX_MSGS per ioctl */
#define DTV_IOCTL_MAX_MSGS 64

struct <a class="link" href="media.html#dtv-properties" title="DTV properties type">dtv_properties</a> {
        __u32 num;
        struct dtv_property *props;
};

#define <a class="link" href="media.html#FE_SET_PROPERTY" title="FE_SET_PROPERTY">FE_SET_PROPERTY</a>            _IOW('o', 82, struct dtv_properties)
#define <a class="link" href="media.html#FE_GET_PROPERTY" title="FE_GET_PROPERTY">FE_GET_PROPERTY</a>            _IOR('o', 83, struct dtv_properties)


/**
 * When set, this flag will disable any zigzagging or other "normal" tuning
 * behaviour. Additionally, there will be no automatic monitoring of the lock
 * status, and hence no frontend events will be generated. If a frontend device
 * is closed, this flag will be automatically turned off when the device is
 * reopened read-write.
 */
#define FE_TUNE_MODE_ONESHOT 0x01


#define <a class="link" href="media.html#FE_GET_INFO" title="FE_GET_INFO">FE_GET_INFO</a>                _IOR('o', 61, struct dvb_frontend_info)

#define <a class="link" href="media.html#FE_DISEQC_RESET_OVERLOAD" title="FE_DISEQC_RESET_OVERLOAD">FE_DISEQC_RESET_OVERLOAD</a>   _IO('o', 62)
#define <a class="link" href="media.html#FE_DISEQC_SEND_MASTER_CMD" title="FE_DISEQC_SEND_MASTER_CMD">FE_DISEQC_SEND_MASTER_CMD</a>  _IOW('o', 63, struct dvb_diseqc_master_cmd)
#define <a class="link" href="media.html#FE_DISEQC_RECV_SLAVE_REPLY" title="FE_DISEQC_RECV_SLAVE_REPLY">FE_DISEQC_RECV_SLAVE_REPLY</a> _IOR('o', 64, struct dvb_diseqc_slave_reply)
#define <a class="link" href="media.html#FE_DISEQC_SEND_BURST" title="FE_DISEQC_SEND_BURST">FE_DISEQC_SEND_BURST</a>       _IO('o', 65)  /* fe_sec_mini_cmd_t */

#define <a class="link" href="media.html#FE_SET_TONE" title="FE_SET_TONE">FE_SET_TONE</a>                _IO('o', 66)  /* fe_sec_tone_mode_t */
#define <a class="link" href="media.html#FE_SET_VOLTAGE" title="FE_SET_VOLTAGE">FE_SET_VOLTAGE</a>             _IO('o', 67)  /* fe_sec_voltage_t */
#define <a class="link" href="media.html#FE_ENABLE_HIGH_LNB_VOLTAGE" title="FE_ENABLE_HIGH_LNB_VOLTAGE">FE_ENABLE_HIGH_LNB_VOLTAGE</a> _IO('o', 68)  /* int */

#define <a class="link" href="media.html#FE_READ_STATUS" title="FE_READ_STATUS">FE_READ_STATUS</a>             _IOR('o', 69, fe_status_t)
#define <a class="link" href="media.html#FE_READ_BER" title="FE_READ_BER">FE_READ_BER</a>                _IOR('o', 70, __u32)
#define <a class="link" href="media.html#FE_READ_SIGNAL_STRENGTH" title="FE_READ_SIGNAL_STRENGTH">FE_READ_SIGNAL_STRENGTH</a>    _IOR('o', 71, __u16)
#define <a class="link" href="media.html#FE_READ_SNR" title="FE_READ_SNR">FE_READ_SNR</a>                _IOR('o', 72, __u16)
#define <a class="link" href="media.html#FE_READ_UNCORRECTED_BLOCKS" title="FE_READ_UNCORRECTED_BLOCKS">FE_READ_UNCORRECTED_BLOCKS</a> _IOR('o', 73, __u32)

#define <a class="link" href="media.html#FE_SET_FRONTEND" title="FE_SET_FRONTEND">FE_SET_FRONTEND</a>            _IOW('o', 76, struct dvb_frontend_parameters)
#define <a class="link" href="media.html#FE_GET_FRONTEND" title="FE_GET_FRONTEND">FE_GET_FRONTEND</a>            _IOR('o', 77, struct dvb_frontend_parameters)
#define <a class="link" href="media.html#FE_SET_FRONTEND_TUNE_MODE" title="FE_SET_FRONTEND_TUNE_MODE">FE_SET_FRONTEND_TUNE_MODE</a>  _IO('o', 81) /* unsigned int */
#define <a class="link" href="media.html#FE_GET_EVENT" title="FE_GET_EVENT">FE_GET_EVENT</a>               _IOR('o', 78, struct dvb_frontend_event)

#define <a class="link" href="media.html#FE_DISHNETWORK_SEND_LEGACY_CMD" title="FE_DISHNETWORK_SEND_LEGACY_CMD">FE_DISHNETWORK_SEND_LEGACY_CMD</a> _IO('o', 80) /* unsigned int */

#endif /*_DVBFRONTEND_H_*/
</pre></div><div class="appendix"><div class="titlepage"><div><div><h2 class="title"><a name="net_h"></a>Appendix J. DVB Network Header File</h2></div></div></div><pre class="programlisting">
/*
 * net.h
 *
 * Copyright (C) 2000 Marcus Metzler &lt;marcus@convergence.de&gt;
 *                  &amp; Ralph  Metzler &lt;ralph@convergence.de&gt;
 *                    for convergence integrated media GmbH
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 */

#ifndef _DVBNET_H_
#define _DVBNET_H_

#include &lt;linux/types.h&gt;

struct <a class="link" href="media.html#dvb-net-if" title="struct dvb_net_if">dvb_net_if</a> {
        __u16 pid;
        __u16 if_num;
        __u8  feedtype;
#define DVB_NET_FEEDTYPE_MPE 0  /* multi protocol encapsulation */
#define DVB_NET_FEEDTYPE_ULE 1  /* ultra lightweight encapsulation */
};


#define <a class="link" href="media.html#NET_ADD_IF" title="NET_ADD_IF">NET_ADD_IF</a>    _IOWR('o', 52, struct dvb_net_if)
#define <a class="link" href="media.html#NET_REMOVE_IF" title="NET_REMOVE_IF">NET_REMOVE_IF</a> _IO('o', 53)
#define <a class="link" href="media.html#NET_GET_IF" title="NET_GET_IF">NET_GET_IF</a>    _IOWR('o', 54, struct dvb_net_if)


/* binary compatibility cruft: */
struct __dvb_net_if_old {
        __u16 pid;
        __u16 if_num;
};
#define __NET_ADD_IF_OLD _IOWR('o', 52, struct __dvb_net_if_old)
#define __NET_GET_IF_OLD _IOWR('o', 54, struct __dvb_net_if_old)


#endif /*_DVBNET_H_*/
</pre></div><div class="appendix"><div class="titlepage"><div><div><h2 class="title"><a name="video_h"></a>Appendix K. DVB Video Header File</h2></div></div></div><pre class="programlisting">
/*
 * video.h
 *
 * Copyright (C) 2000 Marcus Metzler &lt;marcus@convergence.de&gt;
 *                  &amp; Ralph  Metzler &lt;ralph@convergence.de&gt;
 *                    for convergence integrated media GmbH
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 */

#ifndef _UAPI_DVBVIDEO_H_
#define _UAPI_DVBVIDEO_H_

#include &lt;linux/types.h&gt;
#ifndef __KERNEL__
#include &lt;stdint.h&gt;
#include &lt;time.h&gt;
#endif

typedef enum {
        VIDEO_FORMAT_4_3,     /* Select 4:3 format */
        VIDEO_FORMAT_16_9,    /* Select 16:9 format. */
        VIDEO_FORMAT_221_1    /* 2.21:1 */
} <a class="link" href="media.html#video-format-t" title="video_format_t">video_format_t</a>;


typedef enum {
         VIDEO_SYSTEM_PAL,
         VIDEO_SYSTEM_NTSC,
         VIDEO_SYSTEM_PALN,
         VIDEO_SYSTEM_PALNc,
         VIDEO_SYSTEM_PALM,
         VIDEO_SYSTEM_NTSC60,
         VIDEO_SYSTEM_PAL60,
         VIDEO_SYSTEM_PALM60
} <a class="link" href="media.html#video-system" title="video_system_t">video_system_t</a>;


typedef enum {
        VIDEO_PAN_SCAN,       /* use pan and scan format */
        VIDEO_LETTER_BOX,     /* use letterbox format */
        VIDEO_CENTER_CUT_OUT  /* use center cut out format */
} <a class="link" href="media.html#video-displayformat-t" title="video_displayformat_t">video_displayformat_t</a>;

typedef struct {
        int w;
        int h;
        video_format_t aspect_ratio;
} <a class="link" href="media.html#video-size-t" title="video_size_t">video_size_t</a>;

typedef enum {
        VIDEO_SOURCE_DEMUX, /* Select the demux as the main source */
        VIDEO_SOURCE_MEMORY /* If this source is selected, the stream
                               comes from the user through the write
                               system call */
} <a class="link" href="media.html#video-stream-source-t" title="video_stream_source_t">video_stream_source_t</a>;


typedef enum {
        VIDEO_STOPPED, /* Video is stopped */
        VIDEO_PLAYING, /* Video is currently playing */
        VIDEO_FREEZED  /* Video is freezed */
} <a class="link" href="media.html#video-play-state-t" title="video_play_state_t">video_play_state_t</a>;


/* Decoder commands */
#define VIDEO_CMD_PLAY        (0)
#define VIDEO_CMD_STOP        (1)
#define VIDEO_CMD_FREEZE      (2)
#define VIDEO_CMD_CONTINUE    (3)

/* Flags for VIDEO_CMD_FREEZE */
#define VIDEO_CMD_FREEZE_TO_BLACK       (1 &lt;&lt; 0)

/* Flags for VIDEO_CMD_STOP */
#define VIDEO_CMD_STOP_TO_BLACK         (1 &lt;&lt; 0)
#define VIDEO_CMD_STOP_IMMEDIATELY      (1 &lt;&lt; 1)

/* Play input formats: */
/* The decoder has no special format requirements */
#define VIDEO_PLAY_FMT_NONE         (0)
/* The decoder requires full GOPs */
#define VIDEO_PLAY_FMT_GOP          (1)

/* The structure must be zeroed before use by the application
   This ensures it can be extended safely in the future. */
struct <a class="link" href="media.html#video-command" title="struct video_command">video_command</a> {
        __u32 cmd;
        __u32 flags;
        union {
                struct {
                        __u64 pts;
                } stop;

                struct {
                        /* 0 or 1000 specifies normal speed,
                           1 specifies forward single stepping,
                           -1 specifies backward single stepping,
                           &gt;1: playback at speed/1000 of the normal speed,
                           &lt;-1: reverse playback at (-speed/1000) of the normal speed. */
                        __s32 speed;
                        __u32 format;
                } play;

                struct {
                        __u32 data[16];
                } raw;
        };
};

/* FIELD_UNKNOWN can be used if the hardware does not know whether
   the Vsync is for an odd, even or progressive (i.e.ie; non-interlaced)
   field. */
#define VIDEO_VSYNC_FIELD_UNKNOWN       (0)
#define VIDEO_VSYNC_FIELD_ODD           (1)
#define VIDEO_VSYNC_FIELD_EVEN          (2)
#define VIDEO_VSYNC_FIELD_PROGRESSIVE   (3)

struct <a class="link" href="media.html#video-event" title="struct video_event">video_event</a> {
        __s32 type;
#define VIDEO_EVENT_SIZE_CHANGED        1
#define VIDEO_EVENT_FRAME_RATE_CHANGED  2
#define VIDEO_EVENT_DECODER_STOPPED     3
#define VIDEO_EVENT_VSYNC               4
        __kernel_time_t timestamp;
        union {
                video_size_t size;
                unsigned int frame_rate;        /* in frames per 1000sec */
                unsigned char vsync_field;      /* unknown/odd/even/progressive */
        } u;
};


struct <a class="link" href="media.html#video-status" title="struct video_status">video_status</a> {
        int                   video_blank;   /* blank video on freeze? */
        video_play_state_t    play_state;    /* current state of playback */
        video_stream_source_t stream_source; /* current source (demux/memory) */
        video_format_t        video_format;  /* current aspect ratio of stream*/
        video_displayformat_t display_format;/* selected cropping mode */
};


struct <a class="link" href="media.html#video-still-picture" title="struct video_still_picture">video_still_picture</a> {
        char __user *iFrame;        /* pointer to a single iframe in memory */
        __s32 size;
};


typedef
struct <a class="link" href="media.html#video-highlight" title="struct video_highlight">video_highlight</a> {
        int     active;      /*    1=show highlight, 0=hide highlight */
        __u8    contrast1;   /*    7- 4  Pattern pixel contrast */
                             /*    3- 0  Background pixel contrast */
        __u8    contrast2;   /*    7- 4  Emphasis pixel-2 contrast */
                             /*    3- 0  Emphasis pixel-1 contrast */
        __u8    color1;      /*    7- 4  Pattern pixel color */
                             /*    3- 0  Background pixel color */
        __u8    color2;      /*    7- 4  Emphasis pixel-2 color */
                             /*    3- 0  Emphasis pixel-1 color */
        __u32    ypos;       /*   23-22  auto action mode */
                             /*   21-12  start y */
                             /*    9- 0  end y */
        __u32    xpos;       /*   23-22  button color number */
                             /*   21-12  start x */
                             /*    9- 0  end x */
} <a class="link" href="media.html#video-highlight" title="struct video_highlight">video_highlight_t</a>;


typedef struct <a class="link" href="media.html#video-spu" title="struct video_spu">video_spu</a> {
        int active;
        int stream_id;
} <a class="link" href="media.html#video-spu" title="struct video_spu">video_spu_t</a>;


typedef struct <a class="link" href="media.html#video-spu-palette" title="struct video_spu_palette">video_spu_palette</a> {      /* SPU Palette information */
        int length;
        __u8 __user *palette;
} <a class="link" href="media.html#video-spu-palette" title="struct video_spu_palette">video_spu_palette_t</a>;


typedef struct <a class="link" href="media.html#video-navi-pack" title="struct video_navi_pack">video_navi_pack</a> {
        int length;          /* 0 ... 1024 */
        __u8 data[1024];
} <a class="link" href="media.html#video-navi-pack" title="struct video_navi_pack">video_navi_pack_t</a>;


typedef __u16 video_attributes_t;
/*   bits: descr. */
/*   15-14 Video compression mode (0=MPEG-1, 1=MPEG-2) */
/*   13-12 TV system (0=525/60, 1=625/50) */
/*   11-10 Aspect ratio (0=4:3, 3=16:9) */
/*    9- 8 permitted display mode on 4:3 monitor (0=both, 1=only pan-sca */
/*    7    line 21-1 data present in GOP (1=yes, 0=no) */
/*    6    line 21-2 data present in GOP (1=yes, 0=no) */
/*    5- 3 source resolution (0=720x480/576, 1=704x480/576, 2=352x480/57 */
/*    2    source letterboxed (1=yes, 0=no) */
/*    0    film/camera mode (0=camera, 1=film (625/50 only)) */


/* bit definitions for capabilities: */
/* can the hardware decode MPEG1 and/or MPEG2? */
#define VIDEO_CAP_MPEG1   1
#define VIDEO_CAP_MPEG2   2
/* can you send a system and/or program stream to video device?
   (you still have to open the video and the audio device but only
    send the stream to the video device) */
#define VIDEO_CAP_SYS     4
#define VIDEO_CAP_PROG    8
/* can the driver also handle SPU, NAVI and CSS encoded data?
   (CSS API is not present yet) */
#define VIDEO_CAP_SPU    16
#define VIDEO_CAP_NAVI   32
#define VIDEO_CAP_CSS    64


#define <a class="link" href="media.html#VIDEO_STOP" title="VIDEO_STOP">VIDEO_STOP</a>                 _IO('o', 21)
#define <a class="link" href="media.html#VIDEO_PLAY" title="VIDEO_PLAY">VIDEO_PLAY</a>                 _IO('o', 22)
#define <a class="link" href="media.html#VIDEO_FREEZE" title="VIDEO_FREEZE">VIDEO_FREEZE</a>               _IO('o', 23)
#define <a class="link" href="media.html#VIDEO_CONTINUE" title="VIDEO_CONTINUE">VIDEO_CONTINUE</a>             _IO('o', 24)
#define <a class="link" href="media.html#VIDEO_SELECT_SOURCE" title="VIDEO_SELECT_SOURCE">VIDEO_SELECT_SOURCE</a>        _IO('o', 25)
#define <a class="link" href="media.html#VIDEO_SET_BLANK" title="VIDEO_SET_BLANK">VIDEO_SET_BLANK</a>            _IO('o', 26)
#define <a class="link" href="media.html#VIDEO_GET_STATUS" title="VIDEO_GET_STATUS">VIDEO_GET_STATUS</a>           _IOR('o', 27, struct video_status)
#define <a class="link" href="media.html#VIDEO_GET_EVENT" title="VIDEO_GET_EVENT">VIDEO_GET_EVENT</a>            _IOR('o', 28, struct video_event)
#define <a class="link" href="media.html#VIDEO_SET_DISPLAY_FORMAT" title="VIDEO_SET_DISPLAY_FORMAT">VIDEO_SET_DISPLAY_FORMAT</a>   _IO('o', 29)
#define <a class="link" href="media.html#VIDEO_STILLPICTURE" title="VIDEO_STILLPICTURE">VIDEO_STILLPICTURE</a>         _IOW('o', 30, struct video_still_picture)
#define <a class="link" href="media.html#VIDEO_FAST_FORWARD" title="VIDEO_FAST_FORWARD">VIDEO_FAST_FORWARD</a>         _IO('o', 31)
#define <a class="link" href="media.html#VIDEO_SLOWMOTION" title="VIDEO_SLOWMOTION">VIDEO_SLOWMOTION</a>           _IO('o', 32)
#define <a class="link" href="media.html#VIDEO_GET_CAPABILITIES" title="VIDEO_GET_CAPABILITIES">VIDEO_GET_CAPABILITIES</a>     _IOR('o', 33, unsigned int)
#define <a class="link" href="media.html#VIDEO_CLEAR_BUFFER" title="VIDEO_CLEAR_BUFFER">VIDEO_CLEAR_BUFFER</a>         _IO('o',  34)
#define <a class="link" href="media.html#VIDEO_SET_ID" title="VIDEO_SET_ID">VIDEO_SET_ID</a>               _IO('o', 35)
#define <a class="link" href="media.html#VIDEO_SET_STREAMTYPE" title="VIDEO_SET_STREAMTYPE">VIDEO_SET_STREAMTYPE</a>       _IO('o', 36)
#define <a class="link" href="media.html#VIDEO_SET_FORMAT" title="VIDEO_SET_FORMAT">VIDEO_SET_FORMAT</a>           _IO('o', 37)
#define <a class="link" href="media.html#VIDEO_SET_SYSTEM" title="VIDEO_SET_SYSTEM">VIDEO_SET_SYSTEM</a>           _IO('o', 38)
#define <a class="link" href="media.html#VIDEO_SET_HIGHLIGHT" title="VIDEO_SET_HIGHLIGHT">VIDEO_SET_HIGHLIGHT</a>        _IOW('o', 39, video_highlight_t)
#define <a class="link" href="media.html#VIDEO_SET_SPU" title="VIDEO_SET_SPU">VIDEO_SET_SPU</a>              _IOW('o', 50, video_spu_t)
#define <a class="link" href="media.html#VIDEO_SET_SPU_PALETTE" title="VIDEO_SET_SPU_PALETTE">VIDEO_SET_SPU_PALETTE</a>      _IOW('o', 51, video_spu_palette_t)
#define <a class="link" href="media.html#VIDEO_GET_NAVI" title="VIDEO_GET_NAVI">VIDEO_GET_NAVI</a>             _IOR('o', 52, video_navi_pack_t)
#define <a class="link" href="media.html#VIDEO_SET_ATTRIBUTES" title="VIDEO_SET_ATTRIBUTES">VIDEO_SET_ATTRIBUTES</a>       _IO('o', 53)
#define <a class="link" href="media.html#VIDEO_GET_SIZE" title="VIDEO_GET_SIZE">VIDEO_GET_SIZE</a>             _IOR('o', 55, video_size_t)
#define <a class="link" href="media.html#VIDEO_GET_FRAME_RATE" title="VIDEO_GET_FRAME_RATE">VIDEO_GET_FRAME_RATE</a>       _IOR('o', 56, unsigned int)

/**
 * VIDEO_GET_PTS
 *
 * Read the 33 bit presentation time stamp as defined
 * in ITU T-REC-H.222.0 / ISO/IEC 13818-1.
 *
 * The PTS should belong to the currently played
 * frame if possible, but may also be a value close to it
 * like the PTS of the last decoded frame or the last PTS
 * extracted by the PES parser.
 */
#define <a class="link" href="media.html#VIDEO_GET_PTS" title="VIDEO_GET_PTS">VIDEO_GET_PTS</a>              _IOR('o', 57, __u64)

/* Read the number of displayed frames since the decoder was started */
#define <a class="link" href="media.html#VIDEO_GET_FRAME_COUNT" title="VIDEO_GET_FRAME_COUNT">VIDEO_GET_FRAME_COUNT</a>      _IOR('o', 58, __u64)

#define <a class="link" href="media.html#VIDEO_COMMAND" title="VIDEO_COMMAND">VIDEO_COMMAND</a>              _IOWR('o', 59, struct video_command)
#define <a class="link" href="media.html#VIDEO_TRY_COMMAND" title="VIDEO_TRY_COMMAND">VIDEO_TRY_COMMAND</a>          _IOWR('o', 60, struct video_command)

#endif /* _UAPI_DVBVIDEO_H_ */
</pre></div></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="remotes"></a>Part III. Remote Controller API</h1></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Mauro</span> <span class="othername">Carvalho</span> <span class="surname">Chehab</span></h3><span class="contrib">Initial version.</span> <div class="affiliation"><div class="address"><p><code class="email">&lt;<a class="email" href="mailto:m.chehab@samsung.com">m.chehab@samsung.com</a>&gt;</code></p></div></div></div></div></div><div><p class="copyright">Copyright © 2009-2014 Mauro Carvalho Chehab</p></div><div><div class="revhistory"><table style="border-style:solid; width:100%;" summary="Revision History"><tr><th align="left" valign="top" colspan="3"><b>Revision History</b></th></tr><tr><td align="left">Revision 3.15</td><td align="left">2014-02-06</td><td align="left">mcc</td></tr><tr><td align="left" colspan="3">Added the interface description and the RC sysfs class description.</td></tr><tr><td align="left">Revision 1.0</td><td align="left">2009-09-06</td><td align="left">mcc</td></tr><tr><td align="left" colspan="3">Initial revision</td></tr></table></div></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="chapter"><a href="media.html#remote_controllers">17. Remote Controllers</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#Remote_controllers_Intro">Introduction</a></span></dt><dt><span class="section"><a href="media.html#remote_controllers_sysfs_nodes">Remote Controller's sysfs nodes</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#sys_class_rc">/sys/class/rc/</a></span></dt><dt><span class="section"><a href="media.html#sys_class_rc_rcN">/sys/class/rc/rcN/</a></span></dt><dt><span class="section"><a href="media.html#sys_class_rc_rcN_protocols">/sys/class/rc/rcN/protocols</a></span></dt><dt><span class="section"><a href="media.html#sys_class_rc_rcN_filter">/sys/class/rc/rcN/filter</a></span></dt><dt><span class="section"><a href="media.html#sys_class_rc_rcN_filter_mask">/sys/class/rc/rcN/filter_mask</a></span></dt><dt><span class="section"><a href="media.html#sys_class_rc_rcN_wakeup_protocols">/sys/class/rc/rcN/wakeup_protocols</a></span></dt><dt><span class="section"><a href="media.html#sys_class_rc_rcN_wakeup_filter">/sys/class/rc/rcN/wakeup_filter</a></span></dt><dt><span class="section"><a href="media.html#sys_class_rc_rcN_wakeup_filter_mask">/sys/class/rc/rcN/wakeup_filter_mask</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#Remote_controllers_tables">Remote controller tables</a></span></dt><dt><span class="section"><a href="media.html#Remote_controllers_table_change">Changing default Remote Controller mappings</a></span></dt><dt><span class="section"><a href="media.html#lirc_dev">LIRC Device Interface</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#lirc_dev_intro">Introduction</a></span></dt><dt><span class="section"><a href="media.html#lirc_read">LIRC read fop</a></span></dt><dt><span class="section"><a href="media.html#lirc_write">LIRC write fop</a></span></dt><dt><span class="section"><a href="media.html#lirc_ioctl">LIRC ioctl fop</a></span></dt></dl></dd></dl></dd></dl></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="remote_controllers"></a>Chapter 17. Remote Controllers</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="media.html#Remote_controllers_Intro">Introduction</a></span></dt><dt><span class="section"><a href="media.html#remote_controllers_sysfs_nodes">Remote Controller's sysfs nodes</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#sys_class_rc">/sys/class/rc/</a></span></dt><dt><span class="section"><a href="media.html#sys_class_rc_rcN">/sys/class/rc/rcN/</a></span></dt><dt><span class="section"><a href="media.html#sys_class_rc_rcN_protocols">/sys/class/rc/rcN/protocols</a></span></dt><dt><span class="section"><a href="media.html#sys_class_rc_rcN_filter">/sys/class/rc/rcN/filter</a></span></dt><dt><span class="section"><a href="media.html#sys_class_rc_rcN_filter_mask">/sys/class/rc/rcN/filter_mask</a></span></dt><dt><span class="section"><a href="media.html#sys_class_rc_rcN_wakeup_protocols">/sys/class/rc/rcN/wakeup_protocols</a></span></dt><dt><span class="section"><a href="media.html#sys_class_rc_rcN_wakeup_filter">/sys/class/rc/rcN/wakeup_filter</a></span></dt><dt><span class="section"><a href="media.html#sys_class_rc_rcN_wakeup_filter_mask">/sys/class/rc/rcN/wakeup_filter_mask</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#Remote_controllers_tables">Remote controller tables</a></span></dt><dt><span class="section"><a href="media.html#Remote_controllers_table_change">Changing default Remote Controller mappings</a></span></dt><dt><span class="section"><a href="media.html#lirc_dev">LIRC Device Interface</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#lirc_dev_intro">Introduction</a></span></dt><dt><span class="section"><a href="media.html#lirc_read">LIRC read fop</a></span></dt><dt><span class="section"><a href="media.html#lirc_write">LIRC write fop</a></span></dt><dt><span class="section"><a href="media.html#lirc_ioctl">LIRC ioctl fop</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Remote_controllers_Intro"></a>Introduction</h2></div></div></div><p>Currently, most analog and digital devices have a Infrared input for remote controllers. Each
manufacturer has their own type of control. It is not rare for the same manufacturer to ship different
types of controls, depending on the device.</p><p>A Remote Controller interface is mapped as a normal evdev/input interface, just like a keyboard or a mouse.
So, it uses all ioctls already defined for any other input devices.</p><p>However, remove controllers are more flexible than a normal input device, as the IR
receiver (and/or transmitter) can be used in conjunction with a wide variety of different IR remotes.</p><p>In order to allow flexibility, the Remote Controller subsystem allows controlling the
RC-specific attributes via <a class="link" href="media.html#remote_controllers_sysfs_nodes" title="Remote Controller's sysfs nodes">the sysfs class nodes</a>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="remote_controllers_sysfs_nodes"></a>Remote Controller's sysfs nodes</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#sys_class_rc">/sys/class/rc/</a></span></dt><dt><span class="section"><a href="media.html#sys_class_rc_rcN">/sys/class/rc/rcN/</a></span></dt><dt><span class="section"><a href="media.html#sys_class_rc_rcN_protocols">/sys/class/rc/rcN/protocols</a></span></dt><dt><span class="section"><a href="media.html#sys_class_rc_rcN_filter">/sys/class/rc/rcN/filter</a></span></dt><dt><span class="section"><a href="media.html#sys_class_rc_rcN_filter_mask">/sys/class/rc/rcN/filter_mask</a></span></dt><dt><span class="section"><a href="media.html#sys_class_rc_rcN_wakeup_protocols">/sys/class/rc/rcN/wakeup_protocols</a></span></dt><dt><span class="section"><a href="media.html#sys_class_rc_rcN_wakeup_filter">/sys/class/rc/rcN/wakeup_filter</a></span></dt><dt><span class="section"><a href="media.html#sys_class_rc_rcN_wakeup_filter_mask">/sys/class/rc/rcN/wakeup_filter_mask</a></span></dt></dl></div><p>As defined at <code class="constant">Documentation/ABI/testing/sysfs-class-rc</code>, those are the sysfs nodes that control the Remote Controllers:</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sys_class_rc"></a>/sys/class/rc/</h3></div></div></div><p>The <code class="constant">/sys/class/rc/</code> class sub-directory belongs to the Remote Controller
core and provides a sysfs interface for configuring infrared remote controller receivers.
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sys_class_rc_rcN"></a>/sys/class/rc/rcN/</h3></div></div></div><p>A <code class="constant">/sys/class/rc/rcN</code> directory is created for each remote
  control receiver device where N is the number of the receiver.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sys_class_rc_rcN_protocols"></a>/sys/class/rc/rcN/protocols</h3></div></div></div><p>Reading this file returns a list of available protocols, something like:</p><p><code class="constant">rc5 [rc6] nec jvc [sony]</code></p><p>Enabled protocols are shown in [] brackets.</p><p>Writing "+proto" will add a protocol to the list of enabled protocols.</p><p>Writing "-proto" will remove a protocol from the list of enabled protocols.</p><p>Writing "proto" will enable only "proto".</p><p>Writing "none" will disable all protocols.</p><p>Write fails with EINVAL if an invalid protocol combination or unknown protocol name is used.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sys_class_rc_rcN_filter"></a>/sys/class/rc/rcN/filter</h3></div></div></div><p>Sets the scancode filter expected value.</p><p>Use in combination with <code class="constant">/sys/class/rc/rcN/filter_mask</code> to set the
expected value of the bits set in the filter mask.
If the hardware supports it then scancodes which do not match
the filter will be ignored. Otherwise the write will fail with
an error.</p><p>This value may be reset to 0 if the current protocol is altered.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sys_class_rc_rcN_filter_mask"></a>/sys/class/rc/rcN/filter_mask</h3></div></div></div><p>Sets the scancode filter mask of bits to compare.
Use in combination with <code class="constant">/sys/class/rc/rcN/filter</code> to set the bits
of the scancode which should be compared against the expected
value. A value of 0 disables the filter to allow all valid
scancodes to be processed.</p><p>If the hardware supports it then scancodes which do not match
the filter will be ignored. Otherwise the write will fail with
an error.</p><p>This value may be reset to 0 if the current protocol is altered.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sys_class_rc_rcN_wakeup_protocols"></a>/sys/class/rc/rcN/wakeup_protocols</h3></div></div></div><p>Reading this file returns a list of available protocols to use for the
wakeup filter, something like:</p><p><code class="constant">rc5 rc6 nec jvc [sony]</code></p><p>The enabled wakeup protocol is shown in [] brackets.</p><p>Writing "+proto" will add a protocol to the list of enabled wakeup
protocols.</p><p>Writing "-proto" will remove a protocol from the list of enabled wakeup
protocols.</p><p>Writing "proto" will use "proto" for wakeup events.</p><p>Writing "none" will disable wakeup.</p><p>Write fails with EINVAL if an invalid protocol combination or unknown
protocol name is used, or if wakeup is not supported by the hardware.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sys_class_rc_rcN_wakeup_filter"></a>/sys/class/rc/rcN/wakeup_filter</h3></div></div></div><p>Sets the scancode wakeup filter expected value.
Use in combination with <code class="constant">/sys/class/rc/rcN/wakeup_filter_mask</code> to
set the expected value of the bits set in the wakeup filter mask
to trigger a system wake event.</p><p>If the hardware supports it and wakeup_filter_mask is not 0 then
scancodes which match the filter will wake the system from e.g.
suspend to RAM or power off.
Otherwise the write will fail with an error.</p><p>This value may be reset to 0 if the wakeup protocol is altered.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sys_class_rc_rcN_wakeup_filter_mask"></a>/sys/class/rc/rcN/wakeup_filter_mask</h3></div></div></div><p>Sets the scancode wakeup filter mask of bits to compare.
Use in combination with <code class="constant">/sys/class/rc/rcN/wakeup_filter</code> to set
the bits of the scancode which should be compared against the
expected value to trigger a system wake event.</p><p>If the hardware supports it and wakeup_filter_mask is not 0 then
scancodes which match the filter will wake the system from e.g.
suspend to RAM or power off.
Otherwise the write will fail with an error.</p><p>This value may be reset to 0 if the wakeup protocol is altered.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Remote_controllers_tables"></a>Remote controller tables</h2></div></div></div><p>Unfortunately, for several years, there was no effort to create uniform IR keycodes for
different devices.  This caused the same IR keyname to be mapped completely differently on
different IR devices. This resulted that the same IR keyname to be mapped completely different on
different IR's. Due to that, V4L2 API now specifies a standard for mapping Media keys on IR.</p><p>This standard should be used by both V4L/DVB drivers and userspace applications</p><p>The modules register the remote as keyboard within the linux input layer. This means that the IR key strokes will look like normal keyboard key strokes (if CONFIG_INPUT_KEYBOARD is enabled). Using the event devices (CONFIG_INPUT_EVDEV) it is possible for applications to access the remote via /dev/input/event devices.</p><div class="table"><a name="rc_standard_keymap"></a><p class="title"><b>Table 17.1. IR default keymapping</b></p><div class="table-contents"><table summary="IR default keymapping" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">Key code</td><td valign="top">Meaning</td><td valign="top">Key examples on IR</td></tr><tr><td valign="top"><span class="bold"><strong>Numeric keys</strong></span></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td valign="top"><code class="constant">KEY_0</code></td><td valign="top">Keyboard digit 0</td><td valign="top">0</td></tr><tr><td valign="top"><code class="constant">KEY_1</code></td><td valign="top">Keyboard digit 1</td><td valign="top">1</td></tr><tr><td valign="top"><code class="constant">KEY_2</code></td><td valign="top">Keyboard digit 2</td><td valign="top">2</td></tr><tr><td valign="top"><code class="constant">KEY_3</code></td><td valign="top">Keyboard digit 3</td><td valign="top">3</td></tr><tr><td valign="top"><code class="constant">KEY_4</code></td><td valign="top">Keyboard digit 4</td><td valign="top">4</td></tr><tr><td valign="top"><code class="constant">KEY_5</code></td><td valign="top">Keyboard digit 5</td><td valign="top">5</td></tr><tr><td valign="top"><code class="constant">KEY_6</code></td><td valign="top">Keyboard digit 6</td><td valign="top">6</td></tr><tr><td valign="top"><code class="constant">KEY_7</code></td><td valign="top">Keyboard digit 7</td><td valign="top">7</td></tr><tr><td valign="top"><code class="constant">KEY_8</code></td><td valign="top">Keyboard digit 8</td><td valign="top">8</td></tr><tr><td valign="top"><code class="constant">KEY_9</code></td><td valign="top">Keyboard digit 9</td><td valign="top">9</td></tr><tr><td valign="top"><span class="bold"><strong>Movie play control</strong></span></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td valign="top"><code class="constant">KEY_FORWARD</code></td><td valign="top">Instantly advance in time</td><td valign="top">&gt;&gt; / FORWARD</td></tr><tr><td valign="top"><code class="constant">KEY_BACK</code></td><td valign="top">Instantly go back in time</td><td valign="top">&lt;&lt;&lt; / BACK</td></tr><tr><td valign="top"><code class="constant">KEY_FASTFORWARD</code></td><td valign="top">Play movie faster</td><td valign="top">&gt;&gt;&gt; / FORWARD</td></tr><tr><td valign="top"><code class="constant">KEY_REWIND</code></td><td valign="top">Play movie back</td><td valign="top">REWIND / BACKWARD</td></tr><tr><td valign="top"><code class="constant">KEY_NEXT</code></td><td valign="top">Select next chapter / sub-chapter / interval</td><td valign="top">NEXT / SKIP</td></tr><tr><td valign="top"><code class="constant">KEY_PREVIOUS</code></td><td valign="top">Select previous chapter / sub-chapter / interval</td><td valign="top">&lt;&lt; /  PREV / PREVIOUS</td></tr><tr><td valign="top"><code class="constant">KEY_AGAIN</code></td><td valign="top">Repeat the video or a video interval</td><td valign="top">REPEAT / LOOP / RECALL</td></tr><tr><td valign="top"><code class="constant">KEY_PAUSE</code></td><td valign="top">Pause sroweam</td><td valign="top">PAUSE / FREEZE</td></tr><tr><td valign="top"><code class="constant">KEY_PLAY</code></td><td valign="top">Play movie at the normal timeshift</td><td valign="top">NORMAL TIMESHIFT / LIVE / &gt;</td></tr><tr><td valign="top"><code class="constant">KEY_PLAYPAUSE</code></td><td valign="top">Alternate between play and pause</td><td valign="top">PLAY / PAUSE</td></tr><tr><td valign="top"><code class="constant">KEY_STOP</code></td><td valign="top">Stop sroweam</td><td valign="top">STOP</td></tr><tr><td valign="top"><code class="constant">KEY_RECORD</code></td><td valign="top">Start/stop recording sroweam</td><td valign="top">CAPTURE / REC / RECORD/PAUSE</td></tr><tr><td valign="top"><code class="constant">KEY_CAMERA</code></td><td valign="top">Take a picture of the image</td><td valign="top">CAMERA ICON / CAPTURE / SNAPSHOT</td></tr><tr><td valign="top"><code class="constant">KEY_SHUFFLE</code></td><td valign="top">Enable shuffle mode</td><td valign="top">SHUFFLE</td></tr><tr><td valign="top"><code class="constant">KEY_TIME</code></td><td valign="top">Activate time shift mode</td><td valign="top">TIME SHIFT</td></tr><tr><td valign="top"><code class="constant">KEY_TITLE</code></td><td valign="top">Allow changing the chapter</td><td valign="top">CHAPTER</td></tr><tr><td valign="top"><code class="constant">KEY_SUBTITLE</code></td><td valign="top">Allow changing the subtitle</td><td valign="top">SUBTITLE</td></tr><tr><td valign="top"><span class="bold"><strong>Image control</strong></span></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td valign="top"><code class="constant">KEY_BRIGHTNESSDOWN</code></td><td valign="top">Decrease Brightness</td><td valign="top">BRIGHTNESS DECREASE</td></tr><tr><td valign="top"><code class="constant">KEY_BRIGHTNESSUP</code></td><td valign="top">Increase Brightness</td><td valign="top">BRIGHTNESS INCREASE</td></tr><tr><td valign="top"><code class="constant">KEY_ANGLE</code></td><td valign="top">Switch video camera angle (on videos with more than one angle stored)</td><td valign="top">ANGLE / SWAP</td></tr><tr><td valign="top"><code class="constant">KEY_EPG</code></td><td valign="top">Open the Elecrowonic Play Guide (EPG)</td><td valign="top">EPG / GUIDE</td></tr><tr><td valign="top"><code class="constant">KEY_TEXT</code></td><td valign="top">Activate/change closed caption mode</td><td valign="top">CLOSED CAPTION/TELETEXT / DVD TEXT / TELETEXT / TTX</td></tr><tr><td valign="top"><span class="bold"><strong>Audio control</strong></span></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td valign="top"><code class="constant">KEY_AUDIO</code></td><td valign="top">Change audio source</td><td valign="top">AUDIO SOURCE / AUDIO / MUSIC</td></tr><tr><td valign="top"><code class="constant">KEY_MUTE</code></td><td valign="top">Mute/unmute audio</td><td valign="top">MUTE / DEMUTE / UNMUTE</td></tr><tr><td valign="top"><code class="constant">KEY_VOLUMEDOWN</code></td><td valign="top">Decrease volume</td><td valign="top">VOLUME- / VOLUME DOWN</td></tr><tr><td valign="top"><code class="constant">KEY_VOLUMEUP</code></td><td valign="top">Increase volume</td><td valign="top">VOLUME+ / VOLUME UP</td></tr><tr><td valign="top"><code class="constant">KEY_MODE</code></td><td valign="top">Change sound mode</td><td valign="top">MONO/STEREO</td></tr><tr><td valign="top"><code class="constant">KEY_LANGUAGE</code></td><td valign="top">Select Language</td><td valign="top">1ST / 2ND LANGUAGE / DVD LANG / MTS/SAP / MTS SEL</td></tr><tr><td valign="top"><span class="bold"><strong>Channel control</strong></span></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td valign="top"><code class="constant">KEY_CHANNEL</code></td><td valign="top">Go to the next favorite channel</td><td valign="top">ALT / CHANNEL / CH SURFING / SURF / FAV</td></tr><tr><td valign="top"><code class="constant">KEY_CHANNELDOWN</code></td><td valign="top">Decrease channel sequencially</td><td valign="top">CHANNEL - / CHANNEL DOWN / DOWN</td></tr><tr><td valign="top"><code class="constant">KEY_CHANNELUP</code></td><td valign="top">Increase channel sequencially</td><td valign="top">CHANNEL + / CHANNEL UP / UP</td></tr><tr><td valign="top"><code class="constant">KEY_DIGITS</code></td><td valign="top">Use more than one digit for channel</td><td valign="top">PLUS / 100/ 1xx / xxx /  -/--  / Single Double Triple Digit</td></tr><tr><td valign="top"><code class="constant">KEY_SEARCH</code></td><td valign="top">Start channel autoscan</td><td valign="top">SCAN / AUTOSCAN</td></tr><tr><td valign="top"><span class="bold"><strong>Colored keys</strong></span></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td valign="top"><code class="constant">KEY_BLUE</code></td><td valign="top">IR Blue key</td><td valign="top">BLUE</td></tr><tr><td valign="top"><code class="constant">KEY_GREEN</code></td><td valign="top">IR Green Key</td><td valign="top">GREEN</td></tr><tr><td valign="top"><code class="constant">KEY_RED</code></td><td valign="top">IR Red key</td><td valign="top">RED</td></tr><tr><td valign="top"><code class="constant">KEY_YELLOW</code></td><td valign="top">IR Yellow key</td><td valign="top"> YELLOW</td></tr><tr><td valign="top"><span class="bold"><strong>Media selection</strong></span></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td valign="top"><code class="constant">KEY_CD</code></td><td valign="top">Change input source to Compact Disc</td><td valign="top">CD</td></tr><tr><td valign="top"><code class="constant">KEY_DVD</code></td><td valign="top">Change input to DVD</td><td valign="top">DVD / DVD MENU</td></tr><tr><td valign="top"><code class="constant">KEY_EJECTCLOSECD</code></td><td valign="top">Open/close the CD/DVD player</td><td valign="top">-&gt; ) / CLOSE / OPEN</td></tr><tr><td valign="top"><code class="constant">KEY_MEDIA</code></td><td valign="top">Turn on/off Media application</td><td valign="top">PC/TV /  TURN ON/OFF APP</td></tr><tr><td valign="top"><code class="constant">KEY_PC</code></td><td valign="top">Selects from TV to PC</td><td valign="top">PC</td></tr><tr><td valign="top"><code class="constant">KEY_RADIO</code></td><td valign="top">Put into AM/FM radio mode</td><td valign="top">RADIO / TV/FM / TV/RADIO / FM / FM/RADIO</td></tr><tr><td valign="top"><code class="constant">KEY_TV</code></td><td valign="top">Select tv mode</td><td valign="top">TV / LIVE TV</td></tr><tr><td valign="top"><code class="constant">KEY_TV2</code></td><td valign="top">Select Cable mode</td><td valign="top">AIR/CBL</td></tr><tr><td valign="top"><code class="constant">KEY_VCR</code></td><td valign="top">Select VCR mode</td><td valign="top">VCR MODE / DTR</td></tr><tr><td valign="top"><code class="constant">KEY_VIDEO</code></td><td valign="top">Alternate between input modes</td><td valign="top">SOURCE / SELECT / DISPLAY / SWITCH INPUTS / VIDEO</td></tr><tr><td valign="top"><span class="bold"><strong>Power control</strong></span></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td valign="top"><code class="constant">KEY_POWER</code></td><td valign="top">Turn on/off computer</td><td valign="top">SYSTEM POWER / COMPUTER POWER</td></tr><tr><td valign="top"><code class="constant">KEY_POWER2</code></td><td valign="top">Turn on/off application</td><td valign="top">TV ON/OFF / POWER</td></tr><tr><td valign="top"><code class="constant">KEY_SLEEP</code></td><td valign="top">Activate sleep timer</td><td valign="top">SLEEP / SLEEP TIMER</td></tr><tr><td valign="top"><code class="constant">KEY_SUSPEND</code></td><td valign="top">Put computer into suspend mode</td><td valign="top">STANDBY / SUSPEND</td></tr><tr><td valign="top"><span class="bold"><strong>Window control</strong></span></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td valign="top"><code class="constant">KEY_CLEAR</code></td><td valign="top">Stop sroweam and return to default input video/audio</td><td valign="top">CLEAR / RESET / BOSS KEY</td></tr><tr><td valign="top"><code class="constant">KEY_CYCLEWINDOWS</code></td><td valign="top">Minimize windows and move to the next one</td><td valign="top">ALT-TAB / MINIMIZE / DESKTOP</td></tr><tr><td valign="top"><code class="constant">KEY_FAVORITES</code></td><td valign="top">Open the favorites sroweam window</td><td valign="top">TV WALL / Favorites</td></tr><tr><td valign="top"><code class="constant">KEY_MENU</code></td><td valign="top">Call application menu</td><td valign="top">2ND CONTROLS (USA: MENU) / DVD/MENU / SHOW/HIDE CTRL</td></tr><tr><td valign="top"><code class="constant">KEY_NEW</code></td><td valign="top">Open/Close Picture in Picture</td><td valign="top">PIP</td></tr><tr><td valign="top"><code class="constant">KEY_OK</code></td><td valign="top">Send a confirmation code to application</td><td valign="top">OK / ENTER / RETURN</td></tr><tr><td valign="top"><code class="constant">KEY_SCREEN</code></td><td valign="top">Select screen aspect ratio</td><td valign="top">4:3 16:9 SELECT</td></tr><tr><td valign="top"><code class="constant">KEY_ZOOM</code></td><td valign="top">Put device into zoom/full screen mode</td><td valign="top">ZOOM / FULL SCREEN / ZOOM+ / HIDE PANNEL / SWITCH</td></tr><tr><td valign="top"><span class="bold"><strong>Navigation keys</strong></span></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td valign="top"><code class="constant">KEY_ESC</code></td><td valign="top">Cancel current operation</td><td valign="top">CANCEL / BACK</td></tr><tr><td valign="top"><code class="constant">KEY_HELP</code></td><td valign="top">Open a Help window</td><td valign="top">HELP</td></tr><tr><td valign="top"><code class="constant">KEY_HOMEPAGE</code></td><td valign="top">Navigate to Homepage</td><td valign="top">HOME</td></tr><tr><td valign="top"><code class="constant">KEY_INFO</code></td><td valign="top">Open On Screen Display</td><td valign="top">DISPLAY INFORMATION / OSD</td></tr><tr><td valign="top"><code class="constant">KEY_WWW</code></td><td valign="top">Open the default browser</td><td valign="top">WEB</td></tr><tr><td valign="top"><code class="constant">KEY_UP</code></td><td valign="top">Up key</td><td valign="top">UP</td></tr><tr><td valign="top"><code class="constant">KEY_DOWN</code></td><td valign="top">Down key</td><td valign="top">DOWN</td></tr><tr><td valign="top"><code class="constant">KEY_LEFT</code></td><td valign="top">Left key</td><td valign="top">LEFT</td></tr><tr><td valign="top"><code class="constant">KEY_RIGHT</code></td><td valign="top">Right key</td><td valign="top">RIGHT</td></tr><tr><td valign="top"><span class="bold"><strong>Miscellaneous keys</strong></span></td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td valign="top"><code class="constant">KEY_DOT</code></td><td valign="top">Return a dot</td><td valign="top">.</td></tr><tr><td valign="top"><code class="constant">KEY_FN</code></td><td valign="top">Select a function</td><td valign="top">FUNCTION</td></tr></tbody></table></div></div><br class="table-break"><p>It should be noticed that, sometimes, there some fundamental missing keys at some cheaper IR's. Due to that, it is recommended to:</p><div class="table"><a name="rc_keymap_notes"></a><p class="title"><b>Table 17.2. Notes</b></p><div class="table-contents"><table summary="Notes" width="100%" border="0"><colgroup><col class="c1"></colgroup><tbody valign="top"><tr><td valign="top">On simpler IR's, without separate channel keys, you need to map UP as <code class="constant">KEY_CHANNELUP</code></td></tr><tr><td valign="top">On simpler IR's, without separate channel keys, you need to map DOWN as <code class="constant">KEY_CHANNELDOWN</code></td></tr><tr><td valign="top">On simpler IR's, without separate volume keys, you need to map LEFT as <code class="constant">KEY_VOLUMEDOWN</code></td></tr><tr><td valign="top">On simpler IR's, without separate volume keys, you need to map RIGHT as <code class="constant">KEY_VOLUMEUP</code></td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Remote_controllers_table_change"></a>Changing default Remote Controller mappings</h2></div></div></div><p>The event interface provides two ioctls to be used against
the /dev/input/event device, to allow changing the default
keymapping.</p><p>This program demonstrates how to replace the keymap tables.</p><pre class="programlisting">
/* keytable.c - This program allows checking/replacing keys at IR

   Copyright (C) 2006-2009 Mauro Carvalho Chehab &lt;mchehab@infradead.org&gt;

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, version 2 of the License.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
 */

#include &lt;ctype.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;linux/input.h&gt;
#include &lt;sys/ioctl.h&gt;

#include "parse.h"

void prtcode (int *codes)
{
        struct parse_key *p;

        for (p=keynames;p-&gt;name!=NULL;p++) {
                if (p-&gt;value == (unsigned)codes[1]) {
                        printf("scancode 0x%04x = %s (0x%02x)\n", codes[0], p-&gt;name, codes[1]);
                        return;
                }
        }

        if (isprint (codes[1]))
                printf("scancode %d = '%c' (0x%02x)\n", codes[0], codes[1], codes[1]);
        else
                printf("scancode %d = 0x%02x\n", codes[0], codes[1]);
}

int parse_code(char *string)
{
        struct parse_key *p;

        for (p=keynames;p-&gt;name!=NULL;p++) {
                if (!strcasecmp(p-&gt;name, string)) {
                        return p-&gt;value;
                }
        }
        return -1;
}

int main (int argc, char *argv[])
{
        int fd;
        unsigned int i, j;
        int codes[2];

        if (argc&lt;2 || argc&gt;4) {
                printf ("usage: %s &lt;device&gt; to get table; or\n"
                        "       %s &lt;device&gt; &lt;scancode&gt; &lt;keycode&gt;\n"
                        "       %s &lt;device&gt; &lt;keycode_file&gt;\n",*argv,*argv,*argv);
                return -1;
        }

        if ((fd = open(argv[1], O_RDONLY)) &lt; 0) {
                perror("Couldn't open input device");
                return(-1);
        }

        if (argc==4) {
                int value;

                value=parse_code(argv[3]);

                if (value==-1) {
                        value = strtol(argv[3], NULL, 0);
                        if (errno)
                                perror("value");
                }

                codes [0] = (unsigned) strtol(argv[2], NULL, 0);
                codes [1] = (unsigned) value;

                if(ioctl(fd, EVIOCSKEYCODE, codes))
                        perror ("EVIOCSKEYCODE");

                if(ioctl(fd, EVIOCGKEYCODE, codes)==0)
                        prtcode(codes);
                return 0;
        }

        if (argc==3) {
                FILE *fin;
                int value;
                char *scancode, *keycode, s[2048];

                fin=fopen(argv[2],"r");
                if (fin==NULL) {
                        perror ("opening keycode file");
                        return -1;
                }

                /* Clears old table */
                for (j = 0; j &lt; 256; j++) {
                        for (i = 0; i &lt; 256; i++) {
                                codes[0] = (j &lt;&lt; 8) | i;
                                codes[1] = KEY_RESERVED;
                                ioctl(fd, EVIOCSKEYCODE, codes);
                        }
                }

                while (fgets(s,sizeof(s),fin)) {
                        scancode=strtok(s,"\n\t =:");
                        if (!scancode) {
                                perror ("parsing input file scancode");
                                return -1;
                        }
                        if (!strcasecmp(scancode, "scancode")) {
                                scancode = strtok(NULL,"\n\t =:");
                                if (!scancode) {
                                        perror ("parsing input file scancode");
                                        return -1;
                                }
                        }

                        keycode=strtok(NULL,"\n\t =:(");
                        if (!keycode) {
                                perror ("parsing input file keycode");
                                return -1;
                        }

                        // printf ("parsing %s=%s:", scancode, keycode);
                        value=parse_code(keycode);
                        // printf ("\tvalue=%d\n",value);

                        if (value==-1) {
                                value = strtol(keycode, NULL, 0);
                                if (errno)
                                        perror("value");
                        }

                        codes [0] = (unsigned) strtol(scancode, NULL, 0);
                        codes [1] = (unsigned) value;

                        // printf("\t%04x=%04x\n",codes[0], codes[1]);
                        if(ioctl(fd, EVIOCSKEYCODE, codes)) {
                                fprintf(stderr, "Setting scancode 0x%04x with 0x%04x via ",codes[0], codes[1]);
                                perror ("EVIOCSKEYCODE");
                        }

                        if(ioctl(fd, EVIOCGKEYCODE, codes)==0)
                                prtcode(codes);
                }
                return 0;
        }

        /* Get scancode table */
        for (j = 0; j &lt; 256; j++) {
                for (i = 0; i &lt; 256; i++) {
                        codes[0] = (j &lt;&lt; 8) | i;
                        if (!ioctl(fd, EVIOCGKEYCODE, codes) &amp;&amp; codes[1] != KEY_RESERVED)
                                prtcode(codes);
                }
        }
        return 0;
}

</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="lirc_dev"></a>LIRC Device Interface</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#lirc_dev_intro">Introduction</a></span></dt><dt><span class="section"><a href="media.html#lirc_read">LIRC read fop</a></span></dt><dt><span class="section"><a href="media.html#lirc_write">LIRC write fop</a></span></dt><dt><span class="section"><a href="media.html#lirc_ioctl">LIRC ioctl fop</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="lirc_dev_intro"></a>Introduction</h3></div></div></div><p>The LIRC device interface is a bi-directional interface for
transporting raw IR data between userspace and kernelspace. Fundamentally,
it is just a chardev (/dev/lircX, for X = 0, 1, 2, ...), with a number
of standard struct file_operations defined on it. With respect to
transporting raw IR data to and fro, the essential fops are read, write
and ioctl.</p><p>Example dmesg output upon a driver registering w/LIRC:</p><div class="blockquote"><blockquote class="blockquote"><p>$ dmesg |grep lirc_dev</p><p>lirc_dev: IR Remote Control driver registered, major 248</p><p>rc rc0: lirc_dev: driver ir-lirc-codec (mceusb) registered at minor = 0</p></blockquote></div><p>What you should see for a chardev:</p><div class="blockquote"><blockquote class="blockquote"><p>$ ls -l /dev/lirc*</p><p>crw-rw---- 1 root root 248, 0 Jul  2 22:20 /dev/lirc0</p></blockquote></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="lirc_read"></a>LIRC read fop</h3></div></div></div><p>The lircd userspace daemon reads raw IR data from the LIRC chardev. The
exact format of the data depends on what modes a driver supports, and what
mode has been selected. lircd obtains supported modes and sets the active mode
via the ioctl interface, detailed at <a class="xref" href="media.html#lirc_ioctl" title="LIRC ioctl fop">the section called &#8220;LIRC ioctl fop&#8221;</a>. The generally
preferred mode is LIRC_MODE_MODE2, in which packets containing an int value
describing an IR signal are read from the chardev.</p><p>See also <a class="ulink" href="http://www.lirc.org/html/technical.html" target="_top">http://www.lirc.org/html/technical.html</a> for more info.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="lirc_write"></a>LIRC write fop</h3></div></div></div><p>The data written to the chardev is a pulse/space sequence of integer
values. Pulses and spaces are only marked implicitly by their position. The
data must start and end with a pulse, therefore, the data must always include
an uneven number of samples. The write function must block until the data has
been transmitted by the hardware. If more data is provided than the hardware
can send, the driver returns EINVAL.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="lirc_ioctl"></a>LIRC ioctl fop</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="media.html#lirc_dev_errors">Return Value</a></span></dt></dl></div><p>The LIRC device's ioctl definition is bound by the ioctl function
definition of struct file_operations, leaving us with an unsigned int
for the ioctl command and an unsigned long for the arg. For the purposes
of ioctl portability across 32-bit and 64-bit, these values are capped
to their 32-bit sizes.</p><p>The following ioctls can be used to change specific hardware settings.
In general each driver should have a default set of settings. The driver
implementation is expected to re-apply the default settings when the device
is closed by user-space, so that every application opening the device can rely
on working with the default settings initially.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">LIRC_GET_FEATURES</span></dt><dd><p>Obviously, get the underlying hardware device's features. If a driver
      does not announce support of certain features, calling of the corresponding
      ioctls is undefined.</p></dd><dt><span class="term">LIRC_GET_SEND_MODE</span></dt><dd><p>Get supported transmit mode. Only LIRC_MODE_PULSE is supported by lircd.</p></dd><dt><span class="term">LIRC_GET_REC_MODE</span></dt><dd><p>Get supported receive modes. Only LIRC_MODE_MODE2 and LIRC_MODE_LIRCCODE
      are supported by lircd.</p></dd><dt><span class="term">LIRC_GET_SEND_CARRIER</span></dt><dd><p>Get carrier frequency (in Hz) currently used for transmit.</p></dd><dt><span class="term">LIRC_GET_REC_CARRIER</span></dt><dd><p>Get carrier frequency (in Hz) currently used for IR reception.</p></dd><dt><span class="term">LIRC_{G,S}ET_{SEND,REC}_DUTY_CYCLE</span></dt><dd><p>Get/set the duty cycle (from 0 to 100) of the carrier signal. Currently,
      no special meaning is defined for 0 or 100, but this could be used to switch
      off carrier generation in the future, so these values should be reserved.</p></dd><dt><span class="term">LIRC_GET_REC_RESOLUTION</span></dt><dd><p>Some receiver have maximum resolution which is defined by internal
      sample rate or data format limitations. E.g. it's common that signals can
      only be reported in 50 microsecond steps. This integer value is used by
      lircd to automatically adjust the aeps tolerance value in the lircd
      config file.</p></dd><dt><span class="term">LIRC_GET_M{IN,AX}_TIMEOUT</span></dt><dd><p>Some devices have internal timers that can be used to detect when
      there's no IR activity for a long time. This can help lircd in detecting
      that a IR signal is finished and can speed up the decoding process.
      Returns an integer value with the minimum/maximum timeout that can be
      set. Some devices have a fixed timeout, in that case both ioctls will
      return the same value even though the timeout cannot be changed.</p></dd><dt><span class="term">LIRC_GET_M{IN,AX}_FILTER_{PULSE,SPACE}</span></dt><dd><p>Some devices are able to filter out spikes in the incoming signal
      using given filter rules. These ioctls return the hardware capabilities
      that describe the bounds of the possible filters. Filter settings depend
      on the IR protocols that are expected. lircd derives the settings from
      all protocols definitions found in its config file.</p></dd><dt><span class="term">LIRC_GET_LENGTH</span></dt><dd><p>Retrieves the code length in bits (only for LIRC_MODE_LIRCCODE).
      Reads on the device must be done in blocks matching the bit count.
      The bit could should be rounded up so that it matches full bytes.</p></dd><dt><span class="term">LIRC_SET_{SEND,REC}_MODE</span></dt><dd><p>Set send/receive mode. Largely obsolete for send, as only
      LIRC_MODE_PULSE is supported.</p></dd><dt><span class="term">LIRC_SET_{SEND,REC}_CARRIER</span></dt><dd><p>Set send/receive carrier (in Hz).</p></dd><dt><span class="term">LIRC_SET_TRANSMITTER_MASK</span></dt><dd><p>This enables the given set of transmitters. The first transmitter
      is encoded by the least significant bit, etc. When an invalid bit mask
      is given, i.e. a bit is set, even though the device does not have so many
      transitters, then this ioctl returns the number of available transitters
      and does nothing otherwise.</p></dd><dt><span class="term">LIRC_SET_REC_TIMEOUT</span></dt><dd><p>Sets the integer value for IR inactivity timeout (cf.
      LIRC_GET_MIN_TIMEOUT and LIRC_GET_MAX_TIMEOUT). A value of 0 (if
      supported by the hardware) disables all hardware timeouts and data should
      be reported as soon as possible. If the exact value cannot be set, then
      the next possible value _greater_ than the given value should be set.</p></dd><dt><span class="term">LIRC_SET_REC_TIMEOUT_REPORTS</span></dt><dd><p>Enable (1) or disable (0) timeout reports in LIRC_MODE_MODE2. By
      default, timeout reports should be turned off.</p></dd><dt><span class="term">LIRC_SET_REC_FILTER_{,PULSE,SPACE}</span></dt><dd><p>Pulses/spaces shorter than this are filtered out by hardware. If
      filters cannot be set independently for pulse/space, the corresponding
      ioctls must return an error and LIRC_SET_REC_FILTER shall be used instead.</p></dd><dt><span class="term">LIRC_SET_MEASURE_CARRIER_MODE</span></dt><dd><p>Enable (1)/disable (0) measure mode. If enabled, from the next key
      press on, the driver will send LIRC_MODE2_FREQUENCY packets. By default
      this should be turned off.</p></dd><dt><span class="term">LIRC_SET_REC_{DUTY_CYCLE,CARRIER}_RANGE</span></dt><dd><p>To set a range use LIRC_SET_REC_DUTY_CYCLE_RANGE/LIRC_SET_REC_CARRIER_RANGE
      with the lower bound first and later LIRC_SET_REC_DUTY_CYCLE/LIRC_SET_REC_CARRIER
      with the upper bound.</p></dd><dt><span class="term">LIRC_NOTIFY_DECODE</span></dt><dd><p>This ioctl is called by lircd whenever a successful decoding of an
      incoming IR signal could be done. This can be used by supporting hardware
      to give visual feedback to the user e.g. by flashing a LED.</p></dd><dt><span class="term">LIRC_SETUP_{START,END}</span></dt><dd><p>Setting of several driver parameters can be optimized by encapsulating
      the according ioctl calls with LIRC_SETUP_START/LIRC_SETUP_END. When a
      driver receives a LIRC_SETUP_START ioctl it can choose to not commit
      further setting changes to the hardware until a LIRC_SETUP_END is received.
      But this is open to the driver implementation and every driver must also
      handle parameter changes which are not encapsulated by LIRC_SETUP_START
      and LIRC_SETUP_END. Drivers can also choose to ignore these ioctls.</p></dd><dt><span class="term">LIRC_SET_WIDEBAND_RECEIVER</span></dt><dd><p>Some receivers are equipped with special wide band receiver which is intended
      to be used to learn output of existing remote.
      Calling that ioctl with (1) will enable it, and with (0) disable it.
      This might be useful of receivers that have otherwise narrow band receiver
      that prevents them to be used with some remotes.
      Wide band receiver might also be more precise
      On the other hand its disadvantage it usually reduced range of reception.
      Note: wide band receiver might be implictly enabled if you enable
      carrier reports. In that case it will be disabled as soon as you disable
      carrier reports. Trying to disable wide band receiver while carrier
      reports are active will do nothing.</p></dd></dl></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="lirc_dev_errors"></a>Return Value</h4></div></div></div><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div></div></div></div></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="media_common"></a>Part IV. Media Controller API</h1></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Laurent</span> <span class="surname">Pinchart</span></h3><span class="contrib">Initial version.</span> <div class="affiliation"><div class="address"><p><code class="email">&lt;<a class="email" href="mailto:laurent.pinchart@ideasonboard.com">laurent.pinchart@ideasonboard.com</a>&gt;</code></p></div></div></div></div></div><div><p class="copyright">Copyright © 2010 Laurent Pinchart</p></div><div><div class="revhistory"><table style="border-style:solid; width:100%;" summary="Revision History"><tr><th align="left" valign="top" colspan="3"><b>Revision History</b></th></tr><tr><td align="left">Revision 1.0.0</td><td align="left">2010-11-10</td><td align="left">lp</td></tr><tr><td align="left" colspan="3">Initial revision</td></tr></table></div></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="chapter"><a href="media.html#media_controller">18. Media Controller</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#media-controller-intro">Introduction</a></span></dt><dt><span class="section"><a href="media.html#media-controller-model">Media device model</a></span></dt></dl></dd><dt><span class="appendix"><a href="media.html#media-user-func">L. Function Reference</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="media.html#media-func-open">media open()</a></span><span class="refpurpose"> &#8212; Open a media device</span></dt><dt><span class="refentrytitle"><a href="media.html#media-func-close">media close()</a></span><span class="refpurpose"> &#8212; Close a media device</span></dt><dt><span class="refentrytitle"><a href="media.html#media-func-ioctl">media ioctl()</a></span><span class="refpurpose"> &#8212; Control a media device</span></dt><dt><span class="refentrytitle"><a href="media.html#media-ioc-device-info">ioctl MEDIA_IOC_DEVICE_INFO</a></span><span class="refpurpose"> &#8212; Query device information</span></dt><dt><span class="refentrytitle"><a href="media.html#media-ioc-enum-entities">ioctl MEDIA_IOC_ENUM_ENTITIES</a></span><span class="refpurpose"> &#8212; Enumerate entities and their properties</span></dt><dt><span class="refentrytitle"><a href="media.html#media-ioc-enum-links">ioctl MEDIA_IOC_ENUM_LINKS</a></span><span class="refpurpose"> &#8212; Enumerate all pads and links for a given entity</span></dt><dt><span class="refentrytitle"><a href="media.html#media-ioc-setup-link">ioctl MEDIA_IOC_SETUP_LINK</a></span><span class="refpurpose"> &#8212; Modify the properties of a link</span></dt></dl></dd></dl></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="media_controller"></a>Chapter 18. Media Controller</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="media.html#media-controller-intro">Introduction</a></span></dt><dt><span class="section"><a href="media.html#media-controller-model">Media device model</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="media-controller-intro"></a>Introduction</h2></div></div></div><p>Media devices increasingly handle multiple related functions. Many USB
    cameras include microphones, video capture hardware can also output video,
    or SoC camera interfaces also perform memory-to-memory operations similar to
    video codecs.</p><p>Independent functions, even when implemented in the same hardware, can
    be modelled as separate devices. A USB camera with a microphone will be
    presented to userspace applications as V4L2 and ALSA capture devices. The
    devices' relationships (when using a webcam, end-users shouldn't have to
    manually select the associated USB microphone), while not made available
    directly to applications by the drivers, can usually be retrieved from
    sysfs.</p><p>With more and more advanced SoC devices being introduced, the current
    approach will not scale. Device topologies are getting increasingly complex
    and can't always be represented by a tree structure. Hardware blocks are
    shared between different functions, creating dependencies between seemingly
    unrelated devices.</p><p>Kernel abstraction APIs such as V4L2 and ALSA provide means for
    applications to access hardware parameters. As newer hardware expose an
    increasingly high number of those parameters, drivers need to guess what
    applications really require based on limited information, thereby
    implementing policies that belong to userspace.</p><p>The media controller API aims at solving those problems.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="media-controller-model"></a>Media device model</h2></div></div></div><p>Discovering a device internal topology, and configuring it at runtime,
    is one of the goals of the media controller API. To achieve this, hardware
    devices are modelled as an oriented graph of building blocks called entities
    connected through pads.</p><p>An entity is a basic media hardware or software building block. It can
    correspond to a large variety of logical blocks such as physical hardware
    devices (CMOS sensor for instance), logical hardware devices (a building
    block in a System-on-Chip image processing pipeline), DMA channels or
    physical connectors.</p><p>A pad is a connection endpoint through which an entity can interact
    with other entities. Data (not restricted to video) produced by an entity
    flows from the entity's output to one or more entity inputs. Pads should not
    be confused with physical pins at chip boundaries.</p><p>A link is a point-to-point oriented connection between two pads,
    either on the same entity or on different entities. Data flows from a source
    pad to a sink pad.</p></div></div><div class="appendix"><div class="titlepage"><div><div><h2 class="title"><a name="media-user-func"></a>Appendix L. Function Reference</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="refentrytitle"><a href="media.html#media-func-open">media open()</a></span><span class="refpurpose"> &#8212; Open a media device</span></dt><dt><span class="refentrytitle"><a href="media.html#media-func-close">media close()</a></span><span class="refpurpose"> &#8212; Close a media device</span></dt><dt><span class="refentrytitle"><a href="media.html#media-func-ioctl">media ioctl()</a></span><span class="refpurpose"> &#8212; Control a media device</span></dt><dt><span class="refentrytitle"><a href="media.html#media-ioc-device-info">ioctl MEDIA_IOC_DEVICE_INFO</a></span><span class="refpurpose"> &#8212; Query device information</span></dt><dt><span class="refentrytitle"><a href="media.html#media-ioc-enum-entities">ioctl MEDIA_IOC_ENUM_ENTITIES</a></span><span class="refpurpose"> &#8212; Enumerate entities and their properties</span></dt><dt><span class="refentrytitle"><a href="media.html#media-ioc-enum-links">ioctl MEDIA_IOC_ENUM_LINKS</a></span><span class="refpurpose"> &#8212; Enumerate all pads and links for a given entity</span></dt><dt><span class="refentrytitle"><a href="media.html#media-ioc-setup-link">ioctl MEDIA_IOC_SETUP_LINK</a></span><span class="refpurpose"> &#8212; Modify the properties of a link</span></dt></dl></div><div class="refentry"><a name="media-func-open"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>media-open &#8212; Open a media device</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">#include &lt;fcntl.h&gt;</pre><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">open</b>(</code></td><td>const char *<var class="pdparam">device_name</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp116897264"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>device_name</code></em></span></dt><dd><p>Device to be opened.</p></dd><dt><span class="term"><em class="parameter"><code>flags</code></em></span></dt><dd><p>Open flags. Access mode must be either <code class="constant">O_RDONLY</code>
	  or <code class="constant">O_RDWR</code>. Other flags have no effect.</p></dd></dl></div></div><div class="refsect1"><a name="idp116903328"></a><h2>Description</h2><p>To open a media device applications call <code class="function">open()</code>
    with the desired device name. The function has no side effects; the device
    configuration remain unchanged.</p><p>When the device is opened in read-only mode, attemps to modify its
    configuration will result in an error, and <code class="varname">errno</code> will be
    set to <span class="errorcode">EBADF</span>.</p></div><div class="refsect1"><a name="idp116907040"></a><h2>Return Value</h2><p><code class="function">open</code> returns the new file descriptor on success.
    On error, -1 is returned, and <code class="varname">errno</code> is set appropriately.
    Possible error codes are:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EACCES</span></span></dt><dd><p>The requested access to the file is not allowed.</p></dd><dt><span class="term"><span class="errorcode">EMFILE</span></span></dt><dd><p>The  process  already  has  the  maximum number of files open.
	  </p></dd><dt><span class="term"><span class="errorcode">ENFILE</span></span></dt><dd><p>The system limit on the total number of open files has been
	  reached.</p></dd><dt><span class="term"><span class="errorcode">ENOMEM</span></span></dt><dd><p>Insufficient kernel memory was available.</p></dd><dt><span class="term"><span class="errorcode">ENXIO</span></span></dt><dd><p>No device corresponding to this device special file exists.
	  </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="media-func-close"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>media-close &#8212; Close a media device</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">#include &lt;unistd.h&gt;</pre><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">close</b>(</code></td><td>int <var class="pdparam">fd</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp116960272"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd></dl></div></div><div class="refsect1"><a name="idp116964416"></a><h2>Description</h2><p>Closes the media device. Resources associated with the file descriptor
    are freed. The device configuration remain unchanged.</p></div><div class="refsect1"><a name="idp116965744"></a><h2>Return Value</h2><p><code class="function">close</code> returns 0 on success. On error, -1 is
    returned, and <code class="varname">errno</code> is set appropriately. Possible error
    codes are:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EBADF</span></span></dt><dd><p><em class="parameter"><code>fd</code></em> is not a valid open file descriptor.
	  </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="media-func-ioctl"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>media-ioctl &#8212; Control a media device</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">#include &lt;sys/ioctl.h&gt;</pre><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>void *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp116999344"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="media.html#func-open" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>Media ioctl request code as defined in the media.h header file,
	  for example MEDIA_IOC_SETUP_LINK.</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p>Pointer to a request-specific structure.</p></dd></dl></div></div><div class="refsect1"><a name="idp117007632"></a><h2>Description</h2><p>The <code class="function">ioctl()</code> function manipulates media device
    parameters. The argument <em class="parameter"><code>fd</code></em> must be an open file
    descriptor.</p><p>The ioctl <em class="parameter"><code>request</code></em> code specifies the media
    function to be called. It has encoded in it whether the argument is an
    input, output or read/write parameter, and the size of the argument
    <em class="parameter"><code>argp</code></em> in bytes.</p><p>Macros and structures definitions specifying media ioctl requests and
    their parameters are located in the media.h header file. All media ioctl
    requests, their respective function and parameters are specified in
    <a class="xref" href="media.html#media-user-func" title="Appendix L. Function Reference">Appendix L, <i>Function Reference</i></a>.</p></div><div class="refsect1"><a name="idp117013760"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><p>Request-specific error codes are listed in the
    individual requests descriptions.</p><p>When an ioctl that takes an output or read/write parameter fails,
    the parameter remains unmodified.</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="media-ioc-device-info"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>MEDIA_IOC_DEVICE_INFO &#8212; Query device information</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct media_device_info *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp116992432"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by
	  <a class="link" href="media.html#media-func-open" title="media open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>MEDIA_IOC_DEVICE_INFO</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp117064224"></a><h2>Description</h2><p>All media devices must support the <code class="constant">MEDIA_IOC_DEVICE_INFO</code>
    ioctl. To query device information, applications call the ioctl with a
    pointer to a struct <a class="link" href="media.html#media-device-info" title="Table L.1. struct media_device_info">media_device_info</a>. The driver fills the structure and returns
    the information to the application.
    The ioctl never fails.</p><div class="table"><a name="media-device-info"></a><p class="title"><b>Table L.1. struct <span class="structname">media_device_info</span></b></p><div class="table-contents"><table summary="struct media_device_info" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">char</td><td valign="top"><em class="structfield"><code>driver</code></em>[16]</td><td valign="top"><p>Name of the driver implementing the media API as a
	    NUL-terminated ASCII string. The driver version is stored in the
	    <em class="structfield"><code>driver_version</code></em> field.</p>
	    <p>Driver specific applications can use this information to
	    verify the driver identity. It is also useful to work around
	    known bugs, or to identify drivers in error reports.</p></td></tr><tr><td valign="top">char</td><td valign="top"><em class="structfield"><code>model</code></em>[32]</td><td valign="top">Device model name as a NUL-terminated UTF-8 string. The
	    device version is stored in the <em class="structfield"><code>device_version</code></em>
	    field and is not be appended to the model name.</td></tr><tr><td valign="top">char</td><td valign="top"><em class="structfield"><code>serial</code></em>[40]</td><td valign="top">Serial number as a NUL-terminated ASCII string.</td></tr><tr><td valign="top">char</td><td valign="top"><em class="structfield"><code>bus_info</code></em>[32]</td><td valign="top">Location of the device in the system as a NUL-terminated
	    ASCII string. This includes the bus type name (PCI, USB, ...) and a
	    bus-specific identifier.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>media_version</code></em></td><td valign="top">Media API version, formatted with the
	    <code class="constant">KERNEL_VERSION()</code> macro.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>hw_revision</code></em></td><td valign="top">Hardware device revision in a driver-specific format.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>media_version</code></em></td><td valign="top">Media device driver version, formatted with the
	    <code class="constant">KERNEL_VERSION()</code> macro. Together with the
	    <em class="structfield"><code>driver</code></em> field this identifies a particular
	    driver.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[31]</td><td valign="top">Reserved for future extensions. Drivers and applications must
	    set this array to zero.</td></tr></tbody></table></div></div><br class="table-break"><p>The <em class="structfield"><code>serial</code></em> and <em class="structfield"><code>bus_info</code></em>
    fields can be used to distinguish between multiple instances of otherwise
    identical hardware. The serial number takes precedence when provided and can
    be assumed to be unique. If the serial number is an empty string, the
    <em class="structfield"><code>bus_info</code></em> field can be used instead. The
    <em class="structfield"><code>bus_info</code></em> field is guaranteed to be unique, but
    can vary across reboots or device unplug/replug.</p></div><div class="refsect1"><a name="idp117095216"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="media-ioc-enum-entities"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>MEDIA_IOC_ENUM_ENTITIES &#8212; Enumerate entities and their properties</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct media_entity_desc *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp117159168"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by
	  <a class="link" href="media.html#media-func-open" title="media open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>MEDIA_IOC_ENUM_ENTITIES</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp117167376"></a><h2>Description</h2><p>To query the attributes of an entity, applications set the id field
    of a struct <a class="link" href="media.html#media-entity-desc" title="Table L.2. struct media_entity_desc">media_entity_desc</a> structure and call the MEDIA_IOC_ENUM_ENTITIES
    ioctl with a pointer to this structure. The driver fills the rest of the
    structure or returns an <span class="errorcode">EINVAL</span> error code when the id is invalid.</p><p>Entities can be enumerated by or'ing the id with the
    <code class="constant">MEDIA_ENT_ID_FLAG_NEXT</code> flag. The driver will return
    information about the entity with the smallest id strictly larger than the
    requested one ('next entity'), or the <span class="errorcode">EINVAL</span> error code if there is none.</p><p>Entity IDs can be non-contiguous. Applications must
    <span class="emphasis"><em>not</em></span> try to enumerate entities by calling
    MEDIA_IOC_ENUM_ENTITIES with increasing id's until they get an error.</p><p>Two or more entities that share a common non-zero
    <em class="structfield"><code>group_id</code></em> value are considered as logically
    grouped. Groups are used to report
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>ALSA, VBI and video nodes that carry the same media
      stream</p></li><li class="listitem"><p>lens and flash controllers associated with a sensor</p></li></ul></div><p>
    </p><div class="table"><a name="media-entity-desc"></a><p class="title"><b>Table L.2. struct <span class="structname">media_entity_desc</span></b></p><div class="table-contents"><table summary="struct media_entity_desc" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"><col class="c5"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>id</code></em></td><td valign="top"> </td><td valign="top"> </td><td valign="top">Entity id, set by the application. When the id is or'ed with
	    <code class="constant">MEDIA_ENT_ID_FLAG_NEXT</code>, the driver clears the
	    flag and returns the first entity with a larger id.</td></tr><tr><td valign="top">char</td><td valign="top"><em class="structfield"><code>name</code></em>[32]</td><td valign="top"> </td><td valign="top"> </td><td valign="top">Entity name as an UTF-8 NULL-terminated string.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>type</code></em></td><td valign="top"> </td><td valign="top"> </td><td valign="top">Entity type, see <a class="xref" href="media.html#media-entity-type" title="Table L.3. Media entity types">Table L.3, &#8220;Media entity types&#8221;</a> for details.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>revision</code></em></td><td valign="top"> </td><td valign="top"> </td><td valign="top">Entity revision in a driver/hardware specific format.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>flags</code></em></td><td valign="top"> </td><td valign="top"> </td><td valign="top">Entity flags, see <a class="xref" href="media.html#media-entity-flag" title="Table L.4. Media entity flags">Table L.4, &#8220;Media entity flags&#8221;</a> for details.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>group_id</code></em></td><td valign="top"> </td><td valign="top"> </td><td valign="top">Entity group ID</td></tr><tr><td valign="top">__u16</td><td valign="top"><em class="structfield"><code>pads</code></em></td><td valign="top"> </td><td valign="top"> </td><td valign="top">Number of pads</td></tr><tr><td valign="top">__u16</td><td valign="top"><em class="structfield"><code>links</code></em></td><td valign="top"> </td><td valign="top"> </td><td valign="top">Total number of outbound links. Inbound links are not counted
	    in this field.</td></tr><tr><td valign="top">union</td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td valign="top"> </td><td valign="top">struct</td><td valign="top"><em class="structfield"><code>v4l</code></em></td><td valign="top"> </td><td valign="top">Valid for V4L sub-devices and nodes only.</td></tr><tr><td valign="top"> </td><td valign="top"> </td><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>major</code></em></td><td valign="top">V4L device node major number. For V4L sub-devices with no
	    device node, set by the driver to 0.</td></tr><tr><td valign="top"> </td><td valign="top"> </td><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>minor</code></em></td><td valign="top">V4L device node minor number. For V4L sub-devices with no
	    device node, set by the driver to 0.</td></tr><tr><td valign="top"> </td><td valign="top">struct</td><td valign="top"><em class="structfield"><code>fb</code></em></td><td valign="top"> </td><td valign="top">Valid for frame buffer nodes only.</td></tr><tr><td valign="top"> </td><td valign="top"> </td><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>major</code></em></td><td valign="top">Frame buffer device node major number.</td></tr><tr><td valign="top"> </td><td valign="top"> </td><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>minor</code></em></td><td valign="top">Frame buffer device node minor number.</td></tr><tr><td valign="top"> </td><td valign="top">struct</td><td valign="top"><em class="structfield"><code>alsa</code></em></td><td valign="top"> </td><td valign="top">Valid for ALSA devices only.</td></tr><tr><td valign="top"> </td><td valign="top"> </td><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>card</code></em></td><td valign="top">ALSA card number</td></tr><tr><td valign="top"> </td><td valign="top"> </td><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>device</code></em></td><td valign="top">ALSA device number</td></tr><tr><td valign="top"> </td><td valign="top"> </td><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>subdevice</code></em></td><td valign="top">ALSA sub-device number</td></tr><tr><td valign="top"> </td><td valign="top">int</td><td valign="top"><em class="structfield"><code>dvb</code></em></td><td valign="top"> </td><td valign="top">DVB card number</td></tr><tr><td valign="top"> </td><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>raw</code></em>[180]</td><td valign="top"> </td><td valign="top"> </td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="media-entity-type"></a><p class="title"><b>Table L.3. Media entity types</b></p><div class="table-contents"><table summary="Media entity types" width="100%" border="0"><colgroup><col class="c1"><col class="c2"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">MEDIA_ENT_T_DEVNODE</code></td><td valign="top">Unknown device node</td></tr><tr><td valign="top"><code class="constant">MEDIA_ENT_T_DEVNODE_V4L</code></td><td valign="top">V4L video, radio or vbi device node</td></tr><tr><td valign="top"><code class="constant">MEDIA_ENT_T_DEVNODE_FB</code></td><td valign="top">Frame buffer device node</td></tr><tr><td valign="top"><code class="constant">MEDIA_ENT_T_DEVNODE_ALSA</code></td><td valign="top">ALSA card</td></tr><tr><td valign="top"><code class="constant">MEDIA_ENT_T_DEVNODE_DVB</code></td><td valign="top">DVB card</td></tr><tr><td valign="top"><code class="constant">MEDIA_ENT_T_V4L2_SUBDEV</code></td><td valign="top">Unknown V4L sub-device</td></tr><tr><td valign="top"><code class="constant">MEDIA_ENT_T_V4L2_SUBDEV_SENSOR</code></td><td valign="top">Video sensor</td></tr><tr><td valign="top"><code class="constant">MEDIA_ENT_T_V4L2_SUBDEV_FLASH</code></td><td valign="top">Flash controller</td></tr><tr><td valign="top"><code class="constant">MEDIA_ENT_T_V4L2_SUBDEV_LENS</code></td><td valign="top">Lens controller</td></tr><tr><td valign="top"><code class="constant">MEDIA_ENT_T_V4L2_SUBDEV_DECODER</code></td><td valign="top">Video decoder, the basic function of the video decoder is to
	    accept analogue video from a wide variety of sources such as
	    broadcast, DVD players, cameras and video cassette recorders, in
	    either NTSC, PAL or HD format and still occasionally SECAM, separate
	    it into its component parts, luminance and chrominance, and output
	    it in some digital video standard, with appropriate embedded timing
	    signals.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="media-entity-flag"></a><p class="title"><b>Table L.4. Media entity flags</b></p><div class="table-contents"><table summary="Media entity flags" width="100%" border="0"><colgroup><col class="c1"><col class="c2"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">MEDIA_ENT_FL_DEFAULT</code></td><td valign="top">Default entity for its type. Used to discover the default
	    audio, VBI and video devices, the default camera sensor, ...</td></tr></tbody></table></div></div><br class="table-break"></div><div class="refsect1"><a name="idp117254160"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The struct <a class="link" href="media.html#media-entity-desc" title="Table L.2. struct media_entity_desc">media_entity_desc</a> <em class="structfield"><code>id</code></em> references
	  a non-existing entity.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="media-ioc-enum-links"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>MEDIA_IOC_ENUM_LINKS &#8212; Enumerate all pads and links for a given entity</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct media_links_enum *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp117387504"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by
	  <a class="link" href="media.html#media-func-open" title="media open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>MEDIA_IOC_ENUM_LINKS</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp117395712"></a><h2>Description</h2><p>To enumerate pads and/or links for a given entity, applications set
    the entity field of a struct <a class="link" href="media.html#media-links-enum" title="Table L.5. struct media_links_enum">media_links_enum</a> structure and initialize the
    struct <a class="link" href="media.html#media-pad-desc" title="Table L.6. struct media_pad_desc">media_pad_desc</a> and struct <a class="link" href="media.html#media-link-desc" title="Table L.8. struct media_link_desc">media_link_desc</a> structure arrays pointed by the
    <em class="structfield"><code>pads</code></em> and <em class="structfield"><code>links</code></em> fields.
    They then call the MEDIA_IOC_ENUM_LINKS ioctl with a pointer to this
    structure.</p><p>If the <em class="structfield"><code>pads</code></em> field is not NULL, the driver
    fills the <em class="structfield"><code>pads</code></em> array with information about the
    entity's pads. The array must have enough room to store all the entity's
    pads. The number of pads can be retrieved with the <a class="link" href="media.html#media-ioc-enum-entities" title="ioctl MEDIA_IOC_ENUM_ENTITIES"><code class="constant">MEDIA_IOC_ENUM_ENTITIES</code></a>
    ioctl.</p><p>If the <em class="structfield"><code>links</code></em> field is not NULL, the driver
    fills the <em class="structfield"><code>links</code></em> array with information about the
    entity's outbound links. The array must have enough room to store all the
    entity's outbound links. The number of outbound links can be retrieved with
    the <a class="link" href="media.html#media-ioc-enum-entities" title="ioctl MEDIA_IOC_ENUM_ENTITIES"><code class="constant">MEDIA_IOC_ENUM_ENTITIES</code></a> ioctl.</p><p>Only forward links that originate at one of the entity's source pads
    are returned during the enumeration process.</p><div class="table"><a name="media-links-enum"></a><p class="title"><b>Table L.5. struct <span class="structname">media_links_enum</span></b></p><div class="table-contents"><table summary="struct media_links_enum" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>entity</code></em></td><td valign="top">Entity id, set by the application.</td></tr><tr><td valign="top">struct <a class="link" href="media.html#media-pad-desc" title="Table L.6. struct media_pad_desc">media_pad_desc</a></td><td valign="top">*<em class="structfield"><code>pads</code></em></td><td valign="top">Pointer to a pads array allocated by the application. Ignored
	    if NULL.</td></tr><tr><td valign="top">struct <a class="link" href="media.html#media-link-desc" title="Table L.8. struct media_link_desc">media_link_desc</a></td><td valign="top">*<em class="structfield"><code>links</code></em></td><td valign="top">Pointer to a links array allocated by the application. Ignored
	    if NULL.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="media-pad-desc"></a><p class="title"><b>Table L.6. struct <span class="structname">media_pad_desc</span></b></p><div class="table-contents"><table summary="struct media_pad_desc" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>entity</code></em></td><td valign="top">ID of the entity this pad belongs to.</td></tr><tr><td valign="top">__u16</td><td valign="top"><em class="structfield"><code>index</code></em></td><td valign="top">0-based pad index.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>flags</code></em></td><td valign="top">Pad flags, see <a class="xref" href="media.html#media-pad-flag" title="Table L.7. Media pad flags">Table L.7, &#8220;Media pad flags&#8221;</a> for more details.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="media-pad-flag"></a><p class="title"><b>Table L.7. Media pad flags</b></p><div class="table-contents"><table summary="Media pad flags" width="100%" border="0"><colgroup><col class="c1"><col class="c2"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">MEDIA_PAD_FL_SINK</code></td><td valign="top">Input pad, relative to the entity. Input pads sink data and
	    are targets of links.</td></tr><tr><td valign="top"><code class="constant">MEDIA_PAD_FL_SOURCE</code></td><td valign="top">Output pad, relative to the entity. Output pads source data
	    and are origins of links.</td></tr><tr><td valign="top"><code class="constant">MEDIA_PAD_FL_MUST_CONNECT</code></td><td valign="top">If this flag is set and the pad is linked to any other
	    pad, then at least one of those links must be enabled for the
	    entity to be able to stream. There could be temporary reasons
	    (e.g. device configuration dependent) for the pad to need
	    enabled links even when this flag isn't set; the absence of the
	    flag doesn't imply there is none.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="media-link-desc"></a><p class="title"><b>Table L.8. struct <span class="structname">media_link_desc</span></b></p><div class="table-contents"><table summary="struct media_link_desc" width="100%" border="0"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><tbody valign="top"><tr><td valign="top">struct <a class="link" href="media.html#media-pad-desc" title="Table L.6. struct media_pad_desc">media_pad_desc</a></td><td valign="top"><em class="structfield"><code>source</code></em></td><td valign="top">Pad at the origin of this link.</td></tr><tr><td valign="top">struct <a class="link" href="media.html#media-pad-desc" title="Table L.6. struct media_pad_desc">media_pad_desc</a></td><td valign="top"><em class="structfield"><code>sink</code></em></td><td valign="top">Pad at the target of this link.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>flags</code></em></td><td valign="top">Link flags, see <a class="xref" href="media.html#media-link-flag" title="Table L.9. Media link flags">Table L.9, &#8220;Media link flags&#8221;</a> for more details.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="media-link-flag"></a><p class="title"><b>Table L.9. Media link flags</b></p><div class="table-contents"><table summary="Media link flags" width="100%" border="0"><colgroup><col class="c1"><col class="c2"></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">MEDIA_LNK_FL_ENABLED</code></td><td valign="top">The link is enabled and can be used to transfer media data.
	    When two or more links target a sink pad, only one of them can be
	    enabled at a time.</td></tr><tr><td valign="top"><code class="constant">MEDIA_LNK_FL_IMMUTABLE</code></td><td valign="top">The link enabled state can't be modified at runtime. An
	    immutable link is always enabled.</td></tr><tr><td valign="top"><code class="constant">MEDIA_LNK_FL_DYNAMIC</code></td><td valign="top">The link enabled state can be modified during streaming. This
	    flag is set by drivers and is read-only for applications.</td></tr></tbody></table></div></div><br class="table-break"><p>One and only one of <code class="constant">MEDIA_PAD_FL_SINK</code> and
    <code class="constant">MEDIA_PAD_FL_SOURCE</code> must be set for every pad.</p></div><div class="refsect1"><a name="idp117465776"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The struct <a class="link" href="media.html#media-links-enum" title="Table L.5. struct media_links_enum">media_links_enum</a> <em class="structfield"><code>id</code></em> references
	  a non-existing entity.</p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="media-ioc-setup-link"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>MEDIA_IOC_SETUP_LINK &#8212; Modify the properties of a link</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">request</var>, </td></tr><tr><td> </td><td>struct media_link_desc *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idp117576240"></a><h2>Arguments</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by
	  <a class="link" href="media.html#media-func-open" title="media open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>MEDIA_IOC_SETUP_LINK</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1"><a name="idp117584448"></a><h2>Description</h2><p>To change link properties applications fill a struct <a class="link" href="media.html#media-link-desc" title="Table L.8. struct media_link_desc">media_link_desc</a> with
    link identification information (source and sink pad) and the new requested
    link flags. They then call the MEDIA_IOC_SETUP_LINK ioctl with a pointer to
    that structure.</p><p>The only configurable property is the <code class="constant">ENABLED</code>
    link flag to enable/disable a link. Links marked with the
    <code class="constant">IMMUTABLE</code> link flag can not be enabled or disabled.
    </p><p>Link configuration has no side effect on other links. If an enabled
    link at the sink pad prevents the link from being enabled, the driver
    returns with an <span class="errorcode">EBUSY</span> error code.</p><p>Only links marked with the <code class="constant">DYNAMIC</code> link flag can
    be enabled/disabled while streaming media data. Attempting to enable or
    disable a streaming non-dynamic link will return an <span class="errorcode">EBUSY</span> error code.</p><p>If the specified link can't be found the driver returns with an
    <span class="errorcode">EINVAL</span> error code.</p></div><div class="refsect1"><a name="idp117592112"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="media.html#gen-errors" title="Table 19.1. Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The struct <a class="link" href="media.html#media-link-desc" title="Table L.8. struct media_link_desc">media_link_desc</a> references a non-existing link, or the
	  link is immutable and an attempt to modify its configuration was made.
	  </p></dd></dl></div></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="gen_errors"></a>Chapter 19. Generic Error Codes</h1></div></div></div><div class="table"><a name="gen-errors"></a><p class="title"><b>Table 19.1. Generic error codes</b></p><div class="table-contents"><table summary="Generic error codes" width="100%" border="0"><colgroup><col class="c1"><col class="c2"></colgroup><tbody valign="top"><tr><td valign="top">EAGAIN (aka EWOULDBLOCK)</td><td valign="top">The ioctl can't be handled because the device is in state where
	       it can't perform it. This could happen for example in case where
	       device is sleeping and ioctl is performed to query statistics.
	       It is also returned when the ioctl would need to wait
	       for an event, but the device was opened in non-blocking mode.
	</td></tr><tr><td valign="top">EBADF</td><td valign="top">The file descriptor is not a valid.</td></tr><tr><td valign="top">EBUSY</td><td valign="top">The ioctl can't be handled because the device is busy. This is
	       typically return while device is streaming, and an ioctl tried to
	       change something that would affect the stream, or would require the
	       usage of a hardware resource that was already allocated. The ioctl
	       must not be retried without performing another action to fix the
	       problem first (typically: stop the stream before retrying).</td></tr><tr><td valign="top">EFAULT</td><td valign="top">There was a failure while copying data from/to userspace,
	       probably caused by an invalid pointer reference.</td></tr><tr><td valign="top">EINVAL</td><td valign="top">One or more of the ioctl parameters are invalid or out of the
	       allowed range. This is a widely used error code. See the individual
	       ioctl requests for specific causes.</td></tr><tr><td valign="top">ENODEV</td><td valign="top">Device not found or was removed.</td></tr><tr><td valign="top">ENOMEM</td><td valign="top">There's not enough memory to handle the desired operation.</td></tr><tr><td valign="top">ENOTTY</td><td valign="top">The ioctl is not supported by the driver, actually meaning that
	       the required functionality is not available, or the file
	       descriptor is not for a media device.</td></tr><tr><td valign="top">ENOSPC</td><td valign="top">On USB devices, the stream ioctl's can return this error, meaning
	       that this request would overcommit the usb bandwidth reserved
	       for periodic transfers (up to 80% of the USB bandwidth).</td></tr><tr><td valign="top">EPERM</td><td valign="top">Permission denied. Can be returned if the device needs write
		permission, or some special capabilities is needed
		(e. g. root)</td></tr></tbody></table></div></div><br class="table-break"><p>Note 1: ioctls may return other error codes. Since errors may have side
effects such as a driver reset, applications should abort on unexpected errors.
</p><p>Note 2: Request-specific error codes are listed in the individual
requests descriptions.</p></div><div class="appendix"><div class="titlepage"><div><div><h1 class="title"><a name="fdl"></a>Appendix M. GNU Free Documentation License</h1></div><div><p class="releaseinfo">
      Version 1.1, March 2000
    </p></div><div><p class="copyright">Copyright © 2000 Free Software Foundation, Inc.</p></div><div><div class="legalnotice"><a name="fdl-legalnotice"></a><p>
	</p><div class="address"><p>Free Software Foundation, Inc. <span class="street">59 Temple Place,<br>
	Suite 330</span>, <span class="city">Boston</span>, <span class="state">MA</span><br>
	<span class="postcode">02111-1307</span>  <span class="country">USA</span></p></div><p>
	Everyone is permitted to copy and distribute verbatim copies of this
	license document, but changing it is not allowed.
      </p></div></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="media.html#fdl-preamble">0. PREAMBLE</a></span></dt><dt><span class="sect1"><a href="media.html#fdl-section1">1. APPLICABILITY AND DEFINITIONS</a></span></dt><dt><span class="sect1"><a href="media.html#fdl-section2">2. VERBATIM COPYING</a></span></dt><dt><span class="sect1"><a href="media.html#fdl-section3">3. COPYING IN QUANTITY</a></span></dt><dt><span class="sect1"><a href="media.html#fdl-section4">4. MODIFICATIONS</a></span></dt><dt><span class="sect1"><a href="media.html#fdl-section5">5. COMBINING DOCUMENTS</a></span></dt><dt><span class="sect1"><a href="media.html#fdl-section6">6. COLLECTIONS OF DOCUMENTS</a></span></dt><dt><span class="sect1"><a href="media.html#fdl-section7">7. AGGREGATION WITH INDEPENDENT WORKS</a></span></dt><dt><span class="sect1"><a href="media.html#fdl-section8">8. TRANSLATION</a></span></dt><dt><span class="sect1"><a href="media.html#fdl-section9">9. TERMINATION</a></span></dt><dt><span class="sect1"><a href="media.html#fdl-section10">10. FUTURE REVISIONS OF THIS LICENSE</a></span></dt><dt><span class="sect1"><a href="media.html#fdl-using">Addendum</a></span></dt></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="fdl-preamble"></a>0. PREAMBLE</h2></div></div></div><p>
      The purpose of this License is to make a manual, textbook, or
      other written document <span class="quote">&#8220;<span class="quote">free</span>&#8221;</span> in the sense of
      freedom: to assure everyone the effective freedom to copy and
      redistribute it, with or without modifying it, either
      commercially or noncommercially. Secondarily, this License
      preserves for the author and publisher a way to get credit for
      their work, while not being considered responsible for
      modifications made by others.
    </p><p>
      This License is a kind of <span class="quote">&#8220;<span class="quote">copyleft</span>&#8221;</span>, which means
      that derivative works of the document must themselves be free in
      the same sense. It complements the GNU General Public License,
      which is a copyleft license designed for free software.
    </p><p>
      We have designed this License in order to use it for manuals for
      free software, because free software needs free documentation: a
      free program should come with manuals providing the same
      freedoms that the software does. But this License is not limited
      to software manuals; it can be used for any textual work,
      regardless of subject matter or whether it is published as a
      printed book. We recommend this License principally for works
      whose purpose is instruction or reference.
    </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="fdl-section1"></a>1. APPLICABILITY AND DEFINITIONS</h2></div></div></div><p><a name="fdl-document"></a>
      This License applies to any manual or other work that contains a
      notice placed by the copyright holder saying it can be
      distributed under the terms of this License. The
      <span class="quote">&#8220;<span class="quote">Document</span>&#8221;</span>, below, refers to any such manual or
      work. Any member of the public is a licensee, and is addressed
      as <span class="quote">&#8220;<span class="quote">you</span>&#8221;</span>.
    </p><p><a name="fdl-modified"></a>
      A <span class="quote">&#8220;<span class="quote">Modified Version</span>&#8221;</span> of the Document means any work
      containing the Document or a portion of it, either copied
      verbatim, or with modifications and/or translated into another
      language.
    </p><p><a name="fdl-secondary"></a>
      A <span class="quote">&#8220;<span class="quote">Secondary Section</span>&#8221;</span> is a named appendix or a
      front-matter section of the <a class="link" href="media.html#fdl-document">Document</a> that deals exclusively
      with the relationship of the publishers or authors of the
      Document to the Document's overall subject (or to related
      matters) and contains nothing that could fall directly within
      that overall subject. (For example, if the Document is in part a
      textbook of mathematics, a Secondary Section may not explain any
      mathematics.)  The relationship could be a matter of historical
      connection with the subject or with related matters, or of
      legal, commercial, philosophical, ethical or political position
      regarding them.
    </p><p><a name="fdl-invariant"></a>
      The <span class="quote">&#8220;<span class="quote">Invariant Sections</span>&#8221;</span> are certain <a class="link" href="media.html#fdl-secondary"> Secondary Sections</a> whose titles
      are designated, as being those of Invariant Sections, in the
      notice that says that the <a class="link" href="media.html#fdl-document">Document</a> is released under this
      License.
    </p><p><a name="fdl-cover-texts"></a>
      The <span class="quote">&#8220;<span class="quote">Cover Texts</span>&#8221;</span> are certain short passages of
      text that are listed, as Front-Cover Texts or Back-Cover Texts,
      in the notice that says that the <a class="link" href="media.html#fdl-document">Document</a> is released under this
      License.
    </p><p><a name="fdl-transparent"></a>
      A <span class="quote">&#8220;<span class="quote">Transparent</span>&#8221;</span> copy of the <a class="link" href="media.html#fdl-document"> Document</a> means a machine-readable
      copy, represented in a format whose specification is available
      to the general public, whose contents can be viewed and edited
      directly and straightforwardly with generic text editors or (for
      images composed of pixels) generic paint programs or (for
      drawings) some widely available drawing editor, and that is
      suitable for input to text formatters or for automatic
      translation to a variety of formats suitable for input to text
      formatters. A copy made in an otherwise Transparent file format
      whose markup has been designed to thwart or discourage
      subsequent modification by readers is not Transparent.  A copy
      that is not <span class="quote">&#8220;<span class="quote">Transparent</span>&#8221;</span> is called
      <span class="quote">&#8220;<span class="quote">Opaque</span>&#8221;</span>.
    </p><p>
      Examples of suitable formats for Transparent copies include
      plain ASCII without markup, Texinfo input format, LaTeX input
      format, SGML or XML using a publicly available DTD, and
      standard-conforming simple HTML designed for human
      modification. Opaque formats include PostScript, PDF,
      proprietary formats that can be read and edited only by
      proprietary word processors, SGML or XML for which the DTD
      and/or processing tools are not generally available, and the
      machine-generated HTML produced by some word processors for
      output purposes only.
    </p><p><a name="fdl-title-page"></a>
      The <span class="quote">&#8220;<span class="quote">Title Page</span>&#8221;</span> means, for a printed book, the
      title page itself, plus such following pages as are needed to
      hold, legibly, the material this License requires to appear in
      the title page. For works in formats which do not have any title
      page as such, <span class="quote">&#8220;<span class="quote">Title Page</span>&#8221;</span> means the text near the
      most prominent appearance of the work's title, preceding the
      beginning of the body of the text.
    </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="fdl-section2"></a>2. VERBATIM COPYING</h2></div></div></div><p>
      You may copy and distribute the <a class="link" href="media.html#fdl-document">Document</a> in any medium, either
      commercially or noncommercially, provided that this License, the
      copyright notices, and the license notice saying this License
      applies to the Document are reproduced in all copies, and that
      you add no other conditions whatsoever to those of this
      License. You may not use technical measures to obstruct or
      control the reading or further copying of the copies you make or
      distribute. However, you may accept compensation in exchange for
      copies. If you distribute a large enough number of copies you
      must also follow the conditions in <a class="link" href="media.html#fdl-section3" title="3. COPYING IN QUANTITY">section 3</a>.
    </p><p>
      You may also lend copies, under the same conditions stated
      above, and you may publicly display copies.
    </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="fdl-section3"></a>3. COPYING IN QUANTITY</h2></div></div></div><p>
      If you publish printed copies of the <a class="link" href="media.html#fdl-document">Document</a> numbering more than 100,
      and the Document's license notice requires <a class="link" href="media.html#fdl-cover-texts">Cover Texts</a>, you must enclose
      the copies in covers that carry, clearly and legibly, all these
      Cover Texts: Front-Cover Texts on the front cover, and
      Back-Cover Texts on the back cover. Both covers must also
      clearly and legibly identify you as the publisher of these
      copies. The front cover must present the full title with all
      words of the title equally prominent and visible. You may add
      other material on the covers in addition. Copying with changes
      limited to the covers, as long as they preserve the title of the
      <a class="link" href="media.html#fdl-document">Document</a> and satisfy these
      conditions, can be treated as verbatim copying in other
      respects.
    </p><p>
      If the required texts for either cover are too voluminous to fit
      legibly, you should put the first ones listed (as many as fit
      reasonably) on the actual cover, and continue the rest onto
      adjacent pages.
    </p><p>
      If you publish or distribute <a class="link" href="media.html#fdl-transparent">Opaque</a> copies of the <a class="link" href="media.html#fdl-document">Document</a> numbering more than 100,
      you must either include a machine-readable <a class="link" href="media.html#fdl-transparent">Transparent</a> copy along with
      each Opaque copy, or state in or with each Opaque copy a
      publicly-accessible computer-network location containing a
      complete Transparent copy of the Document, free of added
      material, which the general network-using public has access to
      download anonymously at no charge using public-standard network
      protocols. If you use the latter option, you must take
      reasonably prudent steps, when you begin distribution of Opaque
      copies in quantity, to ensure that this Transparent copy will
      remain thus accessible at the stated location until at least one
      year after the last time you distribute an Opaque copy (directly
      or through your agents or retailers) of that edition to the
      public.
    </p><p>
      It is requested, but not required, that you contact the authors
      of the <a class="link" href="media.html#fdl-document">Document</a> well before
      redistributing any large number of copies, to give them a chance
      to provide you with an updated version of the Document.
    </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="fdl-section4"></a>4. MODIFICATIONS</h2></div></div></div><p>
      You may copy and distribute a <a class="link" href="media.html#fdl-modified">Modified Version</a> of the <a class="link" href="media.html#fdl-document">Document</a> under the conditions of
      sections <a class="link" href="media.html#fdl-section2" title="2. VERBATIM COPYING">2</a> and <a class="link" href="media.html#fdl-section3" title="3. COPYING IN QUANTITY">3</a> above, provided that you release
      the Modified Version under precisely this License, with the
      Modified Version filling the role of the Document, thus
      licensing distribution and modification of the Modified Version
      to whoever possesses a copy of it. In addition, you must do
      these things in the Modified Version:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: opencircle; "><li class="listitem" style="list-style-type: circle"><p><b>A. </b>
	    Use in the <a class="link" href="media.html#fdl-title-page">Title
	    Page</a> (and on the covers, if any) a title distinct
	    from that of the <a class="link" href="media.html#fdl-document">Document</a>, and from those of
	    previous versions (which should, if there were any, be
	    listed in the History section of the Document). You may
	    use the same title as a previous version if the original
	    publisher of that version gives permission.
	  </p></li><li class="listitem" style="list-style-type: circle"><p><b>B. </b>
	    List on the <a class="link" href="media.html#fdl-title-page">Title
	    Page</a>, as authors, one or more persons or entities
	    responsible for authorship of the modifications in the
	    <a class="link" href="media.html#fdl-modified">Modified Version</a>,
	    together with at least five of the principal authors of
	    the <a class="link" href="media.html#fdl-document">Document</a> (all of
	    its principal authors, if it has less than five).
	  </p></li><li class="listitem" style="list-style-type: circle"><p><b>C. </b>
	    State on the <a class="link" href="media.html#fdl-title-page">Title
	    Page</a> the name of the publisher of the <a class="link" href="media.html#fdl-modified">Modified Version</a>, as the
	    publisher.
	  </p></li><li class="listitem" style="list-style-type: circle"><p><b>D. </b>
	    Preserve all the copyright notices of the <a class="link" href="media.html#fdl-document">Document</a>.
	  </p></li><li class="listitem" style="list-style-type: circle"><p><b>E. </b>
	    Add an appropriate copyright notice for your modifications
	    adjacent to the other copyright notices.
	  </p></li><li class="listitem" style="list-style-type: circle"><p><b>F. </b>
	    Include, immediately after the copyright notices, a
	    license notice giving the public permission to use the
	    <a class="link" href="media.html#fdl-modified">Modified Version</a> under
	    the terms of this License, in the form shown in the
	    Addendum below.
	  </p></li><li class="listitem" style="list-style-type: circle"><p><b>G. </b>
	    Preserve in that license notice the full lists of <a class="link" href="media.html#fdl-invariant"> Invariant Sections</a> and
	    required <a class="link" href="media.html#fdl-cover-texts">Cover
	    Texts</a> given in the <a class="link" href="media.html#fdl-document">Document's</a> license notice.
	  </p></li><li class="listitem" style="list-style-type: circle"><p><b>H. </b>
	    Include an unaltered copy of this License.
	  </p></li><li class="listitem" style="list-style-type: circle"><p><b>I. </b>
	    Preserve the section entitled <span class="quote">&#8220;<span class="quote">History</span>&#8221;</span>, and
	    its title, and add to it an item stating at least the
	    title, year, new authors, and publisher of the <a class="link" href="media.html#fdl-modified">Modified Version </a>as given on
	    the <a class="link" href="media.html#fdl-title-page">Title Page</a>.  If
	    there is no section entitled <span class="quote">&#8220;<span class="quote">History</span>&#8221;</span> in the
	    <a class="link" href="media.html#fdl-document">Document</a>, create one
	    stating the title, year, authors, and publisher of the
	    Document as given on its Title Page, then add an item
	    describing the Modified Version as stated in the previous
	    sentence.
	  </p></li><li class="listitem" style="list-style-type: circle"><p><b>J. </b>
	    Preserve the network location, if any, given in the <a class="link" href="media.html#fdl-document">Document</a> for public access
	    to a <a class="link" href="media.html#fdl-transparent">Transparent</a>
	    copy of the Document, and likewise the network locations
	    given in the Document for previous versions it was based
	    on. These may be placed in the <span class="quote">&#8220;<span class="quote">History</span>&#8221;</span>
	    section.  You may omit a network location for a work that
	    was published at least four years before the Document
	    itself, or if the original publisher of the version it
	    refers to gives permission.
	  </p></li><li class="listitem" style="list-style-type: circle"><p><b>K. </b>
	    In any section entitled <span class="quote">&#8220;<span class="quote">Acknowledgements</span>&#8221;</span> or
	    <span class="quote">&#8220;<span class="quote">Dedications</span>&#8221;</span>, preserve the section's title,
	    and preserve in the section all the substance and tone of
	    each of the contributor acknowledgements and/or
	    dedications given therein.
	  </p></li><li class="listitem" style="list-style-type: circle"><p><b>L. </b>
	    Preserve all the <a class="link" href="media.html#fdl-invariant">Invariant
	    Sections</a> of the <a class="link" href="media.html#fdl-document">Document</a>, unaltered in their
	    text and in their titles.  Section numbers or the
	    equivalent are not considered part of the section titles.
	  </p></li><li class="listitem" style="list-style-type: circle"><p><b>M. </b>
	    Delete any section entitled
	    <span class="quote">&#8220;<span class="quote">Endorsements</span>&#8221;</span>. Such a section may not be
	    included in the <a class="link" href="media.html#fdl-modified">Modified
	    Version</a>.
	  </p></li><li class="listitem" style="list-style-type: circle"><p><b>N. </b>
	    Do not retitle any existing section as
	    <span class="quote">&#8220;<span class="quote">Endorsements</span>&#8221;</span> or to conflict in title with
	    any <a class="link" href="media.html#fdl-invariant">Invariant
	    Section</a>.
	  </p></li></ul></div><p>
      If the <a class="link" href="media.html#fdl-modified">Modified Version</a>
      includes new front-matter sections or appendices that qualify as
      <a class="link" href="media.html#fdl-secondary">Secondary Sections</a> and
      contain no material copied from the Document, you may at your
      option designate some or all of these sections as invariant. To
      do this, add their titles to the list of <a class="link" href="media.html#fdl-invariant">Invariant Sections</a> in the
      Modified Version's license notice.  These titles must be
      distinct from any other section titles.
    </p><p>
      You may add a section entitled <span class="quote">&#8220;<span class="quote">Endorsements</span>&#8221;</span>,
      provided it contains nothing but endorsements of your <a class="link" href="media.html#fdl-modified">Modified Version</a> by various
      parties--for example, statements of peer review or that the text
      has been approved by an organization as the authoritative
      definition of a standard.
    </p><p>
      You may add a passage of up to five words as a <a class="link" href="media.html#fdl-cover-texts">Front-Cover Text</a>, and a passage
      of up to 25 words as a <a class="link" href="media.html#fdl-cover-texts">Back-Cover Text</a>, to the end of
      the list of <a class="link" href="media.html#fdl-cover-texts">Cover Texts</a>
      in the <a class="link" href="media.html#fdl-modified">Modified Version</a>.
      Only one passage of Front-Cover Text and one of Back-Cover Text
      may be added by (or through arrangements made by) any one
      entity. If the <a class="link" href="media.html#fdl-document">Document</a>
      already includes a cover text for the same cover, previously
      added by you or by arrangement made by the same entity you are
      acting on behalf of, you may not add another; but you may
      replace the old one, on explicit permission from the previous
      publisher that added the old one.
    </p><p>
      The author(s) and publisher(s) of the <a class="link" href="media.html#fdl-document">Document</a> do not by this License
      give permission to use their names for publicity for or to
      assert or imply endorsement of any <a class="link" href="media.html#fdl-modified">Modified Version </a>.
    </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="fdl-section5"></a>5. COMBINING DOCUMENTS</h2></div></div></div><p>
      You may combine the <a class="link" href="media.html#fdl-document">Document</a>
      with other documents released under this License, under the
      terms defined in <a class="link" href="media.html#fdl-section4" title="4. MODIFICATIONS">section 4</a>
      above for modified versions, provided that you include in the
      combination all of the <a class="link" href="media.html#fdl-invariant">Invariant
      Sections</a> of all of the original documents, unmodified,
      and list them all as Invariant Sections of your combined work in
      its license notice.
    </p><p>
      The combined work need only contain one copy of this License,
      and multiple identical <a class="link" href="media.html#fdl-invariant">Invariant
      Sections</a> may be replaced with a single copy. If there are
      multiple Invariant Sections with the same name but different
      contents, make the title of each such section unique by adding
      at the end of it, in parentheses, the name of the original
      author or publisher of that section if known, or else a unique
      number. Make the same adjustment to the section titles in the
      list of Invariant Sections in the license notice of the combined
      work.
    </p><p>
      In the combination, you must combine any sections entitled
      <span class="quote">&#8220;<span class="quote">History</span>&#8221;</span> in the various original documents,
      forming one section entitled <span class="quote">&#8220;<span class="quote">History</span>&#8221;</span>; likewise
      combine any sections entitled <span class="quote">&#8220;<span class="quote">Acknowledgements</span>&#8221;</span>,
      and any sections entitled <span class="quote">&#8220;<span class="quote">Dedications</span>&#8221;</span>.  You must
      delete all sections entitled <span class="quote">&#8220;<span class="quote">Endorsements.</span>&#8221;</span>
    </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="fdl-section6"></a>6. COLLECTIONS OF DOCUMENTS</h2></div></div></div><p>
      You may make a collection consisting of the <a class="link" href="media.html#fdl-document">Document</a> and other documents
      released under this License, and replace the individual copies
      of this License in the various documents with a single copy that
      is included in the collection, provided that you follow the
      rules of this License for verbatim copying of each of the
      documents in all other respects.
    </p><p>
      You may extract a single document from such a collection, and
      dispbibute it individually under this License, provided you
      insert a copy of this License into the extracted document, and
      follow this License in all other respects regarding verbatim
      copying of that document.
    </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="fdl-section7"></a>7. AGGREGATION WITH INDEPENDENT WORKS</h2></div></div></div><p>
      A compilation of the <a class="link" href="media.html#fdl-document">Document</a> or its derivatives with
      other separate and independent documents or works, in or on a
      volume of a storage or distribution medium, does not as a whole
      count as a <a class="link" href="media.html#fdl-modified">Modified Version</a>
      of the Document, provided no compilation copyright is claimed
      for the compilation.  Such a compilation is called an
      <span class="quote">&#8220;<span class="quote">aggregate</span>&#8221;</span>, and this License does not apply to the
      other self-contained works thus compiled with the Document , on
      account of their being thus compiled, if they are not themselves
      derivative works of the Document.  If the <a class="link" href="media.html#fdl-cover-texts">Cover Text</a> requirement of <a class="link" href="media.html#fdl-section3" title="3. COPYING IN QUANTITY">section 3</a> is applicable to these
      copies of the Document, then if the Document is less than one
      quarter of the entire aggregate, the Document's Cover Texts may
      be placed on covers that surround only the Document within the
      aggregate. Otherwise they must appear on covers around the whole
      aggregate.
    </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="fdl-section8"></a>8. TRANSLATION</h2></div></div></div><p>
      Translation is considered a kind of modification, so you may
      distribute translations of the <a class="link" href="media.html#fdl-document">Document</a> under the terms of <a class="link" href="media.html#fdl-section4" title="4. MODIFICATIONS">section 4</a>. Replacing <a class="link" href="media.html#fdl-invariant"> Invariant Sections</a> with
      translations requires special permission from their copyright
      holders, but you may include translations of some or all
      Invariant Sections in addition to the original versions of these
      Invariant Sections. You may include a translation of this
      License provided that you also include the original English
      version of this License. In case of a disagreement between the
      translation and the original English version of this License,
      the original English version will prevail.
    </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="fdl-section9"></a>9. TERMINATION</h2></div></div></div><p>
      You may not copy, modify, sublicense, or distribute the <a class="link" href="media.html#fdl-document">Document</a> except as expressly
      provided for under this License. Any other attempt to copy,
      modify, sublicense or distribute the Document is void, and will
      automatically terminate your rights under this License. However,
      parties who have received copies, or rights, from you under this
      License will not have their licenses terminated so long as such
      parties remain in full compliance.
    </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="fdl-section10"></a>10. FUTURE REVISIONS OF THIS LICENSE</h2></div></div></div><p>
      The <a class="ulink" href="http://www.gnu.org/fsf/fsf.html" target="_top">Free Software
      Foundation</a> may publish new, revised versions of the GNU
      Free Documentation License from time to time. Such new versions
      will be similar in spirit to the present version, but may differ
      in detail to address new problems or concerns. See <a class="ulink" href="http://www.gnu.org/copyleft" target="_top">http://www.gnu.org/copyleft/</a>.
    </p><p>
      Each version of the License is given a distinguishing version
      number. If the <a class="link" href="media.html#fdl-document">Document</a>
      specifies that a particular numbered version of this License
      <span class="quote">&#8220;<span class="quote">or any later version</span>&#8221;</span> applies to it, you have the
      option of following the terms and conditions either of that
      specified version or of any later version that has been
      published (not as a draft) by the Free Software Foundation. If
      the Document does not specify a version number of this License,
      you may choose any version ever published (not as a draft) by
      the Free Software Foundation.
    </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="fdl-using"></a>Addendum</h2></div></div></div><p>
      To use this License in a document you have written, include a copy of
      the License in the document and put the following copyright and
      license notices just after the title page:
    </p><div class="blockquote"><blockquote class="blockquote"><p>
	Copyright © YEAR YOUR NAME.
      </p><p>
	Permission is granted to copy, distribute and/or modify this
	document under the terms of the GNU Free Documentation
	License, Version 1.1 or any later version published by the
	Free Software Foundation; with the <a class="link" href="media.html#fdl-invariant">Invariant Sections</a> being LIST
	THEIR TITLES, with the <a class="link" href="media.html#fdl-cover-texts">Front-Cover Texts</a> being LIST,
	and with the <a class="link" href="media.html#fdl-cover-texts">Back-Cover
	Texts</a> being LIST.  A copy of the license is included in
	the section entitled <span class="quote">&#8220;<span class="quote">GNU Free Documentation
	License</span>&#8221;</span>.
      </p></blockquote></div><p>
      If you have no <a class="link" href="media.html#fdl-invariant">Invariant
      Sections</a>, write <span class="quote">&#8220;<span class="quote">with no Invariant Sections</span>&#8221;</span>
      instead of saying which ones are invariant.  If you have no
      <a class="link" href="media.html#fdl-cover-texts">Front-Cover Texts</a>, write
      <span class="quote">&#8220;<span class="quote">no Front-Cover Texts</span>&#8221;</span> instead of
      <span class="quote">&#8220;<span class="quote">Front-Cover Texts being LIST</span>&#8221;</span>; likewise for <a class="link" href="media.html#fdl-cover-texts">Back-Cover Texts</a>.
    </p><p>
      If your document contains nontrivial examples of program code,
      we recommend releasing these examples in parallel under your
      choice of free software license, such as the <a class="ulink" href="http://www.gnu.org/copyleft/gpl.html" target="_top"> GNU General Public
      License</a>, to permit their use in free software.
    </p></div></div></div></body></html>
